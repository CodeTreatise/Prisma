# 1.3.4 Enums and Advanced Types

## üìã Section Overview
- **Duration**: 30 minutes
- **Prerequisites**: Understanding of Prisma schema basics and data types
- **Learning Objectives**: 
  - Master enum definitions and usage in Prisma schemas
  - Understand composite types and custom type patterns
  - Learn JSON field usage and best practices
  - Apply advanced type patterns for complex business logic
- **Difficulty Level**: Intermediate

---

## üéØ What You'll Learn

By the end of this section, you will:
- ‚úÖ Create and use enums effectively for controlled vocabularies
- ‚úÖ Implement composite types and type unions for complex data
- ‚úÖ Leverage JSON fields for flexible, semi-structured data
- ‚úÖ Design type-safe schemas with advanced validation patterns
- ‚úÖ Choose the right advanced type for each use case

---

## üìñ Content

### Understanding Advanced Types: The Classification System

Advanced types in databases are like **specialized filing systems** in a large organization. Just as different departments need different ways to organize information (HR uses employee status categories, Accounting uses transaction types), databases need specialized types to handle various kinds of structured data.

### üóÇÔ∏è The Organizational Filing System

```
üè¢ Corporate Filing = üìä Database Advanced Types

üìã Status Categories (Enums)
‚îú‚îÄ‚îÄ Employee Status: Active, Inactive, On Leave
‚îú‚îÄ‚îÄ Order Status: Pending, Shipped, Delivered
‚îú‚îÄ‚îÄ Priority Levels: Low, Medium, High, Critical
‚îî‚îÄ‚îÄ Fixed, predefined values only

üì¶ Form Collections (Composite Types)
‚îú‚îÄ‚îÄ Address: Street, City, State, ZIP
‚îú‚îÄ‚îÄ Contact Info: Phone, Email, Fax
‚îú‚îÄ‚îÄ Grouped related data
‚îî‚îÄ‚îÄ Reusable across multiple forms

üìÑ Flexible Documents (JSON)
‚îú‚îÄ‚îÄ Employee Skills: Variable list of competencies
‚îú‚îÄ‚îÄ Product Metadata: Different for each product type
‚îú‚îÄ‚îÄ User Preferences: Customizable settings
‚îî‚îÄ‚îÄ Schema-less, adaptable data

üè∑Ô∏è Smart Labels (Type Unions)
‚îú‚îÄ‚îÄ Payment Method: Credit Card OR Bank Transfer OR Cash
‚îú‚îÄ‚îÄ Contact: Email OR Phone OR Mail
‚îú‚îÄ‚îÄ One of several possible types
‚îî‚îÄ‚îÄ Type-safe alternatives
```

### üìù Enumerations (Enums)

**The Multiple Choice Question Pattern:**

```prisma
// Basic enum definition
enum UserRole {
  USER
  ADMIN
  MODERATOR
  SUPER_ADMIN
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

model User {
  id       Int      @id @default(autoincrement())
  email    String   @unique
  name     String
  role     UserRole @default(USER)     // Enum with default
  status   String   @default("ACTIVE") // Could be enum too
  
  orders   Order[]
}

model Order {
  id         Int         @id @default(autoincrement())
  total      Decimal
  status     OrderStatus @default(PENDING)
  
  customer   User        @relation(fields: [customerId], references: [id])
  customerId Int
  
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
}
```

**Advanced Enum Patterns:**

```prisma
// Content management system enums
enum ContentType {
  BLOG_POST
  NEWS_ARTICLE
  PRODUCT_REVIEW
  USER_GUIDE
  FAQ_ITEM
}

enum ContentStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  PUBLISHED
  ARCHIVED
  REJECTED
}

enum PublishingPlatform {
  WEBSITE
  MOBILE_APP
  EMAIL_NEWSLETTER
  SOCIAL_MEDIA
  PRINT
}

model Content {
  id          Int                @id @default(autoincrement())
  title       String
  body        String
  type        ContentType
  status      ContentStatus      @default(DRAFT)
  platforms   PublishingPlatform[] // Array of enums (PostgreSQL)
  
  author      User               @relation(fields: [authorId], references: [id])
  authorId    Int
  
  publishedAt DateTime?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
}

// Priority system with clear hierarchy
enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
  CRITICAL
}

enum TicketCategory {
  BUG_REPORT
  FEATURE_REQUEST
  TECHNICAL_SUPPORT
  BILLING_ISSUE
  ACCOUNT_ACCESS
  GENERAL_INQUIRY
}

model SupportTicket {
  id          Int            @id @default(autoincrement())
  title       String
  description String
  priority    Priority       @default(LOW)
  category    TicketCategory
  status      TicketStatus   @default(OPEN)
  
  assignee    User?          @relation("AssignedTickets", fields: [assigneeId], references: [id])
  assigneeId  Int?
  reporter    User           @relation("ReportedTickets", fields: [reporterId], references: [id])
  reporterId  Int
  
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_FOR_CUSTOMER
  WAITING_FOR_DEVELOPER
  RESOLVED
  CLOSED
}
```

**Enum Best Practices:**

```prisma
// ‚úÖ Good enum practices
enum UserAccountType {
  FREE          // Clear, descriptive names
  PREMIUM       // Use SCREAMING_SNAKE_CASE
  ENTERPRISE    // Logical progression/grouping
}

enum PaymentStatus {
  PENDING       // Cover all business states
  PROCESSING    // Include intermediate states
  COMPLETED     // Clear success state
  FAILED        // Clear failure state
  REFUNDED      // Handle reversals
  CANCELLED     // Handle cancellations
}

// ‚ùå Avoid these patterns
enum BadExample {
  A             // Unclear meaning
  Type1         // Non-descriptive
  temp          // Lowercase (inconsistent)
  VERY_LONG_DESCRIPTIVE_NAME_THAT_IS_HARD_TO_READ // Too verbose
}
```

### üóÉÔ∏è JSON Fields for Flexible Data

**The Configuration File Pattern:**

```prisma
model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  name          String
  
  // JSON fields for flexible data
  preferences   Json?    // User preferences object
  metadata      Json?    // Additional user data
  settings      Json?    // App-specific settings
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}
```

**Structured JSON Examples:**

```typescript
// TypeScript interfaces for JSON validation
interface UserPreferences {
  theme: 'light' | 'dark' | 'auto'
  language: string
  timezone: string
  notifications: {
    email: boolean
    push: boolean
    sms: boolean
    frequency: 'immediate' | 'daily' | 'weekly'
  }
  dashboard: {
    layout: 'grid' | 'list'
    itemsPerPage: number
    defaultView: string
  }
}

interface ProductMetadata {
  specifications?: {
    [key: string]: string | number | boolean
  }
  compatibility?: string[]
  warranty?: {
    duration: number
    unit: 'days' | 'months' | 'years'
    coverage: string[]
  }
  certifications?: string[]
  dimensions?: {
    length: number
    width: number
    height: number
    weight: number
    unit: 'metric' | 'imperial'
  }
}

// Usage in Prisma models
model Product {
  id          Int               @id @default(autoincrement())
  name        String
  description String
  price       Decimal
  category    ProductCategory   @relation(fields: [categoryId], references: [id])
  categoryId  Int
  
  // Flexible metadata based on product type
  metadata    Json?             // ProductMetadata interface
  
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
}
```

**Advanced JSON Patterns:**

```prisma
// Configuration management system
model ApplicationConfig {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  version   String
  
  // Different config types
  database  Json     // Database connection settings
  api       Json     // API configuration
  features  Json     // Feature flags
  ui        Json     // UI customization
  
  // Environment-specific
  environment String // "development", "staging", "production"
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([name, environment])
}

// Analytics and tracking
model AnalyticsEvent {
  id          Int      @id @default(autoincrement())
  eventType   String   // "page_view", "button_click", "purchase"
  userId      Int?
  sessionId   String
  
  // Flexible event properties
  properties  Json     // Event-specific data
  context     Json     // Browser, device, location info
  
  timestamp   DateTime @default(now())
  
  user        User?    @relation(fields: [userId], references: [id])
  
  @@index([eventType, timestamp])
  @@index([userId, timestamp])
}

// Form builder system
model FormDefinition {
  id          Int      @id @default(autoincrement())
  name        String
  title       String
  description String?
  
  // Dynamic form structure
  fields      Json     // Array of field definitions
  validation  Json     // Validation rules
  styling     Json     // Form appearance
  logic       Json     // Conditional logic
  
  isActive    Boolean  @default(true)
  version     Int      @default(1)
  
  submissions FormSubmission[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model FormSubmission {
  id           Int            @id @default(autoincrement())
  form         FormDefinition @relation(fields: [formId], references: [id])
  formId       Int
  
  // Dynamic response data
  responses    Json           // User's form responses
  metadata     Json?          // IP, user agent, referrer
  
  submittedBy  User?          @relation(fields: [userId], references: [id])
  userId       Int?
  
  submittedAt  DateTime       @default(now())
}
```

### üé≠ Type Union Patterns

**The Either/Or Decision Pattern:**

```prisma
// Payment method union pattern
model Payment {
  id          Int      @id @default(autoincrement())
  amount      Decimal
  currency    String   @default("USD")
  
  // Union type approach using discriminator
  paymentType String   // "credit_card", "bank_transfer", "paypal", "crypto"
  
  // Type-specific data
  paymentData Json     // Contains type-specific payment info
  
  order       Order    @relation(fields: [orderId], references: [id])
  orderId     Int
  
  createdAt   DateTime @default(now())
}

// Notification system with multiple delivery methods
model Notification {
  id           Int      @id @default(autoincrement())
  title        String
  message      String
  
  // Delivery method discriminator
  deliveryType String   // "email", "sms", "push", "webhook"
  
  // Method-specific configuration
  config       Json     // Delivery-specific settings
  
  recipient    User     @relation(fields: [recipientId], references: [id])
  recipientId  Int
  
  status       NotificationStatus @default(PENDING)
  sentAt       DateTime?
  deliveredAt  DateTime?
  
  createdAt    DateTime @default(now())
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  BOUNCED
}
```

**TypeScript Union Types for Type Safety:**

```typescript
// Type-safe union patterns
type PaymentMethod = 
  | { type: 'credit_card'; cardNumber: string; expiryDate: string; cvv: string }
  | { type: 'bank_transfer'; accountNumber: string; routingNumber: string }
  | { type: 'paypal'; email: string }
  | { type: 'crypto'; walletAddress: string; currency: string }

type NotificationConfig = 
  | { type: 'email'; template: string; from: string; replyTo?: string }
  | { type: 'sms'; template: string; from: string }
  | { type: 'push'; title: string; icon?: string; badge?: number }
  | { type: 'webhook'; url: string; method: 'POST' | 'PUT'; headers?: Record<string, string> }

// Usage with Prisma
async function createPayment(orderid: number, method: PaymentMethod) {
  return await prisma.payment.create({
    data: {
      orderId,
      paymentType: method.type,
      paymentData: method as any, // JSON field
      amount: calculateAmount(orderId)
    }
  })
}
```

### üèóÔ∏è Composite Type Patterns

**The Structured Data Group Pattern:**

```prisma
// Address as embedded data pattern
model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  name          String
  
  // Embedded address structure
  address       Json?    // AddressInfo interface
  
  // Alternative: separate related table
  addresses     Address[]
}

model Address {
  id        Int     @id @default(autoincrement())
  type      String  // "home", "work", "billing", "shipping"
  street1   String
  street2   String?
  city      String
  state     String
  zipCode   String
  country   String  @default("US")
  
  user      User    @relation(fields: [userId], references: [id])
  userId    Int
  
  isDefault Boolean @default(false)
  
  @@index([userId, type])
}
```

**Complex Composite Examples:**

```prisma
// Contact information composite
model Contact {
  id            Int      @id @default(autoincrement())
  firstName     String
  lastName      String
  company       String?
  
  // Communication preferences
  communication Json     // CommunicationInfo interface
  
  // Professional information
  professional  Json?    // ProfessionalInfo interface
  
  // Personal information
  personal      Json?    // PersonalInfo interface
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// Product with complex specifications
model Product {
  id             Int      @id @default(autoincrement())
  name           String
  description    String
  
  // Physical properties
  physical       Json?    // PhysicalProperties interface
  
  // Technical specifications
  technical      Json?    // TechnicalSpecs interface
  
  // Marketing information
  marketing      Json?    // MarketingInfo interface
  
  category       Category @relation(fields: [categoryId], references: [id])
  categoryId     Int
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}
```

**TypeScript Interfaces for Composite Types:**

```typescript
interface AddressInfo {
  street1: string
  street2?: string
  city: string
  state: string
  zipCode: string
  country: string
  coordinates?: {
    latitude: number
    longitude: number
  }
}

interface CommunicationInfo {
  email: {
    primary: string
    secondary?: string
    workEmail?: string
  }
  phone: {
    mobile?: string
    home?: string
    work?: string
    fax?: string
  }
  social?: {
    linkedin?: string
    twitter?: string
    github?: string
  }
  preferences: {
    preferredMethod: 'email' | 'phone' | 'text'
    timeZone: string
    availableHours: {
      start: string
      end: string
      days: string[]
    }
  }
}

interface PhysicalProperties {
  dimensions: {
    length: number
    width: number
    height: number
    unit: 'cm' | 'inch'
  }
  weight: {
    value: number
    unit: 'kg' | 'lb'
  }
  color?: string
  material?: string[]
  packaging?: {
    type: string
    recyclable: boolean
    dimensions: {
      length: number
      width: number
      height: number
    }
  }
}
```

### üîß Advanced Type Validation

**Schema Validation with Zod:**

```typescript
import { z } from 'zod'

// Enum validation
const UserRoleSchema = z.enum(['USER', 'ADMIN', 'MODERATOR', 'SUPER_ADMIN'])

// Complex JSON validation
const UserPreferencesSchema = z.object({
  theme: z.enum(['light', 'dark', 'auto']),
  language: z.string().min(2).max(5),
  timezone: z.string(),
  notifications: z.object({
    email: z.boolean(),
    push: z.boolean(),
    sms: z.boolean(),
    frequency: z.enum(['immediate', 'daily', 'weekly'])
  }),
  dashboard: z.object({
    layout: z.enum(['grid', 'list']),
    itemsPerPage: z.number().min(10).max(100),
    defaultView: z.string()
  })
})

// Composite type validation
const AddressSchema = z.object({
  street1: z.string().min(1),
  street2: z.string().optional(),
  city: z.string().min(1),
  state: z.string().length(2),
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/),
  country: z.string().length(2),
  coordinates: z.object({
    latitude: z.number().min(-90).max(90),
    longitude: z.number().min(-180).max(180)
  }).optional()
})

// Usage in application
async function updateUserPreferences(userId: number, preferences: unknown) {
  try {
    const validPreferences = UserPreferencesSchema.parse(preferences)
    
    return await prisma.user.update({
      where: { id: userId },
      data: {
        preferences: validPreferences
      }
    })
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`Invalid preferences: ${error.errors.map(e => e.message).join(', ')}`)
    }
    throw error
  }
}
```

### üéØ Choosing the Right Advanced Type

**Decision Matrix:**

| Use Case | Type Choice | Reason |
|----------|-------------|---------|
| **Fixed set of options** | Enum | Type safety, database constraints |
| **User preferences** | JSON | Flexible structure, evolving schema |
| **Status workflows** | Enum | Clear state transitions |
| **Product specifications** | JSON | Variable fields per product type |
| **Address information** | Separate table | Queryable, reusable |
| **Configuration settings** | JSON | Dynamic structure |
| **Payment methods** | JSON + discriminator | Union type pattern |
| **Form responses** | JSON | Dynamic form fields |

**Pattern Selection Examples:**

```prisma
// ‚úÖ Use enum for fixed business states
enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}

model Order {
  status OrderStatus @default(PENDING)
}

// ‚úÖ Use JSON for flexible configuration
model User {
  preferences Json? // Theme, language, notifications
}

// ‚úÖ Use separate table for queryable data
model Address {
  id      Int    @id @default(autoincrement())
  street  String
  city    String
  userId  Int
  
  user    User   @relation(fields: [userId], references: [id])
  
  @@index([city]) // Can query by city
}

// ‚úÖ Use JSON for dynamic schemas
model Product {
  specifications Json? // Different fields per product category
}
```

---

## üß† Knowledge Check

### Type Selection Quiz

1. **When should you use an enum instead of a string field?**
   - [x] A) When you have a fixed set of predefined values
   - [ ] B) When you need to store long text
   - [ ] C) When values change frequently
   - [ ] D) When you need multilingual support

   **Explanation**: Enums provide type safety and database constraints for fixed vocabularies like status values or categories.

2. **What's the main advantage of JSON fields in Prisma?**
   - [ ] A) Better performance than regular fields
   - [ ] B) Automatic validation
   - [x] C) Flexibility for semi-structured data
   - [ ] D) Easier to query than regular fields

   **Explanation**: JSON fields allow storing flexible, semi-structured data that can vary between records without schema changes.

3. **Which pattern is best for storing different types of payment methods?**
   - [ ] A) Separate table for each payment type
   - [ ] B) Single table with all possible fields
   - [x] C) Discriminator field with JSON data
   - [ ] D) Enum field only

   **Explanation**: Using a discriminator field with JSON data allows type-safe union patterns while keeping the schema flexible.

### Schema Design Exercise

**Design a content management system with the following requirements:**
- Articles can be blog posts, news, or tutorials
- Each content type has different metadata requirements
- Content goes through approval workflow (draft ‚Üí review ‚Üí approved ‚Üí published)
- Authors can have different skill levels and specialties

**Your Schema:**
```prisma
// Design your models with appropriate advanced types
model Content {
  // Your design here
}

// Add enums and other types as needed
```

**Sample Solution:**
```prisma
enum ContentType {
  BLOG_POST
  NEWS_ARTICLE
  TUTORIAL
}

enum ContentStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  PUBLISHED
  ARCHIVED
}

enum AuthorLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

model Author {
  id           Int         @id @default(autoincrement())
  name         String
  email        String      @unique
  level        AuthorLevel @default(BEGINNER)
  
  // Flexible specialties and bio
  specialties  String[]    // Array of expertise areas
  profile      Json?       // Bio, social links, etc.
  
  content      Content[]
}

model Content {
  id           Int           @id @default(autoincrement())
  title        String
  body         String
  type         ContentType
  status       ContentStatus @default(DRAFT)
  
  // Type-specific metadata
  metadata     Json?         // Different for each content type
  
  author       Author        @relation(fields: [authorId], references: [id])
  authorId     Int
  
  publishedAt  DateTime?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  
  @@index([type, status])
  @@index([authorId, status])
}
```

### JSON Validation Challenge

**Write TypeScript interfaces for this e-commerce product metadata:**

```prisma
model Product {
  id       Int    @id @default(autoincrement())
  name     String
  category String
  
  // Different metadata for different categories
  metadata Json?  // Electronics vs Clothing vs Books
}
```

**Requirements:**
- Electronics: specifications, warranty, certifications
- Clothing: sizes, materials, care instructions
- Books: author, publisher, ISBN, page count

**Your Interfaces:**
```typescript
// Define your TypeScript interfaces here
type ProductMetadata = // Your union type
```

**Sample Solution:**
```typescript
type ProductMetadata = ElectronicsMetadata | ClothingMetadata | BookMetadata

interface ElectronicsMetadata {
  type: 'electronics'
  specifications: {
    [key: string]: string | number
  }
  warranty: {
    duration: number
    unit: 'months' | 'years'
    coverage: string[]
  }
  certifications?: string[]
  energyRating?: string
}

interface ClothingMetadata {
  type: 'clothing'
  sizes: {
    available: string[]
    chart: 'US' | 'EU' | 'UK' | 'International'
  }
  materials: {
    primary: string
    secondary?: string[]
    composition: string
  }
  care: {
    washingInstructions: string
    dryingInstructions: string
    specialCare?: string[]
  }
  colors: string[]
}

interface BookMetadata {
  type: 'book'
  author: string
  publisher: string
  isbn: string
  pages: number
  language: string
  edition?: string
  publicationDate: string
  genres: string[]
  format: 'hardcover' | 'paperback' | 'ebook' | 'audiobook'
}
```

---

## üí° Key Takeaways

- üìù **Enums Provide Constraints**: Use enums for fixed vocabularies to ensure data consistency
- üóÉÔ∏è **JSON Enables Flexibility**: JSON fields handle semi-structured data that varies between records
- üé≠ **Type Unions Handle Alternatives**: Use discriminator patterns for "one of several types" scenarios
- üèóÔ∏è **Composite Types Group Related Data**: Structure complex data with interfaces for type safety
- ‚öñÔ∏è **Balance Structure vs Flexibility**: Choose the right level of schema rigidity for your use case
- üîß **Validate JSON Data**: Use schema validation libraries to ensure JSON field integrity
- üéØ **Design for Evolution**: Advanced types help schemas adapt to changing requirements
- üìä **Consider Query Patterns**: Some data belongs in separate tables for better queryability

---

## üîó Navigation

**üìç Current Location**: Module 1 ‚Üí Section 1.3 ‚Üí Lesson 1.3.4

**‚¨ÖÔ∏è Previous**: [1.3.3 Relationships and References](./1.3.3-relationships-and-references.md)
**‚û°Ô∏è Next**: [1.3.5 Schema Validation and Constraints](./1.3.5-schema-validation-and-constraints.md)

**üè† Section Home**: [1.3 Schema Design](./README.md)
**üìö Module Home**: [Module 1: Foundations](../01-foundations.md)

**üó∫Ô∏è Quick Links**:
- [Previous: Relationships](./1.3.3-relationships-and-references.md)
- [Next: Schema Validation](./1.3.5-schema-validation-and-constraints.md)
- [Jump to: Client Operations](../../04-client-operations/)

---

*Ready to learn about schema validation and constraints? Continue to the next lesson!*
