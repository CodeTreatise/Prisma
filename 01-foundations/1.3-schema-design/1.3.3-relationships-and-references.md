# 1.3.3 Relationships and References

## 📋 Section Overview
- **Duration**: 35 minutes
- **Prerequisites**: Understanding of Prisma schema basics and database relationships
- **Learning Objectives**: 
  - Master all types of relationships in Prisma (one-to-one, one-to-many, many-to-many)
  - Understand referential actions and cascade behaviors
  - Learn self-referencing relationships and advanced patterns
  - Apply relationship best practices for data integrity and performance
- **Difficulty Level**: Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Design and implement all relationship types in Prisma schemas
- ✅ Configure referential actions for data consistency
- ✅ Create complex relationship patterns like self-references and polymorphic relations
- ✅ Optimize relationship queries for better performance
- ✅ Avoid common relationship pitfalls and anti-patterns

---

## 📖 Content

### Understanding Relationships: The Family Tree Analogy

Database relationships are like **family connections** - they define how different pieces of data are related to each other. Just as family members have different types of relationships (parent-child, siblings, marriage), database tables have various connection patterns.

### 👨‍👩‍👧‍👦 The Family Connection System

```
👪 Family Relationships = 🗄️ Database Relationships

👫 Marriage (One-to-One)
├── One person → One spouse
├── Unique and exclusive
├── Example: User → Profile
└── Both sides reference each other

👨‍👧‍👦 Parent-Children (One-to-Many)  
├── One parent → Many children
├── Children belong to one parent
├── Example: User → Posts
└── Parent has list, children reference parent

👥 Cousins (Many-to-Many)
├── Many cousins ↔ Many cousins
├── Complex relationships need junction
├── Example: Students ↔ Courses
└── Requires relationship table

🔄 Family Tree (Self-Reference)
├── Family members → Other family members
├── Same type relates to itself
├── Example: Employee → Manager
└── Hierarchical structures
```

### 🔗 One-to-One Relationships

**The Marriage Certificate Pattern:**

```prisma
model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String
  
  // One-to-one relationship
  profile Profile?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  avatar String?
  
  // Back-reference to user
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int    @unique  // This makes it one-to-one
}
```

**Advanced One-to-One Patterns:**

```prisma
// User settings pattern
model User {
  id       Int           @id @default(autoincrement())
  email    String        @unique
  settings UserSettings?
}

model UserSettings {
  id                    Int     @id @default(autoincrement())
  theme                 String  @default("light")
  emailNotifications    Boolean @default(true)
  twoFactorEnabled      Boolean @default(false)
  language              String  @default("en")
  timezone              String  @default("UTC")
  
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                Int     @unique
}

// Account verification pattern
model User {
  id           Int                @id @default(autoincrement())
  email        String             @unique
  verification EmailVerification?
}

model EmailVerification {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  expiresAt DateTime
  verified  Boolean  @default(false)
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int      @unique
}
```

### 📚 One-to-Many Relationships

**The Library Book System:**

```prisma
model Author {
  id    Int    @id @default(autoincrement())
  name  String
  email String @unique
  
  // One author can have many books
  books Book[]
}

model Book {
  id          Int      @id @default(autoincrement())
  title       String
  isbn        String   @unique
  publishedAt DateTime
  
  // Many books belong to one author
  author      Author   @relation(fields: [authorId], references: [id])
  authorId    Int
}
```

**Complex One-to-Many Examples:**

```prisma
// Blog system with categories
model Category {
  id          Int    @id @default(autoincrement())
  name        String @unique
  slug        String @unique
  description String?
  
  posts       Post[]
}

model Post {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  published   Boolean   @default(false)
  publishedAt DateTime?
  
  // Post belongs to one category
  category    Category  @relation(fields: [categoryId], references: [id])
  categoryId  Int
  
  // Post belongs to one author
  author      User      @relation(fields: [authorId], references: [id])
  authorId    Int
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([categoryId, published])
  @@index([authorId])
}

// E-commerce order system
model Customer {
  id      Int     @id @default(autoincrement())
  email   String  @unique
  name    String
  
  orders  Order[]
}

model Order {
  id         Int         @id @default(autoincrement())
  total      Decimal
  status     OrderStatus @default(PENDING)
  
  customer   Customer    @relation(fields: [customerId], references: [id])
  customerId Int
  
  items      OrderItem[]
  
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}
```

### 🤝 Many-to-Many Relationships

**The Student-Course Enrollment System:**

```prisma
model Student {
  id          Int                @id @default(autoincrement())
  email       String             @unique
  name        String
  
  // Many-to-many through junction table
  enrollments CourseEnrollment[]
}

model Course {
  id          Int                @id @default(autoincrement())
  title       String
  code        String             @unique
  credits     Int
  
  // Many-to-many through junction table  
  enrollments CourseEnrollment[]
}

model CourseEnrollment {
  id         Int      @id @default(autoincrement())
  
  // References to both sides
  student    Student  @relation(fields: [studentId], references: [id])
  studentId  Int
  course     Course   @relation(fields: [courseId], references: [id])
  courseId   Int
  
  // Additional fields on the relationship
  enrolledAt DateTime @default(now())
  grade      String?
  completed  Boolean  @default(false)
  
  // Composite unique constraint
  @@unique([studentId, courseId])
}
```

**Advanced Many-to-Many Patterns:**

```prisma
// Social media following system
model User {
  id        Int       @id @default(autoincrement())
  username  String    @unique
  email     String    @unique
  
  // Following relationships
  following Follow[]  @relation("UserFollowing")
  followers Follow[]  @relation("UserFollowers")
  
  posts     Post[]
}

model Follow {
  id          Int      @id @default(autoincrement())
  
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id])
  followerId  Int
  following   User     @relation("UserFollowers", fields: [followingId], references: [id])
  followingId Int
  
  createdAt   DateTime @default(now())
  
  @@unique([followerId, followingId])
}

// Product tagging system
model Product {
  id          Int          @id @default(autoincrement())
  name        String
  description String
  
  tags        ProductTag[]
}

model Tag {
  id       Int          @id @default(autoincrement())
  name     String       @unique
  color    String?
  
  products ProductTag[]
}

model ProductTag {
  id        Int     @id @default(autoincrement())
  
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId Int
  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId     Int
  
  // Additional metadata
  addedAt   DateTime @default(now())
  addedBy   String   // Username who added the tag
  
  @@unique([productId, tagId])
}
```

### 🔄 Self-Referencing Relationships

**The Organizational Chart Pattern:**

```prisma
model Employee {
  id         Int        @id @default(autoincrement())
  name       String
  email      String     @unique
  position   String
  
  // Self-referencing relationship
  manager    Employee?  @relation("EmployeeManager", fields: [managerId], references: [id])
  managerId  Int?
  
  // Reverse relationship
  reports    Employee[] @relation("EmployeeManager")
  
  createdAt  DateTime   @default(now())
}
```

**More Self-Reference Examples:**

```prisma
// Forum categories with subcategories
model Category {
  id          Int        @id @default(autoincrement())
  name        String
  description String?
  
  // Self-reference for hierarchy
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  parentId    Int?
  children    Category[] @relation("CategoryHierarchy")
  
  posts       Post[]
}

// Comment threading system
model Comment {
  id        Int       @id @default(autoincrement())
  content   String
  
  // Post relationship
  post      Post      @relation(fields: [postId], references: [id])
  postId    Int
  
  // Self-reference for replies
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  parentId  Int?
  replies   Comment[] @relation("CommentReplies")
  
  author    User      @relation(fields: [authorId], references: [id])
  authorId  Int
  
  createdAt DateTime  @default(now())
}

// File system structure
model FileNode {
  id        Int        @id @default(autoincrement())
  name      String
  type      FileType   // FILE or FOLDER
  size      Int?       // Only for files
  content   Bytes?     // Only for files
  
  // Directory structure
  parent    FileNode?  @relation("FileHierarchy", fields: [parentId], references: [id])
  parentId  Int?
  children  FileNode[] @relation("FileHierarchy")
  
  owner     User       @relation(fields: [ownerId], references: [id])
  ownerId   Int
  
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

enum FileType {
  FILE
  FOLDER
}
```

### ⚙️ Referential Actions and Cascade Behaviors

**The Chain Reaction System:**

```prisma
model User {
  id       Int       @id @default(autoincrement())
  email    String    @unique
  name     String
  
  posts    Post[]
  comments Comment[]
  profile  Profile?
}

model Post {
  id        Int       @id @default(autoincrement())
  title     String
  content   String
  
  // Different cascade behaviors
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  Int
  
  comments  Comment[]
}

model Comment {
  id      Int    @id @default(autoincrement())
  content String
  
  // Cascade delete when post is deleted
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId  Int
  
  // Set to null when user is deleted (preserve comment)
  author  User?  @relation(fields: [authorId], references: [id], onDelete: SetNull)
  authorId Int?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  avatar String?
  
  // Restrict deletion if profile exists
  user   User   @relation(fields: [userId], references: [id], onDelete: Restrict)
  userId Int    @unique
}
```

**Referential Action Types:**

| Action | Behavior | Use Case |
|--------|----------|----------|
| `Cascade` | Delete related records | User deletion removes all posts |
| `SetNull` | Set foreign key to NULL | Keep comments when user deleted |
| `SetDefault` | Set to default value | Reassign to default category |
| `Restrict` | Prevent deletion | Can't delete category with posts |
| `NoAction` | Database handles it | Let database decide behavior |

**Strategic Action Examples:**

```prisma
// E-commerce system with proper cascades
model Customer {
  id     Int     @id @default(autoincrement())
  email  String  @unique
  name   String
  
  orders Order[]
}

model Order {
  id         Int         @id @default(autoincrement())
  total      Decimal
  
  // Restrict: Can't delete customer with orders
  customer   Customer    @relation(fields: [customerId], references: [id], onDelete: Restrict)
  customerId Int
  
  items      OrderItem[]
}

model Product {
  id          Int         @id @default(autoincrement())
  name        String
  price       Decimal
  
  orderItems  OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  quantity  Int
  price     Decimal // Snapshot of price at time of order
  
  // Cascade: Remove items when order deleted
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   Int
  
  // Restrict: Can't delete product that's been ordered
  product   Product @relation(fields: [productId], references: [id], onDelete: Restrict)
  productId Int
  
  @@unique([orderId, productId])
}
```

### 🎭 Advanced Relationship Patterns

#### **Polymorphic Relationships**

```prisma
model Comment {
  id              Int      @id @default(autoincrement())
  content         String
  
  // Polymorphic reference
  commentableType String   // "Post", "Photo", "Video"
  commentableId   Int      // ID of the referenced entity
  
  author          User     @relation(fields: [authorId], references: [id])
  authorId        Int
  
  createdAt       DateTime @default(now())
  
  @@index([commentableType, commentableId])
}

// Application code handles the polymorphic logic
model Post {
  id      Int    @id @default(autoincrement())
  title   String
  content String
  // Comments handled in application layer
}

model Photo {
  id      Int     @id @default(autoincrement())
  url     String
  caption String?
  // Comments handled in application layer
}
```

#### **Conditional Relationships**

```prisma
model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  accountType   String   // "individual", "business"
  
  // Conditional relationships based on account type
  individualProfile IndividualProfile?
  businessProfile   BusinessProfile?
}

model IndividualProfile {
  id          Int     @id @default(autoincrement())
  firstName   String
  lastName    String
  dateOfBirth DateTime
  
  user        User    @relation(fields: [userId], references: [id])
  userId      Int     @unique
}

model BusinessProfile {
  id            Int     @id @default(autoincrement())
  companyName   String
  taxId         String  @unique
  industry      String
  
  user          User    @relation(fields: [userId], references: [id])
  userId        Int     @unique
}
```

#### **Temporal Relationships**

```prisma
model Employee {
  id          Int                @id @default(autoincrement())
  name        String
  email       String             @unique
  
  assignments ProjectAssignment[]
}

model Project {
  id          Int                @id @default(autoincrement())
  name        String
  description String
  
  assignments ProjectAssignment[]
}

model ProjectAssignment {
  id        Int       @id @default(autoincrement())
  
  employee  Employee  @relation(fields: [employeeId], references: [id])
  employeeId Int
  project   Project   @relation(fields: [projectId], references: [id])
  projectId Int
  
  // Temporal aspects
  startDate DateTime
  endDate   DateTime?
  role      String
  isActive  Boolean   @default(true)
  
  @@unique([employeeId, projectId, startDate])
}
```

### 🚀 Relationship Performance Optimization

#### **Strategic Indexing for Relationships**

```prisma
model Post {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  published   Boolean   @default(false)
  publishedAt DateTime?
  
  author      User      @relation(fields: [authorId], references: [id])
  authorId    Int
  category    Category  @relation(fields: [categoryId], references: [id])
  categoryId  Int
  
  comments    Comment[]
  tags        PostTag[]
  
  createdAt   DateTime  @default(now())
  
  // Strategic indexes for common queries
  @@index([authorId, published])        // Author's published posts
  @@index([categoryId, publishedAt])    // Recent posts in category
  @@index([published, createdAt])       // All published posts by date
}
```

#### **Relationship Loading Strategies**

```typescript
// Eager loading with include
const postsWithComments = await prisma.post.findMany({
  include: {
    author: true,
    comments: {
      include: {
        author: true
      }
    }
  }
});

// Selective loading with select
const postTitlesWithAuthors = await prisma.post.findMany({
  select: {
    title: true,
    author: {
      select: {
        name: true
      }
    }
  }
});

// Pagination for large relationships
const userWithRecentPosts = await prisma.user.findUnique({
  where: { id: 1 },
  include: {
    posts: {
      orderBy: { createdAt: 'desc' },
      take: 10,
      skip: 0
    }
  }
});
```

---

## 🧠 Knowledge Check

### Relationship Type Identification

1. **What type of relationship should you use for a user's profile information?**
   - [x] A) One-to-One
   - [ ] B) One-to-Many  
   - [ ] C) Many-to-Many
   - [ ] D) Self-Reference

   **Explanation**: Each user has exactly one profile, and each profile belongs to exactly one user.

2. **Which referential action should you use when deleting a blog category that has posts?**
   - [ ] A) Cascade (delete all posts)
   - [ ] B) SetNull (remove category reference)
   - [x] C) Restrict (prevent deletion)
   - [ ] D) NoAction

   **Explanation**: Deleting a category with posts would likely be unintentional and cause data loss. Restrict prevents this.

3. **What makes a many-to-many relationship different from two one-to-many relationships?**
   - [ ] A) Nothing, they're the same
   - [ ] B) Many-to-many uses fewer tables
   - [x] C) Many-to-many allows additional data on the relationship
   - [ ] D) Many-to-many is faster

   **Explanation**: The junction table in many-to-many can store additional fields about the relationship itself.

### Schema Design Challenge

**Design a social media platform with the following requirements:**
- Users can create posts
- Users can follow other users
- Posts can be liked by users
- Users can comment on posts
- Comments can be replied to (threaded)

**Your Schema:**
```prisma
// Design your models here
model User {
  // Your design
}

// Add other models as needed
```

**Sample Solution:**
```prisma
model User {
  id        Int       @id @default(autoincrement())
  username  String    @unique
  email     String    @unique
  name      String
  
  posts     Post[]
  comments  Comment[]
  likes     Like[]
  
  // Following relationships
  following Follow[]  @relation("UserFollowing")
  followers Follow[]  @relation("UserFollowers")
  
  createdAt DateTime  @default(now())
}

model Post {
  id        Int       @id @default(autoincrement())
  content   String
  imageUrl  String?
  
  author    User      @relation(fields: [authorId], references: [id])
  authorId  Int
  
  comments  Comment[]
  likes     Like[]
  
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Comment {
  id        Int       @id @default(autoincrement())
  content   String
  
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    Int
  
  author    User      @relation(fields: [authorId], references: [id])
  authorId  Int
  
  // Self-reference for threading
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  parentId  Int?
  replies   Comment[] @relation("CommentReplies")
  
  createdAt DateTime  @default(now())
}

model Like {
  id     Int  @id @default(autoincrement())
  
  user   User @relation(fields: [userId], references: [id])
  userId Int
  post   Post @relation(fields: [postId], references: [id])
  postId Int
  
  createdAt DateTime @default(now())
  
  @@unique([userId, postId])
}

model Follow {
  id          Int      @id @default(autoincrement())
  
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id])
  followerId  Int
  following   User     @relation("UserFollowers", fields: [followingId], references: [id])
  followingId Int
  
  createdAt   DateTime @default(now())
  
  @@unique([followerId, followingId])
}
```

### Referential Action Scenario

**Given this e-learning platform, choose the appropriate referential actions:**

```prisma
model Course {
  id       Int                @id @default(autoincrement())
  title    String
  lessons  Lesson[]
  enrollments CourseEnrollment[]
}

model Lesson {
  id       Int     @id @default(autoincrement())
  title    String
  content  String
  course   Course  @relation(fields: [courseId], references: [id], onDelete: ?)
  courseId Int
}

model Student {
  id          Int                @id @default(autoincrement())
  email       String             @unique
  enrollments CourseEnrollment[]
}

model CourseEnrollment {
  student   Student @relation(fields: [studentId], references: [id], onDelete: ?)
  course    Course  @relation(fields: [courseId], references: [id], onDelete: ?)
  // ... other fields
}
```

**Your Choices:**
1. Lesson → Course: _______________
2. Enrollment → Student: _______________  
3. Enrollment → Course: _______________

**Sample Answers:**
1. **Lesson → Course**: `Cascade` (lessons are meaningless without course)
2. **Enrollment → Student**: `Cascade` (remove enrollments when student deleted)
3. **Enrollment → Course**: `Cascade` (remove enrollments when course deleted)

---

## 💡 Key Takeaways

- 👨‍👩‍👧‍👦 **Relationships Mirror Reality**: Model your data relationships like real-world connections
- 🔗 **Choose the Right Type**: One-to-one for unique pairs, one-to-many for ownership, many-to-many for associations
- ⚙️ **Cascade Carefully**: Think through what should happen when related data is deleted
- 🔄 **Self-References Enable Hierarchies**: Use for organizational charts, categories, comments
- 🎭 **Advanced Patterns Solve Complex Problems**: Polymorphic and conditional relationships handle special cases
- 📊 **Index Relationship Fields**: Foreign keys need indexes for performance
- 🚀 **Load Strategically**: Use include and select to control what data is fetched
- 🔒 **Referential Integrity Protects Data**: Let the database enforce your business rules

---

## 🔗 Navigation

**📍 Current Location**: Module 1 → Section 1.3 → Lesson 1.3.3

**⬅️ Previous**: [1.3.2 Data Types and Field Attributes](./1.3.2-data-types-and-field-attributes.md)
**➡️ Next**: [1.3.4 Enums and Advanced Types](./1.3.4-enums-and-advanced-types.md)

**🏠 Section Home**: [1.3 Schema Design](./README.md)
**📚 Module Home**: [Module 1: Foundations](../01-foundations.md)

**🗺️ Quick Links**:
- [Previous: Data Types](./1.3.2-data-types-and-field-attributes.md)
- [Next: Enums and Advanced Types](./1.3.4-enums-and-advanced-types.md)
- [Jump to: Client Operations](../../04-client-operations/)

---

*Ready to explore enums and advanced type patterns? Continue to the next lesson!*
