# 1.3.2 Data Types and Field Attributes

## 📋 Section Overview
- **Duration**: 40 minutes
- **Prerequisites**: Basic understanding of Prisma schema structure and database concepts
- **Learning Objectives**: 
  - Master all Prisma scalar and composite data types
  - Understand field attributes and their practical applications
  - Learn database-specific type mappings and optimizations
  - Apply validation and constraint attributes effectively
- **Difficulty Level**: Beginner to Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Use all Prisma data types confidently and appropriately
- ✅ Apply field attributes for validation, constraints, and optimization
- ✅ Understand database-specific type mappings and native types
- ✅ Implement proper indexing strategies using attributes
- ✅ Design schemas with performance and data integrity in mind

---

## 📖 Content

### Understanding Data Types: The Building Blocks Analogy

Think of **data types** as different types of **containers** in a warehouse. Just as you wouldn't store liquids in a cardboard box or fragile items in a metal container, each piece of data needs the right "container" (data type) to be stored safely and efficiently.

### 🏗️ The Warehouse Container System

```
📦 Warehouse Storage = 🗄️ Database Storage

📋 Container Types (Data Types)
├── Small boxes → String (text)
├── Number slots → Int, Float (numbers)
├── Calendar slots → DateTime (dates)
├── Switch boxes → Boolean (true/false)
├── Secure vaults → Bytes (binary data)
├── Flexible bags → Json (structured data)
└── Precision scales → Decimal (exact numbers)

🏷️ Container Labels (Attributes)
├── "Fragile" stickers → @unique
├── Size limits → @db.VarChar(50)
├── Required tags → (no ?)
├── Default contents → @default()
├── Special handling → @id, @updatedAt
└── Group organization → @@index()

📍 Warehouse Layout (Schema)
├── Organized sections → Models
├── Container placement → Field definitions
├── Access routes → Relationships
└── Inventory system → Primary keys
```

### 📊 Prisma Scalar Data Types

#### **String Types**

```prisma
model User {
  // Basic string
  name        String              // Required text field
  bio         String?             // Optional text field
  
  // String with length constraints
  username    String    @db.VarChar(50)    // Max 50 characters
  description String    @db.Text           // Large text (>65KB)
  
  // String with validation
  email       String    @unique            // Must be unique
  slug        String    @unique @db.VarChar(100)
  
  // String with defaults
  status      String    @default("active")
  role        String    @default("user")
}
```

**String Type Variations:**

| Prisma Type | Database Mapping | Use Case | Example |
|-------------|------------------|----------|---------|
| `String` | `VARCHAR(191)` (MySQL) | Short text | Names, emails |
| `String @db.Text` | `TEXT` | Long content | Blog posts, descriptions |
| `String @db.VarChar(n)` | `VARCHAR(n)` | Limited length | Usernames, codes |
| `String @db.Char(n)` | `CHAR(n)` | Fixed length | Country codes, UUIDs |

#### **Numeric Types**

```prisma
model Product {
  id          Int       @id @default(autoincrement())
  
  // Integer types
  quantity    Int                           // Standard integer
  views       Int       @default(0)        // With default
  priority    Int       @db.SmallInt       // Small integer (-32K to 32K)
  largeNum    BigInt                       // Large integer
  
  // Floating point numbers
  rating      Float                        // Approximate decimal
  weight      Float     @db.DoublePrecision
  
  // Precise decimal numbers
  price       Decimal   @db.Decimal(10, 2) // 10 digits, 2 decimal places
  tax         Decimal   @db.Decimal(5, 4)  // High precision
}
```

**Numeric Type Guide:**

```
🔢 Choosing the Right Numeric Type

💰 Money/Currency
├── Use: Decimal @db.Decimal(10, 2)
├── Why: Exact precision needed
└── Example: prices, taxes, balances

📊 Statistics/Measurements  
├── Use: Float or DoublePrecision
├── Why: Approximate values acceptable
└── Example: ratings, coordinates, percentages

🔢 Counting/IDs
├── Use: Int (or BigInt for large datasets)
├── Why: Whole numbers only
└── Example: quantities, IDs, counters

📏 Precise Scientific Data
├── Use: Decimal with high precision
├── Why: Accuracy critical
└── Example: scientific measurements, coordinates
```

#### **Date and Time Types**

```prisma
model Event {
  id            Int       @id @default(autoincrement())
  
  // Standard datetime
  createdAt     DateTime  @default(now())     // Auto-set on create
  updatedAt     DateTime  @updatedAt          // Auto-update on modify
  
  // Manual datetime fields
  scheduledAt   DateTime                      // User-specified time
  publishAt     DateTime?                     // Optional future time
  expiresAt     DateTime?                     // Optional expiration
  
  // Date-only field
  eventDate     DateTime  @db.Date           // Date without time
  
  // Time-only field  
  startTime     DateTime  @db.Time           // Time without date
  
  // Timestamp with timezone
  globalTime    DateTime  @db.Timestamptz    // Timezone-aware
}
```

**DateTime Best Practices:**

```prisma
// ✅ Recommended patterns
model Article {
  id            Int       @id @default(autoincrement())
  
  // Audit trail timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Content lifecycle
  publishedAt   DateTime?  // Null = draft, set = published
  archivedAt    DateTime?  // Soft archive timestamp
  
  // Business logic timestamps
  scheduledFor  DateTime?  // Future publication
  deadlineAt    DateTime?  // Content deadline
}

// ❌ Common mistakes
model BadExample {
  created       String    // Don't store dates as strings
  timestamp     Int       // Don't use Unix timestamps
  date          String    // Don't use DD/MM/YYYY format
}
```

#### **Boolean Type**

```prisma
model User {
  id            Int     @id @default(autoincrement())
  
  // Basic boolean fields
  isActive      Boolean @default(true)
  isVerified    Boolean @default(false)
  isAdmin       Boolean @default(false)
  
  // Preference booleans
  emailNotifications    Boolean @default(true)
  smsNotifications     Boolean @default(false)
  
  // Feature flags
  hasProAccess  Boolean @default(false)
  canPost       Boolean @default(true)
}
```

**Boolean Naming Conventions:**

```
✅ Good Boolean Names:
├── is[State]: isActive, isVerified, isPublished
├── has[Feature]: hasAccess, hasPermission, hasPaid
├── can[Action]: canEdit, canDelete, canPost
├── should[Behavior]: shouldNotify, shouldIndex
└── enable[Feature]: enableNotifications, enableLogging

❌ Avoid These Patterns:
├── active (unclear what true/false means)
├── status (should be enum or string)
├── permissions (should be array or relation)
└── settings (too vague)
```

#### **Bytes Type**

```prisma
model Media {
  id          Int     @id @default(autoincrement())
  
  // File storage
  thumbnail   Bytes?  // Small image data
  signature   Bytes   // Digital signature
  hash        Bytes   // File hash/checksum
  
  // Metadata
  filename    String
  mimeType    String
  size        Int
  
  createdAt   DateTime @default(now())
}
```

#### **JSON Type**

```prisma
model Configuration {
  id        Int   @id @default(autoincrement())
  
  // Flexible data storage
  settings  Json  // User preferences object
  metadata  Json? // Optional extra data
  analytics Json? // Usage statistics
  
  // Typed JSON examples in application code:
  // settings: { theme: "dark", language: "en" }
  // metadata: { tags: ["urgent", "review"], priority: 1 }
  // analytics: { views: 150, clicks: 23, lastVisit: "2024-01-15" }
}
```

**JSON Field Best Practices:**

```typescript
// ✅ Good JSON usage patterns
interface UserSettings {
  theme: 'light' | 'dark'
  language: string
  notifications: {
    email: boolean
    push: boolean
    frequency: 'daily' | 'weekly' | 'never'
  }
}

// In your Prisma model
model User {
  id       Int           @id @default(autoincrement())
  email    String        @unique
  settings Json          // Store UserSettings interface
}

// ❌ Avoid storing relational data in JSON
// Don't do this:
// settings: { friends: [1, 2, 3], posts: [...] }
// Use proper relationships instead
```

### 🏷️ Field Attributes

#### **Constraint Attributes**

```prisma
model User {
  // Primary key
  id          Int      @id @default(autoincrement())
  uuid        String   @id @default(uuid())         // UUID primary key
  
  // Unique constraints
  email       String   @unique
  username    String   @unique
  phoneNumber String?  @unique                      // Optional but unique
  
  // Required vs Optional
  name        String                                // Required
  bio         String?                               // Optional (nullable)
  age         Int?                                  // Optional integer
}
```

#### **Default Value Attributes**

```prisma
model Post {
  id          Int       @id @default(autoincrement())
  
  // Static defaults
  status      String    @default("draft")
  priority    Int       @default(0)
  isPublished Boolean   @default(false)
  
  // Function defaults
  createdAt   DateTime  @default(now())
  uuid        String    @default(uuid())
  slug        String    @default(cuid())
  
  // Database function defaults  
  sequence    Int       @default(autoincrement())
}
```

**Default Value Functions:**

| Function | Description | Example |
|----------|-------------|---------|
| `autoincrement()` | Auto-incrementing integer | `id Int @default(autoincrement())` |
| `now()` | Current timestamp | `createdAt DateTime @default(now())` |
| `uuid()` | Random UUID v4 | `publicId String @default(uuid())` |
| `cuid()` | Collision-resistant ID | `slug String @default(cuid())` |
| `dbgenerated()` | Database-generated value | `hash String @default(dbgenerated("gen_random_uuid()"))` |

#### **Auto-Update Attributes**

```prisma
model Article {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  
  // Automatic timestamp management
  createdAt   DateTime  @default(now())     // Set once on creation
  updatedAt   DateTime  @updatedAt          // Updated on every change
  
  // Manual timestamp fields
  publishedAt DateTime?                     // Set programmatically
  viewedAt    DateTime?                     // Updated by application
}
```

### 🗄️ Database-Specific Type Mappings

#### **PostgreSQL Native Types**

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model PostgresTypes {
  id            Int       @id @default(autoincrement())
  
  // Text types
  shortText     String    @db.VarChar(255)
  longText      String    @db.Text
  charField     String    @db.Char(10)
  
  // Numeric types
  smallNumber   Int       @db.SmallInt      // -32,768 to 32,767
  bigNumber     BigInt    @db.BigInt        // Large integers
  realNumber    Float     @db.Real          // Single precision
  doubleNumber  Float     @db.DoublePrecision
  
  // Precise decimals
  money         Decimal   @db.Money         // PostgreSQL money type
  precise       Decimal   @db.Decimal(10,2) // 10 digits, 2 decimal
  
  // Date/time types
  timestamp     DateTime  @db.Timestamp(6)  // Microsecond precision
  timestampTz   DateTime  @db.Timestamptz(6)
  dateOnly      DateTime  @db.Date
  timeOnly      DateTime  @db.Time(6)
  
  // PostgreSQL specific
  uuid          String    @db.Uuid          // Native UUID
  jsonField     Json      @db.Json          // JSON type
  jsonbField    Json      @db.JsonB         // Binary JSON (faster)
  
  // Array types (PostgreSQL only)
  tags          String[]                    // Array of strings
  numbers       Int[]                       // Array of integers
}
```

#### **MySQL Native Types**

```prisma
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model MySQLTypes {
  id            Int       @id @default(autoincrement())
  
  // String types
  title         String    @db.VarChar(255)
  content       String    @db.Text
  summary       String    @db.TinyText      // Up to 255 chars
  description   String    @db.MediumText    // Up to 16MB
  fullContent   String    @db.LongText      // Up to 4GB
  
  // Integer types
  tinyNum       Int       @db.TinyInt       // -128 to 127
  smallNum      Int       @db.SmallInt      // -32K to 32K
  mediumNum     Int       @db.MediumInt     // -8M to 8M
  regularNum    Int       @db.Int           // Standard int
  bigNum        BigInt    @db.BigInt        // Large integers
  
  // Floating point
  floatNum      Float     @db.Float
  doubleNum     Float     @db.Double
  
  // Date/time
  dateField     DateTime  @db.Date
  timeField     DateTime  @db.Time
  yearField     Int       @db.Year          // Year only
  
  // MySQL specific
  binaryData    Bytes     @db.Binary(16)    // Fixed length binary
  varBinary     Bytes     @db.VarBinary(255)
}
```

#### **SQLite Type Mappings**

```prisma
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model SQLiteTypes {
  id          Int       @id @default(autoincrement())
  
  // SQLite has fewer native types, but Prisma maps appropriately
  text        String                    // TEXT
  integer     Int                       // INTEGER  
  real        Float                     // REAL
  blob        Bytes                     // BLOB
  
  // Date handling in SQLite (stored as text/integer)
  createdAt   DateTime  @default(now()) // Stored as ISO string
  timestamp   Int                       // Unix timestamp
}
```

### 📊 Composite Attributes and Indexes

#### **Multi-field Indexes**

```prisma
model BlogPost {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  published   Boolean   @default(false)
  authorId    Int
  categoryId  Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  author      User      @relation(fields: [authorId], references: [id])
  category    Category  @relation(fields: [categoryId], references: [id])
  
  // Composite indexes for performance
  @@index([published, createdAt])      // Query published posts by date
  @@index([authorId, published])       // Query author's published posts
  @@index([categoryId, published, createdAt]) // Category posts by date
  
  // Unique composite constraint
  @@unique([authorId, title])          // No duplicate titles per author
}
```

#### **Advanced Composite Attributes**

```prisma
model Product {
  id            Int       @id @default(autoincrement())
  sku           String
  name          String
  categoryId    Int
  brandId       Int
  price         Decimal   @db.Decimal(10,2)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  
  category      Category  @relation(fields: [categoryId], references: [id])
  brand         Brand     @relation(fields: [brandId], references: [id])
  
  // Multiple composite constraints
  @@unique([sku])                      // SKU must be unique globally
  @@unique([categoryId, name])         // Name unique within category
  @@unique([brandId, sku])             // SKU unique within brand
  
  // Performance indexes
  @@index([isActive, price])           // Active products by price
  @@index([categoryId, isActive])      // Active products in category
  @@index([createdAt])                 // Recent products
  
  // Full-text search index (database specific)
  @@index([name, sku], type: Hash)     // Hash index for exact matches
}
```

### 🎯 Advanced Field Patterns

#### **Soft Delete Pattern**

```prisma
model User {
  id          Int       @id @default(autoincrement())
  email       String    @unique
  name        String
  
  // Audit trail
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Soft delete timestamp
  
  // Only include non-deleted users in most queries
  @@index([deletedAt])  // Index for filtering soft-deleted records
}
```

#### **Versioning Pattern**

```prisma
model Document {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  
  // Versioning fields
  version     Int       @default(1)
  isLatest    Boolean   @default(true)
  parentId    Int?      // Reference to previous version
  
  // Relationships
  parent      Document? @relation("DocumentVersions", fields: [parentId], references: [id])
  versions    Document[] @relation("DocumentVersions")
  
  createdAt   DateTime  @default(now())
  
  // Ensure only one latest version per document chain
  @@index([parentId, isLatest])
}
```

#### **Multi-tenant Pattern**

```prisma
model Post {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  
  // Multi-tenancy
  organizationId Int
  organization   Organization @relation(fields: [organizationId], references: [id])
  
  // Always filter by organization
  @@index([organizationId, createdAt])
  @@unique([organizationId, title])  // Unique titles per organization
}
```

### 🔧 Type Validation and Error Handling

#### **Schema Validation Patterns**

```prisma
model User {
  id          Int       @id @default(autoincrement())
  
  // Email validation (application level)
  email       String    @unique
  
  // Constrained strings
  username    String    @unique @db.VarChar(50)  // Max 50 chars
  
  // Enum validation
  role        UserRole  @default(USER)
  status      UserStatus @default(ACTIVE)
  
  // Range constraints (application level validation needed)
  age         Int?      // Validate 0-150 in application
  rating      Float?    // Validate 0.0-5.0 in application
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
  SUPER_ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}
```

#### **Error Prevention Strategies**

```typescript
// Application-level validation with Prisma
import { PrismaClient } from '@prisma/client'
import { z } from 'zod'

const prisma = new PrismaClient()

// Define validation schema
const UserCreateSchema = z.object({
  email: z.string().email(),
  username: z.string().min(3).max(50),
  age: z.number().min(0).max(150).optional(),
  role: z.enum(['USER', 'ADMIN', 'MODERATOR']).default('USER')
})

// Validated user creation
async function createUser(userData: unknown) {
  try {
    // Validate input
    const validData = UserCreateSchema.parse(userData)
    
    // Create user with Prisma
    const user = await prisma.user.create({
      data: validData
    })
    
    return { success: true, user }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, errors: error.errors }
    }
    throw error
  }
}
```

---

## 🧠 Knowledge Check

### Data Type Selection Quiz

1. **Which data type should you use for storing exact monetary values?**
   - [ ] A) Float
   - [ ] B) Int
   - [x] C) Decimal
   - [ ] D) String

   **Explanation**: Decimal provides exact precision needed for monetary calculations, avoiding floating-point rounding errors.

2. **What's the difference between `@default(now())` and `@updatedAt`?**
   - [x] A) `@default(now())` sets timestamp on creation only, `@updatedAt` updates on every change
   - [ ] B) They do the same thing
   - [ ] C) `@updatedAt` only works with DateTime fields
   - [ ] D) `@default(now())` is deprecated

   **Explanation**: `@default(now())` sets the timestamp once when the record is created, while `@updatedAt` automatically updates the timestamp whenever the record is modified.

3. **Which attribute makes a field optional/nullable?**
   - [ ] A) @optional
   - [ ] B) @nullable
   - [x] C) ? (question mark)
   - [ ] D) @default(null)

   **Explanation**: Adding a `?` after the type (e.g., `String?`) makes the field optional and nullable in the database.

### Schema Design Exercise

**Design a product catalog schema with proper data types:**

```prisma
model Product {
  // Add appropriate fields with correct types and attributes
  // Requirements:
  // - Unique product SKU
  // - Name and description
  // - Price with exact precision
  // - Stock quantity
  // - Product ratings (0.0 to 5.0)
  // - Creation and update timestamps
  // - Optional category relationship
}
```

**Sample Solution:**
```prisma
model Product {
  id          Int       @id @default(autoincrement())
  sku         String    @unique @db.VarChar(50)
  name        String    @db.VarChar(255)
  description String?   @db.Text
  price       Decimal   @db.Decimal(10, 2)
  stock       Int       @default(0)
  rating      Float?    // Application validates 0.0-5.0
  isActive    Boolean   @default(true)
  
  categoryId  Int?
  category    Category? @relation(fields: [categoryId], references: [id])
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([isActive, categoryId])
  @@index([price])
}

model Category {
  id          Int       @id @default(autoincrement())
  name        String    @unique @db.VarChar(100)
  description String?
  products    Product[]
}
```

### Performance Optimization Challenge

**Analyze this schema and suggest index improvements:**

```prisma
model BlogPost {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  published   Boolean   @default(false)
  publishedAt DateTime?
  authorId    Int
  categoryId  Int
  viewCount   Int       @default(0)
  createdAt   DateTime  @default(now())
  
  author      User      @relation(fields: [authorId], references: [id])
  category    Category  @relation(fields: [categoryId], references: [id])
}
```

**Common Query Patterns:**
1. Find published posts ordered by publication date
2. Find posts by specific author
3. Find popular posts (high view count) in a category
4. Find recent posts across all categories

**Your Index Suggestions:**
```prisma
// Add your @@index() suggestions here
```

**Sample Solution:**
```prisma
model BlogPost {
  // ... same fields as above
  
  // Indexes for common query patterns
  @@index([published, publishedAt])      // Published posts by date
  @@index([authorId, published])         // Author's published posts
  @@index([categoryId, viewCount])       // Popular posts in category
  @@index([createdAt])                   // Recent posts
  @@index([published, categoryId, publishedAt]) // Category posts by date
}
```

---

## 💡 Key Takeaways

- 🏗️ **Right Container for Right Data**: Choose data types based on how data will be used and stored
- 🎯 **Precision Matters**: Use Decimal for exact numbers (money), Float for approximate values
- 📅 **Timestamp Strategy**: Use `@default(now())` for creation time, `@updatedAt` for modification tracking
- 🔧 **Attributes Add Power**: Constraints, defaults, and indexes make your schema robust and performant
- 🗄️ **Database-Specific Types**: Leverage native database types for optimal performance and storage
- 📊 **Index Strategically**: Create composite indexes based on your actual query patterns
- ✅ **Validate Early**: Combine database constraints with application-level validation
- 🔗 **Think Relationships**: Design fields to support the relationships your application needs

---

## 🔗 Navigation

**📍 Current Location**: Module 1 → Section 1.3 → Lesson 1.3.2

**⬅️ Previous**: [1.3.1 Introduction to Prisma Schema](./1.3.1-introduction-to-prisma-schema.md)
**➡️ Next**: [1.3.3 Relationships and References](./1.3.3-relationships-and-references.md)

**🏠 Section Home**: [1.3 Schema Design](./README.md)
**📚 Module Home**: [Module 1: Foundations](../01-foundations.md)

**🗺️ Quick Links**:
- [Previous: Schema Introduction](./1.3.1-introduction-to-prisma-schema.md)
- [Next: Relationships](./1.3.3-relationships-and-references.md)
- [Jump to: Client Operations](../../04-client-operations/)

---

*Ready to master relationships and references in Prisma? Continue to the next lesson!*
