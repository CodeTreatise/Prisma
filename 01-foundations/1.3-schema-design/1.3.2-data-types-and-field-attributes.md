# 1.3.2 Data Types and Field Attributes

## üìã Section Overview
- **Duration**: 40 minutes
- **Prerequisites**: Basic understanding of Prisma schema structure and database concepts
- **Learning Objectives**: 
  - Master all Prisma scalar and composite data types
  - Understand field attributes and their practical applications
  - Learn database-specific type mappings and optimizations
  - Apply validation and constraint attributes effectively
- **Difficulty Level**: Beginner to Intermediate

---

## üéØ What You'll Learn

By the end of this section, you will:
- ‚úÖ Use all Prisma data types confidently and appropriately
- ‚úÖ Apply field attributes for validation, constraints, and optimization
- ‚úÖ Understand database-specific type mappings and native types
- ‚úÖ Implement proper indexing strategies using attributes
- ‚úÖ Design schemas with performance and data integrity in mind

---

## üìñ Content

### Understanding Data Types: The Building Blocks Analogy

Think of **data types** as different types of **containers** in a warehouse. Just as you wouldn't store liquids in a cardboard box or fragile items in a metal container, each piece of data needs the right "container" (data type) to be stored safely and efficiently.

### üèóÔ∏è The Warehouse Container System

```
üì¶ Warehouse Storage = üóÑÔ∏è Database Storage

üìã Container Types (Data Types)
‚îú‚îÄ‚îÄ Small boxes ‚Üí String (text)
‚îú‚îÄ‚îÄ Number slots ‚Üí Int, Float (numbers)
‚îú‚îÄ‚îÄ Calendar slots ‚Üí DateTime (dates)
‚îú‚îÄ‚îÄ Switch boxes ‚Üí Boolean (true/false)
‚îú‚îÄ‚îÄ Secure vaults ‚Üí Bytes (binary data)
‚îú‚îÄ‚îÄ Flexible bags ‚Üí Json (structured data)
‚îî‚îÄ‚îÄ Precision scales ‚Üí Decimal (exact numbers)

üè∑Ô∏è Container Labels (Attributes)
‚îú‚îÄ‚îÄ "Fragile" stickers ‚Üí @unique
‚îú‚îÄ‚îÄ Size limits ‚Üí @db.VarChar(50)
‚îú‚îÄ‚îÄ Required tags ‚Üí (no ?)
‚îú‚îÄ‚îÄ Default contents ‚Üí @default()
‚îú‚îÄ‚îÄ Special handling ‚Üí @id, @updatedAt
‚îî‚îÄ‚îÄ Group organization ‚Üí @@index()

üìç Warehouse Layout (Schema)
‚îú‚îÄ‚îÄ Organized sections ‚Üí Models
‚îú‚îÄ‚îÄ Container placement ‚Üí Field definitions
‚îú‚îÄ‚îÄ Access routes ‚Üí Relationships
‚îî‚îÄ‚îÄ Inventory system ‚Üí Primary keys
```

### üìä Prisma Scalar Data Types

#### **String Types**

```prisma
model User {
  // Basic string
  name        String              // Required text field
  bio         String?             // Optional text field
  
  // String with length constraints
  username    String    @db.VarChar(50)    // Max 50 characters
  description String    @db.Text           // Large text (>65KB)
  
  // String with validation
  email       String    @unique            // Must be unique
  slug        String    @unique @db.VarChar(100)
  
  // String with defaults
  status      String    @default("active")
  role        String    @default("user")
}
```

**String Type Variations:**

| Prisma Type | Database Mapping | Use Case | Example |
|-------------|------------------|----------|---------|
| `String` | `VARCHAR(191)` (MySQL) | Short text | Names, emails |
| `String @db.Text` | `TEXT` | Long content | Blog posts, descriptions |
| `String @db.VarChar(n)` | `VARCHAR(n)` | Limited length | Usernames, codes |
| `String @db.Char(n)` | `CHAR(n)` | Fixed length | Country codes, UUIDs |

#### **Numeric Types**

```prisma
model Product {
  id          Int       @id @default(autoincrement())
  
  // Integer types
  quantity    Int                           // Standard integer
  views       Int       @default(0)        // With default
  priority    Int       @db.SmallInt       // Small integer (-32K to 32K)
  largeNum    BigInt                       // Large integer
  
  // Floating point numbers
  rating      Float                        // Approximate decimal
  weight      Float     @db.DoublePrecision
  
  // Precise decimal numbers
  price       Decimal   @db.Decimal(10, 2) // 10 digits, 2 decimal places
  tax         Decimal   @db.Decimal(5, 4)  // High precision
}
```

**Numeric Type Guide:**

```
üî¢ Choosing the Right Numeric Type

üí∞ Money/Currency
‚îú‚îÄ‚îÄ Use: Decimal @db.Decimal(10, 2)
‚îú‚îÄ‚îÄ Why: Exact precision needed
‚îî‚îÄ‚îÄ Example: prices, taxes, balances

üìä Statistics/Measurements  
‚îú‚îÄ‚îÄ Use: Float or DoublePrecision
‚îú‚îÄ‚îÄ Why: Approximate values acceptable
‚îî‚îÄ‚îÄ Example: ratings, coordinates, percentages

üî¢ Counting/IDs
‚îú‚îÄ‚îÄ Use: Int (or BigInt for large datasets)
‚îú‚îÄ‚îÄ Why: Whole numbers only
‚îî‚îÄ‚îÄ Example: quantities, IDs, counters

üìè Precise Scientific Data
‚îú‚îÄ‚îÄ Use: Decimal with high precision
‚îú‚îÄ‚îÄ Why: Accuracy critical
‚îî‚îÄ‚îÄ Example: scientific measurements, coordinates
```

#### **Date and Time Types**

```prisma
model Event {
  id            Int       @id @default(autoincrement())
  
  // Standard datetime
  createdAt     DateTime  @default(now())     // Auto-set on create
  updatedAt     DateTime  @updatedAt          // Auto-update on modify
  
  // Manual datetime fields
  scheduledAt   DateTime                      // User-specified time
  publishAt     DateTime?                     // Optional future time
  expiresAt     DateTime?                     // Optional expiration
  
  // Date-only field
  eventDate     DateTime  @db.Date           // Date without time
  
  // Time-only field  
  startTime     DateTime  @db.Time           // Time without date
  
  // Timestamp with timezone
  globalTime    DateTime  @db.Timestamptz    // Timezone-aware
}
```

**DateTime Best Practices:**

```prisma
// ‚úÖ Recommended patterns
model Article {
  id            Int       @id @default(autoincrement())
  
  // Audit trail timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Content lifecycle
  publishedAt   DateTime?  // Null = draft, set = published
  archivedAt    DateTime?  // Soft archive timestamp
  
  // Business logic timestamps
  scheduledFor  DateTime?  // Future publication
  deadlineAt    DateTime?  // Content deadline
}

// ‚ùå Common mistakes
model BadExample {
  created       String    // Don't store dates as strings
  timestamp     Int       // Don't use Unix timestamps
  date          String    // Don't use DD/MM/YYYY format
}
```

#### **Boolean Type**

```prisma
model User {
  id            Int     @id @default(autoincrement())
  
  // Basic boolean fields
  isActive      Boolean @default(true)
  isVerified    Boolean @default(false)
  isAdmin       Boolean @default(false)
  
  // Preference booleans
  emailNotifications    Boolean @default(true)
  smsNotifications     Boolean @default(false)
  
  // Feature flags
  hasProAccess  Boolean @default(false)
  canPost       Boolean @default(true)
}
```

**Boolean Naming Conventions:**

```
‚úÖ Good Boolean Names:
‚îú‚îÄ‚îÄ is[State]: isActive, isVerified, isPublished
‚îú‚îÄ‚îÄ has[Feature]: hasAccess, hasPermission, hasPaid
‚îú‚îÄ‚îÄ can[Action]: canEdit, canDelete, canPost
‚îú‚îÄ‚îÄ should[Behavior]: shouldNotify, shouldIndex
‚îî‚îÄ‚îÄ enable[Feature]: enableNotifications, enableLogging

‚ùå Avoid These Patterns:
‚îú‚îÄ‚îÄ active (unclear what true/false means)
‚îú‚îÄ‚îÄ status (should be enum or string)
‚îú‚îÄ‚îÄ permissions (should be array or relation)
‚îî‚îÄ‚îÄ settings (too vague)
```

#### **Bytes Type**

```prisma
model Media {
  id          Int     @id @default(autoincrement())
  
  // File storage
  thumbnail   Bytes?  // Small image data
  signature   Bytes   // Digital signature
  hash        Bytes   // File hash/checksum
  
  // Metadata
  filename    String
  mimeType    String
  size        Int
  
  createdAt   DateTime @default(now())
}
```

#### **JSON Type**

```prisma
model Configuration {
  id        Int   @id @default(autoincrement())
  
  // Flexible data storage
  settings  Json  // User preferences object
  metadata  Json? // Optional extra data
  analytics Json? // Usage statistics
  
  // Typed JSON examples in application code:
  // settings: { theme: "dark", language: "en" }
  // metadata: { tags: ["urgent", "review"], priority: 1 }
  // analytics: { views: 150, clicks: 23, lastVisit: "2024-01-15" }
}
```

**JSON Field Best Practices:**

```typescript
// ‚úÖ Good JSON usage patterns
interface UserSettings {
  theme: 'light' | 'dark'
  language: string
  notifications: {
    email: boolean
    push: boolean
    frequency: 'daily' | 'weekly' | 'never'
  }
}

// In your Prisma model
model User {
  id       Int           @id @default(autoincrement())
  email    String        @unique
  settings Json          // Store UserSettings interface
}

// ‚ùå Avoid storing relational data in JSON
// Don't do this:
// settings: { friends: [1, 2, 3], posts: [...] }
// Use proper relationships instead
```

### üè∑Ô∏è Field Attributes

#### **Constraint Attributes**

```prisma
model User {
  // Primary key
  id          Int      @id @default(autoincrement())
  uuid        String   @id @default(uuid())         // UUID primary key
  
  // Unique constraints
  email       String   @unique
  username    String   @unique
  phoneNumber String?  @unique                      // Optional but unique
  
  // Required vs Optional
  name        String                                // Required
  bio         String?                               // Optional (nullable)
  age         Int?                                  // Optional integer
}
```

#### **Default Value Attributes**

```prisma
model Post {
  id          Int       @id @default(autoincrement())
  
  // Static defaults
  status      String    @default("draft")
  priority    Int       @default(0)
  isPublished Boolean   @default(false)
  
  // Function defaults
  createdAt   DateTime  @default(now())
  uuid        String    @default(uuid())
  slug        String    @default(cuid())
  
  // Database function defaults  
  sequence    Int       @default(autoincrement())
}
```

**Default Value Functions:**

| Function | Description | Example |
|----------|-------------|---------|
| `autoincrement()` | Auto-incrementing integer | `id Int @default(autoincrement())` |
| `now()` | Current timestamp | `createdAt DateTime @default(now())` |
| `uuid()` | Random UUID v4 | `publicId String @default(uuid())` |
| `cuid()` | Collision-resistant ID | `slug String @default(cuid())` |
| `dbgenerated()` | Database-generated value | `hash String @default(dbgenerated("gen_random_uuid()"))` |

#### **Auto-Update Attributes**

```prisma
model Article {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  
  // Automatic timestamp management
  createdAt   DateTime  @default(now())     // Set once on creation
  updatedAt   DateTime  @updatedAt          // Updated on every change
  
  // Manual timestamp fields
  publishedAt DateTime?                     // Set programmatically
  viewedAt    DateTime?                     // Updated by application
}
```

### üóÑÔ∏è Database-Specific Type Mappings

#### **PostgreSQL Native Types**

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model PostgresTypes {
  id            Int       @id @default(autoincrement())
  
  // Text types
  shortText     String    @db.VarChar(255)
  longText      String    @db.Text
  charField     String    @db.Char(10)
  
  // Numeric types
  smallNumber   Int       @db.SmallInt      // -32,768 to 32,767
  bigNumber     BigInt    @db.BigInt        // Large integers
  realNumber    Float     @db.Real          // Single precision
  doubleNumber  Float     @db.DoublePrecision
  
  // Precise decimals
  money         Decimal   @db.Money         // PostgreSQL money type
  precise       Decimal   @db.Decimal(10,2) // 10 digits, 2 decimal
  
  // Date/time types
  timestamp     DateTime  @db.Timestamp(6)  // Microsecond precision
  timestampTz   DateTime  @db.Timestamptz(6)
  dateOnly      DateTime  @db.Date
  timeOnly      DateTime  @db.Time(6)
  
  // PostgreSQL specific
  uuid          String    @db.Uuid          // Native UUID
  jsonField     Json      @db.Json          // JSON type
  jsonbField    Json      @db.JsonB         // Binary JSON (faster)
  
  // Array types (PostgreSQL only)
  tags          String[]                    // Array of strings
  numbers       Int[]                       // Array of integers
}
```

#### **MySQL Native Types**

```prisma
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model MySQLTypes {
  id            Int       @id @default(autoincrement())
  
  // String types
  title         String    @db.VarChar(255)
  content       String    @db.Text
  summary       String    @db.TinyText      // Up to 255 chars
  description   String    @db.MediumText    // Up to 16MB
  fullContent   String    @db.LongText      // Up to 4GB
  
  // Integer types
  tinyNum       Int       @db.TinyInt       // -128 to 127
  smallNum      Int       @db.SmallInt      // -32K to 32K
  mediumNum     Int       @db.MediumInt     // -8M to 8M
  regularNum    Int       @db.Int           // Standard int
  bigNum        BigInt    @db.BigInt        // Large integers
  
  // Floating point
  floatNum      Float     @db.Float
  doubleNum     Float     @db.Double
  
  // Date/time
  dateField     DateTime  @db.Date
  timeField     DateTime  @db.Time
  yearField     Int       @db.Year          // Year only
  
  // MySQL specific
  binaryData    Bytes     @db.Binary(16)    // Fixed length binary
  varBinary     Bytes     @db.VarBinary(255)
}
```

#### **SQLite Type Mappings**

```prisma
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model SQLiteTypes {
  id          Int       @id @default(autoincrement())
  
  // SQLite has fewer native types, but Prisma maps appropriately
  text        String                    // TEXT
  integer     Int                       // INTEGER  
  real        Float                     // REAL
  blob        Bytes                     // BLOB
  
  // Date handling in SQLite (stored as text/integer)
  createdAt   DateTime  @default(now()) // Stored as ISO string
  timestamp   Int                       // Unix timestamp
}
```

### üìä Composite Attributes and Indexes

#### **Multi-field Indexes**

```prisma
model BlogPost {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  published   Boolean   @default(false)
  authorId    Int
  categoryId  Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  author      User      @relation(fields: [authorId], references: [id])
  category    Category  @relation(fields: [categoryId], references: [id])
  
  // Composite indexes for performance
  @@index([published, createdAt])      // Query published posts by date
  @@index([authorId, published])       // Query author's published posts
  @@index([categoryId, published, createdAt]) // Category posts by date
  
  // Unique composite constraint
  @@unique([authorId, title])          // No duplicate titles per author
}
```

#### **Advanced Composite Attributes**

```prisma
model Product {
  id            Int       @id @default(autoincrement())
  sku           String
  name          String
  categoryId    Int
  brandId       Int
  price         Decimal   @db.Decimal(10,2)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  
  category      Category  @relation(fields: [categoryId], references: [id])
  brand         Brand     @relation(fields: [brandId], references: [id])
  
  // Multiple composite constraints
  @@unique([sku])                      // SKU must be unique globally
  @@unique([categoryId, name])         // Name unique within category
  @@unique([brandId, sku])             // SKU unique within brand
  
  // Performance indexes
  @@index([isActive, price])           // Active products by price
  @@index([categoryId, isActive])      // Active products in category
  @@index([createdAt])                 // Recent products
  
  // Full-text search index (database specific)
  @@index([name, sku], type: Hash)     // Hash index for exact matches
}
```

### üéØ Advanced Field Patterns

#### **Soft Delete Pattern**

```prisma
model User {
  id          Int       @id @default(autoincrement())
  email       String    @unique
  name        String
  
  // Audit trail
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Soft delete timestamp
  
  // Only include non-deleted users in most queries
  @@index([deletedAt])  // Index for filtering soft-deleted records
}
```

#### **Versioning Pattern**

```prisma
model Document {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  
  // Versioning fields
  version     Int       @default(1)
  isLatest    Boolean   @default(true)
  parentId    Int?      // Reference to previous version
  
  // Relationships
  parent      Document? @relation("DocumentVersions", fields: [parentId], references: [id])
  versions    Document[] @relation("DocumentVersions")
  
  createdAt   DateTime  @default(now())
  
  // Ensure only one latest version per document chain
  @@index([parentId, isLatest])
}
```

#### **Multi-tenant Pattern**

```prisma
model Post {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  
  // Multi-tenancy
  organizationId Int
  organization   Organization @relation(fields: [organizationId], references: [id])
  
  // Always filter by organization
  @@index([organizationId, createdAt])
  @@unique([organizationId, title])  // Unique titles per organization
}
```

### üîß Type Validation and Error Handling

#### **Schema Validation Patterns**

```prisma
model User {
  id          Int       @id @default(autoincrement())
  
  // Email validation (application level)
  email       String    @unique
  
  // Constrained strings
  username    String    @unique @db.VarChar(50)  // Max 50 chars
  
  // Enum validation
  role        UserRole  @default(USER)
  status      UserStatus @default(ACTIVE)
  
  // Range constraints (application level validation needed)
  age         Int?      // Validate 0-150 in application
  rating      Float?    // Validate 0.0-5.0 in application
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
  SUPER_ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}
```

#### **Error Prevention Strategies**

```typescript
// Application-level validation with Prisma
import { PrismaClient } from '@prisma/client'
import { z } from 'zod'

const prisma = new PrismaClient()

// Define validation schema
const UserCreateSchema = z.object({
  email: z.string().email(),
  username: z.string().min(3).max(50),
  age: z.number().min(0).max(150).optional(),
  role: z.enum(['USER', 'ADMIN', 'MODERATOR']).default('USER')
})

// Validated user creation
async function createUser(userData: unknown) {
  try {
    // Validate input
    const validData = UserCreateSchema.parse(userData)
    
    // Create user with Prisma
    const user = await prisma.user.create({
      data: validData
    })
    
    return { success: true, user }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, errors: error.errors }
    }
    throw error
  }
}
```

---

## üß† Knowledge Check

### Data Type Selection Quiz

1. **Which data type should you use for storing exact monetary values?**
   - [ ] A) Float
   - [ ] B) Int
   - [x] C) Decimal
   - [ ] D) String

   **Explanation**: Decimal provides exact precision needed for monetary calculations, avoiding floating-point rounding errors.

2. **What's the difference between `@default(now())` and `@updatedAt`?**
   - [x] A) `@default(now())` sets timestamp on creation only, `@updatedAt` updates on every change
   - [ ] B) They do the same thing
   - [ ] C) `@updatedAt` only works with DateTime fields
   - [ ] D) `@default(now())` is deprecated

   **Explanation**: `@default(now())` sets the timestamp once when the record is created, while `@updatedAt` automatically updates the timestamp whenever the record is modified.

3. **Which attribute makes a field optional/nullable?**
   - [ ] A) @optional
   - [ ] B) @nullable
   - [x] C) ? (question mark)
   - [ ] D) @default(null)

   **Explanation**: Adding a `?` after the type (e.g., `String?`) makes the field optional and nullable in the database.

### Schema Design Exercise

**Design a product catalog schema with proper data types:**

```prisma
model Product {
  // Add appropriate fields with correct types and attributes
  // Requirements:
  // - Unique product SKU
  // - Name and description
  // - Price with exact precision
  // - Stock quantity
  // - Product ratings (0.0 to 5.0)
  // - Creation and update timestamps
  // - Optional category relationship
}
```

**Sample Solution:**
```prisma
model Product {
  id          Int       @id @default(autoincrement())
  sku         String    @unique @db.VarChar(50)
  name        String    @db.VarChar(255)
  description String?   @db.Text
  price       Decimal   @db.Decimal(10, 2)
  stock       Int       @default(0)
  rating      Float?    // Application validates 0.0-5.0
  isActive    Boolean   @default(true)
  
  categoryId  Int?
  category    Category? @relation(fields: [categoryId], references: [id])
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([isActive, categoryId])
  @@index([price])
}

model Category {
  id          Int       @id @default(autoincrement())
  name        String    @unique @db.VarChar(100)
  description String?
  products    Product[]
}
```

### Performance Optimization Challenge

**Analyze this schema and suggest index improvements:**

```prisma
model BlogPost {
  id          Int       @id @default(autoincrement())
  title       String
  content     String
  published   Boolean   @default(false)
  publishedAt DateTime?
  authorId    Int
  categoryId  Int
  viewCount   Int       @default(0)
  createdAt   DateTime  @default(now())
  
  author      User      @relation(fields: [authorId], references: [id])
  category    Category  @relation(fields: [categoryId], references: [id])
}
```

**Common Query Patterns:**
1. Find published posts ordered by publication date
2. Find posts by specific author
3. Find popular posts (high view count) in a category
4. Find recent posts across all categories

**Your Index Suggestions:**
```prisma
// Add your @@index() suggestions here
```

**Sample Solution:**
```prisma
model BlogPost {
  // ... same fields as above
  
  // Indexes for common query patterns
  @@index([published, publishedAt])      // Published posts by date
  @@index([authorId, published])         // Author's published posts
  @@index([categoryId, viewCount])       // Popular posts in category
  @@index([createdAt])                   // Recent posts
  @@index([published, categoryId, publishedAt]) // Category posts by date
}
```

---

## üí° Key Takeaways

- üèóÔ∏è **Right Container for Right Data**: Choose data types based on how data will be used and stored
- üéØ **Precision Matters**: Use Decimal for exact numbers (money), Float for approximate values
- üìÖ **Timestamp Strategy**: Use `@default(now())` for creation time, `@updatedAt` for modification tracking
- üîß **Attributes Add Power**: Constraints, defaults, and indexes make your schema robust and performant
- üóÑÔ∏è **Database-Specific Types**: Leverage native database types for optimal performance and storage
- üìä **Index Strategically**: Create composite indexes based on your actual query patterns
- ‚úÖ **Validate Early**: Combine database constraints with application-level validation
- üîó **Think Relationships**: Design fields to support the relationships your application needs

---

## üîó Navigation

**üìç Current Location**: Module 1 ‚Üí Section 1.3 ‚Üí Lesson 1.3.2

**‚¨ÖÔ∏è Previous**: [1.3.1 Introduction to Prisma Schema](./1.3.1-introduction-to-prisma-schema.md)
**‚û°Ô∏è Next**: [1.3.3 Relationships and References](./1.3.3-relationships-and-references.md)

**üè† Section Home**: [1.3 Schema Design](./README.md)
**üìö Module Home**: [Module 1: Foundations](../01-foundations.md)

**üó∫Ô∏è Quick Links**:
- [Previous: Schema Introduction](./1.3.1-introduction-to-prisma-schema.md)
- [Next: Relationships](./1.3.3-relationships-and-references.md)
- [Jump to: Client Operations](../../04-client-operations/)

---

*Ready to master relationships and references in Prisma? Continue to the next lesson!*
