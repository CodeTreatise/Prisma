# 1.2.2 SQL Fundamentals

## ğŸ“‹ Section Overview
- **Duration**: 40 minutes
- **Prerequisites**: Understanding of relational database concepts, tables, and relationships
- **Learning Objectives**: 
  - Master essential SQL commands and syntax
  - Understand how SQL operations translate to Prisma queries
  - Learn to read and write basic to intermediate SQL
  - Recognize SQL patterns that Prisma optimizes automatically
- **Difficulty Level**: Beginner to Intermediate

---

## ğŸ¯ What You'll Learn

By the end of this section, you will:
- âœ… Write basic SQL queries for data retrieval and manipulation
- âœ… Understand JOIN operations and their relationship equivalents in Prisma
- âœ… Recognize how Prisma's query API maps to SQL operations
- âœ… Debug and optimize database queries using SQL knowledge
- âœ… Appreciate how Prisma abstracts complex SQL patterns

---

## ğŸ“– Content

### What is SQL?

**SQL** (Structured Query Language) is like the **universal language** for talking to databases. Think of it as learning to speak directly with your database, while Prisma serves as your intelligent translator.

### ğŸ—£ï¸ The Language Learning Analogy

```
ğŸŒ Database Communication

ğŸ‘¤ You (Developer)
â”œâ”€â”€ Speaks: JavaScript/TypeScript
â”œâ”€â”€ Thinks: Objects and functions
â””â”€â”€ Wants: Clean, readable code

ğŸ¤– Prisma (Translator)
â”œâ”€â”€ Understands: Your object-based queries
â”œâ”€â”€ Translates: To optimized SQL
â””â”€â”€ Handles: Complex SQL patterns automatically

ğŸ—„ï¸ Database
â”œâ”€â”€ Speaks: Only SQL
â”œâ”€â”€ Thinks: Tables, rows, columns
â””â”€â”€ Executes: SQL commands efficiently
```

### ğŸ”¤ SQL Command Categories

#### **1. DDL (Data Definition Language) - Structure Commands**

**Creating the Building:**
```sql
-- Create a new table (like buying a filing cabinet)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Modify table structure (like adding new drawers)
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- Remove table (like throwing away the cabinet)
DROP TABLE users;
```

**Prisma Equivalent:**
```prisma
// schema.prisma handles DDL through migrations
model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  phone     String?
  createdAt DateTime @default(now())
}
```

#### **2. DML (Data Manipulation Language) - Data Commands**

**Working with the Files:**

##### **INSERT - Adding New Records**

**SQL:**
```sql
-- Add a single user
INSERT INTO users (name, email) 
VALUES ('Alice Smith', 'alice@example.com');

-- Add multiple users at once
INSERT INTO users (name, email) VALUES 
    ('Bob Johnson', 'bob@example.com'),
    ('Carol Davis', 'carol@example.com');
```

**Prisma:**
```typescript
// Single user
const user = await prisma.user.create({
  data: {
    name: 'Alice Smith',
    email: 'alice@example.com'
  }
});

// Multiple users
const users = await prisma.user.createMany({
  data: [
    { name: 'Bob Johnson', email: 'bob@example.com' },
    { name: 'Carol Davis', email: 'carol@example.com' }
  ]
});
```

##### **SELECT - Retrieving Data**

**Basic Queries:**
```sql
-- Get all users
SELECT * FROM users;

-- Get specific columns
SELECT name, email FROM users;

-- Get users with conditions
SELECT * FROM users WHERE name = 'Alice Smith';

-- Get users with pattern matching
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- Sort results
SELECT * FROM users ORDER BY created_at DESC;

-- Limit results
SELECT * FROM users LIMIT 10;
```

**Prisma Equivalents:**
```typescript
// Get all users
const users = await prisma.user.findMany();

// Get specific fields
const users = await prisma.user.findMany({
  select: {
    name: true,
    email: true
  }
});

// Get with conditions
const user = await prisma.user.findFirst({
  where: {
    name: 'Alice Smith'
  }
});

// Pattern matching
const gmailUsers = await prisma.user.findMany({
  where: {
    email: {
      endsWith: '@gmail.com'
    }
  }
});

// Sort and limit
const recentUsers = await prisma.user.findMany({
  orderBy: {
    createdAt: 'desc'
  },
  take: 10
});
```

##### **UPDATE - Modifying Records**

**SQL:**
```sql
-- Update a single user
UPDATE users 
SET name = 'Alice Johnson' 
WHERE id = 1;

-- Update multiple users
UPDATE users 
SET phone = '555-0000' 
WHERE created_at < '2023-01-01';
```

**Prisma:**
```typescript
// Update single user
const user = await prisma.user.update({
  where: { id: 1 },
  data: { name: 'Alice Johnson' }
});

// Update multiple users
const users = await prisma.user.updateMany({
  where: {
    createdAt: {
      lt: new Date('2023-01-01')
    }
  },
  data: {
    phone: '555-0000'
  }
});
```

##### **DELETE - Removing Records**

**SQL:**
```sql
-- Delete specific user
DELETE FROM users WHERE id = 1;

-- Delete with conditions
DELETE FROM users WHERE created_at < '2022-01-01';
```

**Prisma:**
```typescript
// Delete specific user
await prisma.user.delete({
  where: { id: 1 }
});

// Delete multiple users
await prisma.user.deleteMany({
  where: {
    createdAt: {
      lt: new Date('2022-01-01')
    }
  }
});
```

#### **3. DQL (Data Query Language) - Advanced Retrieval**

##### **JOINs - Connecting Tables**

**The Restaurant Order Analogy:**
```
ğŸ½ï¸ Restaurant Database

ğŸ“‹ Customers Table (Customer info)
ğŸ›ï¸ Orders Table (Order details)
ğŸ• OrderItems Table (What was ordered)
ğŸ“Š Products Table (Menu items)

To get "What did Alice order?", we need to:
1. Find Alice in Customers
2. Find her orders in Orders  
3. Find order items in OrderItems
4. Get product details from Products
```

**SQL JOINs:**
```sql
-- INNER JOIN: Get users and their orders (only users who have orders)
SELECT u.name, o.total, o.created_at
FROM users u
INNER JOIN orders o ON u.id = o.user_id;

-- LEFT JOIN: Get all users, with orders if they exist
SELECT u.name, o.total, o.created_at
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;

-- Complex JOIN: Get order details with products
SELECT 
    u.name as customer_name,
    o.id as order_id,
    p.name as product_name,
    oi.quantity,
    oi.price
FROM users u
INNER JOIN orders o ON u.id = o.user_id
INNER JOIN order_items oi ON o.id = oi.order_id
INNER JOIN products p ON oi.product_id = p.id;
```

**Prisma's Elegant Approach:**
```typescript
// Get users with their orders (automatic JOIN)
const usersWithOrders = await prisma.user.findMany({
  include: {
    orders: true
  }
});

// Complex nested includes (multiple JOINs)
const orderDetails = await prisma.user.findMany({
  include: {
    orders: {
      include: {
        items: {
          include: {
            product: true
          }
        }
      }
    }
  }
});

// Selective includes with filtering
const recentOrders = await prisma.user.findMany({
  include: {
    orders: {
      where: {
        createdAt: {
          gte: new Date('2024-01-01')
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                name: true,
                price: true
              }
            }
          }
        }
      }
    }
  }
});
```

##### **Aggregation Functions**

**SQL Aggregations:**
```sql
-- Count records
SELECT COUNT(*) FROM users;

-- Sum values
SELECT SUM(total) FROM orders;

-- Average, min, max
SELECT 
    AVG(total) as avg_order,
    MIN(total) as min_order,
    MAX(total) as max_order
FROM orders;

-- Group by
SELECT 
    user_id,
    COUNT(*) as order_count,
    SUM(total) as total_spent
FROM orders
GROUP BY user_id;

-- Having clause (filter groups)
SELECT 
    user_id,
    COUNT(*) as order_count
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 5;
```

**Prisma Aggregations:**
```typescript
// Count records
const userCount = await prisma.user.count();

// Sum values
const totalRevenue = await prisma.order.aggregate({
  _sum: {
    total: true
  }
});

// Multiple aggregations
const orderStats = await prisma.order.aggregate({
  _avg: { total: true },
  _min: { total: true },
  _max: { total: true },
  _count: true
});

// Group by with aggregations
const userOrderStats = await prisma.user.findMany({
  include: {
    _count: {
      select: {
        orders: true
      }
    },
    orders: {
      select: {
        total: true
      }
    }
  }
});
```

### ğŸš€ Advanced SQL Concepts

#### **Subqueries - Queries Within Queries**

**SQL Subqueries:**
```sql
-- Find users who have spent more than average
SELECT name, email
FROM users
WHERE id IN (
    SELECT user_id
    FROM orders
    GROUP BY user_id
    HAVING SUM(total) > (
        SELECT AVG(total_spent)
        FROM (
            SELECT SUM(total) as total_spent
            FROM orders
            GROUP BY user_id
        ) as user_totals
    )
);
```

**Prisma's Cleaner Approach:**
```typescript
// Prisma handles this with nested conditions
const highSpendingUsers = await prisma.user.findMany({
  where: {
    orders: {
      some: {
        total: {
          gt: averageOrderValue // Pre-calculated
        }
      }
    }
  }
});
```

#### **Window Functions (Advanced)**

**SQL Window Functions:**
```sql
-- Rank orders by total within each user
SELECT 
    user_id,
    total,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY total DESC) as rank
FROM orders;

-- Running totals
SELECT 
    created_at,
    total,
    SUM(total) OVER (ORDER BY created_at) as running_total
FROM orders;
```

**Prisma Approach:**
```typescript
// Prisma handles complex analytics through raw queries or application logic
const ordersWithRank = await prisma.$queryRaw`
  SELECT 
    user_id,
    total,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY total DESC) as rank
  FROM orders
`;
```

### ğŸ”§ How Prisma Optimizes SQL

#### **Automatic Query Optimization**

**What Prisma Does Behind the Scenes:**

```typescript
// Your Prisma code
const usersWithPosts = await prisma.user.findMany({
  include: {
    posts: {
      where: { published: true }
    }
  }
});

// Prisma generates optimized SQL
// Instead of N+1 queries, it creates:
/*
SELECT 
  u.id, u.name, u.email,
  p.id as post_id, p.title, p.content
FROM users u
LEFT JOIN posts p ON u.id = p.user_id AND p.published = true
*/
```

**Prevention of Common Issues:**

```typescript
// This WOULD be N+1 problem in traditional ORMs
const users = await User.findAll(); // 1 query
for (const user of users) {
  const posts = await user.getPosts(); // N queries!
}

// Prisma prevents this automatically
const users = await prisma.user.findMany({
  include: { posts: true } // Single optimized query
});
```

### ğŸ“Š SQL Data Types and Prisma Mapping

| SQL Type | Prisma Type | TypeScript Type | Example |
|----------|-------------|-----------------|---------|
| `INTEGER` | `Int` | `number` | `42` |
| `VARCHAR(n)` | `String` | `string` | `"Hello"` |
| `TEXT` | `String` | `string` | `"Long text..."` |
| `BOOLEAN` | `Boolean` | `boolean` | `true` |
| `TIMESTAMP` | `DateTime` | `Date` | `new Date()` |
| `DECIMAL` | `Decimal` | `Decimal` | `new Decimal("19.99")` |
| `JSON` | `Json` | `JsonValue` | `{ "key": "value" }` |

### ğŸ¯ Reading and Understanding SQL

#### **Common SQL Patterns You'll See:**

```sql
-- Pattern 1: Basic filtering
SELECT * FROM users WHERE active = true;

-- Pattern 2: Sorting and limiting
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10;

-- Pattern 3: Joins with conditions
SELECT u.name, COUNT(p.id) as post_count
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
WHERE u.active = true
GROUP BY u.id, u.name;

-- Pattern 4: Existence checks
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM posts p 
    WHERE p.user_id = u.id AND p.published = true
);
```

#### **How to Read Complex SQL:**

```sql
-- Reading this step by step:
SELECT 
    u.name as author_name,           -- 1. Select user name
    COUNT(p.id) as published_posts,  -- 2. Count their posts
    AVG(p.views) as avg_views        -- 3. Average post views
FROM users u                         -- 4. From users table
INNER JOIN posts p ON u.id = p.user_id  -- 5. Join with posts
WHERE p.published = true             -- 6. Only published posts
GROUP BY u.id, u.name               -- 7. Group by user
HAVING COUNT(p.id) > 5              -- 8. Only users with 5+ posts
ORDER BY avg_views DESC             -- 9. Sort by average views
LIMIT 10;                           -- 10. Top 10 results
```

---

## ğŸ§  Knowledge Check

### Quick Quiz

1. **What's the difference between INNER JOIN and LEFT JOIN?**
   - [ ] A) INNER JOIN is faster
   - [x] B) INNER JOIN only returns rows with matches in both tables
   - [ ] C) LEFT JOIN is more secure
   - [ ] D) There's no difference

   **Explanation**: INNER JOIN only returns rows where there's a match in both tables, while LEFT JOIN returns all rows from the left table plus matches from the right.

2. **How does Prisma prevent the N+1 query problem?**
   - [x] A) By automatically generating optimized JOINs
   - [ ] B) By caching all query results
   - [ ] C) By limiting the number of queries
   - [ ] D) By using a faster database connection

   **Explanation**: Prisma analyzes your query patterns and automatically generates optimized SQL with appropriate JOINs instead of multiple separate queries.

3. **What does the GROUP BY clause do?**
   - [ ] A) Sorts the results
   - [ ] B) Limits the number of results
   - [x] C) Combines rows with the same values for aggregation
   - [ ] D) Filters out duplicate rows

   **Explanation**: GROUP BY groups rows that have the same values in specified columns, allowing you to perform aggregation functions on each group.

### SQL to Prisma Translation

**Translate these SQL queries to Prisma:**

1. **SQL:**
   ```sql
   SELECT name, email FROM users WHERE active = true;
   ```
   
   **Your Prisma Query:**
   ```typescript
   // Your answer here
   ```

2. **SQL:**
   ```sql
   SELECT u.name, COUNT(p.id) as post_count
   FROM users u
   LEFT JOIN posts p ON u.id = p.user_id
   GROUP BY u.id, u.name;
   ```
   
   **Your Prisma Query:**
   ```typescript
   // Your answer here
   ```

**Sample Answers:**

1. ```typescript
   const activeUsers = await prisma.user.findMany({
     where: { active: true },
     select: { name: true, email: true }
   });
   ```

2. ```typescript
   const usersWithPostCount = await prisma.user.findMany({
     include: {
       _count: {
         select: { posts: true }
       }
     }
   });
   ```

### Performance Analysis

**Which approach is more efficient and why?**

**Scenario A:**
```typescript
const users = await prisma.user.findMany();
for (const user of users) {
  const postCount = await prisma.post.count({
    where: { userId: user.id }
  });
  console.log(`${user.name}: ${postCount} posts`);
}
```

**Scenario B:**
```typescript
const usersWithCounts = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true }
    }
  }
});
```

**Your Analysis:** _______________

**Answer:** Scenario B is much more efficient because it uses a single query with JOIN instead of N+1 queries (one for users, then one count query per user).

---

## ğŸ’¡ Key Takeaways

- ğŸ—£ï¸ **SQL is the Database Language**: Understanding SQL helps you appreciate what Prisma does behind the scenes
- ğŸ”„ **Prisma Translates Elegantly**: Object-based queries become optimized SQL automatically
- ğŸš€ **JOINs vs Includes**: Prisma's `include` and `select` generate efficient JOIN operations
- ğŸ¯ **No N+1 Problems**: Prisma automatically optimizes to prevent common performance issues
- ğŸ“Š **Type Safety Bridge**: Prisma provides TypeScript types for SQL operations
- ğŸ”§ **Raw Query Escape Hatch**: For complex SQL, Prisma offers `$queryRaw` and `$executeRaw`
- ğŸª **Best of Both Worlds**: Get SQL power with JavaScript/TypeScript developer experience

---

## ğŸ”— Navigation

**ğŸ“ Current Location**: Module 1 â†’ Section 1.2 â†’ Lesson 1.2.2

**â¬…ï¸ Previous**: [1.2.1 Relational Database Concepts](./1.2.1-relational-database-concepts.md)
**â¡ï¸ Next**: [1.2.3 Database Design Principles](./1.2.3-database-design-principles.md)

**ğŸ  Section Home**: [1.2 Database Fundamentals](./README.md)
**ğŸ“š Module Home**: [Module 1: Foundations](../01-foundations.md)

**ğŸ—ºï¸ Quick Links**:
- [Previous: Database Concepts](./1.2.1-relational-database-concepts.md)
- [Next: Design Principles](./1.2.3-database-design-principles.md)
- [Jump to: Schema Design](../1.3-schema-design/)

---

*Ready to learn about database design principles and best practices? Continue to the next lesson!*
