# 1.4.5 Docker Setup for Development

## 📋 Section Overview
- **Duration**: 40 minutes
- **Prerequisites**: Basic understanding of containerization concepts, Docker fundamentals
- **Learning Objectives**: 
  - Set up Docker containers for Prisma development environments
  - Configure multi-service development stacks with Docker Compose
  - Implement database containerization with persistent volumes
  - Optimize Docker workflows for rapid development iteration
  - Configure development, testing, and production-like environments
- **Difficulty Level**: Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Create Docker containers optimized for Prisma development
- ✅ Set up multi-service stacks with Docker Compose
- ✅ Configure persistent database storage and networking
- ✅ Implement hot reloading and development workflows
- ✅ Create consistent environments across team members
- ✅ Set up testing and CI/CD integration with Docker
- ✅ Optimize container performance and resource usage

---

## 📖 Content

### Understanding Docker for Prisma Development

Using Docker for Prisma development is like creating a **standardized laboratory with controlled conditions**. Just as scientists need consistent, reproducible environments to conduct reliable experiments, developers need isolated, consistent environments to ensure their Prisma applications work reliably across different machines, operating systems, and deployment scenarios.

### 🧪 The Controlled Laboratory Analogy

```
🧪 Scientific Laboratory = 🐳 Docker Environment

🏗️ Laboratory Infrastructure (Container Architecture)
├── Clean room → Isolated container environment
├── Controlled atmosphere → Consistent Node.js runtime
├── Precise instruments → Configured development tools
├── Standard protocols → Defined Docker workflows
├── Safety systems → Health checks and monitoring
└── Backup facilities → Volume persistence and snapshots

⚗️ Experiment Setup (Development Stack)
├── Main workbench → Application container
├── Sample storage → Database container
├── Analysis tools → Admin tools (Prisma Studio)
├── Data pipes → Container networking
├── Documentation → Configuration files
└── Quality control → Testing containers

🔬 Research Protocol (Development Workflow)
├── Setup procedures → docker-compose up
├── Sample preparation → Database seeding
├── Experiment execution → Code development
├── Data analysis → Application testing
├── Result validation → Integration testing
└── Documentation → Deployment preparation

🔒 Laboratory Standards (Consistency & Security)
├── Equipment calibration → Version pinning
├── Access control → Environment variables
├── Contamination prevention → Image security
├── Standard materials → Base image selection
├── Procedure documentation → Dockerfile best practices
└── Quality assurance → Multi-stage builds
```

---

## 🐳 Docker Fundamentals for Prisma

### 1. Basic Docker Setup

Start with a foundational understanding of Docker for Prisma applications.

#### **Dockerfile for Prisma Application**

```dockerfile
# Dockerfile
# Multi-stage build for optimized production image

# Development stage
FROM node:18-alpine AS development

# Install system dependencies
RUN apk add --no-cache \
    postgresql-client \
    git \
    curl

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./
COPY prisma ./prisma/

# Install dependencies
RUN npm ci

# Generate Prisma client
RUN npx prisma generate

# Copy source code
COPY . .

# Expose port
EXPOSE 3000

# Development command
CMD ["npm", "run", "dev"]

# Build stage
FROM development AS build

# Build the application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

# Install only production dependencies and PostgreSQL client
RUN apk add --no-cache postgresql-client

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install production dependencies only
RUN npm ci --only=production && npm cache clean --force

# Copy built application
COPY --from=build /app/dist ./dist
COPY --from=build /app/prisma ./prisma
COPY --from=build /app/node_modules/.prisma ./node_modules/.prisma

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# Change ownership
USER nextjs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# Production command
CMD ["npm", "start"]
```

#### **Optimized Development Dockerfile**

```dockerfile
# Dockerfile.dev - Optimized for development
FROM node:18-alpine

# Install development tools
RUN apk add --no-cache \
    postgresql-client \
    git \
    curl \
    bash \
    vim

# Install global tools
RUN npm install -g nodemon ts-node

# Set working directory
WORKDIR /app

# Copy package files first (for better layer caching)
COPY package*.json ./

# Install all dependencies
RUN npm ci

# Copy Prisma schema
COPY prisma ./prisma/

# Generate Prisma client
RUN npx prisma generate

# Create uploads directory
RUN mkdir -p uploads

# Expose ports
EXPOSE 3000 5555

# Health check
HEALTHCHECK --interval=10s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# Development command with watch mode
CMD ["npm", "run", "dev"]
```

### 2. Docker Compose Configuration

Create a comprehensive development environment with multiple services.

#### **Complete Docker Compose Setup**

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Main application
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
      target: development
    container_name: prisma_app
    ports:
      - "3000:3000"
      - "5555:5555"  # Prisma Studio
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp_dev
      - SHADOW_DATABASE_URL=postgresql://postgres:password@db:5432/myapp_shadow
      - PORT=3000
    volumes:
      - .:/app
      - /app/node_modules
      - uploads_data:/app/uploads
    depends_on:
      db:
        condition: service_healthy
    networks:
      - prisma_network
    restart: unless-stopped
    stdin_open: true
    tty: true

  # PostgreSQL Database
  db:
    image: postgres:15-alpine
    container_name: prisma_db
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=myapp_dev
      - POSTGRES_INITDB_ARGS=--auth-host=scram-sha-256
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    networks:
      - prisma_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d myapp_dev"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Redis (for caching/sessions)
  redis:
    image: redis:7-alpine
    container_name: prisma_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - prisma_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  # Prisma Studio (standalone)
  studio:
    build:
      context: .
      dockerfile: Dockerfile.dev
    container_name: prisma_studio
    ports:
      - "5556:5555"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp_dev
    command: ["npx", "prisma", "studio", "--port", "5555", "--hostname", "0.0.0.0"]
    depends_on:
      db:
        condition: service_healthy
    networks:
      - prisma_network
    restart: unless-stopped

  # pgAdmin (Database Administration)
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: prisma_pgadmin
    ports:
      - "8080:80"
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@example.com
      - PGADMIN_DEFAULT_PASSWORD=admin
      - PGADMIN_CONFIG_SERVER_MODE=False
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      - db
    networks:
      - prisma_network
    restart: unless-stopped

  # Mailhog (Email testing)
  mailhog:
    image: mailhog/mailhog:latest
    container_name: prisma_mailhog
    ports:
      - "1025:1025"  # SMTP
      - "8025:8025"  # Web UI
    networks:
      - prisma_network
    restart: unless-stopped

# Volumes for data persistence
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  pgadmin_data:
    driver: local
  uploads_data:
    driver: local

# Networks
networks:
  prisma_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

#### **Environment-Specific Compose Files**

```yaml
# docker-compose.test.yml
version: '3.8'

services:
  app:
    environment:
      - NODE_ENV=test
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp_test
    command: ["npm", "run", "test"]

  db:
    environment:
      - POSTGRES_DB=myapp_test
    volumes:
      - test_postgres_data:/var/lib/postgresql/data

volumes:
  test_postgres_data:
    driver: local
```

```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  app:
    build:
      target: production
    environment:
      - NODE_ENV=production
    restart: always
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M

  db:
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
```

### 3. Database Initialization

Set up database initialization scripts and seeding.

#### **Database Initialization Script**

```sql
-- scripts/init-db.sql
-- Create additional databases for testing
CREATE DATABASE myapp_test;
CREATE DATABASE myapp_shadow;

-- Create a read-only user for reporting
CREATE USER readonly_user WITH PASSWORD 'readonly_password';
GRANT CONNECT ON DATABASE myapp_dev TO readonly_user;
GRANT USAGE ON SCHEMA public TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO readonly_user;

-- Create extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
CREATE EXTENSION IF NOT EXISTS "btree_gin";

-- Performance optimizations
ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements';
ALTER SYSTEM SET track_activity_query_size = 2048;
ALTER SYSTEM SET pg_stat_statements.track = 'all';
```

#### **Docker Entrypoint Script**

```bash
#!/bin/bash
# scripts/docker-entrypoint.sh

set -e

# Wait for database to be ready
echo "🔄 Waiting for database to be ready..."
while ! pg_isready -h db -p 5432 -U postgres; do
  echo "Database is unavailable - sleeping"
  sleep 1
done

echo "✅ Database is ready!"

# Run Prisma migrations
echo "🔄 Running Prisma migrations..."
npx prisma migrate deploy

# Generate Prisma client
echo "🔄 Generating Prisma client..."
npx prisma generate

# Seed database if needed
if [ "$NODE_ENV" = "development" ]; then
  echo "🌱 Seeding database..."
  npx prisma db seed
fi

# Start the application
echo "🚀 Starting application..."
exec "$@"
```

---

## 🔧 Development Workflows

### 1. Development Commands

Create convenient npm scripts for Docker operations.

#### **Package.json Scripts**

```json
{
  "scripts": {
    "docker:build": "docker-compose build",
    "docker:up": "docker-compose up -d",
    "docker:down": "docker-compose down",
    "docker:logs": "docker-compose logs -f app",
    "docker:shell": "docker-compose exec app /bin/bash",
    "docker:db": "docker-compose exec db psql -U postgres -d myapp_dev",
    "docker:studio": "docker-compose exec app npx prisma studio",
    "docker:migrate": "docker-compose exec app npx prisma migrate dev",
    "docker:reset": "docker-compose exec app npx prisma migrate reset --force",
    "docker:seed": "docker-compose exec app npx prisma db seed",
    "docker:test": "docker-compose -f docker-compose.yml -f docker-compose.test.yml up --abort-on-container-exit",
    "docker:clean": "docker-compose down -v --remove-orphans && docker system prune -f",
    "docker:rebuild": "npm run docker:clean && npm run docker:build && npm run docker:up"
  }
}
```

#### **Makefile for Common Operations**

```makefile
# Makefile
.PHONY: help build up down logs shell db studio migrate reset seed test clean rebuild

# Default target
help:
	@echo "Available commands:"
	@echo "  build     - Build Docker images"
	@echo "  up        - Start all services"
	@echo "  down      - Stop all services"
	@echo "  logs      - View application logs"
	@echo "  shell     - Access application shell"
	@echo "  db        - Access database shell"
	@echo "  studio    - Open Prisma Studio"
	@echo "  migrate   - Run database migrations"
	@echo "  reset     - Reset database"
	@echo "  seed      - Seed database"
	@echo "  test      - Run tests"
	@echo "  clean     - Clean up containers and volumes"
	@echo "  rebuild   - Clean and rebuild everything"

build:
	docker-compose build

up:
	docker-compose up -d

down:
	docker-compose down

logs:
	docker-compose logs -f app

shell:
	docker-compose exec app /bin/bash

db:
	docker-compose exec db psql -U postgres -d myapp_dev

studio:
	@echo "🎨 Opening Prisma Studio at http://localhost:5556"
	@docker-compose up -d studio

migrate:
	docker-compose exec app npx prisma migrate dev

reset:
	docker-compose exec app npx prisma migrate reset --force

seed:
	docker-compose exec app npx prisma db seed

test:
	docker-compose -f docker-compose.yml -f docker-compose.test.yml up --abort-on-container-exit

clean:
	docker-compose down -v --remove-orphans
	docker system prune -f

rebuild: clean build up
	@echo "✅ Rebuild complete!"
```

### 2. Hot Reloading Setup

Configure hot reloading for rapid development iteration.

#### **Nodemon Configuration**

```json
{
  "watch": ["src", "prisma"],
  "ext": "ts,js,prisma",
  "ignore": ["dist", "node_modules", "*.test.ts"],
  "exec": "ts-node src/index.ts",
  "env": {
    "NODE_ENV": "development"
  },
  "events": {
    "restart": "echo '🔄 Application restarted due to file changes'"
  },
  "delay": 1000
}
```

#### **Volume Configuration for Development**

```yaml
# In docker-compose.yml - optimized volumes for development
services:
  app:
    volumes:
      # Bind mount source code for hot reloading
      - .:/app
      # Anonymous volume for node_modules (prevents overwrite)
      - /app/node_modules
      # Bind mount for Prisma generated client
      - ./node_modules/.prisma:/app/node_modules/.prisma
      # Persistent volume for uploads
      - uploads_data:/app/uploads
      # Cache directories for better performance
      - node_cache:/app/.npm
      - ts_cache:/app/.tscache
```

### 3. Environment Configuration

Manage different environments with Docker.

#### **Environment Files Structure**

```bash
# Project structure for environment management
.env.docker.development
.env.docker.test  
.env.docker.production
.env.docker.local     # Local overrides (gitignored)
```

#### **Environment File Examples**

```bash
# .env.docker.development
NODE_ENV=development
PORT=3000

# Database
DATABASE_URL=postgresql://postgres:password@db:5432/myapp_dev
SHADOW_DATABASE_URL=postgresql://postgres:password@db:5432/myapp_shadow

# Redis
REDIS_URL=redis://redis:6379

# Email (Mailhog)
SMTP_HOST=mailhog
SMTP_PORT=1025
SMTP_USER=
SMTP_PASS=

# Development features
DEBUG=prisma:*
ENABLE_LOGGING=true
ENABLE_DEBUG_ROUTES=true

# Security (development)
JWT_SECRET=development-secret-key
CORS_ORIGIN=http://localhost:3000
```

```bash
# .env.docker.test
NODE_ENV=test
PORT=3001

# Test database
DATABASE_URL=postgresql://postgres:password@db:5432/myapp_test
SHADOW_DATABASE_URL=postgresql://postgres:password@db:5432/myapp_shadow

# Test configuration
DISABLE_LOGGING=true
TEST_TIMEOUT=30000

# Security (test)
JWT_SECRET=test-secret-key
```

---

## 🏗️ Advanced Docker Configurations

### 1. Multi-Stage Builds

Optimize Docker images for different environments.

#### **Advanced Multi-Stage Dockerfile**

```dockerfile
# Advanced Dockerfile with optimization
FROM node:18-alpine AS base

# Install system dependencies
RUN apk add --no-cache \
    postgresql-client \
    git \
    curl \
    dumb-init

# Create app directory
WORKDIR /app

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

# Dependencies stage
FROM base AS dependencies

# Copy package files
COPY package*.json ./
COPY prisma ./prisma/

# Install dependencies
RUN npm ci --only=production && \
    npm cache clean --force

# Development dependencies
FROM dependencies AS dev-dependencies
RUN npm ci

# Build stage
FROM dev-dependencies AS build

# Copy source code
COPY . .

# Build application
RUN npm run build

# Generate Prisma client
RUN npx prisma generate

# Development stage
FROM dev-dependencies AS development

# Copy source code
COPY . .

# Generate Prisma client
RUN npx prisma generate

# Change ownership
RUN chown -R nextjs:nodejs /app
USER nextjs

# Expose ports
EXPOSE 3000 5555

# Use dumb-init for proper signal handling
ENTRYPOINT ["dumb-init", "--"]
CMD ["npm", "run", "dev"]

# Production stage
FROM base AS production

# Copy built application and dependencies
COPY --from=build --chown=nextjs:nodejs /app/dist ./dist
COPY --from=build --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=build --chown=nextjs:nodejs /app/package*.json ./
COPY --from=build --chown=nextjs:nodejs /app/prisma ./prisma

# Switch to non-root user
USER nextjs

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# Expose port
EXPOSE 3000

# Use dumb-init for proper signal handling
ENTRYPOINT ["dumb-init", "--"]
CMD ["npm", "start"]
```

### 2. Performance Optimization

Optimize Docker performance for development and production.

#### **Docker Build Optimization**

```dockerfile
# .dockerignore
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.nyc_output
coverage
.env.local
.env.development.local
.env.test.local
.env.production.local
dist
.next
.nuxt
.cache
.vscode
.idea
*.log
```

#### **Layer Caching Optimization**

```dockerfile
# Optimized Dockerfile for layer caching
FROM node:18-alpine AS base

# Install system dependencies (rarely changes)
RUN apk add --no-cache postgresql-client curl

WORKDIR /app

# Copy package files first (changes less frequently)
COPY package*.json ./

# Install dependencies (cached unless package.json changes)
RUN npm ci --only=production

# Copy Prisma schema (changes moderately)
COPY prisma ./prisma/

# Generate Prisma client (cached unless schema changes)
RUN npx prisma generate

# Copy source code last (changes most frequently)
COPY . .

# Build application
RUN npm run build
```

### 3. Health Checks and Monitoring

Implement comprehensive health checking.

#### **Application Health Check Endpoint**

```typescript
// src/health.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

interface HealthStatus {
  status: 'healthy' | 'unhealthy';
  timestamp: string;
  uptime: number;
  services: {
    database: 'connected' | 'disconnected' | 'error';
    redis?: 'connected' | 'disconnected' | 'error';
    memory: {
      used: string;
      total: string;
      percentage: number;
    };
  };
  version: string;
}

export async function healthCheck(): Promise<HealthStatus> {
  const startTime = Date.now();
  
  // Check database connection
  let databaseStatus: 'connected' | 'disconnected' | 'error';
  try {
    await prisma.$queryRaw`SELECT 1`;
    databaseStatus = 'connected';
  } catch (error) {
    console.error('Database health check failed:', error);
    databaseStatus = 'error';
  }

  // Memory usage
  const memUsage = process.memoryUsage();
  const memUsed = Math.round((memUsage.heapUsed / 1024 / 1024) * 100) / 100;
  const memTotal = Math.round((memUsage.heapTotal / 1024 / 1024) * 100) / 100;
  const memPercentage = Math.round((memUsed / memTotal) * 100);

  const status: HealthStatus = {
    status: databaseStatus === 'connected' ? 'healthy' : 'unhealthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    services: {
      database: databaseStatus,
      memory: {
        used: `${memUsed} MB`,
        total: `${memTotal} MB`,
        percentage: memPercentage
      }
    },
    version: process.env.npm_package_version || '1.0.0'
  };

  return status;
}
```

#### **Docker Health Check Script**

```bash
#!/bin/bash
# scripts/health-check.sh

# Check if the application is responding
response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/health)

if [ "$response" = "200" ]; then
    echo "Health check passed"
    exit 0
else
    echo "Health check failed with status: $response"
    exit 1
fi
```

---

## 🧪 Testing with Docker

### 1. Test Environment Setup

Configure isolated testing environments.

#### **Test-Specific Docker Compose**

```yaml
# docker-compose.test.yml
version: '3.8'

services:
  test-app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    environment:
      - NODE_ENV=test
      - DATABASE_URL=postgresql://postgres:password@test-db:5432/myapp_test
      - SHADOW_DATABASE_URL=postgresql://postgres:password@test-db:5432/myapp_shadow
    command: ["npm", "run", "test:integration"]
    depends_on:
      test-db:
        condition: service_healthy
    networks:
      - test_network

  test-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=myapp_test
    networks:
      - test_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d myapp_test"]
      interval: 5s
      timeout: 3s
      retries: 5

networks:
  test_network:
    driver: bridge
```

#### **Integration Test Script**

```bash
#!/bin/bash
# scripts/test-integration.sh

set -e

echo "🧪 Starting integration tests..."

# Cleanup any existing test containers
docker-compose -f docker-compose.test.yml down -v

# Start test environment
docker-compose -f docker-compose.test.yml up -d test-db

# Wait for database
echo "⏳ Waiting for test database..."
sleep 10

# Run migrations
docker-compose -f docker-compose.test.yml run --rm test-app npx prisma migrate deploy

# Run tests
docker-compose -f docker-compose.test.yml run --rm test-app npm run test

# Cleanup
docker-compose -f docker-compose.test.yml down -v

echo "✅ Integration tests completed!"
```

### 2. CI/CD Integration

Configure Docker for continuous integration.

#### **GitHub Actions Workflow**

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
          POSTGRES_DB: myapp_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Generate Prisma client
      run: npx prisma generate
    
    - name: Run migrations
      run: npx prisma migrate deploy
      env:
        DATABASE_URL: postgresql://postgres:password@localhost:5432/myapp_test
    
    - name: Run tests
      run: npm test
      env:
        NODE_ENV: test
        DATABASE_URL: postgresql://postgres:password@localhost:5432/myapp_test
    
    - name: Build Docker image
      run: docker build -t myapp:latest .
    
    - name: Test Docker image
      run: |
        docker run --rm \
          -e DATABASE_URL=postgresql://postgres:password@host.docker.internal:5432/myapp_test \
          myapp:latest npm run test:docker
```

---

## 🔧 Troubleshooting Common Issues

### 1. Connection Issues

Debug common Docker networking and connection problems.

#### **Database Connection Debugging**

```bash
# Check if containers are running
docker-compose ps

# Check container logs
docker-compose logs db
docker-compose logs app

# Test database connection from app container
docker-compose exec app pg_isready -h db -p 5432 -U postgres

# Test network connectivity
docker-compose exec app ping db

# Check environment variables
docker-compose exec app env | grep DATABASE_URL

# Manual database connection test
docker-compose exec app psql postgresql://postgres:password@db:5432/myapp_dev
```

#### **Common Connection Fixes**

```yaml
# docker-compose.yml - Common fixes
services:
  app:
    environment:
      # Use service name for database host
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp_dev
    depends_on:
      db:
        condition: service_healthy  # Wait for health check
    networks:
      - prisma_network  # Ensure same network

  db:
    networks:
      - prisma_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
```

### 2. Performance Issues

Optimize Docker performance for development.

#### **Performance Optimization Checklist**

```yaml
# docker-compose.yml - Performance optimizations
services:
  app:
    volumes:
      # Use delegated consistency for better performance on macOS
      - .:/app:delegated
      # Anonymous volume for node_modules
      - /app/node_modules
    tmpfs:
      # Use tmpfs for temporary files
      - /tmp
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
```

#### **Development Speed Optimizations**

```bash
# Use Docker BuildKit for faster builds
export DOCKER_BUILDKIT=1
export COMPOSE_DOCKER_CLI_BUILD=1

# Parallel build and cache optimization
docker-compose build --parallel

# Use .dockerignore to reduce build context
echo "node_modules\n.git\ndist" > .dockerignore
```

### 3. Memory and Resource Management

Monitor and optimize resource usage.

#### **Resource Monitoring Script**

```bash
#!/bin/bash
# scripts/monitor-resources.sh

echo "📊 Docker Resource Usage:"
echo "========================"

# Container resource usage
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}\t{{.NetIO}}\t{{.BlockIO}}"

echo ""
echo "💾 Volume Usage:"
echo "================"

# Volume usage
docker system df

echo ""
echo "🔍 Detailed Container Info:"
echo "============================"

# Detailed container information
for container in $(docker-compose ps -q); do
    name=$(docker inspect --format='{{.Name}}' $container | sed 's/\///')
    echo "Container: $name"
    docker exec $container ps aux | head -5
    echo "---"
done
```

---

## 📊 Docker Development Workflow

### Complete Development Flow

```mermaid
graph TD
    A[Start Development] --> B[docker-compose up]
    B --> C[Code Changes]
    C --> D[Hot Reload]
    D --> E[Test Changes]
    E --> F{Tests Pass?}
    F -->|No| G[Fix Issues]
    G --> C
    F -->|Yes| H[Commit Changes]
    H --> I[Push to Repository]
    I --> J[CI/CD Pipeline]
    J --> K[Deploy to Staging]
    
    style A fill:#e1f5fe
    style K fill:#e8f5e8
    style F fill:#fff3e0
```

### Container Orchestration

```mermaid
graph LR
    subgraph "Development Environment"
        A[App Container] --> B[Database Container]
        A --> C[Redis Container]
        A --> D[Mailhog Container]
        E[Prisma Studio] --> B
        F[pgAdmin] --> B
    end
    
    subgraph "External"
        G[Developer] --> A
        H[Browser] --> E
        I[Admin] --> F
    end
```

---

## 🧠 Knowledge Check

### Docker Setup Quiz

1. **What is the primary benefit of using Docker for Prisma development?**
   - [ ] A) Faster database queries
   - [ ] B) Smaller application size
   - [x] C) Consistent environment across different machines
   - [ ] D) Automatic code generation

   **Explanation**: Docker provides consistent, reproducible environments regardless of the host system.

2. **Which Docker Compose feature ensures containers start in the correct order?**
   - [ ] A) networks
   - [ ] B) volumes
   - [x] C) depends_on with health checks
   - [ ] D) environment variables

   **Explanation**: `depends_on` with health checks ensures services start only when their dependencies are healthy.

3. **What is the best practice for handling sensitive data in Docker containers?**
   - [ ] A) Hard-code in Dockerfile
   - [ ] B) Include in docker-compose.yml
   - [x] C) Use environment variables and secrets
   - [ ] D) Store in volume mounts

   **Explanation**: Environment variables and proper secrets management keep sensitive data secure.

### Practical Exercise: Docker Setup

**Challenge**: Create a complete Docker development environment

**Tasks**:
1. Create a Dockerfile for your Prisma application
2. Set up docker-compose.yml with all necessary services
3. Configure environment variables and networking
4. Set up health checks and monitoring
5. Test the complete development workflow

```yaml
# Your docker-compose.yml
version: '3.8'

services:
  # Add your services here
```

---

## 💡 Key Takeaways

- 🧪 **Controlled Environment**: Docker provides consistent, reproducible development environments
- 🐳 **Service Orchestration**: Docker Compose manages multi-service applications effectively
- 🔄 **Development Workflow**: Hot reloading and volume mounts enable rapid iteration
- 🏗️ **Multi-Stage Builds**: Optimize images for different environments and deployment stages
- 🔒 **Security & Secrets**: Proper environment variable management keeps applications secure
- 📊 **Monitoring**: Health checks and resource monitoring ensure application reliability
- 🧪 **Testing Integration**: Isolated test environments prevent interference with development
- 🚀 **CI/CD Ready**: Docker containers integrate seamlessly with deployment pipelines

---

## 🔗 Navigation

**📍 Current Location**: Module 1 → Section 1.4 → Lesson 1.4.5

**⬅️ Previous**: [1.5.4 Git Workflow & Version Control Best Practices](./1.5.4-git-workflow-version-control-best-practices.md)
**➡️ Next**: **Module 1 Complete!** → [Module 2: Getting Started](../../02-getting-started/README.md)

**🏠 Section Home**: [1.4 Development Environment](./README.md)
**📚 Module Home**: [Module 1: Foundations](../01-foundations.md)

**🗺️ Quick Links**:
- [Previous: Git Workflow](./1.4.4-git-workflow-version-control-best-practices.md)
- [Module Assessment](../01-foundations.md#module-1-assessment)
- [Continue to Module 2](../../02-getting-started/02-getting-started.md)

---

*🎉 **Congratulations!** You've completed Module 1 and now have a complete Docker-based development environment for Prisma. Ready to start building with Prisma? Continue to Module 2!*
