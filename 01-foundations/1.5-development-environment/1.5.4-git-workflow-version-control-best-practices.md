# 1.4.4 Git Workflow & Version Control Best Practices

## 📋 Section Overview
- **Duration**: 35 minutes
- **Prerequisites**: Basic Git knowledge, understanding of version control concepts
- **Learning Objectives**: 
  - Master Git workflows specifically for Prisma development
  - Understand best practices for managing database schemas in version control
  - Learn to handle Prisma migrations and generated files effectively
  - Configure Git hooks and automation for database development
  - Manage environment files and sensitive data securely
- **Difficulty Level**: Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Set up optimal Git configuration for Prisma projects
- ✅ Master branching strategies for database schema changes
- ✅ Handle Prisma migrations in version control effectively
- ✅ Configure .gitignore for Prisma-specific files
- ✅ Implement Git hooks for automated validations
- ✅ Manage environment variables and secrets securely
- ✅ Collaborate effectively on database schema changes

---

## 📖 Content

### Understanding Git for Database Development

Using Git for Prisma development is like managing a **master blueprint archive for a growing city**. Just as city planners need careful coordination when changing infrastructure that affects everyone, database schema changes require meticulous version control to ensure all developers stay synchronized and no critical changes are lost.

### 🏗️ The City Planning Archive Analogy

```
🏗️ City Planning Archive = 📁 Git Repository

📋 Master Blueprints (Schema Files)
├── Foundation plans → schema.prisma (core structure)
├── Infrastructure maps → migrations/ (change history)
├── Utility connections → environment configs
├── Building permits → generated client code
├── Safety protocols → validation scripts
└── Progress reports → commit history

🔄 Planning Process (Git Workflow)
├── Proposal drafts → feature branches
├── Review meetings → pull requests
├── Impact assessments → migration testing
├── Approval process → code review
├── Implementation → merge to main
└── Progress tracking → release tags

🏢 Construction Teams (Development Team)
├── Lead architect → senior developer
├── Structural engineer → database specialist
├── Safety inspector → CI/CD pipeline
├── Documentation clerk → technical writer
├── Quality control → automated testing
└── Project coordinator → team lead

🔒 Security Protocols (Access Control)
├── Restricted blueprints → .gitignore sensitive files
├── Access badges → environment variables
├── Secure vaults → secrets management
├── Audit trails → commit signatures
├── Emergency procedures → rollback strategies
└── Backup systems → remote repositories
```

---

## 🔧 Git Configuration for Prisma Projects

### 1. Repository Structure Setup

Establish a well-organized repository structure for Prisma development.

#### **Recommended Project Structure**

```
my-prisma-app/
├── .git/                           # Git repository
├── .github/                        # GitHub workflows
│   ├── workflows/
│   │   ├── ci.yml                  # Continuous integration
│   │   ├── migrate.yml             # Migration testing
│   │   └── release.yml             # Release automation
│   └── PULL_REQUEST_TEMPLATE.md    # PR template
├── .vscode/                        # VS Code configuration
│   ├── settings.json
│   ├── tasks.json
│   └── extensions.json
├── prisma/                         # Prisma directory
│   ├── schema.prisma               # Main schema file
│   ├── migrations/                 # Migration history
│   │   ├── 20240101000000_init/
│   │   ├── 20240102120000_add_user_profile/
│   │   └── migration_lock.toml
│   └── seed.ts                     # Database seeding
├── src/                            # Application source
├── tests/                          # Test files
├── scripts/                        # Development scripts
├── docs/                           # Documentation
├── .env.example                    # Environment template
├── .gitignore                      # Git ignore rules
├── .gitattributes                  # Git attributes
├── docker-compose.yml              # Development setup
├── package.json                    # Dependencies
└── README.md                       # Project documentation
```

### 2. Essential Git Configuration

Configure Git for optimal Prisma development experience.

#### **Global Git Configuration**

```bash
# Configure user information
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"

# Configure editor for commit messages
git config --global core.editor "code --wait"

# Configure merge behavior
git config --global merge.ours.driver true
git config --global pull.rebase false

# Configure line ending handling
git config --global core.autocrlf input  # Linux/macOS
git config --global core.autocrlf true   # Windows

# Configure default branch name
git config --global init.defaultBranch main

# Configure push behavior
git config --global push.default simple
git config --global push.followTags true

# Configure signing (recommended for team projects)
git config --global commit.gpgsign true
git config --global user.signingkey YOUR_GPG_KEY_ID
```

#### **Project-Specific Configuration**

```bash
# Navigate to your project
cd my-prisma-app

# Configure project-specific settings
git config core.fileMode false
git config core.ignorecase false

# Configure hooks path
git config core.hooksPath .githooks

# Configure merge strategies for specific files
echo "*.prisma merge=ours" >> .gitattributes
echo "package-lock.json merge=ours" >> .gitattributes
```

### 3. Gitignore Configuration

Create a comprehensive `.gitignore` for Prisma projects.

#### **Complete .gitignore Template**

```gitignore
# .gitignore for Prisma projects

# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.db
*.sqlite
*.sqlite3
*.db-wal
*.db-shm

# Prisma
# Keep migrations/ directory but ignore specific files if needed
# prisma/migrations/*
# !prisma/migrations/.gitkeep

# Generated Prisma Client (usually want to ignore)
/prisma/generated/
/node_modules/.prisma/
/node_modules/@prisma/

# Build outputs
dist/
build/
out/
.next/
.nuxt/

# IDE and Editor files
.vscode/settings.json
.vscode/launch.json
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov
.nyc_output/

# Testing
.jest/
coverage/

# Docker
.dockerignore
docker-compose.override.yml

# Temporary files
*.tmp
*.temp
.cache/

# Security
*.pem
*.key
!mock/**/*.key
.env.keys

# Backup files
*.backup
*.bak
*.old

# Analytics
.vercel/
.netlify/

# Local development
.vscode/
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# Package managers
.yarn/
.pnp.*
.yarn/install-state.gz
```

#### **Git Attributes Configuration**

```gitattributes
# .gitattributes for Prisma projects

# Auto detect text files and perform LF normalization
* text=auto

# Explicitly declare text files you want to always be normalized and converted
# to native line endings on checkout.
*.prisma text eol=lf
*.sql text eol=lf
*.js text eol=lf
*.ts text eol=lf
*.json text eol=lf
*.md text eol=lf
*.yml text eol=lf
*.yaml text eol=lf

# Declare files that will always have CRLF line endings on checkout.
*.bat text eol=crlf

# Denote all files that are truly binary and should not be modified.
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.pdf binary
*.zip binary
*.tar.gz binary

# Prisma-specific files
prisma/schema.prisma text eol=lf
prisma/migrations/**/*.sql text eol=lf

# Package files
package.json text eol=lf
package-lock.json text eol=lf -diff
yarn.lock text eol=lf -diff

# Environment files
.env* text eol=lf

# Merge strategies for specific files
package-lock.json merge=ours
yarn.lock merge=ours
```

---

## 🌿 Branching Strategies for Database Development

### 1. Feature Branch Workflow

Implement a safe branching strategy for database schema changes.

#### **Branch Naming Convention**

```bash
# Branch naming patterns
feature/user-authentication      # New features
fix/migration-rollback-issue    # Bug fixes
schema/add-user-profile-table   # Schema changes
migrate/update-user-constraints # Migration-specific
hotfix/critical-data-loss       # Emergency fixes
docs/update-migration-guide     # Documentation
chore/update-dependencies       # Maintenance

# Examples of good branch names
git checkout -b feature/add-user-roles
git checkout -b schema/refactor-order-relationships
git checkout -b fix/migration-foreign-key-error
git checkout -b migrate/split-user-table
```

#### **Database Change Workflow**

```bash
# 1. Create feature branch from main
git checkout main
git pull origin main
git checkout -b schema/add-user-profile

# 2. Make schema changes
# Edit prisma/schema.prisma

# 3. Create migration
npx prisma migrate dev --name add_user_profile

# 4. Test the migration
npm test

# 5. Commit changes
git add .
git commit -m "feat: add user profile table with relationships

- Add Profile model with user relationship
- Add profile fields: bio, avatar, preferences
- Create migration for profile table
- Update seed data to include profiles
- Add tests for profile functionality

Migration: add_user_profile
Schema changes: Added Profile model
Breaking changes: None"

# 6. Push and create PR
git push origin schema/add-user-profile
```

### 2. Migration Management Strategy

Handle Prisma migrations carefully in version control.

#### **Migration Best Practices**

```bash
# ✅ DO: Always create migrations on feature branches
git checkout -b schema/add-indexes
# Edit schema
npx prisma migrate dev --name add_performance_indexes
git add prisma/migrations/
git commit -m "perf: add database indexes for query optimization"

# ✅ DO: Include descriptive migration names
npx prisma migrate dev --name add_user_email_unique_constraint
npx prisma migrate dev --name split_address_into_separate_table
npx prisma migrate dev --name add_soft_delete_to_users

# ✅ DO: Test migrations before committing
npx prisma migrate reset --force
npx prisma migrate dev
npm test

# ❌ DON'T: Edit existing migrations after they're committed
# ❌ DON'T: Commit migrations without testing
# ❌ DON'T: Create migrations directly on main branch
```

#### **Handling Migration Conflicts**

```bash
# When migration conflicts occur during merge
git checkout main
git pull origin main
git checkout feature/my-schema-changes

# Option 1: Rebase and recreate migration
git rebase main
npx prisma migrate reset --force
npx prisma migrate dev --name my_changes_rebased

# Option 2: Reset and apply in sequence
npx prisma migrate reset --force
npx prisma migrate dev  # Apply all migrations including conflicts
# Resolve any issues manually

# Option 3: Manual conflict resolution
git merge main
# Resolve migration conflicts manually
npx prisma migrate dev --create-only --name resolve_merge_conflicts
# Review generated migration, edit if necessary
npx prisma migrate dev
```

### 3. Environment Branch Strategy

Manage different environments with appropriate branching.

#### **Environment Branches**

```bash
# Branch structure for different environments
main                    # Production-ready code
├── develop            # Integration branch
├── staging            # Pre-production testing
├── feature/*          # Feature development
├── hotfix/*           # Emergency fixes
└── release/*          # Release preparation

# Environment-specific workflows
# Development
git checkout develop
git pull origin develop
git checkout -b feature/new-api-endpoint

# Staging deployment
git checkout staging
git merge develop
git push origin staging

# Production deployment
git checkout main
git merge staging
git tag v1.2.0
git push origin main --tags
```

---

## 🔗 Git Hooks for Automation

### 1. Pre-commit Hooks

Set up automated validations before commits.

#### **Pre-commit Hook Script**

```bash
#!/bin/sh
# .githooks/pre-commit

echo "🔍 Running pre-commit checks..."

# Check if schema file exists and is valid
if [ -f "prisma/schema.prisma" ]; then
    echo "✅ Validating Prisma schema..."
    npx prisma validate
    if [ $? -ne 0 ]; then
        echo "❌ Prisma schema validation failed!"
        exit 1
    fi
fi

# Check for sensitive data in environment files
echo "🔒 Checking for exposed secrets..."
if grep -r "password\|secret\|key" .env* 2>/dev/null; then
    echo "❌ Potential secrets found in environment files!"
    echo "Please review and use environment variables instead."
    exit 1
fi

# Format Prisma schema
if [ -f "prisma/schema.prisma" ]; then
    echo "🎨 Formatting Prisma schema..."
    npx prisma format
    git add prisma/schema.prisma
fi

# Run linting
echo "🧹 Running ESLint..."
npm run lint
if [ $? -ne 0 ]; then
    echo "❌ Linting failed! Please fix errors before committing."
    exit 1
fi

# Run type checking
echo "🔍 Running TypeScript checks..."
npm run type-check
if [ $? -ne 0 ]; then
    echo "❌ TypeScript errors found! Please fix before committing."
    exit 1
fi

echo "✅ All pre-commit checks passed!"
```

#### **Commit Message Hook**

```bash
#!/bin/sh
# .githooks/commit-msg

commit_regex='^(feat|fix|docs|style|refactor|perf|test|chore|schema|migrate)(\(.+\))?: .{1,50}'

error_msg="❌ Invalid commit message format!

Please use the conventional commit format:
  feat: add new user authentication
  fix: resolve migration rollback issue
  schema: add user profile relationships
  migrate: split user table for performance
  docs: update API documentation
  
Format: <type>(<scope>): <description>
Types: feat, fix, docs, style, refactor, perf, test, chore, schema, migrate"

if ! grep -qE "$commit_regex" "$1"; then
    echo "$error_msg" >&2
    exit 1
fi
```

#### **Pre-push Hook**

```bash
#!/bin/sh
# .githooks/pre-push

echo "🚀 Running pre-push checks..."

# Check if migrations are up to date
echo "🔍 Checking migration status..."
npx prisma migrate status
if [ $? -ne 0 ]; then
    echo "❌ Migrations are not up to date!"
    echo "Please run 'npx prisma migrate dev' before pushing."
    exit 1
fi

# Run tests
echo "🧪 Running tests..."
npm test
if [ $? -ne 0 ]; then
    echo "❌ Tests failed! Please fix before pushing."
    exit 1
fi

# Check for migration conflicts
current_branch=$(git branch --show-current)
if [ "$current_branch" != "main" ]; then
    echo "🔍 Checking for potential migration conflicts..."
    
    # Count migrations in current branch vs main
    local_migrations=$(find prisma/migrations -name "*.sql" | wc -l)
    git fetch origin main --quiet
    main_migrations=$(git show origin/main:prisma/migrations 2>/dev/null | grep -c "\.sql" || echo "0")
    
    if [ "$local_migrations" -gt "$main_migrations" ]; then
        echo "⚠️  Warning: You have new migrations that may conflict."
        echo "Consider rebasing against main before pushing."
    fi
fi

echo "✅ All pre-push checks passed!"
```

### 2. Setting Up Git Hooks

Configure and install the hooks in your project.

#### **Hook Installation Script**

```bash
#!/bin/bash
# scripts/install-hooks.sh

echo "🔧 Installing Git hooks..."

# Create hooks directory if it doesn't exist
mkdir -p .githooks

# Make hooks executable
chmod +x .githooks/*

# Configure Git to use our hooks directory
git config core.hooksPath .githooks

# Copy hooks to .git/hooks as backup
cp .githooks/* .git/hooks/ 2>/dev/null || true

echo "✅ Git hooks installed successfully!"
echo "📝 Available hooks:"
ls -la .githooks/
```

---

## 📦 Managing Generated Files

### 1. Prisma Client Handling

Decide how to handle generated Prisma Client files.

#### **Option 1: Ignore Generated Client (Recommended)**

```gitignore
# .gitignore - Ignore generated client
node_modules/.prisma/
prisma/generated/

# Ensure client is generated in CI/CD
```

```json
// package.json - Ensure generation in build process
{
  "scripts": {
    "postinstall": "prisma generate",
    "build": "prisma generate && tsc",
    "dev": "prisma generate && nodemon",
    "test": "prisma generate && jest"
  }
}
```

#### **Option 2: Commit Generated Client (Team Decision)**

```gitignore
# .gitignore - Keep generated client in repo
node_modules/
!node_modules/.prisma/client/
```

### 2. Migration Lock File

Handle the migration lock file appropriately.

#### **Migration Lock Best Practices**

```toml
# prisma/migrations/migration_lock.toml
# This file should be committed to version control
provider = "postgresql"
```

```gitignore
# .gitignore - Always commit migration lock
# !prisma/migrations/migration_lock.toml
```

---

## 🔒 Security and Environment Management

### 1. Environment File Strategy

Manage environment variables securely across different environments.

#### **Environment File Structure**

```bash
# Project structure for environment management
.env.example          # Template with all required variables
.env                  # Local development (gitignored)
.env.local           # Local overrides (gitignored)
.env.development     # Development environment (gitignored)
.env.test            # Test environment (gitignored)
.env.production      # Production environment (never commit)
```

#### **Environment Template**

```bash
# .env.example - Template file (commit this)
# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/myapp_dev"
SHADOW_DATABASE_URL="postgresql://username:password@localhost:5432/myapp_shadow"

# Application Configuration
NODE_ENV="development"
PORT=3000
HOST="localhost"

# Authentication
JWT_SECRET="your-jwt-secret-here"
JWT_EXPIRES_IN="7d"

# External Services
REDIS_URL="redis://localhost:6379"
SMTP_HOST="smtp.example.com"
SMTP_PORT=587
SMTP_USER="your-smtp-user"
SMTP_PASS="your-smtp-password"

# Feature Flags
ENABLE_DEBUG=true
ENABLE_LOGGING=true

# File Upload
UPLOAD_DIR="./uploads"
MAX_FILE_SIZE=10485760

# Security
CORS_ORIGIN="http://localhost:3000"
RATE_LIMIT_WINDOW=900000
RATE_LIMIT_MAX=100
```

### 2. Secrets Management

Implement secure handling of sensitive data.

#### **Git-secrets Integration**

```bash
# Install git-secrets
# macOS
brew install git-secrets

# Ubuntu/Debian
sudo apt-get install git-secrets

# Configure for your repository
git secrets --register-aws
git secrets --install
git secrets --scan

# Add custom patterns
git secrets --add --allowed 'allowedpattern'
git secrets --add --forbidden 'password\s*=\s*.+'
git secrets --add --forbidden 'secret\s*=\s*.+'
git secrets --add --forbidden 'key\s*=\s*.+'
```

#### **Environment Validation Script**

```javascript
// scripts/validate-env.js
const requiredEnvVars = [
  'DATABASE_URL',
  'SHADOW_DATABASE_URL',
  'JWT_SECRET',
  'NODE_ENV'
];

const optionalEnvVars = [
  'PORT',
  'HOST',
  'REDIS_URL'
];

function validateEnvironment() {
  console.log('🔍 Validating environment variables...');
  
  const missing = requiredEnvVars.filter(envVar => !process.env[envVar]);
  
  if (missing.length > 0) {
    console.error('❌ Missing required environment variables:');
    missing.forEach(envVar => console.error(`  - ${envVar}`));
    console.error('\n📝 Check .env.example for reference');
    process.exit(1);
  }
  
  // Check for common insecure values
  const insecureValues = [
    'password',
    'secret',
    'changeme',
    '123456',
    'admin'
  ];
  
  const insecure = requiredEnvVars
    .filter(envVar => insecureValues.includes(process.env[envVar]?.toLowerCase()))
    .concat(optionalEnvVars.filter(envVar => 
      process.env[envVar] && insecureValues.includes(process.env[envVar].toLowerCase())
    ));
  
  if (insecure.length > 0) {
    console.warn('⚠️  Warning: Potentially insecure environment values:');
    insecure.forEach(envVar => console.warn(`  - ${envVar}`));
  }
  
  console.log('✅ Environment validation passed!');
}

if (require.main === module) {
  validateEnvironment();
}

module.exports = { validateEnvironment };
```

---

## 🤝 Collaboration Workflows

### 1. Pull Request Guidelines

Establish clear guidelines for database-related pull requests.

#### **PR Template for Schema Changes**

```markdown
<!-- .github/PULL_REQUEST_TEMPLATE.md -->
## 📋 Pull Request Checklist

### Type of Change
- [ ] 🐛 Bug fix (non-breaking change which fixes an issue)
- [ ] ✨ New feature (non-breaking change which adds functionality)
- [ ] 💥 Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] 🗃️ Database schema change
- [ ] 📝 Documentation update

### Database Changes
- [ ] No database changes
- [ ] ✅ Schema changes included
- [ ] ✅ Migration created and tested
- [ ] ✅ Migration is reversible
- [ ] ✅ Seed data updated if necessary
- [ ] ✅ No breaking changes to existing data
- [ ] ⚠️ Breaking changes documented

### Description
Brief description of changes and motivation.

### Schema Changes
If this PR includes database schema changes, describe:
- What models/tables are affected?
- Are there any breaking changes?
- How should existing data be handled?

### Migration Details
- Migration name: `YYYYMMDDHHMMSS_migration_name`
- Migration type: [additive/destructive/neutral]
- Rollback strategy: [describe how to rollback if needed]

### Testing
- [ ] Tests pass locally
- [ ] Migration tested on development database
- [ ] Migration tested on staging environment
- [ ] Performance impact assessed
- [ ] Rollback tested

### Documentation
- [ ] README updated
- [ ] API documentation updated
- [ ] Database schema documentation updated
- [ ] Migration notes added

### Review Notes
Any specific areas that need careful review?
```

### 2. Code Review Guidelines

Establish standards for reviewing database-related changes.

#### **Review Checklist**

```markdown
# Database Change Review Checklist

## Schema Review
- [ ] Schema changes are necessary and well-justified
- [ ] Field names follow naming conventions
- [ ] Proper indexes are defined
- [ ] Relationships are correctly defined
- [ ] Constraints are appropriate
- [ ] Data types are optimal

## Migration Review
- [ ] Migration name is descriptive
- [ ] Migration is idempotent
- [ ] Migration handles existing data appropriately
- [ ] No SQL injection vulnerabilities
- [ ] Performance impact is minimal
- [ ] Rollback strategy is viable

## Code Quality
- [ ] Prisma Client usage follows best practices
- [ ] Error handling is appropriate
- [ ] Transactions are used where necessary
- [ ] Query performance is optimized
- [ ] Type safety is maintained

## Testing
- [ ] Unit tests cover new functionality
- [ ] Integration tests include database operations
- [ ] Migration tests verify schema changes
- [ ] Performance tests if applicable
- [ ] Rollback scenarios tested

## Documentation
- [ ] Code is self-documenting
- [ ] Complex queries are commented
- [ ] Migration includes descriptive comments
- [ ] API changes are documented
```

---

## 🚨 Emergency Procedures

### 1. Rollback Strategies

Prepare for emergency rollbacks and recovery.

#### **Migration Rollback Procedure**

```bash
# Emergency rollback procedure
echo "🚨 Emergency rollback initiated..."

# 1. Stop application servers
echo "🛑 Stopping application..."
# kubectl scale deployment myapp --replicas=0  # Kubernetes
# docker-compose stop  # Docker Compose
# pm2 stop all  # PM2

# 2. Identify the problematic migration
npx prisma migrate status

# 3. Reset to known good state
git log --oneline -10  # Find good commit
git checkout <good-commit-hash>

# 4. Reset database to good migration
npx prisma migrate reset --force
npx prisma migrate deploy  # Production: use deploy instead of dev

# 5. Verify database state
npx prisma validate
npm test

# 6. Restart application
echo "✅ Rollback complete, restarting application..."
```

#### **Data Recovery Scripts**

```javascript
// scripts/data-recovery.js
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function backupData(tableName) {
  console.log(`📦 Backing up ${tableName}...`);
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupFile = `backup-${tableName}-${timestamp}.json`;
  
  try {
    const data = await prisma[tableName].findMany();
    await fs.writeFileSync(backupFile, JSON.stringify(data, null, 2));
    console.log(`✅ Backup saved to ${backupFile}`);
  } catch (error) {
    console.error(`❌ Backup failed for ${tableName}:`, error);
  }
}

async function restoreData(backupFile, tableName) {
  console.log(`🔄 Restoring ${tableName} from ${backupFile}...`);
  
  try {
    const data = JSON.parse(fs.readFileSync(backupFile, 'utf8'));
    
    // Clear existing data
    await prisma[tableName].deleteMany();
    
    // Restore data
    await prisma[tableName].createMany({ data });
    
    console.log(`✅ Restored ${data.length} records to ${tableName}`);
  } catch (error) {
    console.error(`❌ Restore failed for ${tableName}:`, error);
  }
}
```

### 2. Conflict Resolution

Handle merge conflicts in database files.

#### **Schema Conflict Resolution**

```bash
# When schema.prisma has conflicts
git status
# both modified: prisma/schema.prisma

# 1. Understand both changes
git show HEAD:prisma/schema.prisma > schema-head.prisma
git show MERGE_HEAD:prisma/schema.prisma > schema-merge.prisma
code schema-head.prisma schema-merge.prisma prisma/schema.prisma

# 2. Manually resolve conflicts
# Edit prisma/schema.prisma to combine both changes

# 3. Validate resolved schema
npx prisma validate

# 4. Generate new migration for combined changes
npx prisma migrate dev --name resolve_merge_conflicts

# 5. Test the resolution
npm test

# 6. Complete the merge
git add .
git commit -m "resolve: merge schema conflicts

- Combined changes from both branches
- Created unified migration
- Verified schema validity"
```

---

## 📊 Git Workflow Visualization

### Development Flow Diagram

```mermaid
graph TD
    A[Start Development] --> B[Create Feature Branch]
    B --> C[Edit Schema]
    C --> D[Create Migration]
    D --> E[Test Locally]
    E --> F{Tests Pass?}
    F -->|No| G[Fix Issues]
    G --> C
    F -->|Yes| H[Commit Changes]
    H --> I[Push Branch]
    I --> J[Create Pull Request]
    J --> K[Code Review]
    K --> L{Review Approved?}
    L -->|No| M[Address Feedback]
    M --> G
    L -->|Yes| N[Merge to Main]
    N --> O[Deploy]
    
    style A fill:#e1f5fe
    style O fill:#e8f5e8
    style F fill:#fff3e0
    style L fill:#fff3e0
```

### Migration Workflow

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant Git as Git Repository
    participant DB as Database
    participant CI as CI/CD
    
    Dev->>Git: Create feature branch
    Dev->>Dev: Edit schema.prisma
    Dev->>DB: Run migrate dev
    DB->>Dev: Create migration files
    Dev->>Git: Commit schema + migration
    Dev->>Git: Push branch
    Git->>CI: Trigger checks
    CI->>DB: Test migration
    CI->>Git: Report status
    Dev->>Git: Create pull request
    Git->>CI: Run full test suite
    CI->>Git: Approve/reject
    Git->>Git: Merge to main
    Git->>CI: Deploy to staging
    CI->>DB: Apply migrations
```

---

## 🧠 Knowledge Check

### Git Workflow Quiz

1. **What should you do before creating a database migration?**
   - [ ] A) Commit your schema changes first
   - [ ] B) Push to main branch immediately
   - [x] C) Create a feature branch and test locally
   - [ ] D) Skip testing and create the migration

   **Explanation**: Always create migrations on feature branches and test thoroughly before committing.

2. **Which files should typically be committed in a Prisma project?**
   - [x] A) schema.prisma and migration files
   - [ ] B) .env files with real credentials
   - [ ] C) node_modules directory
   - [ ] D) Generated client code only

   **Explanation**: Schema and migration files are essential for version control, while .env files should be ignored.

3. **What's the recommended approach for handling migration conflicts?**
   - [ ] A) Force push to overwrite conflicts
   - [ ] B) Delete conflicting migrations
   - [x] C) Rebase branch and create new migration
   - [ ] D) Edit existing migration files

   **Explanation**: Rebasing and creating a new migration maintains migration history integrity.

### Practical Exercise: Git Setup

**Challenge**: Set up a complete Git workflow for Prisma development

**Tasks**:
1. Create proper .gitignore and .gitattributes files
2. Set up Git hooks for validation
3. Configure branch protection rules
4. Create a PR template for schema changes
5. Test the workflow with a sample migration

```bash
# Your commands here
git init
# Add your setup commands
```

---

## 💡 Key Takeaways

- 🏗️ **Structured Approach**: Organized repository structure prevents chaos in team development
- 🌿 **Smart Branching**: Feature branches protect main branch from experimental changes
- 🔒 **Security First**: Never commit sensitive data, use proper environment management
- 🔄 **Automated Validation**: Git hooks catch issues before they reach the repository
- 📝 **Clear Communication**: Good commit messages and PR templates improve collaboration
- 🚨 **Emergency Preparedness**: Rollback procedures and conflict resolution save critical time
- 🤝 **Team Collaboration**: Standardized workflows ensure consistent team practices
- 📊 **Visibility**: Clear workflows help team members understand the development process

---

## 🔗 Navigation

**📍 Current Location**: Module 1 → Section 1.4 → Lesson 1.4.4

**⬅️ Previous**: [1.5.3 VS Code with Prisma Extension Configuration](./1.5.3-vscode-prisma-extension-configuration.md)
**➡️ Next**: [1.5.5 Docker Setup for Development](./1.5.5-docker-setup-development.md)

**🏠 Section Home**: [1.4 Development Environment](./README.md)
**📚 Module Home**: [Module 1: Foundations](../01-foundations.md)

**🗺️ Quick Links**:
- [Previous: VS Code Configuration](./1.4.3-vscode-prisma-extension-configuration.md)
- [Next: Docker Setup](./1.4.5-docker-setup-development.md)
- [Jump to: Module Assessment](../01-foundations.md#module-1-assessment)

---

*Effective version control is the backbone of successful database development. Ready to complete your development environment with Docker? Continue to the final lesson!*
