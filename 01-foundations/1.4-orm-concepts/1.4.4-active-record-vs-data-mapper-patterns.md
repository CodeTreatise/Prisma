# 1.3B.4 Active Record vs Data Mapper Patterns

## üìã Section Overview
- **Duration**: 35 minutes
- **Prerequisites**: Understanding of ORM principles, object-oriented programming, and database design patterns
- **Learning Objectives**: 
  - Compare Active Record and Data Mapper architectural patterns
  - Understand the trade-offs between simplicity and flexibility
  - Learn how Prisma implements Data Mapper concepts
  - Recognize when to use each pattern in different scenarios
  - Design applications using appropriate ORM patterns
- **Difficulty Level**: Intermediate

---

## üéØ What You'll Learn

By the end of this section, you will:
- ‚úÖ Distinguish between Active Record and Data Mapper patterns
- ‚úÖ Understand the benefits and limitations of each approach
- ‚úÖ Implement both patterns using practical examples
- ‚úÖ Choose the appropriate pattern for different application needs
- ‚úÖ Recognize how Prisma combines the best of both patterns
- ‚úÖ Design clean, maintainable data access layers

---

## üìñ Content

### Understanding ORM Design Patterns

ORM design patterns are like **different architectural styles for organizing a library**. The Active Record pattern is like a **personal library** where each book knows its own location and can move itself around, while the Data Mapper pattern is like a **professional library** with dedicated librarians who manage all book movements and organization. Each approach has its strengths depending on the complexity and scale of your needs.

### üìö The Library Management Analogy

```
üìö Library System = üóÑÔ∏è ORM Architecture

üìñ Active Record (Personal Library)
‚îú‚îÄ‚îÄ Each book manages itself ‚Üí Objects contain business logic + persistence
‚îú‚îÄ‚îÄ Simple, intuitive ‚Üí Easy to understand and use
‚îú‚îÄ‚îÄ Books know their location ‚Üí Domain objects know database details
‚îú‚îÄ‚îÄ Direct shelf access ‚Üí Direct database operations on objects
‚îú‚îÄ‚îÄ Works for small collections ‚Üí Great for simple applications
‚îî‚îÄ‚îÄ Can become cluttered ‚Üí Tight coupling as complexity grows

üèõÔ∏è Data Mapper (Professional Library)
‚îú‚îÄ‚îÄ Dedicated librarians ‚Üí Separate mapper/repository classes
‚îú‚îÄ‚îÄ Organized cataloging system ‚Üí Clean separation of concerns
‚îú‚îÄ‚îÄ Books focus on content ‚Üí Domain objects focus on business logic
‚îú‚îÄ‚îÄ Librarians handle movement ‚Üí Mappers handle persistence
‚îú‚îÄ‚îÄ Scales to massive collections ‚Üí Handles complex domain models
‚îî‚îÄ‚îÄ More complex setup ‚Üí Higher initial complexity

üîÑ Hybrid Approach (Modern Library)
‚îú‚îÄ‚îÄ Smart catalog system ‚Üí Query builder with type safety
‚îú‚îÄ‚îÄ Automated organization ‚Üí Generated client with intelligent APIs
‚îú‚îÄ‚îÄ Self-organizing books ‚Üí Objects with built-in persistence awareness
‚îî‚îÄ‚îÄ Professional management ‚Üí Framework handles complexity
```

---

## üìñ Active Record Pattern

### Core Philosophy

In the Active Record pattern, **domain objects are responsible for both business logic and persistence**. Each object knows how to save, update, and delete itself from the database. This creates a direct, intuitive relationship between objects and database records.

#### **Classic Active Record Implementation**

```typescript
// Traditional Active Record example (Rails-style)
abstract class ActiveRecord {
  public id?: number
  
  // Instance methods for persistence
  async save(): Promise<this> {
    if (this.id) {
      return await this.update()
    } else {
      return await this.create()
    }
  }
  
  async update(): Promise<this> {
    const tableName = this.constructor.name.toLowerCase() + 's'
    const fields = this.getFields()
    const setClause = Object.keys(fields)
      .map(key => `${key} = ?`)
      .join(', ')
    
    await db.query(
      `UPDATE ${tableName} SET ${setClause} WHERE id = ?`,
      [...Object.values(fields), this.id]
    )
    
    return this
  }
  
  async delete(): Promise<void> {
    const tableName = this.constructor.name.toLowerCase() + 's'
    await db.query(`DELETE FROM ${tableName} WHERE id = ?`, [this.id])
  }
  
  // Class methods for querying
  static async find(id: number): Promise<any> {
    const tableName = this.name.toLowerCase() + 's'
    const result = await db.query(
      `SELECT * FROM ${tableName} WHERE id = ?`, 
      [id]
    )
    return result.length ? this.fromRow(result[0]) : null
  }
  
  static async findAll(): Promise<any[]> {
    const tableName = this.name.toLowerCase() + 's'
    const results = await db.query(`SELECT * FROM ${tableName}`)
    return results.map(row => this.fromRow(row))
  }
  
  private getFields(): Record<string, any> {
    const { id, ...fields } = this
    return fields
  }
  
  private static fromRow(row: any): any {
    const instance = new this()
    Object.assign(instance, row)
    return instance
  }
}
```

#### **User Model with Active Record**

```typescript
// User model extending Active Record
class User extends ActiveRecord {
  public email!: string
  public firstName!: string
  public lastName!: string
  public createdAt?: Date
  public updatedAt?: Date
  
  // Business logic methods
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`.trim()
  }
  
  async sendWelcomeEmail(): Promise<void> {
    if (!this.email) {
      throw new Error('User must have an email to send welcome message')
    }
    
    await emailService.send({
      to: this.email,
      subject: 'Welcome!',
      template: 'welcome',
      data: { name: this.getFullName() }
    })
  }
  
  async activate(): Promise<this> {
    this.activatedAt = new Date()
    return await this.save()
  }
  
  // Custom finders
  static async findByEmail(email: string): Promise<User | null> {
    const result = await db.query(
      'SELECT * FROM users WHERE email = ?', 
      [email]
    )
    return result.length ? this.fromRow(result[0]) : null
  }
  
  static async findActive(): Promise<User[]> {
    const results = await db.query(
      'SELECT * FROM users WHERE activated_at IS NOT NULL'
    )
    return results.map(row => this.fromRow(row))
  }
  
  // Associations
  async getPosts(): Promise<Post[]> {
    return await Post.findByUserId(this.id!)
  }
  
  async getProfile(): Promise<Profile | null> {
    return await Profile.findByUserId(this.id!)
  }
}
```

#### **Usage Examples**

```typescript
// Creating and saving users
const user = new User()
user.email = 'john@example.com'
user.firstName = 'John'
user.lastName = 'Doe'

await user.save() // Automatically inserts into database
console.log(user.id) // Now has an ID

// Updating users
user.firstName = 'Jonathan'
await user.save() // Updates existing record

// Finding users
const foundUser = await User.find(1)
const activeUsers = await User.findActive()
const johnDoe = await User.findByEmail('john@example.com')

// Business operations
if (foundUser) {
  await foundUser.sendWelcomeEmail()
  await foundUser.activate()
  
  const posts = await foundUser.getPosts()
  const fullName = foundUser.getFullName()
}

// Deleting users
await user.delete()
```

### Active Record Benefits

#### **1. Simplicity and Intuitiveness**

```typescript
// Very straightforward API
const post = new Post()
post.title = 'My First Post'
post.content = 'Hello, world!'
post.authorId = user.id

await post.save() // It just works!

// Easy to understand relationships
const author = await post.getAuthor()
const comments = await post.getComments()
```

#### **2. Rapid Prototyping**

```typescript
// Quick model creation for MVPs
class Product extends ActiveRecord {
  public name!: string
  public price!: number
  public description?: string
  
  // Business logic co-located
  applyDiscount(percentage: number): this {
    this.price = this.price * (1 - percentage / 100)
    return this
  }
  
  async publish(): Promise<this> {
    this.publishedAt = new Date()
    return await this.save()
  }
}

// Immediate usage
const product = new Product()
product.name = 'Amazing Widget'
product.price = 99.99

await product
  .applyDiscount(10)
  .publish()
```

#### **3. Convention over Configuration**

```typescript
// Automatic table mapping and CRUD operations
class Order extends ActiveRecord {
  public customerId!: number
  public total!: number
  public status: string = 'pending'
  
  // Conventions automatically provide:
  // - orders table mapping
  // - save/update/delete methods
  // - find/findAll class methods
  // - created_at/updated_at handling
}
```

### Active Record Challenges

#### **1. Tight Coupling**

```typescript
// Problem: Business logic coupled with persistence
class User extends ActiveRecord {
  async calculateLoyaltyPoints(): Promise<number> {
    // Business logic mixed with database queries
    const orders = await db.query(
      'SELECT * FROM orders WHERE user_id = ?', 
      [this.id]
    )
    
    const purchases = await db.query(
      'SELECT SUM(total) as total FROM purchases WHERE user_id = ?',
      [this.id]
    )
    
    // Complex business calculation
    return orders.length * 10 + (purchases[0]?.total || 0) * 0.1
  }
  
  // Hard to test without database
  // Hard to change persistence without affecting business logic
}
```

#### **2. Testing Difficulties**

```typescript
// Testing Active Record requires database setup
describe('User', () => {
  beforeEach(async () => {
    await setupTestDatabase() // Required for every test
    await seedTestData()
  })
  
  afterEach(async () => {
    await cleanupTestDatabase()
  })
  
  it('should calculate loyalty points', async () => {
    const user = await User.find(1) // Database dependency
    const points = await user.calculateLoyaltyPoints() // Hits database
    
    expect(points).toBe(150)
  })
  
  // Tests are slow and require database state management
})
```

#### **3. Complex Domain Logic**

```typescript
// As domain complexity grows, Active Record becomes unwieldy
class Order extends ActiveRecord {
  // Persistence concerns mixed with business rules
  async calculateShipping(): Promise<number> { /* ... */ }
  async applyTaxes(): Promise<void> { /* ... */ }
  async processPayment(): Promise<void> { /* ... */ }
  async updateInventory(): Promise<void> { /* ... */ }
  async sendNotifications(): Promise<void> { /* ... */ }
  
  // Single class handles too many responsibilities
  // Violates Single Responsibility Principle
}
```

---

## üèõÔ∏è Data Mapper Pattern

### Core Philosophy

In the Data Mapper pattern, **domain objects are completely separate from persistence logic**. Specialized mapper classes handle the translation between domain objects and database records, keeping business logic pure and database-agnostic.

#### **Data Mapper Implementation**

```typescript
// Pure domain object (no persistence knowledge)
export class User {
  constructor(
    public readonly id: string,
    public email: string,
    public firstName: string,
    public lastName: string,
    public createdAt: Date = new Date(),
    public updatedAt: Date = new Date()
  ) {}
  
  // Pure business logic
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`.trim()
  }
  
  updateName(firstName: string, lastName: string): void {
    this.firstName = firstName
    this.lastName = lastName
    this.updatedAt = new Date()
  }
  
  isEmailValid(): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(this.email)
  }
  
  // No database knowledge whatsoever
}
```

#### **Dedicated Mapper Class**

```typescript
// Mapper handles all persistence logic
export interface UserRepository {
  findById(id: string): Promise<User | null>
  findByEmail(email: string): Promise<User | null>
  findAll(): Promise<User[]>
  save(user: User): Promise<User>
  delete(id: string): Promise<void>
}

export class DatabaseUserRepository implements UserRepository {
  constructor(private db: Database) {}
  
  async findById(id: string): Promise<User | null> {
    const row = await this.db.query(
      'SELECT * FROM users WHERE id = ?', 
      [id]
    )
    
    return row.length ? this.mapRowToUser(row[0]) : null
  }
  
  async findByEmail(email: string): Promise<User | null> {
    const row = await this.db.query(
      'SELECT * FROM users WHERE email = ?', 
      [email]
    )
    
    return row.length ? this.mapRowToUser(row[0]) : null
  }
  
  async findAll(): Promise<User[]> {
    const rows = await this.db.query('SELECT * FROM users')
    return rows.map(row => this.mapRowToUser(row))
  }
  
  async save(user: User): Promise<User> {
    const userData = this.mapUserToRow(user)
    
    if (await this.exists(user.id)) {
      await this.db.query(
        `UPDATE users SET 
         email = ?, first_name = ?, last_name = ?, updated_at = ?
         WHERE id = ?`,
        [userData.email, userData.first_name, userData.last_name, 
         userData.updated_at, user.id]
      )
    } else {
      await this.db.query(
        `INSERT INTO users (id, email, first_name, last_name, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [userData.id, userData.email, userData.first_name, userData.last_name,
         userData.created_at, userData.updated_at]
      )
    }
    
    return user
  }
  
  async delete(id: string): Promise<void> {
    await this.db.query('DELETE FROM users WHERE id = ?', [id])
  }
  
  // Private mapping methods
  private mapRowToUser(row: any): User {
    return new User(
      row.id,
      row.email,
      row.first_name,
      row.last_name,
      new Date(row.created_at),
      new Date(row.updated_at)
    )
  }
  
  private mapUserToRow(user: User): any {
    return {
      id: user.id,
      email: user.email,
      first_name: user.firstName,
      last_name: user.lastName,
      created_at: user.createdAt,
      updated_at: user.updatedAt
    }
  }
  
  private async exists(id: string): Promise<boolean> {
    const result = await this.db.query(
      'SELECT COUNT(*) as count FROM users WHERE id = ?', 
      [id]
    )
    return result[0].count > 0
  }
}
```

#### **Service Layer Implementation**

```typescript
// Service layer orchestrates domain logic and persistence
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService
  ) {}
  
  async createUser(userData: CreateUserData): Promise<User> {
    // Validate business rules
    if (!this.isValidEmail(userData.email)) {
      throw new Error('Invalid email format')
    }
    
    // Check if user already exists
    const existing = await this.userRepository.findByEmail(userData.email)
    if (existing) {
      throw new Error('User with this email already exists')
    }
    
    // Create domain object
    const user = new User(
      generateId(),
      userData.email,
      userData.firstName,
      userData.lastName
    )
    
    // Persist through repository
    const savedUser = await this.userRepository.save(user)
    
    // Send welcome email
    await this.emailService.sendWelcomeEmail(savedUser)
    
    return savedUser
  }
  
  async updateUserName(
    userId: string, 
    firstName: string, 
    lastName: string
  ): Promise<User> {
    const user = await this.userRepository.findById(userId)
    if (!user) {
      throw new Error('User not found')
    }
    
    // Use domain method for business logic
    user.updateName(firstName, lastName)
    
    // Persist changes
    return await this.userRepository.save(user)
  }
  
  async getUserProfile(userId: string): Promise<UserProfile | null> {
    const user = await this.userRepository.findById(userId)
    if (!user) {
      return null
    }
    
    return {
      id: user.id,
      fullName: user.getFullName(),
      email: user.email,
      memberSince: user.createdAt,
      isEmailValid: user.isEmailValid()
    }
  }
  
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  }
}
```

#### **Usage Examples**

```typescript
// Dependency injection setup
const database = new Database(connectionString)
const userRepository = new DatabaseUserRepository(database)
const emailService = new EmailService()
const userService = new UserService(userRepository, emailService)

// Business operations through service layer
const user = await userService.createUser({
  email: 'john@example.com',
  firstName: 'John',
  lastName: 'Doe'
})

// Update through service (maintains business rules)
const updatedUser = await userService.updateUserName(
  user.id, 
  'Jonathan', 
  'Smith'
)

// Query through repository (when direct access needed)
const foundUser = await userRepository.findByEmail('john@example.com')
const allUsers = await userRepository.findAll()

// Domain operations are pure
if (foundUser) {
  const fullName = foundUser.getFullName() // No database hit
  const isValid = foundUser.isEmailValid() // Pure function
}
```

### Data Mapper Benefits

#### **1. Clean Separation of Concerns**

```typescript
// Domain logic is pure and testable
export class Order {
  constructor(
    public readonly id: string,
    public customerId: string,
    public items: OrderItem[],
    public status: OrderStatus = OrderStatus.PENDING
  ) {}
  
  // Pure business logic - no database dependencies
  calculateTotal(): number {
    return this.items.reduce((sum, item) => 
      sum + (item.quantity * item.price), 0)
  }
  
  canBeCancelled(): boolean {
    return this.status === OrderStatus.PENDING || 
           this.status === OrderStatus.CONFIRMED
  }
  
  cancel(): void {
    if (!this.canBeCancelled()) {
      throw new Error('Order cannot be cancelled in current status')
    }
    this.status = OrderStatus.CANCELLED
  }
  
  // No persistence knowledge
}

// Separate persistence logic
export class OrderRepository {
  async save(order: Order): Promise<Order> {
    // Handle complex mapping and relationships
    await this.saveOrderItems(order.items, order.id)
    await this.updateOrderStatus(order.id, order.status)
    return order
  }
}
```

#### **2. Excellent Testability**

```typescript
// Domain objects can be tested in isolation
describe('Order', () => {
  it('should calculate total correctly', () => {
    const items = [
      new OrderItem('1', 2, 10.00),
      new OrderItem('2', 1, 25.00)
    ]
    const order = new Order('order-1', 'customer-1', items)
    
    expect(order.calculateTotal()).toBe(45.00) // No database needed!
  })
  
  it('should allow cancellation when pending', () => {
    const order = new Order('order-1', 'customer-1', [])
    
    expect(order.canBeCancelled()).toBe(true)
    order.cancel()
    expect(order.status).toBe(OrderStatus.CANCELLED)
  })
})

// Repository can be mocked for service tests
describe('OrderService', () => {
  it('should create order successfully', async () => {
    const mockRepository = {
      save: jest.fn().mockResolvedValue(mockOrder),
      findById: jest.fn()
    }
    
    const service = new OrderService(mockRepository)
    const result = await service.createOrder(orderData)
    
    expect(mockRepository.save).toHaveBeenCalledWith(expect.any(Order))
    expect(result.id).toBeDefined()
  })
})
```

#### **3. Flexible Persistence**

```typescript
// Easy to swap implementations
export class InMemoryUserRepository implements UserRepository {
  private users: Map<string, User> = new Map()
  
  async findById(id: string): Promise<User | null> {
    return this.users.get(id) || null
  }
  
  async save(user: User): Promise<User> {
    this.users.set(user.id, user)
    return user
  }
  
  // Useful for testing, caching, etc.
}

export class RedisUserRepository implements UserRepository {
  constructor(private redis: RedisClient) {}
  
  async findById(id: string): Promise<User | null> {
    const data = await this.redis.get(`user:${id}`)
    return data ? this.deserialize(data) : null
  }
  
  // Different persistence strategy, same interface
}

// Service remains unchanged
const userService = new UserService(
  process.env.NODE_ENV === 'test' 
    ? new InMemoryUserRepository()
    : new DatabaseUserRepository(database)
)
```

### Data Mapper Challenges

#### **1. Higher Complexity**

```typescript
// More classes and interfaces to manage
interface UserRepository { /* ... */ }
interface PostRepository { /* ... */ }
interface CommentRepository { /* ... */ }

class DatabaseUserRepository implements UserRepository { /* ... */ }
class DatabasePostRepository implements PostRepository { /* ... */ }
class DatabaseCommentRepository implements CommentRepository { /* ... */ }

class UserService { /* ... */ }
class PostService { /* ... */ }
class CommentService { /* ... */ }

// vs Active Record's single class per model
```

#### **2. More Boilerplate**

```typescript
// Mapping between domain objects and database rows
private mapRowToUser(row: any): User {
  return new User(
    row.id,
    row.email,
    row.first_name,  // Field mapping
    row.last_name,   // Field mapping
    new Date(row.created_at), // Type conversion
    new Date(row.updated_at)  // Type conversion
  )
}

private mapUserToRow(user: User): any {
  return {
    id: user.id,
    email: user.email,
    first_name: user.firstName,  // Reverse mapping
    last_name: user.lastName,    // Reverse mapping
    created_at: user.createdAt,  // Type conversion
    updated_at: user.updatedAt   // Type conversion
  }
}

// Active Record handles this automatically
```

#### **3. Relationship Complexity**

```typescript
// Complex relationship loading
export class OrderRepository {
  async findWithItems(orderId: string): Promise<Order | null> {
    // Multiple queries needed
    const orderRow = await this.db.query(
      'SELECT * FROM orders WHERE id = ?', 
      [orderId]
    )
    
    if (!orderRow.length) return null
    
    const itemRows = await this.db.query(
      'SELECT * FROM order_items WHERE order_id = ?',
      [orderId]
    )
    
    const customerRow = await this.db.query(
      'SELECT * FROM customers WHERE id = ?',
      [orderRow[0].customer_id]
    )
    
    // Manual assembly required
    const order = this.mapRowToOrder(orderRow[0])
    order.items = itemRows.map(row => this.mapRowToOrderItem(row))
    order.customer = this.mapRowToCustomer(customerRow[0])
    
    return order
  }
}
```

---

## üîÑ Prisma's Hybrid Approach

Prisma combines the best aspects of both patterns, providing **Active Record-like simplicity with Data Mapper-like separation**.

### Prisma Implementation

```prisma
// Clean schema definition (Data Mapper-like separation)
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String   @map("first_name")
  lastName  String   @map("last_name")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  posts     Post[]
  profile   Profile?
  
  @@map("users")
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String   @map("author_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  author    User     @relation(fields: [authorId], references: [id])
  
  @@map("posts")
}
```

```typescript
// Generated client provides Active Record-like API
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Simple operations (Active Record style)
const user = await prisma.user.create({
  data: {
    email: 'john@example.com',
    firstName: 'John',
    lastName: 'Doe'
  }
})

await prisma.user.update({
  where: { id: user.id },
  data: { firstName: 'Jonathan' }
})

// Complex queries with relationships
const userWithPosts = await prisma.user.findUnique({
  where: { id: user.id },
  include: {
    posts: {
      where: { published: true },
      orderBy: { createdAt: 'desc' }
    },
    profile: true
  }
})

// Transaction support (Data Mapper style control)
await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({
    data: { email: 'jane@example.com', firstName: 'Jane', lastName: 'Smith' }
  })
  
  await tx.post.create({
    data: {
      title: 'Welcome Post',
      content: 'Hello from Jane!',
      authorId: user.id,
      published: true
    }
  })
})
```

### Domain Layer with Prisma

```typescript
// Pure domain models (Data Mapper style)
export class User {
  constructor(
    public readonly id: string,
    public email: string,
    public firstName: string,
    public lastName: string,
    public createdAt: Date,
    public updatedAt: Date
  ) {}
  
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`.trim()
  }
  
  updateName(firstName: string, lastName: string): void {
    this.firstName = firstName
    this.lastName = lastName
  }
}

// Service layer with Prisma
export class UserService {
  constructor(private prisma: PrismaClient) {}
  
  async createUser(data: CreateUserData): Promise<User> {
    // Business validation
    if (!this.isValidEmail(data.email)) {
      throw new Error('Invalid email format')
    }
    
    // Prisma handles persistence (Active Record style simplicity)
    const dbUser = await this.prisma.user.create({
      data: {
        email: data.email,
        firstName: data.firstName,
        lastName: data.lastName
      }
    })
    
    // Convert to domain object
    return this.toDomain(dbUser)
  }
  
  async updateUserName(
    userId: string, 
    firstName: string, 
    lastName: string
  ): Promise<User> {
    // Get current user
    const dbUser = await this.prisma.user.findUnique({
      where: { id: userId }
    })
    
    if (!dbUser) {
      throw new Error('User not found')
    }
    
    // Apply business logic through domain object
    const user = this.toDomain(dbUser)
    user.updateName(firstName, lastName)
    
    // Persist changes
    const updated = await this.prisma.user.update({
      where: { id: userId },
      data: {
        firstName: user.firstName,
        lastName: user.lastName
      }
    })
    
    return this.toDomain(updated)
  }
  
  private toDomain(dbUser: any): User {
    return new User(
      dbUser.id,
      dbUser.email,
      dbUser.firstName,
      dbUser.lastName,
      dbUser.createdAt,
      dbUser.updatedAt
    )
  }
  
  private isValidEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
  }
}
```

### Benefits of Prisma's Approach

```typescript
// 1. Type safety (Data Mapper benefit)
const user = await prisma.user.findUnique({ 
  where: { id: 'invalid-id' } // TypeScript catches type errors
})

// 2. Simple API (Active Record benefit)
await prisma.user.create({
  data: {
    email: 'test@example.com',
    firstName: 'Test',
    lastName: 'User',
    posts: {
      create: [
        { title: 'First Post', content: 'Hello world!' }
      ]
    }
  }
})

// 3. Flexible querying (Best of both)
const result = await prisma.user.findMany({
  where: {
    posts: {
      some: {
        published: true,
        createdAt: {
          gte: new Date('2023-01-01')
        }
      }
    }
  },
  include: {
    posts: {
      where: { published: true },
      select: { id: true, title: true, createdAt: true }
    },
    _count: {
      select: { posts: true }
    }
  }
})

// 4. Transaction control (Data Mapper style)
await prisma.$transaction([
  prisma.user.create({ data: userData }),
  prisma.post.create({ data: postData }),
  prisma.profile.create({ data: profileData })
])
```

---

## üìä Pattern Comparison Summary

| Aspect | Active Record | Data Mapper | Prisma Hybrid |
|--------|---------------|-------------|---------------|
| **Simplicity** | ‚úÖ Very High | ‚ùå Lower | ‚úÖ High |
| **Testability** | ‚ùå Database Required | ‚úÖ Pure Unit Tests | ‚úÖ Good |
| **Separation of Concerns** | ‚ùå Coupled | ‚úÖ Clean | ‚úÖ Flexible |
| **Learning Curve** | ‚úÖ Low | ‚ùå Higher | ‚úÖ Moderate |
| **Performance Control** | ‚ùå Limited | ‚úÖ Full Control | ‚úÖ Good Control |
| **Type Safety** | ‚ùå Runtime Errors | ‚úÖ Compile-time | ‚úÖ Excellent |
| **Relationship Handling** | ‚úÖ Automatic | ‚ùå Manual | ‚úÖ Automatic + Control |
| **Boilerplate Code** | ‚úÖ Minimal | ‚ùå Significant | ‚úÖ Minimal |

---

## üß† Knowledge Check

### Pattern Recognition Quiz

1. **Which pattern is best for rapid prototyping?**
   - [x] A) Active Record
   - [ ] B) Data Mapper
   - [ ] C) Both are equally good
   - [ ] D) Neither, use raw SQL

   **Explanation**: Active Record's simplicity and convention-over-configuration approach makes it ideal for rapid prototyping.

2. **What is the main advantage of Data Mapper pattern?**
   - [ ] A) Simpler to understand
   - [x] B) Better separation of concerns
   - [ ] C) Faster performance
   - [ ] D) Less code to write

   **Explanation**: Data Mapper keeps domain logic separate from persistence, enabling better testability and maintainability.

3. **How does Prisma combine both patterns?**
   - [ ] A) It only uses Active Record
   - [ ] B) It only uses Data Mapper
   - [x] C) Simple API with clean separation capabilities
   - [ ] D) It creates a new pattern entirely

   **Explanation**: Prisma provides Active Record-like simplicity while allowing Data Mapper-style separation when needed.

### Practical Exercise: Pattern Implementation

**Scenario**: Design a simple blog system using both patterns.

**Requirements**:
- Users can create posts
- Posts can have comments
- Users can have profiles

```typescript
// 1. Implement using Active Record pattern
class BlogPost extends ActiveRecord {
  // Your implementation here
}

// 2. Implement using Data Mapper pattern
interface BlogPostRepository {
  // Your interface here
}

class BlogPost {
  // Your domain object here
}

class BlogPostService {
  // Your service layer here
}

// 3. Compare the approaches
// Which would you choose for:
// - A personal blog with 10 users?
// - An enterprise CMS with complex business rules?
// - A high-traffic social platform?
```

---

## üí° Key Takeaways

- üìö **Pattern Purpose**: Active Record for simplicity, Data Mapper for complex domains
- üîÑ **Trade-offs**: Simplicity vs. flexibility, rapid development vs. maintainability
- üèõÔ∏è **Separation Matters**: Data Mapper's separation enables better testing and evolution
- ‚ö° **Development Speed**: Active Record excels for prototypes and simple applications
- üéØ **Context-Driven**: Choose patterns based on project complexity and team experience
- üîß **Prisma's Innovation**: Combines benefits of both patterns with excellent developer experience
- üìà **Evolution Path**: Start simple with Active Record-style, refactor to Data Mapper as complexity grows
- üß™ **Testing Strategy**: Data Mapper enables pure unit tests, Active Record requires integration tests

---

## üîó Navigation

**üìç Current Location**: Module 1 ‚Üí Section 1.3B ‚Üí Lesson 1.3B.4

**‚¨ÖÔ∏è Previous**: [1.4.3 Migration Strategies & Schema Evolution](./1.4.3-migration-strategies-schema-evolution.md)
**‚û°Ô∏è Next**: [1.4.5 Type Generation & Code Safety](./1.4.5-type-generation-code-safety.md)

**üè† Section Home**: [1.3B ORM Concepts](./README.md)
**üìö Module Home**: [Module 1: Foundations](../01-foundations.md)

**üó∫Ô∏è Quick Links**:
- [Previous: Migration Strategies](./1.3b.3-migration-strategies-schema-evolution.md)
- [Next: Type Safety](./1.3b.5-type-generation-code-safety.md)
- [Jump to: Development Environment](../1.4-development-environment/)

---

*Understanding ORM patterns helps you choose the right architecture for your applications. Ready to explore type generation and code safety? Let's complete the ORM concepts section!*
