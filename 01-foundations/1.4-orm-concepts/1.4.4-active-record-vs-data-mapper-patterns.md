# 1.3B.4 Active Record vs Data Mapper Patterns

## 📋 Section Overview
- **Duration**: 35 minutes
- **Prerequisites**: Understanding of ORM principles, object-oriented programming, and database design patterns
- **Learning Objectives**: 
  - Compare Active Record and Data Mapper architectural patterns
  - Understand the trade-offs between simplicity and flexibility
  - Learn how Prisma implements Data Mapper concepts
  - Recognize when to use each pattern in different scenarios
  - Design applications using appropriate ORM patterns
- **Difficulty Level**: Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Distinguish between Active Record and Data Mapper patterns
- ✅ Understand the benefits and limitations of each approach
- ✅ Implement both patterns using practical examples
- ✅ Choose the appropriate pattern for different application needs
- ✅ Recognize how Prisma combines the best of both patterns
- ✅ Design clean, maintainable data access layers

---

## 📖 Content

### Understanding ORM Design Patterns

ORM design patterns are like **different architectural styles for organizing a library**. The Active Record pattern is like a **personal library** where each book knows its own location and can move itself around, while the Data Mapper pattern is like a **professional library** with dedicated librarians who manage all book movements and organization. Each approach has its strengths depending on the complexity and scale of your needs.

### 📚 The Library Management Analogy

```
📚 Library System = 🗄️ ORM Architecture

📖 Active Record (Personal Library)
├── Each book manages itself → Objects contain business logic + persistence
├── Simple, intuitive → Easy to understand and use
├── Books know their location → Domain objects know database details
├── Direct shelf access → Direct database operations on objects
├── Works for small collections → Great for simple applications
└── Can become cluttered → Tight coupling as complexity grows

🏛️ Data Mapper (Professional Library)
├── Dedicated librarians → Separate mapper/repository classes
├── Organized cataloging system → Clean separation of concerns
├── Books focus on content → Domain objects focus on business logic
├── Librarians handle movement → Mappers handle persistence
├── Scales to massive collections → Handles complex domain models
└── More complex setup → Higher initial complexity

🔄 Hybrid Approach (Modern Library)
├── Smart catalog system → Query builder with type safety
├── Automated organization → Generated client with intelligent APIs
├── Self-organizing books → Objects with built-in persistence awareness
└── Professional management → Framework handles complexity
```

---

## 📖 Active Record Pattern

### Core Philosophy

In the Active Record pattern, **domain objects are responsible for both business logic and persistence**. Each object knows how to save, update, and delete itself from the database. This creates a direct, intuitive relationship between objects and database records.

#### **Classic Active Record Implementation**

```typescript
// Traditional Active Record example (Rails-style)
abstract class ActiveRecord {
  public id?: number
  
  // Instance methods for persistence
  async save(): Promise<this> {
    if (this.id) {
      return await this.update()
    } else {
      return await this.create()
    }
  }
  
  async update(): Promise<this> {
    const tableName = this.constructor.name.toLowerCase() + 's'
    const fields = this.getFields()
    const setClause = Object.keys(fields)
      .map(key => `${key} = ?`)
      .join(', ')
    
    await db.query(
      `UPDATE ${tableName} SET ${setClause} WHERE id = ?`,
      [...Object.values(fields), this.id]
    )
    
    return this
  }
  
  async delete(): Promise<void> {
    const tableName = this.constructor.name.toLowerCase() + 's'
    await db.query(`DELETE FROM ${tableName} WHERE id = ?`, [this.id])
  }
  
  // Class methods for querying
  static async find(id: number): Promise<any> {
    const tableName = this.name.toLowerCase() + 's'
    const result = await db.query(
      `SELECT * FROM ${tableName} WHERE id = ?`, 
      [id]
    )
    return result.length ? this.fromRow(result[0]) : null
  }
  
  static async findAll(): Promise<any[]> {
    const tableName = this.name.toLowerCase() + 's'
    const results = await db.query(`SELECT * FROM ${tableName}`)
    return results.map(row => this.fromRow(row))
  }
  
  private getFields(): Record<string, any> {
    const { id, ...fields } = this
    return fields
  }
  
  private static fromRow(row: any): any {
    const instance = new this()
    Object.assign(instance, row)
    return instance
  }
}
```

#### **User Model with Active Record**

```typescript
// User model extending Active Record
class User extends ActiveRecord {
  public email!: string
  public firstName!: string
  public lastName!: string
  public createdAt?: Date
  public updatedAt?: Date
  
  // Business logic methods
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`.trim()
  }
  
  async sendWelcomeEmail(): Promise<void> {
    if (!this.email) {
      throw new Error('User must have an email to send welcome message')
    }
    
    await emailService.send({
      to: this.email,
      subject: 'Welcome!',
      template: 'welcome',
      data: { name: this.getFullName() }
    })
  }
  
  async activate(): Promise<this> {
    this.activatedAt = new Date()
    return await this.save()
  }
  
  // Custom finders
  static async findByEmail(email: string): Promise<User | null> {
    const result = await db.query(
      'SELECT * FROM users WHERE email = ?', 
      [email]
    )
    return result.length ? this.fromRow(result[0]) : null
  }
  
  static async findActive(): Promise<User[]> {
    const results = await db.query(
      'SELECT * FROM users WHERE activated_at IS NOT NULL'
    )
    return results.map(row => this.fromRow(row))
  }
  
  // Associations
  async getPosts(): Promise<Post[]> {
    return await Post.findByUserId(this.id!)
  }
  
  async getProfile(): Promise<Profile | null> {
    return await Profile.findByUserId(this.id!)
  }
}
```

#### **Usage Examples**

```typescript
// Creating and saving users
const user = new User()
user.email = 'john@example.com'
user.firstName = 'John'
user.lastName = 'Doe'

await user.save() // Automatically inserts into database
console.log(user.id) // Now has an ID

// Updating users
user.firstName = 'Jonathan'
await user.save() // Updates existing record

// Finding users
const foundUser = await User.find(1)
const activeUsers = await User.findActive()
const johnDoe = await User.findByEmail('john@example.com')

// Business operations
if (foundUser) {
  await foundUser.sendWelcomeEmail()
  await foundUser.activate()
  
  const posts = await foundUser.getPosts()
  const fullName = foundUser.getFullName()
}

// Deleting users
await user.delete()
```

### Active Record Benefits

#### **1. Simplicity and Intuitiveness**

```typescript
// Very straightforward API
const post = new Post()
post.title = 'My First Post'
post.content = 'Hello, world!'
post.authorId = user.id

await post.save() // It just works!

// Easy to understand relationships
const author = await post.getAuthor()
const comments = await post.getComments()
```

#### **2. Rapid Prototyping**

```typescript
// Quick model creation for MVPs
class Product extends ActiveRecord {
  public name!: string
  public price!: number
  public description?: string
  
  // Business logic co-located
  applyDiscount(percentage: number): this {
    this.price = this.price * (1 - percentage / 100)
    return this
  }
  
  async publish(): Promise<this> {
    this.publishedAt = new Date()
    return await this.save()
  }
}

// Immediate usage
const product = new Product()
product.name = 'Amazing Widget'
product.price = 99.99

await product
  .applyDiscount(10)
  .publish()
```

#### **3. Convention over Configuration**

```typescript
// Automatic table mapping and CRUD operations
class Order extends ActiveRecord {
  public customerId!: number
  public total!: number
  public status: string = 'pending'
  
  // Conventions automatically provide:
  // - orders table mapping
  // - save/update/delete methods
  // - find/findAll class methods
  // - created_at/updated_at handling
}
```

### Active Record Challenges

#### **1. Tight Coupling**

```typescript
// Problem: Business logic coupled with persistence
class User extends ActiveRecord {
  async calculateLoyaltyPoints(): Promise<number> {
    // Business logic mixed with database queries
    const orders = await db.query(
      'SELECT * FROM orders WHERE user_id = ?', 
      [this.id]
    )
    
    const purchases = await db.query(
      'SELECT SUM(total) as total FROM purchases WHERE user_id = ?',
      [this.id]
    )
    
    // Complex business calculation
    return orders.length * 10 + (purchases[0]?.total || 0) * 0.1
  }
  
  // Hard to test without database
  // Hard to change persistence without affecting business logic
}
```

#### **2. Testing Difficulties**

```typescript
// Testing Active Record requires database setup
describe('User', () => {
  beforeEach(async () => {
    await setupTestDatabase() // Required for every test
    await seedTestData()
  })
  
  afterEach(async () => {
    await cleanupTestDatabase()
  })
  
  it('should calculate loyalty points', async () => {
    const user = await User.find(1) // Database dependency
    const points = await user.calculateLoyaltyPoints() // Hits database
    
    expect(points).toBe(150)
  })
  
  // Tests are slow and require database state management
})
```

#### **3. Complex Domain Logic**

```typescript
// As domain complexity grows, Active Record becomes unwieldy
class Order extends ActiveRecord {
  // Persistence concerns mixed with business rules
  async calculateShipping(): Promise<number> { /* ... */ }
  async applyTaxes(): Promise<void> { /* ... */ }
  async processPayment(): Promise<void> { /* ... */ }
  async updateInventory(): Promise<void> { /* ... */ }
  async sendNotifications(): Promise<void> { /* ... */ }
  
  // Single class handles too many responsibilities
  // Violates Single Responsibility Principle
}
```

---

## 🏛️ Data Mapper Pattern

### Core Philosophy

In the Data Mapper pattern, **domain objects are completely separate from persistence logic**. Specialized mapper classes handle the translation between domain objects and database records, keeping business logic pure and database-agnostic.

#### **Data Mapper Implementation**

```typescript
// Pure domain object (no persistence knowledge)
export class User {
  constructor(
    public readonly id: string,
    public email: string,
    public firstName: string,
    public lastName: string,
    public createdAt: Date = new Date(),
    public updatedAt: Date = new Date()
  ) {}
  
  // Pure business logic
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`.trim()
  }
  
  updateName(firstName: string, lastName: string): void {
    this.firstName = firstName
    this.lastName = lastName
    this.updatedAt = new Date()
  }
  
  isEmailValid(): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(this.email)
  }
  
  // No database knowledge whatsoever
}
```

#### **Dedicated Mapper Class**

```typescript
// Mapper handles all persistence logic
export interface UserRepository {
  findById(id: string): Promise<User | null>
  findByEmail(email: string): Promise<User | null>
  findAll(): Promise<User[]>
  save(user: User): Promise<User>
  delete(id: string): Promise<void>
}

export class DatabaseUserRepository implements UserRepository {
  constructor(private db: Database) {}
  
  async findById(id: string): Promise<User | null> {
    const row = await this.db.query(
      'SELECT * FROM users WHERE id = ?', 
      [id]
    )
    
    return row.length ? this.mapRowToUser(row[0]) : null
  }
  
  async findByEmail(email: string): Promise<User | null> {
    const row = await this.db.query(
      'SELECT * FROM users WHERE email = ?', 
      [email]
    )
    
    return row.length ? this.mapRowToUser(row[0]) : null
  }
  
  async findAll(): Promise<User[]> {
    const rows = await this.db.query('SELECT * FROM users')
    return rows.map(row => this.mapRowToUser(row))
  }
  
  async save(user: User): Promise<User> {
    const userData = this.mapUserToRow(user)
    
    if (await this.exists(user.id)) {
      await this.db.query(
        `UPDATE users SET 
         email = ?, first_name = ?, last_name = ?, updated_at = ?
         WHERE id = ?`,
        [userData.email, userData.first_name, userData.last_name, 
         userData.updated_at, user.id]
      )
    } else {
      await this.db.query(
        `INSERT INTO users (id, email, first_name, last_name, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [userData.id, userData.email, userData.first_name, userData.last_name,
         userData.created_at, userData.updated_at]
      )
    }
    
    return user
  }
  
  async delete(id: string): Promise<void> {
    await this.db.query('DELETE FROM users WHERE id = ?', [id])
  }
  
  // Private mapping methods
  private mapRowToUser(row: any): User {
    return new User(
      row.id,
      row.email,
      row.first_name,
      row.last_name,
      new Date(row.created_at),
      new Date(row.updated_at)
    )
  }
  
  private mapUserToRow(user: User): any {
    return {
      id: user.id,
      email: user.email,
      first_name: user.firstName,
      last_name: user.lastName,
      created_at: user.createdAt,
      updated_at: user.updatedAt
    }
  }
  
  private async exists(id: string): Promise<boolean> {
    const result = await this.db.query(
      'SELECT COUNT(*) as count FROM users WHERE id = ?', 
      [id]
    )
    return result[0].count > 0
  }
}
```

#### **Service Layer Implementation**

```typescript
// Service layer orchestrates domain logic and persistence
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService
  ) {}
  
  async createUser(userData: CreateUserData): Promise<User> {
    // Validate business rules
    if (!this.isValidEmail(userData.email)) {
      throw new Error('Invalid email format')
    }
    
    // Check if user already exists
    const existing = await this.userRepository.findByEmail(userData.email)
    if (existing) {
      throw new Error('User with this email already exists')
    }
    
    // Create domain object
    const user = new User(
      generateId(),
      userData.email,
      userData.firstName,
      userData.lastName
    )
    
    // Persist through repository
    const savedUser = await this.userRepository.save(user)
    
    // Send welcome email
    await this.emailService.sendWelcomeEmail(savedUser)
    
    return savedUser
  }
  
  async updateUserName(
    userId: string, 
    firstName: string, 
    lastName: string
  ): Promise<User> {
    const user = await this.userRepository.findById(userId)
    if (!user) {
      throw new Error('User not found')
    }
    
    // Use domain method for business logic
    user.updateName(firstName, lastName)
    
    // Persist changes
    return await this.userRepository.save(user)
  }
  
  async getUserProfile(userId: string): Promise<UserProfile | null> {
    const user = await this.userRepository.findById(userId)
    if (!user) {
      return null
    }
    
    return {
      id: user.id,
      fullName: user.getFullName(),
      email: user.email,
      memberSince: user.createdAt,
      isEmailValid: user.isEmailValid()
    }
  }
  
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  }
}
```

#### **Usage Examples**

```typescript
// Dependency injection setup
const database = new Database(connectionString)
const userRepository = new DatabaseUserRepository(database)
const emailService = new EmailService()
const userService = new UserService(userRepository, emailService)

// Business operations through service layer
const user = await userService.createUser({
  email: 'john@example.com',
  firstName: 'John',
  lastName: 'Doe'
})

// Update through service (maintains business rules)
const updatedUser = await userService.updateUserName(
  user.id, 
  'Jonathan', 
  'Smith'
)

// Query through repository (when direct access needed)
const foundUser = await userRepository.findByEmail('john@example.com')
const allUsers = await userRepository.findAll()

// Domain operations are pure
if (foundUser) {
  const fullName = foundUser.getFullName() // No database hit
  const isValid = foundUser.isEmailValid() // Pure function
}
```

### Data Mapper Benefits

#### **1. Clean Separation of Concerns**

```typescript
// Domain logic is pure and testable
export class Order {
  constructor(
    public readonly id: string,
    public customerId: string,
    public items: OrderItem[],
    public status: OrderStatus = OrderStatus.PENDING
  ) {}
  
  // Pure business logic - no database dependencies
  calculateTotal(): number {
    return this.items.reduce((sum, item) => 
      sum + (item.quantity * item.price), 0)
  }
  
  canBeCancelled(): boolean {
    return this.status === OrderStatus.PENDING || 
           this.status === OrderStatus.CONFIRMED
  }
  
  cancel(): void {
    if (!this.canBeCancelled()) {
      throw new Error('Order cannot be cancelled in current status')
    }
    this.status = OrderStatus.CANCELLED
  }
  
  // No persistence knowledge
}

// Separate persistence logic
export class OrderRepository {
  async save(order: Order): Promise<Order> {
    // Handle complex mapping and relationships
    await this.saveOrderItems(order.items, order.id)
    await this.updateOrderStatus(order.id, order.status)
    return order
  }
}
```

#### **2. Excellent Testability**

```typescript
// Domain objects can be tested in isolation
describe('Order', () => {
  it('should calculate total correctly', () => {
    const items = [
      new OrderItem('1', 2, 10.00),
      new OrderItem('2', 1, 25.00)
    ]
    const order = new Order('order-1', 'customer-1', items)
    
    expect(order.calculateTotal()).toBe(45.00) // No database needed!
  })
  
  it('should allow cancellation when pending', () => {
    const order = new Order('order-1', 'customer-1', [])
    
    expect(order.canBeCancelled()).toBe(true)
    order.cancel()
    expect(order.status).toBe(OrderStatus.CANCELLED)
  })
})

// Repository can be mocked for service tests
describe('OrderService', () => {
  it('should create order successfully', async () => {
    const mockRepository = {
      save: jest.fn().mockResolvedValue(mockOrder),
      findById: jest.fn()
    }
    
    const service = new OrderService(mockRepository)
    const result = await service.createOrder(orderData)
    
    expect(mockRepository.save).toHaveBeenCalledWith(expect.any(Order))
    expect(result.id).toBeDefined()
  })
})
```

#### **3. Flexible Persistence**

```typescript
// Easy to swap implementations
export class InMemoryUserRepository implements UserRepository {
  private users: Map<string, User> = new Map()
  
  async findById(id: string): Promise<User | null> {
    return this.users.get(id) || null
  }
  
  async save(user: User): Promise<User> {
    this.users.set(user.id, user)
    return user
  }
  
  // Useful for testing, caching, etc.
}

export class RedisUserRepository implements UserRepository {
  constructor(private redis: RedisClient) {}
  
  async findById(id: string): Promise<User | null> {
    const data = await this.redis.get(`user:${id}`)
    return data ? this.deserialize(data) : null
  }
  
  // Different persistence strategy, same interface
}

// Service remains unchanged
const userService = new UserService(
  process.env.NODE_ENV === 'test' 
    ? new InMemoryUserRepository()
    : new DatabaseUserRepository(database)
)
```

### Data Mapper Challenges

#### **1. Higher Complexity**

```typescript
// More classes and interfaces to manage
interface UserRepository { /* ... */ }
interface PostRepository { /* ... */ }
interface CommentRepository { /* ... */ }

class DatabaseUserRepository implements UserRepository { /* ... */ }
class DatabasePostRepository implements PostRepository { /* ... */ }
class DatabaseCommentRepository implements CommentRepository { /* ... */ }

class UserService { /* ... */ }
class PostService { /* ... */ }
class CommentService { /* ... */ }

// vs Active Record's single class per model
```

#### **2. More Boilerplate**

```typescript
// Mapping between domain objects and database rows
private mapRowToUser(row: any): User {
  return new User(
    row.id,
    row.email,
    row.first_name,  // Field mapping
    row.last_name,   // Field mapping
    new Date(row.created_at), // Type conversion
    new Date(row.updated_at)  // Type conversion
  )
}

private mapUserToRow(user: User): any {
  return {
    id: user.id,
    email: user.email,
    first_name: user.firstName,  // Reverse mapping
    last_name: user.lastName,    // Reverse mapping
    created_at: user.createdAt,  // Type conversion
    updated_at: user.updatedAt   // Type conversion
  }
}

// Active Record handles this automatically
```

#### **3. Relationship Complexity**

```typescript
// Complex relationship loading
export class OrderRepository {
  async findWithItems(orderId: string): Promise<Order | null> {
    // Multiple queries needed
    const orderRow = await this.db.query(
      'SELECT * FROM orders WHERE id = ?', 
      [orderId]
    )
    
    if (!orderRow.length) return null
    
    const itemRows = await this.db.query(
      'SELECT * FROM order_items WHERE order_id = ?',
      [orderId]
    )
    
    const customerRow = await this.db.query(
      'SELECT * FROM customers WHERE id = ?',
      [orderRow[0].customer_id]
    )
    
    // Manual assembly required
    const order = this.mapRowToOrder(orderRow[0])
    order.items = itemRows.map(row => this.mapRowToOrderItem(row))
    order.customer = this.mapRowToCustomer(customerRow[0])
    
    return order
  }
}
```

---

## 🔄 Prisma's Hybrid Approach

Prisma combines the best aspects of both patterns, providing **Active Record-like simplicity with Data Mapper-like separation**.

### Prisma Implementation

```prisma
// Clean schema definition (Data Mapper-like separation)
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String   @map("first_name")
  lastName  String   @map("last_name")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  posts     Post[]
  profile   Profile?
  
  @@map("users")
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String   @map("author_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  author    User     @relation(fields: [authorId], references: [id])
  
  @@map("posts")
}
```

```typescript
// Generated client provides Active Record-like API
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Simple operations (Active Record style)
const user = await prisma.user.create({
  data: {
    email: 'john@example.com',
    firstName: 'John',
    lastName: 'Doe'
  }
})

await prisma.user.update({
  where: { id: user.id },
  data: { firstName: 'Jonathan' }
})

// Complex queries with relationships
const userWithPosts = await prisma.user.findUnique({
  where: { id: user.id },
  include: {
    posts: {
      where: { published: true },
      orderBy: { createdAt: 'desc' }
    },
    profile: true
  }
})

// Transaction support (Data Mapper style control)
await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({
    data: { email: 'jane@example.com', firstName: 'Jane', lastName: 'Smith' }
  })
  
  await tx.post.create({
    data: {
      title: 'Welcome Post',
      content: 'Hello from Jane!',
      authorId: user.id,
      published: true
    }
  })
})
```

### Domain Layer with Prisma

```typescript
// Pure domain models (Data Mapper style)
export class User {
  constructor(
    public readonly id: string,
    public email: string,
    public firstName: string,
    public lastName: string,
    public createdAt: Date,
    public updatedAt: Date
  ) {}
  
  getFullName(): string {
    return `${this.firstName} ${this.lastName}`.trim()
  }
  
  updateName(firstName: string, lastName: string): void {
    this.firstName = firstName
    this.lastName = lastName
  }
}

// Service layer with Prisma
export class UserService {
  constructor(private prisma: PrismaClient) {}
  
  async createUser(data: CreateUserData): Promise<User> {
    // Business validation
    if (!this.isValidEmail(data.email)) {
      throw new Error('Invalid email format')
    }
    
    // Prisma handles persistence (Active Record style simplicity)
    const dbUser = await this.prisma.user.create({
      data: {
        email: data.email,
        firstName: data.firstName,
        lastName: data.lastName
      }
    })
    
    // Convert to domain object
    return this.toDomain(dbUser)
  }
  
  async updateUserName(
    userId: string, 
    firstName: string, 
    lastName: string
  ): Promise<User> {
    // Get current user
    const dbUser = await this.prisma.user.findUnique({
      where: { id: userId }
    })
    
    if (!dbUser) {
      throw new Error('User not found')
    }
    
    // Apply business logic through domain object
    const user = this.toDomain(dbUser)
    user.updateName(firstName, lastName)
    
    // Persist changes
    const updated = await this.prisma.user.update({
      where: { id: userId },
      data: {
        firstName: user.firstName,
        lastName: user.lastName
      }
    })
    
    return this.toDomain(updated)
  }
  
  private toDomain(dbUser: any): User {
    return new User(
      dbUser.id,
      dbUser.email,
      dbUser.firstName,
      dbUser.lastName,
      dbUser.createdAt,
      dbUser.updatedAt
    )
  }
  
  private isValidEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
  }
}
```

### Benefits of Prisma's Approach

```typescript
// 1. Type safety (Data Mapper benefit)
const user = await prisma.user.findUnique({ 
  where: { id: 'invalid-id' } // TypeScript catches type errors
})

// 2. Simple API (Active Record benefit)
await prisma.user.create({
  data: {
    email: 'test@example.com',
    firstName: 'Test',
    lastName: 'User',
    posts: {
      create: [
        { title: 'First Post', content: 'Hello world!' }
      ]
    }
  }
})

// 3. Flexible querying (Best of both)
const result = await prisma.user.findMany({
  where: {
    posts: {
      some: {
        published: true,
        createdAt: {
          gte: new Date('2023-01-01')
        }
      }
    }
  },
  include: {
    posts: {
      where: { published: true },
      select: { id: true, title: true, createdAt: true }
    },
    _count: {
      select: { posts: true }
    }
  }
})

// 4. Transaction control (Data Mapper style)
await prisma.$transaction([
  prisma.user.create({ data: userData }),
  prisma.post.create({ data: postData }),
  prisma.profile.create({ data: profileData })
])
```

---

## 📊 Pattern Comparison Summary

| Aspect | Active Record | Data Mapper | Prisma Hybrid |
|--------|---------------|-------------|---------------|
| **Simplicity** | ✅ Very High | ❌ Lower | ✅ High |
| **Testability** | ❌ Database Required | ✅ Pure Unit Tests | ✅ Good |
| **Separation of Concerns** | ❌ Coupled | ✅ Clean | ✅ Flexible |
| **Learning Curve** | ✅ Low | ❌ Higher | ✅ Moderate |
| **Performance Control** | ❌ Limited | ✅ Full Control | ✅ Good Control |
| **Type Safety** | ❌ Runtime Errors | ✅ Compile-time | ✅ Excellent |
| **Relationship Handling** | ✅ Automatic | ❌ Manual | ✅ Automatic + Control |
| **Boilerplate Code** | ✅ Minimal | ❌ Significant | ✅ Minimal |

---

## 🧠 Knowledge Check

### Pattern Recognition Quiz

1. **Which pattern is best for rapid prototyping?**
   - [x] A) Active Record
   - [ ] B) Data Mapper
   - [ ] C) Both are equally good
   - [ ] D) Neither, use raw SQL

   **Explanation**: Active Record's simplicity and convention-over-configuration approach makes it ideal for rapid prototyping.

2. **What is the main advantage of Data Mapper pattern?**
   - [ ] A) Simpler to understand
   - [x] B) Better separation of concerns
   - [ ] C) Faster performance
   - [ ] D) Less code to write

   **Explanation**: Data Mapper keeps domain logic separate from persistence, enabling better testability and maintainability.

3. **How does Prisma combine both patterns?**
   - [ ] A) It only uses Active Record
   - [ ] B) It only uses Data Mapper
   - [x] C) Simple API with clean separation capabilities
   - [ ] D) It creates a new pattern entirely

   **Explanation**: Prisma provides Active Record-like simplicity while allowing Data Mapper-style separation when needed.

### Practical Exercise: Pattern Implementation

**Scenario**: Design a simple blog system using both patterns.

**Requirements**:
- Users can create posts
- Posts can have comments
- Users can have profiles

```typescript
// 1. Implement using Active Record pattern
class BlogPost extends ActiveRecord {
  // Your implementation here
}

// 2. Implement using Data Mapper pattern
interface BlogPostRepository {
  // Your interface here
}

class BlogPost {
  // Your domain object here
}

class BlogPostService {
  // Your service layer here
}

// 3. Compare the approaches
// Which would you choose for:
// - A personal blog with 10 users?
// - An enterprise CMS with complex business rules?
// - A high-traffic social platform?
```

---

## 💡 Key Takeaways

- 📚 **Pattern Purpose**: Active Record for simplicity, Data Mapper for complex domains
- 🔄 **Trade-offs**: Simplicity vs. flexibility, rapid development vs. maintainability
- 🏛️ **Separation Matters**: Data Mapper's separation enables better testing and evolution
- ⚡ **Development Speed**: Active Record excels for prototypes and simple applications
- 🎯 **Context-Driven**: Choose patterns based on project complexity and team experience
- 🔧 **Prisma's Innovation**: Combines benefits of both patterns with excellent developer experience
- 📈 **Evolution Path**: Start simple with Active Record-style, refactor to Data Mapper as complexity grows
- 🧪 **Testing Strategy**: Data Mapper enables pure unit tests, Active Record requires integration tests

---

## 🔗 Navigation

**📍 Current Location**: Module 1 → Section 1.3B → Lesson 1.3B.4

**⬅️ Previous**: [1.4.3 Migration Strategies & Schema Evolution](./1.4.3-migration-strategies-schema-evolution.md)
**➡️ Next**: [1.4.5 Type Generation & Code Safety](./1.4.5-type-generation-code-safety.md)

**🏠 Section Home**: [1.3B ORM Concepts](./README.md)
**📚 Module Home**: [Module 1: Foundations](../01-foundations.md)

**🗺️ Quick Links**:
- [Previous: Migration Strategies](./1.3b.3-migration-strategies-schema-evolution.md)
- [Next: Type Safety](./1.3b.5-type-generation-code-safety.md)
- [Jump to: Development Environment](../1.4-development-environment/)

---

*Understanding ORM patterns helps you choose the right architecture for your applications. Ready to explore type generation and code safety? Let's complete the ORM concepts section!*
