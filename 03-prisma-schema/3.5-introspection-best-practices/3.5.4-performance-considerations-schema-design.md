# 3.5.4 Performance Considerations in Schema Design

## Learning Objectives
By the end of this lesson, you will be able to:
- Design high-performance schemas optimized for specific workload patterns
- Implement strategic indexing for maximum query performance
- Balance normalization and denormalization for optimal performance
- Optimize database relationships for efficient joins and queries
- Design schema patterns that scale with growing data volumes
- Handle large-scale data operations efficiently
- Monitor and optimize schema performance over time

## Introduction

Think of performance optimization as **engineering a Formula 1 race car for your data** - every component must be precisely tuned for maximum speed while maintaining reliability. Like how aerodynamics, engine tuning, and weight distribution affect lap times, your schema design choices directly impact query performance, scalability, and user experience.

Understanding performance implications during schema design prevents bottlenecks before they occur and ensures your application can handle growth gracefully.

## Indexing Strategy and Optimization

### Strategic Index Design
Building the right indexes for your query patterns:

```prisma
// Performance-optimized e-commerce schema with strategic indexing
model Customer {
  id            String   @id @default(cuid())
  email         String   @unique
  firstName     String   @map("first_name")
  lastName      String   @map("last_name")
  
  // Customer segmentation for marketing
  segment       String   @default("standard") // standard, premium, enterprise
  status        String   @default("active")   // active, inactive, suspended
  
  // Location for geo-queries
  country       String
  region        String?
  city          String?
  
  // Customer lifetime value (denormalized for performance)
  totalOrders   Int      @default(0) @map("total_orders")
  totalSpent    Decimal  @default(0) @db.Decimal(12, 2) @map("total_spent")
  lastOrderAt   DateTime? @map("last_order_at")
  
  orders        Order[]
  
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  // Strategic indexes for common query patterns
  @@index([email])                           // Login queries
  @@index([segment, totalSpent])             // Customer segmentation analysis
  @@index([country, region])                 // Geographic analysis
  @@index([status, lastOrderAt])             // Customer activity analysis
  @@index([createdAt])                       // Customer acquisition reports
  @@index([totalSpent, createdAt])           // Revenue analysis
  
  // Composite index for complex filtering
  @@index([status, segment, country])        // Multi-dimensional filtering
  
  @@map("customers")
}

model Product {
  id            String      @id @default(cuid())
  sku           String      @unique
  name          String
  description   String?     @db.Text
  
  // Product categorization
  categoryId    String      @map("category_id")
  category      Category    @relation(fields: [categoryId], references: [id])
  
  // Pricing and inventory
  price         Decimal     @db.Decimal(10, 2)
  costPrice     Decimal     @db.Decimal(10, 2) @map("cost_price")
  stockLevel    Int         @default(0) @map("stock_level")
  reorderLevel  Int         @default(10) @map("reorder_level")
  
  // Product attributes for filtering
  brand         String?
  color         String?
  size          String?
  weight        Decimal?    @db.Decimal(8, 3)
  
  // Product performance metrics (denormalized)
  viewCount     Int         @default(0) @map("view_count")
  orderCount    Int         @default(0) @map("order_count")
  revenue       Decimal     @default(0) @db.Decimal(12, 2)
  
  // Status and visibility
  status        String      @default("active") // active, inactive, discontinued
  isVisible     Boolean     @default(true) @map("is_visible")
  isFeatured    Boolean     @default(false) @map("is_featured")
  
  orderItems    OrderItem[]
  
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  
  // Performance-optimized indexes
  @@index([sku])                             // Product lookup
  @@index([categoryId, status])              // Category browsing
  @@index([status, isVisible])               // Visible products
  @@index([brand, categoryId])               // Brand filtering
  @@index([price, categoryId])               // Price-based sorting
  @@index([stockLevel]) where stockLevel <= reorderLevel  // Low stock alerts
  @@index([isFeatured, orderCount])          // Featured products by popularity
  @@index([createdAt]) where status = "active"            // New products
  
  // Full-text search index
  @@fulltext([name, description])            // Product search
  
  // Composite indexes for complex queries
  @@index([categoryId, price, stockLevel])   // Category + price + availability
  @@index([brand, color, size])              // Product variant filtering
  
  @@map("products")
}

model Order {
  id            String      @id @default(cuid())
  orderNumber   String      @unique @map("order_number")
  
  customerId    String      @map("customer_id")
  customer      Customer    @relation(fields: [customerId], references: [id])
  
  // Order details
  status        String      @default("pending") // pending, processing, shipped, delivered, cancelled
  subtotal      Decimal     @db.Decimal(10, 2)
  taxAmount     Decimal     @db.Decimal(10, 2) @map("tax_amount")
  shippingCost  Decimal     @db.Decimal(10, 2) @map("shipping_cost")
  total         Decimal     @db.Decimal(10, 2)
  
  // Shipping information
  shippingMethod String?    @map("shipping_method")
  trackingNumber String?    @map("tracking_number")
  
  // Important dates for reporting
  orderDate     DateTime    @default(now()) @map("order_date")
  shippedDate   DateTime?   @map("shipped_date")
  deliveredDate DateTime?   @map("delivered_date")
  
  // Denormalized customer data for performance
  customerEmail String      @map("customer_email")
  customerSegment String    @map("customer_segment")
  
  items         OrderItem[]
  
  @@index([customerId, orderDate])           // Customer order history
  @@index([status, orderDate])               // Order processing queues
  @@index([orderDate])                       // Daily sales reports
  @@index([customerSegment, total])          // Segment revenue analysis
  @@index([shippedDate]) where status = "shipped"     // Shipping reports
  @@index([trackingNumber]) where trackingNumber != null  // Package tracking
  
  // Time-based partitioning hint (for very large datasets)
  @@index([orderDate, status])               // Partition by date + status
  
  @@map("orders")
}
```

### Advanced Indexing Techniques
Specialized indexing for complex scenarios:

```prisma
// Time-series data optimization
model WebsiteAnalytics {
  id            String   @id @default(cuid())
  
  // Time-series dimensions
  timestamp     DateTime @map("timestamp")
  date          DateTime @map("date") @db.Date  // Separate date field for partitioning
  hour          Int      // Hour of day (0-23)
  
  // Website metrics
  pageUrl       String   @map("page_url")
  sessionId     String   @map("session_id")
  userId        String?  @map("user_id")
  
  // Performance metrics
  pageLoadTime  Int      @map("page_load_time") // milliseconds
  bounceRate    Boolean  @map("bounce_rate")
  
  // Geographic data
  country       String
  region        String?
  city          String?
  
  // Device information
  deviceType    String   @map("device_type") // mobile, desktop, tablet
  browser       String
  os            String
  
  // Metrics
  visitors      Int      @default(1)
  pageViews     Int      @default(1)
  sessions      Int      @default(1)
  
  // Time-series optimized indexes
  @@index([date, hour])                      // Time-based queries
  @@index([pageUrl, date])                   // Page performance over time
  @@index([userId, timestamp])               // User activity timeline
  @@index([sessionId, timestamp])            // Session analysis
  @@index([country, date])                   // Geographic reports
  @@index([deviceType, date])                // Device usage trends
  
  // Performance monitoring indexes
  @@index([pageLoadTime]) where pageLoadTime > 3000  // Slow page detection
  @@index([bounceRate, date]) where bounceRate = true // Bounce rate analysis
  
  @@map("website_analytics")
}

// Search optimization with materialized views concept
model ProductSearchIndex {
  id            String   @id @default(cuid())
  productId     String   @unique @map("product_id")
  
  // Searchable content (concatenated and normalized)
  searchContent String   @map("search_content") @db.Text
  
  // Search metadata
  category      String
  brand         String?
  tags          String[] // Array of search tags
  
  // Search ranking factors
  popularity    Int      @default(0)
  rating        Decimal  @default(0) @db.Decimal(3, 2)
  priceRange    String   @map("price_range") // low, medium, high
  
  // Search performance optimization
  isActive      Boolean  @default(true) @map("is_active")
  lastUpdated   DateTime @default(now()) @map("last_updated")
  
  @@fulltext([searchContent])                // Full-text search
  @@index([category, popularity])            // Category + popularity sorting
  @@index([brand, rating])                   // Brand + rating filtering
  @@index([priceRange, category])            // Price range browsing
  @@index([tags]) where isActive = true     // Tag-based search
  
  @@map("product_search_index")
}
```

## Query Optimization Patterns

### Efficient Join Strategies
Optimize relationships for better join performance:

```prisma
// Optimized relationship design for complex queries
model Blog {
  id            String      @id @default(cuid())
  title         String
  slug          String      @unique
  
  // Author relationship optimized for queries
  authorId      String      @map("author_id")
  author        User        @relation(fields: [authorId], references: [id])
  
  // Denormalized author data for list views (avoid joins)
  authorName    String      @map("author_name")
  authorAvatar  String?     @map("author_avatar")
  
  // Category relationship
  categoryId    String      @map("category_id")
  category      BlogCategory @relation(fields: [categoryId], references: [id])
  
  // Denormalized category data
  categoryName  String      @map("category_name")
  categorySlug  String      @map("category_slug")
  
  // Content and metadata
  excerpt       String
  content       String      @db.LongText
  featuredImage String?     @map("featured_image")
  
  // SEO fields
  metaTitle     String?     @map("meta_title")
  metaDescription String?   @map("meta_description")
  
  // Blog metrics (denormalized for performance)
  viewCount     Int         @default(0) @map("view_count")
  commentCount  Int         @default(0) @map("comment_count")
  likeCount     Int         @default(0) @map("like_count")
  shareCount    Int         @default(0) @map("share_count")
  
  // Publishing information
  status        String      @default("draft") // draft, published, archived
  publishedAt   DateTime?   @map("published_at")
  
  // Relationships
  comments      BlogComment[]
  tags          BlogPostTag[]
  
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  
  // Optimized indexes to avoid expensive joins
  @@index([status, publishedAt])             // Published posts chronologically
  @@index([authorId, status])                // Author's posts by status
  @@index([categoryId, publishedAt])         // Category posts by date
  @@index([viewCount]) where status = "published"  // Popular posts
  @@index([authorName, categoryName])        // Denormalized filtering (no joins)
  @@index([slug])                            // URL routing
  
  @@map("blogs")
}

model BlogCategory {
  id            String   @id @default(cuid())
  name          String   @unique
  slug          String   @unique
  description   String?
  
  // Hierarchy support
  parentId      String?  @map("parent_id")
  parent        BlogCategory? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children      BlogCategory[] @relation("CategoryHierarchy")
  
  // Denormalized counts for performance
  postCount     Int      @default(0) @map("post_count")
  
  blogs         Blog[]
  
  @@index([parentId])
  @@map("blog_categories")
}

// Many-to-many optimization with denormalized data
model BlogPostTag {
  id            String   @id @default(cuid())
  
  blogId        String   @map("blog_id")
  blog          Blog     @relation(fields: [blogId], references: [id], onDelete: Cascade)
  
  tagId         String   @map("tag_id")
  tag           BlogTag  @relation(fields: [tagId], references: [id])
  
  // Denormalized tag data to avoid joins in tag queries
  tagName       String   @map("tag_name")
  tagSlug       String   @map("tag_slug")
  
  @@unique([blogId, tagId])
  @@index([blogId])
  @@index([tagId])
  @@index([tagName])                         // Tag-based queries without joins
  @@map("blog_post_tags")
}

model BlogTag {
  id            String        @id @default(cuid())
  name          String        @unique
  slug          String        @unique
  description   String?
  
  // Tag usage statistics
  postCount     Int           @default(0) @map("post_count")
  
  blogPosts     BlogPostTag[]
  
  @@map("blog_tags")
}
```

### Pagination and Large Dataset Handling
Efficient patterns for handling large result sets:

```prisma
// Cursor-based pagination optimization
model TimelineEvent {
  id            String   @id @default(cuid())
  
  // Cursor field for efficient pagination
  sequence      BigInt   @default(autoincrement()) @db.BigInt
  
  // Event data
  eventType     String   @map("event_type")
  userId        String   @map("user_id")
  entityType    String   @map("entity_type")
  entityId      String   @map("entity_id")
  
  // Event payload
  data          Json     @db.JsonB
  metadata      Json     @default("{}") @db.JsonB
  
  // Temporal information
  occurredAt    DateTime @default(now()) @map("occurred_at")
  
  // Aggregation helpers
  dateKey       String   @map("date_key") // YYYY-MM-DD for daily aggregations
  hourKey       String   @map("hour_key") // YYYY-MM-DD-HH for hourly aggregations
  
  // Pagination and filtering indexes
  @@index([sequence])                        // Cursor-based pagination
  @@index([userId, sequence])                // User timeline
  @@index([eventType, sequence])             // Event type filtering
  @@index([occurredAt, sequence])            // Time-based pagination
  @@index([dateKey, eventType])              // Daily aggregations
  @@index([userId, occurredAt])              // User activity by time
  
  @@map("timeline_events")
}

// Efficient aggregation tables
model DailyMetrics {
  id            String   @id @default(cuid())
  
  // Time dimension
  date          DateTime @unique @db.Date
  dateKey       String   @unique @map("date_key") // YYYY-MM-DD
  
  // Metric dimensions
  entityType    String   @map("entity_type")
  entityId      String?  @map("entity_id")
  
  // Aggregated metrics
  totalEvents   Int      @default(0) @map("total_events")
  uniqueUsers   Int      @default(0) @map("unique_users")
  totalRevenue  Decimal  @default(0) @db.Decimal(12, 2) @map("total_revenue")
  
  // Custom metrics by type
  metrics       Json     @default("{}") @db.JsonB
  
  // Calculation metadata
  calculatedAt  DateTime @default(now()) @map("calculated_at")
  
  @@index([date, entityType])
  @@index([entityType, entityId])
  @@index([dateKey])
  @@map("daily_metrics")
}
```

## Memory and Storage Optimization

### Efficient Data Types and Storage
Choose optimal data types for performance:

```prisma
// Storage-optimized schema design
model OptimizedUser {
  id            String   @id @default(cuid())
  
  // Optimized string fields with appropriate lengths
  email         String   @unique @db.VarChar(255)
  username      String   @unique @db.VarChar(50)
  firstName     String   @db.VarChar(100)
  lastName      String   @db.VarChar(100)
  
  // Use smaller integer types where appropriate
  age           Int      @db.SmallInt  // -32,768 to 32,767
  status        Int      @db.TinyInt   // 0 to 255 (could be enum)
  
  // Optimized boolean storage
  isActive      Boolean  @default(true)
  isVerified    Boolean  @default(false)
  isPremium     Boolean  @default(false)
  
  // Efficient decimal storage
  balance       Decimal  @default(0) @db.Decimal(10, 2)  // Appropriate precision
  
  // Optimized timestamps
  createdAt     DateTime @default(now()) @db.Timestamp(0)  // Second precision
  updatedAt     DateTime @updatedAt @db.Timestamp(0)
  lastLoginAt   DateTime? @db.Timestamp(0) @map("last_login_at")
  
  // JSON for flexible data (when needed)
  preferences   Json?    @db.JsonB  // Use JsonB for PostgreSQL
  metadata      Json?    @db.JsonB
  
  @@map("optimized_users")
}

// Partitioned table design for large datasets
model LargeDataTable {
  id            String   @id @default(cuid())
  
  // Partition key (usually time-based)
  createdYear   Int      @map("created_year")
  createdMonth  Int      @map("created_month")
  createdAt     DateTime @default(now()) @map("created_at")
  
  // Data fields optimized for storage
  eventType     String   @db.VarChar(50)
  data          Json     @db.JsonB
  
  // Composite primary key including partition key
  @@index([createdYear, createdMonth, id])
  @@index([createdYear, createdMonth, eventType])
  @@index([createdAt])
  
  @@map("large_data_table")
}
```

### Caching Strategy Integration
Schema design that supports efficient caching:

```prisma
// Cache-friendly schema design
model CacheOptimizedProduct {
  id            String   @id @default(cuid())
  sku           String   @unique
  
  // Frequently accessed fields grouped together
  name          String
  price         Decimal  @db.Decimal(10, 2)
  inStock       Boolean  @default(true) @map("in_stock")
  
  // Cache invalidation helper
  cacheVersion  Int      @default(1) @map("cache_version")
  lastModified  DateTime @updatedAt @map("last_modified")
  
  // Denormalized data for cache efficiency
  categoryName  String   @map("category_name")
  brandName     String   @map("brand_name")
  
  // Less frequently accessed data
  description   String?  @db.Text
  specifications Json?   @db.JsonB
  
  @@index([sku, cacheVersion])  // Cache key + version
  @@index([lastModified])       // Cache invalidation
  @@map("cache_optimized_products")
}

// Session store optimization
model UserSession {
  id            String   @id @default(cuid())
  sessionToken  String   @unique @map("session_token") @db.VarChar(255)
  
  userId        String   @map("user_id")
  
  // Session data optimized for quick access
  userData      Json     @db.JsonB @map("user_data")  // Frequently accessed user info
  preferences   Json     @db.JsonB @default("{}")     // User preferences
  
  // Session management
  expiresAt     DateTime @map("expires_at")
  createdAt     DateTime @default(now()) @map("created_at")
  lastAccessAt  DateTime @default(now()) @map("last_access_at")
  
  @@index([sessionToken])
  @@index([userId])
  @@index([expiresAt])  // Cleanup expired sessions
  @@map("user_sessions")
}
```

## Real-Time Performance Monitoring

### Performance Monitoring Schema
Built-in performance tracking:

```prisma
// Query performance monitoring
model QueryPerformanceLog {
  id            String   @id @default(cuid())
  
  // Query identification
  queryType     String   @map("query_type")     // SELECT, INSERT, UPDATE, DELETE
  tableName     String   @map("table_name")
  queryHash     String   @map("query_hash")     // Hash of normalized query
  
  // Performance metrics
  executionTime Int      @map("execution_time") // milliseconds
  rowsAffected  Int      @map("rows_affected")
  indexesUsed   String[] @map("indexes_used")
  
  // Context information
  userId        String?  @map("user_id")
  endpoint      String?  // API endpoint that triggered query
  
  // System state
  cpuUsage      Float?   @map("cpu_usage")
  memoryUsage   BigInt?  @map("memory_usage")
  
  timestamp     DateTime @default(now())
  
  @@index([queryType, timestamp])
  @@index([tableName, executionTime])
  @@index([queryHash, timestamp])
  @@index([executionTime]) where executionTime > 1000  // Slow queries
  @@map("query_performance_log")
}

// Database health monitoring
model DatabaseHealthMetrics {
  id                String   @id @default(cuid())
  
  // Time dimension
  timestamp         DateTime @default(now())
  
  // Connection metrics
  activeConnections Int      @map("active_connections")
  maxConnections    Int      @map("max_connections")
  connectionUtilization Float @map("connection_utilization")
  
  // Performance metrics
  avgQueryTime      Float    @map("avg_query_time")
  slowQueryCount    Int      @map("slow_query_count")
  deadlockCount     Int      @map("deadlock_count")
  
  // Resource utilization
  cpuUsage          Float    @map("cpu_usage")
  memoryUsage       Float    @map("memory_usage")
  diskUsage         Float    @map("disk_usage")
  
  // Table-specific metrics
  largestTableSize  BigInt   @map("largest_table_size")
  fragmentationLevel Float   @map("fragmentation_level")
  
  @@index([timestamp])
  @@map("database_health_metrics")
}
```

### Automated Performance Optimization
Schema patterns for self-optimizing systems:

```prisma
// Index usage tracking
model IndexUsageStats {
  id            String   @id @default(cuid())
  
  // Index identification
  tableName     String   @map("table_name")
  indexName     String   @map("index_name")
  indexType     String   @map("index_type")
  
  // Usage statistics
  totalScans    BigInt   @default(0) @map("total_scans")
  totalSeeks    BigInt   @default(0) @map("total_seeks")
  totalLookups  BigInt   @default(0) @map("total_lookups")
  
  // Performance impact
  avgScanTime   Float    @map("avg_scan_time")
  avgSeekTime   Float    @map("avg_seek_time")
  
  // Maintenance statistics
  lastUsed      DateTime? @map("last_used")
  lastRebuilt   DateTime? @map("last_rebuilt")
  
  // Efficiency metrics
  selectivity   Float    @map("selectivity")    // How selective the index is
  utilization   Float    @map("utilization")    // How often it's used
  
  collectedAt   DateTime @default(now()) @map("collected_at")
  
  @@unique([tableName, indexName])
  @@index([utilization]) where utilization < 0.1  // Unused indexes
  @@index([lastUsed]) where lastUsed < dateadd(day, -30, getdate())  // Old indexes
  @@map("index_usage_stats")
}

// Query optimization suggestions
model QueryOptimizationSuggestion {
  id                String   @id @default(cuid())
  
  // Query identification
  queryHash         String   @map("query_hash")
  tableName         String   @map("table_name")
  queryType         String   @map("query_type")
  
  // Current performance
  avgExecutionTime  Float    @map("avg_execution_time")
  executionCount    Int      @map("execution_count")
  
  // Optimization suggestion
  suggestionType    String   @map("suggestion_type")  // INDEX, DENORMALIZE, PARTITION
  suggestion        String   @map("suggestion")       // Detailed suggestion
  estimatedImprovement Float @map("estimated_improvement")  // Expected % improvement
  
  // Implementation details
  implementationSQL String?  @map("implementation_sql")
  estimatedCost     String?  @map("estimated_cost")    // HIGH, MEDIUM, LOW
  
  // Suggestion metadata
  priority          Int      @default(5) @map("priority")  // 1-10
  status            String   @default("pending")           // pending, implemented, rejected
  
  createdAt         DateTime @default(now()) @map("created_at")
  implementedAt     DateTime? @map("implemented_at")
  
  @@index([priority, status])
  @@index([suggestionType, priority])
  @@map("query_optimization_suggestions")
}
```

## High-Scale Performance Patterns

### Distributed Database Patterns
Schema design for distributed systems:

```prisma
// Distributed system optimization
model DistributedEntity {
  id            String   @id @default(cuid())
  
  // Shard routing key
  shardKey      String   @map("shard_key")
  tenantId      String   @map("tenant_id")
  
  // Entity data
  name          String
  data          Json     @db.JsonB
  
  // Distributed system metadata
  nodeId        String   @map("node_id")        // Which node owns this data
  replicationFactor Int   @default(3) @map("replication_factor")
  consistencyLevel String @default("eventual") @map("consistency_level")
  
  // Version vector for conflict resolution
  version       BigInt   @default(1)
  vectorClock   Json     @db.JsonB @map("vector_clock")
  
  // Timestamps with timezone awareness
  createdAt     DateTime @default(now()) @db.Timestamptz
  updatedAt     DateTime @updatedAt @db.Timestamptz
  
  @@index([shardKey, tenantId])
  @@index([nodeId, shardKey])
  @@index([version])
  @@map("distributed_entities")
}

// Event sourcing for high-scale writes
model EventSourcingStream {
  id            String   @id @default(cuid())
  
  // Stream identification
  streamId      String   @map("stream_id")
  streamType    String   @map("stream_type")
  
  // Event data
  eventType     String   @map("event_type")
  eventData     Json     @db.JsonB @map("event_data")
  metadata      Json     @db.JsonB @default("{}")
  
  // Ordering and consistency
  sequenceNumber BigInt  @map("sequence_number")
  globalSequence BigInt  @default(autoincrement()) @map("global_sequence")
  
  // Partitioning hint
  partitionKey  String   @map("partition_key")
  
  // Event timestamp
  eventTime     DateTime @default(now()) @db.Timestamptz @map("event_time")
  
  @@unique([streamId, sequenceNumber])
  @@index([streamId, sequenceNumber])
  @@index([globalSequence])
  @@index([partitionKey, eventTime])
  @@index([streamType, eventTime])
  @@map("event_sourcing_stream")
}
```

## Exercise: Performance Optimization Challenge

Optimize a schema for a high-traffic social media platform:

```prisma
// Your task: Optimize this social media schema for high performance

// Requirements:
// - 10M+ users
// - 100M+ posts
// - 1B+ interactions (likes, comments, shares)
// - Real-time feeds
// - Global search
// - Analytics and reporting

// Current problematic schema:
model User {
  id       String @id @default(cuid())
  username String @unique
  email    String @unique
  bio      String?
  
  posts    Post[]
  likes    Like[]
  comments Comment[]
  follows  Follow[]
}

model Post {
  id        String @id @default(cuid())
  content   String
  authorId  String
  author    User   @relation(fields: [authorId], references: [id])
  
  likes     Like[]
  comments  Comment[]
  
  createdAt DateTime @default(now())
}

// Optimize for:
// 1. Fast user timeline generation
// 2. Efficient like/comment counting
// 3. Search performance
// 4. Real-time notifications
// 5. Analytics queries
// 6. Global trending content
```

## Key Takeaways

1. **Index Strategy**: Design indexes based on actual query patterns, not assumptions
2. **Denormalization**: Strategically denormalize for read-heavy workloads
3. **Data Types**: Choose appropriate data types and precision for storage efficiency
4. **Partitioning**: Use time-based and logical partitioning for large datasets
5. **Caching Integration**: Design schemas that work well with caching layers
6. **Monitoring**: Build performance monitoring into your schema from the start
7. **Scalability Planning**: Design for future scale, not just current requirements

## Next Steps

In the final lesson, we'll explore **Migration Strategy Planning** and learn how to safely evolve your schema while maintaining performance and data integrity.

---

**Estimated Time:** 25 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of database performance concepts, indexing strategies, and high-scale system design
