# 3.5.2 Schema Validation & Error Handling

## Learning Objectives
By the end of this lesson, you will be able to:
- Validate Prisma schemas for syntax and logical errors
- Implement comprehensive error handling strategies for schema issues
- Use Prisma's built-in validation tools effectively
- Create custom validation workflows for complex schema requirements
- Debug common schema configuration problems
- Set up automated schema validation in development workflows
- Handle schema validation in production environments

## Introduction

Think of schema validation as **quality assurance for your database blueprint** - like having a building inspector verify your architectural plans before construction begins. Schema validation ensures your Prisma schema is syntactically correct, logically sound, and production-ready before you deploy or generate your database.

Proper validation prevents runtime errors, catches configuration mistakes early, and ensures your schema follows best practices for performance and maintainability.

## Basic Schema Validation

### Built-in Prisma Validation Commands
Essential commands for validating your Prisma schema:

```bash
# 1. Format and validate schema syntax
npx prisma format

# 2. Validate schema without generating client
npx prisma validate

# 3. Generate client (includes validation)
npx prisma generate

# 4. Validate and push schema to database
npx prisma db push

# 5. Create and validate migration
npx prisma migrate dev
```

### Understanding Validation Output
Interpreting Prisma's validation messages:

```prisma
// schema.prisma with validation errors
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(cuid())
  email    String  @unique
  name     String
  
  // ‚ùå Error: Missing relation field
  posts    Post[]
}

model Post {
  id       String  @id @default(cuid())
  title    String
  content  String?
  
  // ‚ùå Error: authorId field exists but no relation defined
  authorId String
  
  @@map("posts")
}
```

Running `npx prisma validate` would produce:
```bash
Error validating: 
‚Üí Field "authorId" in model "Post" is a scalar field but is missing the relation directive.
  You must either define a relation field or add the @relation directive to this field.

‚Üí Field "posts" in model "User" is of type Post[] but no corresponding relation field exists on model "Post".
  Every relation must have exactly two relation fields.
```

### Fixed Schema with Proper Validation
Correcting validation errors:

```prisma
// Corrected schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(cuid())
  email    String  @unique
  name     String
  
  // ‚úÖ Proper relation field
  posts    Post[]  @relation("UserPosts")
  
  createdAt DateTime @default(now())
  
  @@map("users")
}

model Post {
  id       String  @id @default(cuid())
  title    String
  content  String?
  
  // ‚úÖ Proper foreign key with relation
  authorId String  @map("author_id")
  author   User    @relation("UserPosts", fields: [authorId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([authorId])
  @@map("posts")
}
```

## Advanced Schema Validation Patterns

### Custom Validation Workflows
Implement comprehensive validation beyond basic syntax checking:

```javascript
// scripts/validate-schema.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class SchemaValidator {
  constructor(schemaPath = './schema.prisma') {
    this.schemaPath = schemaPath;
    this.errors = [];
    this.warnings = [];
  }

  async validateSchema() {
    console.log('üîç Starting comprehensive schema validation...');
    
    try {
      // 1. Basic Prisma validation
      await this.validatePrismaSchema();
      
      // 2. Custom business rule validation
      await this.validateBusinessRules();
      
      // 3. Performance validation
      await this.validatePerformance();
      
      // 4. Security validation
      await this.validateSecurity();
      
      // 5. Generate validation report
      this.generateReport();
      
    } catch (error) {
      this.errors.push(`Validation failed: ${error.message}`);
      this.generateReport();
      process.exit(1);
    }
  }

  async validatePrismaSchema() {
    console.log('üìã Validating Prisma schema syntax...');
    
    try {
      execSync('npx prisma validate', { stdio: 'pipe' });
      console.log('‚úÖ Prisma schema syntax is valid');
    } catch (error) {
      this.errors.push(`Prisma validation failed: ${error.stdout || error.message}`);
    }
  }

  async validateBusinessRules() {
    console.log('üè¢ Validating business rules...');
    
    const schema = fs.readFileSync(this.schemaPath, 'utf8');
    
    // Check for required models
    const requiredModels = ['User', 'Organization', 'AuditLog'];
    requiredModels.forEach(model => {
      if (!schema.includes(`model ${model}`)) {
        this.errors.push(`Required model '${model}' is missing from schema`);
      }
    });
    
    // Check for audit fields
    const auditableModels = this.extractModels(schema);
    auditableModels.forEach(model => {
      if (!this.hasAuditFields(model)) {
        this.warnings.push(`Model '${model.name}' missing audit fields (createdAt, updatedAt)`);
      }
    });
    
    // Check for proper indexing on foreign keys
    this.validateForeignKeyIndexes(schema);
    
    console.log('‚úÖ Business rule validation complete');
  }

  async validatePerformance() {
    console.log('‚ö° Validating performance considerations...');
    
    const schema = fs.readFileSync(this.schemaPath, 'utf8');
    
    // Check for missing indexes on foreign keys
    const foreignKeys = this.extractForeignKeys(schema);
    foreignKeys.forEach(fk => {
      if (!this.hasIndex(schema, fk)) {
        this.warnings.push(`Foreign key '${fk}' should have an index for better performance`);
      }
    });
    
    // Check for very large text fields without full-text search
    this.validateTextFields(schema);
    
    console.log('‚úÖ Performance validation complete');
  }

  async validateSecurity() {
    console.log('üîí Validating security considerations...');
    
    const schema = fs.readFileSync(this.schemaPath, 'utf8');
    
    // Check for sensitive data without encryption hints
    const sensitiveFields = ['password', 'ssn', 'credit_card', 'token'];
    sensitiveFields.forEach(field => {
      if (schema.includes(field) && !schema.includes('@encrypted')) {
        this.warnings.push(`Potentially sensitive field '${field}' should consider encryption`);
      }
    });
    
    // Check for missing cascade restrictions on critical relationships
    this.validateCascadeRestrictions(schema);
    
    console.log('‚úÖ Security validation complete');
  }

  extractModels(schema) {
    const modelRegex = /model\s+(\w+)\s*{([^}]*)}/g;
    const models = [];
    let match;
    
    while ((match = modelRegex.exec(schema)) !== null) {
      models.push({
        name: match[1],
        content: match[2]
      });
    }
    
    return models;
  }

  hasAuditFields(model) {
    return model.content.includes('createdAt') && model.content.includes('updatedAt');
  }

  extractForeignKeys(schema) {
    const fkRegex = /(\w+)\s+\w+\s+@relation\(/g;
    const foreignKeys = [];
    let match;
    
    while ((match = fkRegex.exec(schema)) !== null) {
      foreignKeys.push(match[1]);
    }
    
    return foreignKeys;
  }

  hasIndex(schema, fieldName) {
    return schema.includes(`@@index([${fieldName}])`);
  }

  validateTextFields(schema) {
    if (schema.includes('@db.LongText') && !schema.includes('@@fulltext')) {
      this.warnings.push('Large text fields detected without full-text search indexes');
    }
  }

  validateCascadeRestrictions(schema) {
    if (schema.includes('onDelete: Cascade') && 
        !schema.includes('// CASCADE_APPROVED')) {
      this.warnings.push('Cascade delete operations should be explicitly approved with comments');
    }
  }

  generateReport() {
    console.log('\nüìä Validation Report');
    console.log('===================');
    
    if (this.errors.length === 0 && this.warnings.length === 0) {
      console.log('‚úÖ All validations passed!');
      return;
    }
    
    if (this.errors.length > 0) {
      console.log('\n‚ùå Errors:');
      this.errors.forEach((error, index) => {
        console.log(`  ${index + 1}. ${error}`);
      });
    }
    
    if (this.warnings.length > 0) {
      console.log('\n‚ö†Ô∏è  Warnings:');
      this.warnings.forEach((warning, index) => {
        console.log(`  ${index + 1}. ${warning}`);
      });
    }
    
    if (this.errors.length > 0) {
      console.log('\n‚ùå Validation failed due to errors');
      process.exit(1);
    }
  }
}

// Usage
const validator = new SchemaValidator();
validator.validateSchema();
```

### Automated Validation in Development
Integration with development workflows:

```json
// package.json scripts for validation
{
  "scripts": {
    "schema:validate": "npx prisma validate",
    "schema:format": "npx prisma format",
    "schema:check": "node scripts/validate-schema.js",
    "schema:full-check": "npm run schema:format && npm run schema:validate && npm run schema:check",
    "pre-commit": "npm run schema:full-check"
  }
}
```

```yaml
# .github/workflows/schema-validation.yml
name: Schema Validation

on:
  pull_request:
    paths:
      - 'schema.prisma'
      - 'prisma/**'
  push:
    branches: [main, develop]

jobs:
  validate-schema:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Format schema
        run: npx prisma format
      
      - name: Check for formatting changes
        run: |
          if ! git diff --exit-code schema.prisma; then
            echo "Schema formatting issues found. Please run 'npx prisma format'"
            exit 1
          fi
      
      - name: Validate schema syntax
        run: npx prisma validate
      
      - name: Custom validation checks
        run: npm run schema:check
      
      - name: Generate client (validation test)
        run: npx prisma generate
```

## Error Handling Strategies

### Common Validation Errors and Solutions
Handle typical schema validation problems:

```prisma
// Common Error 1: Missing relation fields
model Order {
  id         String @id @default(cuid())
  customerId String @map("customer_id")
  // ‚ùå Missing: customer User @relation(...)
  
  @@map("orders")
}

model Customer {
  id     String @id @default(cuid())
  orders Order[] // ‚ùå This will fail validation
  
  @@map("customers")
}

// Solution: Complete the relationship
model OrderFixed {
  id         String      @id @default(cuid())
  customerId String      @map("customer_id")
  customer   CustomerFixed @relation(fields: [customerId], references: [id])
  
  @@index([customerId])
  @@map("orders")
}

model CustomerFixed {
  id     String       @id @default(cuid())
  orders OrderFixed[]
  
  @@map("customers")
}

// Common Error 2: Duplicate relation names
model User {
  id       String @id @default(cuid())
  posts    Post[] @relation("UserPosts")
  comments Post[] @relation("UserPosts") // ‚ùå Duplicate relation name
}

// Solution: Use unique relation names
model UserFixed {
  id       String      @id @default(cuid())
  posts    PostFixed[] @relation("UserPosts")
  comments PostFixed[] @relation("UserComments")
}

model PostFixed {
  id       String     @id @default(cuid())
  authorId String     @map("author_id")
  author   UserFixed  @relation("UserPosts", fields: [authorId], references: [id])
  
  commenterId String?    @map("commenter_id")
  commenter   UserFixed? @relation("UserComments", fields: [commenterId], references: [id])
  
  @@index([authorId])
  @@index([commenterId])
  @@map("posts")
}

// Common Error 3: Invalid field types
model Product {
  id       String @id @default(cuid())
  price    Money  // ‚ùå Invalid type
  quantity InvalidType // ‚ùå Invalid type
}

// Solution: Use supported types
model ProductFixed {
  id       String  @id @default(cuid())
  price    Decimal @db.Decimal(10, 2)
  quantity Int     @default(0)
  
  @@map("products")
}

// Common Error 4: Incorrect enum usage
enum Status {
  active
  inactive  // ‚ùå Should be UPPERCASE by convention
}

model Item {
  id     String @id @default(cuid())
  status Status @default(active) // ‚ùå Should reference enum value properly
}

// Solution: Proper enum definition and usage
enum StatusFixed {
  ACTIVE
  INACTIVE
}

model ItemFixed {
  id     String      @id @default(cuid())
  status StatusFixed @default(ACTIVE)
  
  @@map("items")
}
```

### Validation Error Recovery
Strategies for handling and recovering from validation errors:

```javascript
// scripts/error-recovery.js
const { execSync } = require('child_process');
const fs = require('fs');

class SchemaErrorRecovery {
  constructor() {
    this.backupPath = './schema.prisma.backup';
  }

  async attemptRecovery() {
    console.log('üö® Schema validation failed. Attempting recovery...');
    
    // 1. Create backup of current schema
    this.createBackup();
    
    // 2. Try common fixes
    await this.applyCommonFixes();
    
    // 3. Validate again
    if (await this.validateSchema()) {
      console.log('‚úÖ Schema recovery successful');
      return true;
    }
    
    // 4. If recovery fails, restore backup
    this.restoreBackup();
    console.log('‚ùå Recovery failed. Schema restored to previous state.');
    return false;
  }

  createBackup() {
    fs.copyFileSync('./schema.prisma', this.backupPath);
    console.log('üì¶ Schema backup created');
  }

  async applyCommonFixes() {
    let schema = fs.readFileSync('./schema.prisma', 'utf8');
    
    // Fix 1: Add missing relation fields
    schema = this.fixMissingRelations(schema);
    
    // Fix 2: Fix enum naming conventions
    schema = this.fixEnumNaming(schema);
    
    // Fix 3: Add missing indexes for foreign keys
    schema = this.addMissingIndexes(schema);
    
    fs.writeFileSync('./schema.prisma', schema);
    console.log('üîß Applied common fixes');
  }

  fixMissingRelations(schema) {
    // This is a simplified example - real implementation would be more complex
    return schema.replace(
      /(\w+)\s+(\w+)\[\]\s*$/gm,
      '$1 $2[] // TODO: Add proper relation'
    );
  }

  fixEnumNaming(schema) {
    return schema.replace(
      /enum\s+(\w+)\s*{([^}]*)}/g,
      (match, enumName, enumBody) => {
        const fixedBody = enumBody.replace(
          /(\w+)/g,
          (m, value) => value.toUpperCase()
        );
        return `enum ${enumName} {${fixedBody}}`;
      }
    );
  }

  addMissingIndexes(schema) {
    // Add indexes for foreign keys that don't have them
    const foreignKeyRegex = /(\w+)\s+(\w+)\s+@relation\([^)]*fields:\s*\[(\w+)\]/g;
    let match;
    
    while ((match = foreignKeyRegex.exec(schema)) !== null) {
      const fieldName = match[3];
      if (!schema.includes(`@@index([${fieldName}])`)) {
        schema = schema.replace(
          new RegExp(`(model\\s+\\w+\\s*{[^}]*)(@@map\\([^)]*\\))`),
          `$1  @@index([${fieldName}])\n  $2`
        );
      }
    }
    
    return schema;
  }

  async validateSchema() {
    try {
      execSync('npx prisma validate', { stdio: 'pipe' });
      return true;
    } catch (error) {
      return false;
    }
  }

  restoreBackup() {
    if (fs.existsSync(this.backupPath)) {
      fs.copyFileSync(this.backupPath, './schema.prisma');
      fs.unlinkSync(this.backupPath);
    }
  }
}
```

## Production Validation Strategies

### Environment-Specific Validation
Different validation approaches for different environments:

```javascript
// scripts/env-validation.js
const { execSync } = require('child_process');

class EnvironmentValidator {
  constructor(environment) {
    this.environment = environment;
    this.validationRules = this.getValidationRules();
  }

  getValidationRules() {
    const rules = {
      development: {
        allowMissingIndexes: true,
        allowCascadeDeletes: true,
        requireAuditFields: false,
        allowUnsupportedTypes: true
      },
      staging: {
        allowMissingIndexes: false,
        allowCascadeDeletes: true,
        requireAuditFields: true,
        allowUnsupportedTypes: false
      },
      production: {
        allowMissingIndexes: false,
        allowCascadeDeletes: false,
        requireAuditFields: true,
        allowUnsupportedTypes: false,
        requireBackupStrategy: true,
        requireMigrationApproval: true
      }
    };
    
    return rules[this.environment] || rules.development;
  }

  async validate() {
    console.log(`üîç Validating schema for ${this.environment} environment...`);
    
    // 1. Basic Prisma validation
    await this.basicValidation();
    
    // 2. Environment-specific validation
    await this.environmentValidation();
    
    // 3. Security validation for production
    if (this.environment === 'production') {
      await this.productionSecurityValidation();
    }
    
    console.log('‚úÖ Environment validation complete');
  }

  async basicValidation() {
    try {
      execSync('npx prisma validate', { stdio: 'pipe' });
    } catch (error) {
      throw new Error(`Basic validation failed: ${error.stdout}`);
    }
  }

  async environmentValidation() {
    const schema = require('fs').readFileSync('./schema.prisma', 'utf8');
    
    if (!this.validationRules.allowMissingIndexes) {
      this.validateIndexes(schema);
    }
    
    if (!this.validationRules.allowCascadeDeletes) {
      this.validateCascadeOperations(schema);
    }
    
    if (this.validationRules.requireAuditFields) {
      this.validateAuditFields(schema);
    }
  }

  validateIndexes(schema) {
    const foreignKeys = this.extractForeignKeys(schema);
    const missingIndexes = foreignKeys.filter(fk => 
      !schema.includes(`@@index([${fk}])`)
    );
    
    if (missingIndexes.length > 0) {
      throw new Error(`Missing indexes for foreign keys: ${missingIndexes.join(', ')}`);
    }
  }

  validateCascadeOperations(schema) {
    if (schema.includes('onDelete: Cascade')) {
      throw new Error('Cascade delete operations not allowed in production');
    }
  }

  validateAuditFields(schema) {
    const models = this.extractModels(schema);
    const modelsWithoutAudit = models.filter(model => 
      !model.content.includes('createdAt') || !model.content.includes('updatedAt')
    );
    
    if (modelsWithoutAudit.length > 0) {
      throw new Error(`Models missing audit fields: ${modelsWithoutAudit.map(m => m.name).join(', ')}`);
    }
  }

  async productionSecurityValidation() {
    console.log('üîí Running production security validation...');
    
    // Check for development-only configurations
    const schema = require('fs').readFileSync('./schema.prisma', 'utf8');
    
    if (schema.includes('localhost') || schema.includes('127.0.0.1')) {
      throw new Error('Development database URLs detected in production schema');
    }
    
    // Validate backup strategy exists
    if (this.validationRules.requireBackupStrategy && 
        !require('fs').existsSync('./backup-strategy.md')) {
      throw new Error('Production deployment requires documented backup strategy');
    }
  }

  extractForeignKeys(schema) {
    const fkRegex = /(\w+)\s+\w+\s+@relation\([^)]*fields:\s*\[(\w+)\]/g;
    const foreignKeys = [];
    let match;
    
    while ((match = fkRegex.exec(schema)) !== null) {
      foreignKeys.push(match[2]);
    }
    
    return foreignKeys;
  }

  extractModels(schema) {
    const modelRegex = /model\s+(\w+)\s*{([^}]*)}/g;
    const models = [];
    let match;
    
    while ((match = modelRegex.exec(schema)) !== null) {
      models.push({
        name: match[1],
        content: match[2]
      });
    }
    
    return models;
  }
}

// Usage
const environment = process.env.NODE_ENV || 'development';
const validator = new EnvironmentValidator(environment);
validator.validate().catch(error => {
  console.error('‚ùå Validation failed:', error.message);
  process.exit(1);
});
```

### Migration Validation
Validate schema changes during migrations:

```javascript
// scripts/migration-validation.js
const { execSync } = require('child_process');
const fs = require('fs');

class MigrationValidator {
  async validateMigration(migrationName) {
    console.log(`üîç Validating migration: ${migrationName}`);
    
    try {
      // 1. Validate migration syntax
      await this.validateMigrationSyntax(migrationName);
      
      // 2. Check for destructive operations
      await this.checkDestructiveOperations(migrationName);
      
      // 3. Validate rollback plan
      await this.validateRollbackPlan(migrationName);
      
      // 4. Performance impact assessment
      await this.assessPerformanceImpact(migrationName);
      
      console.log('‚úÖ Migration validation passed');
      
    } catch (error) {
      console.error('‚ùå Migration validation failed:', error.message);
      throw error;
    }
  }

  async validateMigrationSyntax(migrationName) {
    const migrationPath = `./prisma/migrations/${migrationName}/migration.sql`;
    
    if (!fs.existsSync(migrationPath)) {
      throw new Error(`Migration file not found: ${migrationPath}`);
    }
    
    const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
    
    // Basic SQL syntax validation
    const dangerousPatterns = [
      /DROP\s+DATABASE/i,
      /TRUNCATE\s+TABLE/i,
      /DELETE\s+FROM\s+\w+\s*;/i  // DELETE without WHERE clause
    ];
    
    for (const pattern of dangerousPatterns) {
      if (pattern.test(migrationSQL)) {
        throw new Error(`Dangerous operation detected in migration: ${pattern.source}`);
      }
    }
  }

  async checkDestructiveOperations(migrationName) {
    const migrationPath = `./prisma/migrations/${migrationName}/migration.sql`;
    const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
    
    const destructiveOperations = [
      { pattern: /DROP\s+COLUMN/i, message: 'Column deletion detected' },
      { pattern: /DROP\s+TABLE/i, message: 'Table deletion detected' },
      { pattern: /ALTER\s+COLUMN.*DROP\s+NOT\s+NULL/i, message: 'NOT NULL constraint removal' }
    ];
    
    const foundOperations = destructiveOperations.filter(op => 
      op.pattern.test(migrationSQL)
    );
    
    if (foundOperations.length > 0) {
      const messages = foundOperations.map(op => op.message).join(', ');
      console.warn(`‚ö†Ô∏è  Destructive operations found: ${messages}`);
      
      // In production, might require manual approval
      if (process.env.NODE_ENV === 'production') {
        throw new Error('Destructive operations require manual approval in production');
      }
    }
  }

  async validateRollbackPlan(migrationName) {
    const rollbackPath = `./prisma/migrations/${migrationName}/rollback.sql`;
    
    if (!fs.existsSync(rollbackPath)) {
      console.warn('‚ö†Ô∏è  No rollback plan found. Consider creating one for complex migrations.');
      return;
    }
    
    console.log('‚úÖ Rollback plan exists');
  }

  async assessPerformanceImpact(migrationName) {
    const migrationPath = `./prisma/migrations/${migrationName}/migration.sql`;
    const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
    
    // Check for potentially slow operations
    const slowOperations = [
      { pattern: /CREATE\s+INDEX/i, message: 'Index creation may be slow on large tables' },
      { pattern: /ALTER\s+TABLE.*ADD\s+COLUMN.*NOT\s+NULL/i, message: 'Adding NOT NULL column requires table scan' },
      { pattern: /UPDATE\s+.*WHERE/i, message: 'Large UPDATE operations may lock tables' }
    ];
    
    const foundOperations = slowOperations.filter(op => 
      op.pattern.test(migrationSQL)
    );
    
    if (foundOperations.length > 0) {
      console.warn('‚ö†Ô∏è  Performance impact warnings:');
      foundOperations.forEach(op => {
        console.warn(`   - ${op.message}`);
      });
    }
  }
}

// Usage in migration workflow
async function validateAndRunMigration() {
  const validator = new MigrationValidator();
  
  try {
    // Create migration
    console.log('üìù Creating migration...');
    const output = execSync('npx prisma migrate dev --create-only', { 
      encoding: 'utf8' 
    });
    
    // Extract migration name from output
    const migrationMatch = output.match(/Created migration (\d+_\w+)/);
    if (!migrationMatch) {
      throw new Error('Could not extract migration name from output');
    }
    
    const migrationName = migrationMatch[1];
    
    // Validate migration
    await validator.validateMigration(migrationName);
    
    // Apply migration if validation passes
    console.log('‚úÖ Applying validated migration...');
    execSync('npx prisma migrate dev', { stdio: 'inherit' });
    
  } catch (error) {
    console.error('‚ùå Migration process failed:', error.message);
    process.exit(1);
  }
}
```

## Real-Time Validation Tools

### VS Code Extension Integration
Set up real-time validation in your development environment:

```json
// .vscode/settings.json
{
  "prisma.showPrismaDataPlatformNotification": false,
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll": true
  },
  "files.associations": {
    "*.prisma": "prisma"
  },
  "prisma.fileWatcher": true
}
```

### Git Hooks for Validation
Ensure validation runs before commits:

```bash
#!/bin/sh
# .git/hooks/pre-commit
# Prisma schema validation pre-commit hook

echo "üîç Running Prisma schema validation..."

# Format schema
npx prisma format

# Check if formatting changed anything
if ! git diff --exit-code schema.prisma; then
  echo "Schema was formatted. Please review changes and commit again."
  exit 1
fi

# Validate schema
if ! npx prisma validate; then
  echo "‚ùå Schema validation failed. Please fix errors before committing."
  exit 1
fi

# Run custom validation
if ! npm run schema:check; then
  echo "‚ùå Custom validation failed. Please fix issues before committing."
  exit 1
fi

echo "‚úÖ Schema validation passed"
exit 0
```

## Exercise: Build a Comprehensive Validation System

Create a complete validation system for a multi-environment project:

```javascript
// Your task: Build a validation system with the following features:

// 1. Multi-environment validation rules
// 2. Custom business rule validation
// 3. Performance impact assessment
// 4. Security validation
// 5. Migration validation
// 6. Automated reporting

class ComprehensiveValidator {
  constructor(config) {
    this.config = config;
    // Implement your validation system here
  }

  // Implement methods for:
  // - Schema syntax validation
  // - Business rule validation
  // - Performance validation
  // - Security validation
  // - Environment-specific validation
  // - Migration validation
  // - Report generation
}

// Consider:
// - Different validation rules for dev/staging/production
// - Integration with CI/CD pipelines
// - Rollback strategies for failed validations
// - Performance monitoring and alerting
// - Security compliance checking
```

## Key Takeaways

1. **Early Validation**: Validate schemas early and often to catch issues before deployment
2. **Multi-Layer Validation**: Combine Prisma's built-in validation with custom business rule validation
3. **Environment-Specific Rules**: Apply different validation rules for different environments
4. **Automated Integration**: Integrate validation into CI/CD pipelines and development workflows
5. **Error Recovery**: Implement strategies for recovering from validation failures
6. **Performance Awareness**: Validate for performance implications, especially in production
7. **Security Validation**: Include security considerations in schema validation processes

## Next Steps

In the next lesson, we'll explore **Design Pattern Selection Guidelines** and learn how to choose the right schema patterns for different use cases and requirements.

---

**Estimated Time:** 22 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of schema design, validation concepts, and development workflows
