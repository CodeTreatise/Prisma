# 3.5.3 Design Pattern Selection Guidelines

## Learning Objectives
By the end of this lesson, you will be able to:
- Evaluate and select appropriate schema design patterns for different use cases
- Understand the trade-offs between different data modeling approaches
- Apply decision frameworks for pattern selection based on business requirements
- Design scalable schema patterns for various application types
- Balance normalization vs denormalization strategies effectively
- Choose optimal relationship patterns for different scenarios
- Implement design patterns that support future growth and changes

## Introduction

Think of design pattern selection as **choosing the right architectural blueprint for your data mansion** - like an architect deciding between different structural approaches based on the building's purpose, expected load, and future expansion plans. Each pattern has strengths and weaknesses, and the key is matching the right pattern to your specific requirements.

Understanding when and why to use different patterns is crucial for building maintainable, performant, and scalable applications that can evolve with your business needs.

## Pattern Selection Framework

### Decision Matrix for Pattern Selection
A systematic approach to evaluating design patterns:

```javascript
// Pattern evaluation framework
class PatternSelector {
  constructor(requirements) {
    this.requirements = requirements;
    this.patterns = this.getAvailablePatterns();
  }

  evaluatePatterns() {
    const criteria = {
      // Performance requirements
      readPerformance: this.requirements.readVolume || 'medium',
      writePerformance: this.requirements.writeVolume || 'medium',
      queryComplexity: this.requirements.queryComplexity || 'medium',
      
      // Scalability requirements
      dataVolume: this.requirements.expectedDataSize || 'medium',
      concurrency: this.requirements.concurrentUsers || 'medium',
      growth: this.requirements.growthExpectation || 'medium',
      
      // Consistency requirements
      consistencyLevel: this.requirements.consistencyNeeds || 'strict',
      transactionNeeds: this.requirements.transactionComplexity || 'simple',
      
      // Development requirements
      teamSize: this.requirements.teamSize || 'small',
      complexity: this.requirements.acceptableComplexity || 'medium',
      maintenance: this.requirements.maintenanceCapacity || 'medium'
    };
    
    return this.patterns.map(pattern => ({
      name: pattern.name,
      score: this.calculateScore(pattern, criteria),
      pros: pattern.pros,
      cons: pattern.cons,
      useCase: pattern.bestFor
    })).sort((a, b) => b.score - a.score);
  }

  getAvailablePatterns() {
    return [
      {
        name: 'Normalized Relational',
        readPerformance: 2,
        writePerformance: 4,
        consistencyLevel: 5,
        complexity: 3,
        pros: ['Strong consistency', 'No data duplication', 'Easy updates'],
        cons: ['Complex joins', 'Slower reads', 'Rigid structure'],
        bestFor: 'Transactional systems with strong consistency needs'
      },
      {
        name: 'Denormalized Performance',
        readPerformance: 5,
        writePerformance: 2,
        consistencyLevel: 3,
        complexity: 4,
        pros: ['Fast reads', 'Simple queries', 'Read scalability'],
        cons: ['Data duplication', 'Update complexity', 'Consistency challenges'],
        bestFor: 'Read-heavy applications with performance requirements'
      },
      {
        name: 'Event Sourcing',
        readPerformance: 3,
        writePerformance: 4,
        consistencyLevel: 4,
        complexity: 5,
        pros: ['Complete audit trail', 'Time travel', 'Scalable writes'],
        cons: ['Complex implementation', 'Storage overhead', 'Query complexity'],
        bestFor: 'Audit-heavy systems requiring complete history'
      },
      {
        name: 'CQRS Pattern',
        readPerformance: 5,
        writePerformance: 4,
        consistencyLevel: 3,
        complexity: 5,
        pros: ['Optimized reads/writes', 'Independent scaling', 'Flexible queries'],
        cons: ['Eventual consistency', 'Complex architecture', 'Data synchronization'],
        bestFor: 'High-scale systems with different read/write patterns'
      }
    ];
  }

  calculateScore(pattern, criteria) {
    // Weighted scoring based on requirements
    const weights = {
      readPerformance: criteria.readPerformance === 'high' ? 3 : 1,
      writePerformance: criteria.writePerformance === 'high' ? 3 : 1,
      consistencyLevel: criteria.consistencyLevel === 'strict' ? 3 : 1,
      complexity: criteria.acceptableComplexity === 'low' ? 3 : 1
    };
    
    return Object.entries(weights).reduce((score, [key, weight]) => {
      return score + (pattern[key] || 3) * weight;
    }, 0);
  }
}

// Usage example
const requirements = {
  readVolume: 'high',
  writeVolume: 'medium',
  consistencyNeeds: 'eventual',
  expectedDataSize: 'large',
  queryComplexity: 'complex'
};

const selector = new PatternSelector(requirements);
const recommendations = selector.evaluatePatterns();
console.log('Recommended patterns:', recommendations);
```

## Application-Specific Pattern Selection

### E-commerce Platform Patterns
Design patterns for different e-commerce scenarios:

```prisma
// Pattern 1: Traditional Normalized E-commerce (Strong Consistency)
// Best for: Small to medium businesses with complex inventory management

model Customer {
  id            String   @id @default(cuid())
  email         String   @unique
  firstName     String
  lastName      String
  
  // Normalized address relationship
  addresses     Address[]
  orders        Order[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("customers")
}

model Address {
  id            String   @id @default(cuid())
  street        String
  city          String
  state         String
  postalCode    String
  country       String
  
  customerId    String
  customer      Customer @relation(fields: [customerId], references: [id])
  
  // Orders using this address
  ordersShipping Order[] @relation("ShippingAddress")
  ordersBilling  Order[] @relation("BillingAddress")
  
  @@index([customerId])
  @@map("addresses")
}

model Product {
  id            String      @id @default(cuid())
  sku           String      @unique
  name          String
  description   String?
  price         Decimal     @db.Decimal(10, 2)
  
  // Normalized category relationship
  categoryId    String
  category      Category    @relation(fields: [categoryId], references: [id])
  
  // Inventory tracking
  inventory     Inventory[]
  orderItems    OrderItem[]
  
  @@index([categoryId])
  @@map("products")
}

model Order {
  id                String   @id @default(cuid())
  orderNumber       String   @unique
  status            String   @default("pending")
  
  customerId        String
  customer          Customer @relation(fields: [customerId], references: [id])
  
  shippingAddressId String
  shippingAddress   Address  @relation("ShippingAddress", fields: [shippingAddressId], references: [id])
  
  billingAddressId  String
  billingAddress    Address  @relation("BillingAddress", fields: [billingAddressId], references: [id])
  
  items             OrderItem[]
  
  total             Decimal  @db.Decimal(10, 2)
  createdAt         DateTime @default(now())
  
  @@index([customerId])
  @@map("orders")
}

// Pattern 2: Denormalized Performance E-commerce (Fast Reads)
// Best for: High-traffic sites with heavy read workloads

model PerformanceOrder {
  id                String   @id @default(cuid())
  orderNumber       String   @unique
  status            String   @default("pending")
  
  // Denormalized customer data for fast order lookups
  customerId        String   @map("customer_id")
  customerEmail     String   @map("customer_email")
  customerName      String   @map("customer_name")
  
  // Denormalized address data
  shippingStreet    String   @map("shipping_street")
  shippingCity      String   @map("shipping_city")
  shippingState     String   @map("shipping_state")
  shippingPostal    String   @map("shipping_postal")
  
  billingStreet     String   @map("billing_street")
  billingCity       String   @map("billing_city")
  billingState      String   @map("billing_state")
  billingPostal     String   @map("billing_postal")
  
  // Order summary data
  itemCount         Int      @default(0) @map("item_count")
  totalAmount       Decimal  @db.Decimal(10, 2) @map("total_amount")
  
  createdAt         DateTime @default(now()) @map("created_at")
  
  @@index([customerId])
  @@index([customerEmail])
  @@index([status, createdAt])
  @@map("performance_orders")
}

model PerformanceOrderItem {
  id              String  @id @default(cuid())
  
  orderId         String  @map("order_id")
  
  // Denormalized product data for fast access
  productId       String  @map("product_id")
  productSku      String  @map("product_sku")
  productName     String  @map("product_name")
  productPrice    Decimal @db.Decimal(10, 2) @map("product_price")
  
  quantity        Int
  totalPrice      Decimal @db.Decimal(10, 2) @map("total_price")
  
  @@index([orderId])
  @@index([productId])
  @@map("performance_order_items")
}
```

### Content Management System Patterns
Different approaches for CMS requirements:

```prisma
// Pattern 1: Hierarchical Content (Tree Structure)
// Best for: Traditional websites with clear page hierarchies

model Page {
  id            String   @id @default(cuid())
  title         String
  slug          String   @unique
  content       String   @db.Text
  
  // Hierarchical structure
  parentId      String?  @map("parent_id")
  parent        Page?    @relation("PageHierarchy", fields: [parentId], references: [id])
  children      Page[]   @relation("PageHierarchy")
  
  // SEO and metadata
  metaTitle     String?  @map("meta_title")
  metaDescription String? @map("meta_description")
  
  // Content management
  status        String   @default("draft") // draft, published, archived
  publishedAt   DateTime? @map("published_at")
  
  // Hierarchy optimization
  level         Int      @default(0)
  path          String   @default("/")
  
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  @@index([parentId])
  @@index([status, publishedAt])
  @@index([path])
  @@map("pages")
}

// Pattern 2: Flexible Content Blocks (Component-Based)
// Best for: Modern headless CMS with reusable components

model ContentBlock {
  id            String   @id @default(cuid())
  type          String   // text, image, video, gallery, form
  name          String
  
  // Flexible content storage
  content       Json     @db.JsonB
  settings      Json     @default("{}") @db.JsonB
  
  // Reusability
  isReusable    Boolean  @default(false) @map("is_reusable")
  category      String?  // For organizing reusable blocks
  
  // Usage tracking
  usageCount    Int      @default(0) @map("usage_count")
  
  // Block relationships
  pageBlocks    PageBlock[]
  
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  @@index([type])
  @@index([isReusable, category])
  @@map("content_blocks")
}

model FlexiblePage {
  id            String     @id @default(cuid())
  title         String
  slug          String     @unique
  
  // SEO and metadata
  metaTitle     String?    @map("meta_title")
  metaDescription String?  @map("meta_description")
  
  // Page configuration
  template      String     @default("default")
  status        String     @default("draft")
  publishedAt   DateTime?  @map("published_at")
  
  // Block composition
  blocks        PageBlock[]
  
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @updatedAt @map("updated_at")
  
  @@index([status, publishedAt])
  @@index([template])
  @@map("flexible_pages")
}

model PageBlock {
  id            String       @id @default(cuid())
  
  pageId        String       @map("page_id")
  page          FlexiblePage @relation(fields: [pageId], references: [id], onDelete: Cascade)
  
  blockId       String       @map("block_id")
  block         ContentBlock @relation(fields: [blockId], references: [id])
  
  // Positioning and layout
  sortOrder     Int          @default(0) @map("sort_order")
  zone          String       @default("main") // main, sidebar, header, footer
  
  // Block-specific overrides
  overrides     Json         @default("{}") @db.JsonB
  
  @@index([pageId, sortOrder])
  @@index([blockId])
  @@map("page_blocks")
}
```

### SaaS Application Patterns
Multi-tenant and subscription-based patterns:

```prisma
// Pattern 1: Shared Database, Shared Schema (Row-Level Security)
// Best for: Small to medium SaaS with similar tenant requirements

model Tenant {
  id            String   @id @default(cuid())
  slug          String   @unique
  name          String
  
  // Subscription management
  plan          String   @default("trial")
  status        String   @default("active")
  trialEndsAt   DateTime? @map("trial_ends_at")
  
  // Tenant data
  users         TenantUser[]
  projects      TenantProject[]
  
  createdAt     DateTime @default(now()) @map("created_at")
  
  @@map("tenants")
}

model TenantUser {
  id            String   @id @default(cuid())
  email         String
  name          String
  role          String   @default("member")
  
  // Tenant scoping
  tenantId      String   @map("tenant_id")
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // Tenant-scoped unique email
  @@unique([tenantId, email])
  @@index([tenantId])
  @@map("tenant_users")
}

model TenantProject {
  id            String     @id @default(cuid())
  name          String
  description   String?
  
  // Tenant scoping
  tenantId      String     @map("tenant_id")
  tenant        Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // Project owner
  ownerId       String     @map("owner_id")
  
  createdAt     DateTime   @default(now()) @map("created_at")
  
  @@index([tenantId])
  @@map("tenant_projects")
}

// Pattern 2: Database-per-Tenant (Complete Isolation)
// Best for: Enterprise SaaS with strict isolation requirements

model TenantRegistry {
  id              String   @id @default(cuid())
  slug            String   @unique
  name            String
  
  // Database connection info
  databaseUrl     String   @map("database_url")
  schemaName      String   @map("schema_name")
  
  // Tenant metadata
  plan            String   @default("enterprise")
  status          String   @default("active")
  region          String   @default("us-east-1")
  
  // Provisioning info
  provisionedAt   DateTime @default(now()) @map("provisioned_at")
  lastAccessAt    DateTime @default(now()) @map("last_access_at")
  
  @@map("tenant_registry")
}

// Individual tenant schemas would be separate databases
// with their own complete schema definitions
```

## Performance vs Consistency Trade-offs

### High-Performance Patterns
When to choose performance over strict consistency:

```prisma
// Eventual Consistency Pattern for High Performance
// Use case: Social media feeds, activity streams

model User {
  id              String   @id @default(cuid())
  username        String   @unique
  email           String   @unique
  displayName     String   @map("display_name")
  
  // Denormalized follower counts for fast access
  followerCount   Int      @default(0) @map("follower_count")
  followingCount  Int      @default(0) @map("following_count")
  postCount       Int      @default(0) @map("post_count")
  
  // Relationships
  posts           Post[]
  following       Follow[] @relation("UserFollowing")
  followers       Follow[] @relation("UserFollowers")
  
  // Activity feed cache
  feedCache       FeedCache[]
  
  @@map("users")
}

model Post {
  id              String   @id @default(cuid())
  content         String
  
  authorId        String   @map("author_id")
  author          User     @relation(fields: [authorId], references: [id])
  
  // Denormalized author data for fast timeline generation
  authorUsername  String   @map("author_username")
  authorDisplayName String @map("author_display_name")
  
  // Engagement metrics (updated asynchronously)
  likeCount       Int      @default(0) @map("like_count")
  shareCount      Int      @default(0) @map("share_count")
  commentCount    Int      @default(0) @map("comment_count")
  
  createdAt       DateTime @default(now()) @map("created_at")
  
  @@index([authorId, createdAt])
  @@index([createdAt]) // Global timeline
  @@map("posts")
}

model Follow {
  id              String   @id @default(cuid())
  
  followerId      String   @map("follower_id")
  follower        User     @relation("UserFollowing", fields: [followerId], references: [id])
  
  followingId     String   @map("following_id")
  following       User     @relation("UserFollowers", fields: [followingId], references: [id])
  
  createdAt       DateTime @default(now()) @map("created_at")
  
  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// Pre-computed feed cache for performance
model FeedCache {
  id              String   @id @default(cuid())
  
  userId          String   @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  postId          String   @map("post_id")
  
  // Denormalized post data
  postContent     String   @map("post_content")
  postAuthor      String   @map("post_author")
  postCreatedAt   DateTime @map("post_created_at")
  
  // Cache metadata
  addedAt         DateTime @default(now()) @map("added_at")
  
  @@unique([userId, postId])
  @@index([userId, addedAt])
  @@map("feed_cache")
}
```

### Strong Consistency Patterns
When data integrity is paramount:

```prisma
// Financial/Banking Pattern with Strong Consistency
// Use case: Payment processing, accounting systems

model Account {
  id              String      @id @default(cuid())
  accountNumber   String      @unique @map("account_number")
  accountType     String      @map("account_type") // checking, savings, credit
  
  customerId      String      @map("customer_id")
  customer        Customer    @relation(fields: [customerId], references: [id])
  
  // Balance tracking with strong consistency
  balance         Decimal     @db.Decimal(15, 2) @default(0.00)
  availableBalance Decimal    @db.Decimal(15, 2) @default(0.00) @map("available_balance")
  
  // Account status
  status          String      @default("active") // active, frozen, closed
  
  // Audit trail
  transactions    Transaction[]
  
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt @map("updated_at")
  
  @@index([customerId])
  @@index([accountNumber])
  @@map("accounts")
}

model Transaction {
  id              String    @id @default(cuid())
  transactionId   String    @unique @map("transaction_id") // External reference
  
  // Double-entry bookkeeping
  fromAccountId   String?   @map("from_account_id")
  fromAccount     Account?  @relation("FromAccount", fields: [fromAccountId], references: [id])
  
  toAccountId     String?   @map("to_account_id")
  toAccount       Account?  @relation("ToAccount", fields: [toAccountId], references: [id])
  
  // Transaction details
  amount          Decimal   @db.Decimal(15, 2)
  description     String
  type            String    // debit, credit, transfer
  category        String?   // payment, deposit, withdrawal, etc.
  
  // Transaction state
  status          String    @default("pending") // pending, completed, failed, reversed
  
  // Balances at time of transaction (for reconciliation)
  fromBalanceBefore Decimal? @db.Decimal(15, 2) @map("from_balance_before")
  fromBalanceAfter  Decimal? @db.Decimal(15, 2) @map("from_balance_after")
  toBalanceBefore   Decimal? @db.Decimal(15, 2) @map("to_balance_before")
  toBalanceAfter    Decimal? @db.Decimal(15, 2) @map("to_balance_after")
  
  // Audit information
  processedAt     DateTime? @map("processed_at")
  processedBy     String?   @map("processed_by")
  
  createdAt       DateTime  @default(now()) @map("created_at")
  
  @@index([fromAccountId, createdAt])
  @@index([toAccountId, createdAt])
  @@index([transactionId])
  @@index([status, createdAt])
  @@map("transactions")
}

// Separate relation definitions for double-entry bookkeeping
model Account {
  // ... previous fields ...
  
  outgoingTransactions Transaction[] @relation("FromAccount")
  incomingTransactions Transaction[] @relation("ToAccount")
}
```

## Scalability Pattern Guidelines

### Horizontal Scaling Patterns
Design for distributed systems:

```prisma
// Sharded Data Pattern
// Use case: Large-scale applications requiring data distribution

model ShardedUser {
  id              String   @id @default(cuid())
  
  // Shard key for distribution
  shardKey        String   @map("shard_key") // Hash of user ID or region
  
  email           String   @unique
  username        String   @unique
  
  // User data
  profileData     Json     @db.JsonB @map("profile_data")
  preferences     Json     @db.JsonB @default("{}") 
  
  // Shard-local relationships only
  posts           ShardedPost[]
  
  createdAt       DateTime @default(now()) @map("created_at")
  
  @@index([shardKey])
  @@index([shardKey, createdAt])
  @@map("sharded_users")
}

model ShardedPost {
  id              String      @id @default(cuid())
  
  // Same shard key as user for co-location
  shardKey        String      @map("shard_key")
  
  authorId        String      @map("author_id")
  author          ShardedUser @relation(fields: [authorId], references: [id])
  
  content         String
  metadata        Json        @db.JsonB @default("{}")
  
  createdAt       DateTime    @default(now()) @map("created_at")
  
  @@index([shardKey, authorId])
  @@index([shardKey, createdAt])
  @@map("sharded_posts")
}

// Cross-shard reference table (for global lookups)
model UserDirectory {
  id              String   @id @default(cuid())
  userId          String   @unique @map("user_id")
  shardKey        String   @map("shard_key")
  username        String   @unique
  email           String   @unique
  
  @@index([shardKey])
  @@map("user_directory")
}
```

### Event-Driven Architecture Pattern
For microservices and eventual consistency:

```prisma
// Event Store Pattern
// Use case: Microservices with event sourcing

model EventStore {
  id              String   @id @default(cuid())
  eventId         String   @unique @map("event_id")
  
  // Event metadata
  eventType       String   @map("event_type")
  aggregateType   String   @map("aggregate_type")
  aggregateId     String   @map("aggregate_id")
  
  // Event data
  eventData       Json     @db.JsonB @map("event_data")
  metadata        Json     @db.JsonB @default("{}")
  
  // Event ordering
  version         Int      // Aggregate version
  globalSequence  BigInt   @default(autoincrement()) @map("global_sequence")
  
  // Event processing
  processed       Boolean  @default(false)
  processedAt     DateTime? @map("processed_at")
  
  createdAt       DateTime @default(now()) @map("created_at")
  
  @@index([aggregateType, aggregateId, version])
  @@index([eventType, createdAt])
  @@index([processed, createdAt])
  @@index([globalSequence])
  @@map("event_store")
}

// Read model for queries (CQRS pattern)
model UserReadModel {
  id              String   @id @default(cuid())
  userId          String   @unique @map("user_id")
  
  // Projected data from events
  email           String   @unique
  displayName     String   @map("display_name")
  status          String   @default("active")
  
  // Derived statistics
  totalPosts      Int      @default(0) @map("total_posts")
  totalFollowers  Int      @default(0) @map("total_followers")
  totalFollowing  Int      @default(0) @map("total_following")
  
  // Projection metadata
  lastEventVersion Int     @map("last_event_version")
  projectedAt     DateTime @default(now()) @map("projected_at")
  
  @@index([status])
  @@map("user_read_model")
}
```

## Pattern Selection Decision Tree

### Interactive Decision Framework
A practical guide for choosing patterns:

```javascript
// Decision tree for pattern selection
class PatternDecisionTree {
  static decide(requirements) {
    const decisions = [];
    
    // 1. Consistency Requirements
    if (requirements.needsStrictConsistency) {
      decisions.push("Use normalized schema with transactions");
      if (requirements.financialData) {
        return "Strong Consistency Pattern (Banking/Financial)";
      }
    } else {
      decisions.push("Consider denormalized patterns for performance");
    }
    
    // 2. Scale Requirements
    if (requirements.expectedUsers > 1000000) {
      decisions.push("Consider sharding or microservices patterns");
      if (requirements.globalDistribution) {
        return "Sharded Data Pattern with Regional Distribution";
      }
    }
    
    // 3. Read/Write Patterns
    if (requirements.readWriteRatio > 10) {
      decisions.push("Optimize for read performance");
      return "Denormalized Performance Pattern with Read Replicas";
    }
    
    if (requirements.complexQueries) {
      decisions.push("Maintain normalized structure for flexibility");
      return "Normalized Relational Pattern with Query Optimization";
    }
    
    // 4. Team and Maintenance
    if (requirements.teamSize < 5 && requirements.complexity === 'low') {
      return "Simple Normalized Pattern";
    }
    
    // 5. Multi-tenancy
    if (requirements.multiTenant) {
      if (requirements.tenantCount < 100) {
        return "Shared Database, Row-Level Security Pattern";
      } else {
        return "Database-per-Tenant Pattern";
      }
    }
    
    // Default recommendation
    return "Hybrid Pattern with Selective Denormalization";
  }
  
  static getImplementationGuidelines(pattern) {
    const guidelines = {
      "Strong Consistency Pattern": {
        keyPrinciples: [
          "Use transactions for all critical operations",
          "Implement double-entry bookkeeping for financial data",
          "Add comprehensive audit trails",
          "Use strict foreign key constraints"
        ],
        considerations: [
          "Performance may be lower due to consistency checks",
          "Requires careful transaction management",
          "May need specialized database features"
        ]
      },
      
      "Denormalized Performance Pattern": {
        keyPrinciples: [
          "Duplicate data strategically for read performance",
          "Use background jobs for data synchronization",
          "Implement eventual consistency patterns",
          "Cache frequently accessed data"
        ],
        considerations: [
          "Increased storage requirements",
          "Complex update logic",
          "Potential data inconsistency windows"
        ]
      },
      
      "Sharded Data Pattern": {
        keyPrinciples: [
          "Choose shard keys carefully for even distribution",
          "Co-locate related data in same shard",
          "Implement cross-shard query mechanisms",
          "Plan for shard rebalancing"
        ],
        considerations: [
          "Complex application logic",
          "Limited cross-shard transactions",
          "Operational complexity"
        ]
      }
    };
    
    return guidelines[pattern] || guidelines["Hybrid Pattern"];
  }
}

// Usage example
const requirements = {
  needsStrictConsistency: false,
  expectedUsers: 500000,
  readWriteRatio: 15,
  complexQueries: true,
  teamSize: 8,
  multiTenant: true,
  tenantCount: 50
};

const recommendedPattern = PatternDecisionTree.decide(requirements);
const guidelines = PatternDecisionTree.getImplementationGuidelines(recommendedPattern);

console.log("Recommended Pattern:", recommendedPattern);
console.log("Implementation Guidelines:", guidelines);
```

## Exercise: Pattern Selection for Real-World Scenario

Design a comprehensive schema for a project management SaaS:

```prisma
// Your task: Choose and implement the optimal pattern for a project management SaaS

// Requirements:
// - 10,000+ organizations (tenants)
// - Each org has 5-500 users
// - Heavy read workload (reports, dashboards)
// - Real-time collaboration features
// - Audit trails for compliance
// - Global deployment (multi-region)
// - Team size: 15 developers

// Consider these factors:
// 1. Multi-tenancy strategy
// 2. Performance optimization
// 3. Consistency requirements
// 4. Scalability needs
// 5. Maintenance complexity

// Your design should address:
// - Tenant isolation strategy
// - Read/write optimization
// - Real-time data patterns
// - Audit and compliance
// - Cross-region considerations

model ProjectManagementSaaS {
  // Design your schema here based on the requirements
  // Choose between:
  // - Row-level security vs database-per-tenant
  // - Normalized vs denormalized patterns
  // - Event sourcing vs traditional updates
  // - Synchronous vs asynchronous processing
}
```

## Key Takeaways

1. **Requirements First**: Always start with clear requirements before selecting patterns
2. **Trade-off Awareness**: Understand the trade-offs between consistency, performance, and complexity
3. **Scalability Planning**: Consider future growth when selecting patterns
4. **Team Capabilities**: Match pattern complexity to team size and experience
5. **Hybrid Approaches**: Often the best solution combines multiple patterns
6. **Iterative Design**: Be prepared to evolve patterns as requirements change
7. **Performance Testing**: Validate pattern choices with realistic data volumes

## Next Steps

In the next lesson, we'll explore **Performance Considerations in Schema Design** and learn how to optimize schemas for maximum performance while maintaining data integrity.

---

**Estimated Time:** 20 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of database design patterns, scalability concepts, and system architecture
