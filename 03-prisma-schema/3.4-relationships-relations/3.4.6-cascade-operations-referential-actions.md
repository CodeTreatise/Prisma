# 3.4.6 Cascade Operations & Referential Actions

## Learning Objectives
By the end of this lesson, you will be able to:
- Configure cascade delete and update operations effectively
- Implement referential integrity constraints for data consistency
- Design complex cascade scenarios for business workflows
- Handle orphaned data and cleanup strategies
- Implement soft delete patterns with referential actions
- Optimize cascade performance for large datasets
- Troubleshoot and prevent cascade-related issues

## Introduction

Think of cascade operations as **domino effects in your database** - when you push one domino (make a change), others automatically fall in sequence (related data updates). Like organizing a corporate restructure where changing a manager automatically updates all their reports, cascade operations ensure your data relationships remain consistent even during complex changes.

These automated database behaviors are crucial for maintaining data integrity, implementing business rules, and ensuring your application handles data lifecycle events correctly without manual intervention.

## Basic Cascade Operations

### Delete Cascades: Automatic Cleanup
Configure automatic deletion of related records:

```prisma
model Customer {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  isActive  Boolean  @default(true)
  
  // One-to-many: Orders cascade delete when customer is deleted
  orders    Order[]
  
  // One-to-one: Profile cascade deletes with customer
  profile   CustomerProfile?
  
  createdAt DateTime @default(now())
  
  @@map("customers")
}

model Order {
  id          String   @id @default(cuid())
  orderNumber String   @unique
  total       Decimal  @db.Decimal(10, 2)
  status      String   @default("pending")
  
  // CASCADE DELETE: Delete order when customer is deleted
  customerId  String   @map("customer_id")
  customer    Customer @relation(
    fields: [customerId], 
    references: [id],
    onDelete: Cascade    // ← Order deleted when customer deleted
  )
  
  // Cascade to order items
  items       OrderItem[]
  
  createdAt   DateTime @default(now())
  
  @@index([customerId])
  @@map("orders")
}

model OrderItem {
  id         String  @id @default(cuid())
  quantity   Int
  unitPrice  Decimal @db.Decimal(10, 2)
  
  // CASCADE DELETE: Delete items when order is deleted
  orderId    String  @map("order_id")
  order      Order   @relation(
    fields: [orderId], 
    references: [id],
    onDelete: Cascade  // ← Items deleted when order deleted
  )
  
  // RESTRICT: Cannot delete product if used in orders
  productId  String  @map("product_id")
  product    Product @relation(
    fields: [productId], 
    references: [id],
    onDelete: Restrict // ← Prevents product deletion if referenced
  )
  
  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

model Product {
  id          String      @id @default(cuid())
  sku         String      @unique
  name        String
  price       Decimal     @db.Decimal(10, 2)
  isActive    Boolean     @default(true)
  
  orderItems  OrderItem[] // Back-relation
  
  @@map("products")
}

model CustomerProfile {
  id           String   @id @default(cuid())
  bio          String?
  preferences  Json?    @db.JsonB
  
  // CASCADE DELETE: Profile deleted when customer deleted
  customerId   String   @unique @map("customer_id")
  customer     Customer @relation(
    fields: [customerId], 
    references: [id],
    onDelete: Cascade    // ← Profile deleted with customer
  )
  
  @@map("customer_profiles")
}
```

### Update Cascades: Propagating Changes
Handle primary key updates across relationships:

```prisma
model Department {
  id       String @id @default(cuid())
  code     String @unique  // Business key that might change
  name     String
  budget   Decimal @db.Decimal(12, 2)
  
  employees Employee[]
  
  @@map("departments")
}

model Employee {
  id           String @id @default(cuid())
  employeeId   String @unique
  name         String
  email        String @unique
  
  // CASCADE UPDATE: Update department reference if department ID changes
  departmentId String @map("department_id")
  department   Department @relation(
    fields: [departmentId], 
    references: [id],
    onUpdate: Cascade    // ← Update foreign key if department ID changes
  )
  
  // Self-referential with cascade update
  managerId    String? @map("manager_id")
  manager      Employee? @relation("ManagerReports", 
    fields: [managerId], 
    references: [id],
    onUpdate: Cascade  // ← Update manager reference if manager ID changes
  )
  reports      Employee[] @relation("ManagerReports")
  
  @@index([departmentId])
  @@index([managerId])
  @@map("employees")
}
```

## Advanced Cascade Patterns

### Set Null: Graceful Disconnection
Handle optional relationships with automatic cleanup:

```prisma
model Author {
  id       String @id @default(cuid())
  name     String
  email    String @unique
  isActive Boolean @default(true)
  
  // Back-relations
  books    Book[]
  articles Article[]
  
  @@map("authors")
}

model Book {
  id        String   @id @default(cuid())
  title     String
  isbn      String?  @unique
  publishedAt DateTime?
  
  // SET NULL: Keep book but remove author reference when author deleted
  authorId  String?  @map("author_id")
  author    Author?  @relation(
    fields: [authorId], 
    references: [id],
    onDelete: SetNull  // ← Set to NULL when author deleted
  )
  
  // CASCADE: Delete reviews when book deleted
  reviews   BookReview[]
  
  @@index([authorId])
  @@map("books")
}

model Article {
  id          String   @id @default(cuid())
  title       String
  content     String
  publishedAt DateTime?
  
  // SET NULL: Articles can exist without author
  authorId    String?  @map("author_id")
  author      Author?  @relation(
    fields: [authorId], 
    references: [id],
    onDelete: SetNull
  )
  
  // RESTRICT: Don't delete article if it has approved comments
  comments    ArticleComment[]
  
  @@index([authorId])
  @@map("articles")
}

model BookReview {
  id       String @id @default(cuid())
  rating   Int    // 1-5 stars
  comment  String?
  
  // CASCADE DELETE: Delete review when book deleted
  bookId   String @map("book_id")
  book     Book   @relation(
    fields: [bookId], 
    references: [id],
    onDelete: Cascade
  )
  
  reviewedAt DateTime @default(now())
  
  @@index([bookId])
  @@map("book_reviews")
}

model ArticleComment {
  id        String @id @default(cuid())
  content   String
  status    String @default("pending") // pending, approved, rejected
  
  // RESTRICT: Cannot delete article with approved comments
  articleId String @map("article_id")
  article   Article @relation(
    fields: [articleId], 
    references: [id],
    onDelete: Restrict // ← Prevents article deletion if comments exist
  )
  
  createdAt DateTime @default(now())
  
  @@index([articleId, status])
  @@map("article_comments")
}
```

### Set Default: Fallback Values
Assign default relationships when references are deleted:

```prisma
model UserRole {
  id          String @id @default(cuid())
  name        String @unique
  description String?
  isDefault   Boolean @default(false)
  permissions Json    @default("[]") @db.JsonB
  
  users       User[]
  
  @@map("user_roles")
}

model User {
  id       String @id @default(cuid())
  email    String @unique
  name     String
  isActive Boolean @default(true)
  
  // SET DEFAULT: Assign default role when current role is deleted
  roleId   String   @default("default-role-id") @map("role_id")
  role     UserRole @relation(
    fields: [roleId], 
    references: [id],
    onDelete: SetDefault  // ← Set to default role when current role deleted
  )
  
  posts    Post[]
  
  @@index([roleId])
  @@map("users")
}

model Post {
  id       String @id @default(cuid())
  title    String
  content  String
  status   String @default("draft")
  
  // SET NULL: Posts can exist without author (anonymous)
  authorId String? @map("author_id")
  author   User?   @relation(
    fields: [authorId], 
    references: [id],
    onDelete: SetNull
  )
  
  createdAt DateTime @default(now())
  
  @@index([authorId])
  @@map("posts")
}
```

## Complex Cascade Scenarios

### Multi-Level Cascades: Chain Reactions
Handle deep relationship hierarchies with cascading effects:

```prisma
model Organization {
  id          String @id @default(cuid())
  name        String
  slug        String @unique
  
  departments Department[]
  projects    Project[]
  
  @@map("organizations")
}

model Department {
  id             String @id @default(cuid())
  name           String
  code           String
  
  // CASCADE: Delete department when organization deleted
  organizationId String @map("organization_id")
  organization   Organization @relation(
    fields: [organizationId], 
    references: [id],
    onDelete: Cascade
  )
  
  teams          Team[]
  employees      Employee[]
  
  @@unique([organizationId, code])
  @@index([organizationId])
  @@map("departments")
}

model Team {
  id           String @id @default(cuid())
  name         String
  
  // CASCADE: Delete team when department deleted
  departmentId String @map("department_id")
  department   Department @relation(
    fields: [departmentId], 
    references: [id],
    onDelete: Cascade  // ← Org deletion → Dept deletion → Team deletion
  )
  
  members      TeamMember[]
  
  @@index([departmentId])
  @@map("teams")
}

model Employee {
  id           String @id @default(cuid())
  employeeId   String @unique
  name         String
  email        String @unique
  
  // SET NULL: Employee can exist without department assignment
  departmentId String? @map("department_id")
  department   Department? @relation(
    fields: [departmentId], 
    references: [id],
    onDelete: SetNull  // ← Keep employee, remove department link
  )
  
  teamMemberships TeamMember[]
  
  @@index([departmentId])
  @@map("employees")
}

model TeamMember {
  id         String @id @default(cuid())
  role       String @default("member")
  joinedAt   DateTime @default(now())
  
  // CASCADE: Delete membership when team deleted
  teamId     String @map("team_id")
  team       Team @relation(
    fields: [teamId], 
    references: [id],
    onDelete: Cascade  // ← Team deletion cascades to memberships
  )
  
  // SET NULL: Keep membership record but remove employee reference
  employeeId String? @map("employee_id")
  employee   Employee? @relation(
    fields: [employeeId], 
    references: [id],
    onDelete: SetNull  // ← Employee deletion removes reference
  )
  
  @@unique([teamId, employeeId])
  @@index([teamId])
  @@index([employeeId])
  @@map("team_members")
}

model Project {
  id             String @id @default(cuid())
  name           String
  description    String?
  status         String @default("planning")
  
  // RESTRICT: Cannot delete organization with active projects
  organizationId String @map("organization_id")
  organization   Organization @relation(
    fields: [organizationId], 
    references: [id],
    onDelete: Restrict  // ← Prevents org deletion if projects exist
  )
  
  tasks          ProjectTask[]
  
  @@index([organizationId])
  @@map("projects")
}

model ProjectTask {
  id          String @id @default(cuid())
  title       String
  description String?
  status      String @default("todo")
  
  // CASCADE: Delete tasks when project deleted
  projectId   String @map("project_id")
  project     Project @relation(
    fields: [projectId], 
    references: [id],
    onDelete: Cascade
  )
  
  @@index([projectId])
  @@map("project_tasks")
}
```

### Conditional Cascades: Business Rule Implementation
Implement complex business logic through cascade patterns:

```prisma
model Subscription {
  id            String @id @default(cuid())
  planName      String
  status        String @default("active") // active, canceled, expired
  startDate     DateTime @default(now())
  endDate       DateTime?
  
  customerId    String @map("customer_id")
  customer      Customer @relation(
    fields: [customerId], 
    references: [id],
    onDelete: Cascade  // Cancel subscription when customer deleted
  )
  
  // Different cascade behaviors based on subscription status
  invoices      SubscriptionInvoice[]
  usageRecords  UsageRecord[]
  
  @@index([customerId])
  @@map("subscriptions")
}

model SubscriptionInvoice {
  id             String @id @default(cuid())
  amount         Decimal @db.Decimal(10, 2)
  status         String @default("pending") // pending, paid, failed, canceled
  billingPeriod  String
  
  // RESTRICT: Cannot delete subscription with unpaid invoices
  subscriptionId String @map("subscription_id")
  subscription   Subscription @relation(
    fields: [subscriptionId], 
    references: [id],
    onDelete: Restrict  // ← Prevents deletion if unpaid invoices exist
  )
  
  payments       InvoicePayment[]
  
  @@index([subscriptionId])
  @@index([status])
  @@map("subscription_invoices")
}

model InvoicePayment {
  id           String @id @default(cuid())
  amount       Decimal @db.Decimal(10, 2)
  paymentMethod String
  status       String @default("pending")
  
  // CASCADE: Delete payments when invoice deleted
  invoiceId    String @map("invoice_id")
  invoice      SubscriptionInvoice @relation(
    fields: [invoiceId], 
    references: [id],
    onDelete: Cascade
  )
  
  processedAt  DateTime?
  
  @@index([invoiceId])
  @@map("invoice_payments")
}

model UsageRecord {
  id             String @id @default(cuid())
  metricName     String
  value          Decimal @db.Decimal(15, 6)
  unit           String
  recordedAt     DateTime @default(now())
  
  // SET NULL: Keep usage records for analytics even after subscription ends
  subscriptionId String? @map("subscription_id")
  subscription   Subscription? @relation(
    fields: [subscriptionId], 
    references: [id],
    onDelete: SetNull  // ← Preserve usage data for analytics
  )
  
  @@index([subscriptionId, recordedAt])
  @@index([metricName, recordedAt])
  @@map("usage_records")
}
```

## Soft Delete Patterns with Cascades

### Implementing Soft Deletes with Referential Actions
Combine soft deletes with cascade behaviors for flexible data management:

```prisma
model SoftDeleteCustomer {
  id          String   @id @default(cuid())
  email       String   @unique
  name        String
  
  // Soft delete fields
  isDeleted   Boolean  @default(false) @map("is_deleted")
  deletedAt   DateTime? @map("deleted_at")
  deletedBy   String?  @map("deleted_by")
  
  orders      SoftDeleteOrder[]
  
  @@index([isDeleted])
  @@map("soft_delete_customers")
}

model SoftDeleteOrder {
  id            String   @id @default(cuid())
  orderNumber   String   @unique
  total         Decimal  @db.Decimal(10, 2)
  
  // Customer relationship with soft delete awareness
  customerId    String   @map("customer_id")
  customer      SoftDeleteCustomer @relation(
    fields: [customerId], 
    references: [id],
    onDelete: Restrict  // ← Prevent hard delete if orders exist
  )
  
  // Soft delete fields - cascade soft delete from customer
  isDeleted     Boolean  @default(false) @map("is_deleted")
  deletedAt     DateTime? @map("deleted_at")
  deletedBy     String?  @map("deleted_by")
  
  items         SoftDeleteOrderItem[]
  
  @@index([customerId, isDeleted])
  @@index([isDeleted])
  @@map("soft_delete_orders")
}

model SoftDeleteOrderItem {
  id         String  @id @default(cuid())
  quantity   Int
  unitPrice  Decimal @db.Decimal(10, 2)
  
  // Order relationship
  orderId    String  @map("order_id")
  order      SoftDeleteOrder @relation(
    fields: [orderId], 
    references: [id],
    onDelete: Cascade  // ← Hard delete items when order hard deleted
  )
  
  // Soft delete - inherits from order
  isDeleted  Boolean @default(false) @map("is_deleted")
  deletedAt  DateTime? @map("deleted_at")
  
  @@index([orderId, isDeleted])
  @@map("soft_delete_order_items")
}
```

### Audit Trail with Cascade Operations
Maintain comprehensive audit trails with proper cascade behaviors:

```prisma
model AuditableEntity {
  id        String @id @default(cuid())
  name      String
  data      Json   @db.JsonB
  
  // Audit fields
  createdBy String   @map("created_by")
  createdAt DateTime @default(now()) @map("created_at")
  updatedBy String?  @map("updated_by")
  updatedAt DateTime @updatedAt @map("updated_at")
  version   Int      @default(1)
  
  // Audit trail - CASCADE DELETE to clean up history
  auditLogs AuditLog[]
  
  @@map("auditable_entities")
}

model AuditLog {
  id           String @id @default(cuid())
  action       String // CREATE, UPDATE, DELETE
  oldValues    Json?  @db.JsonB @map("old_values")
  newValues    Json?  @db.JsonB @map("new_values")
  changedBy    String @map("changed_by")
  changedAt    DateTime @default(now()) @map("changed_at")
  
  // Entity relationship - CASCADE for cleanup
  entityId     String @map("entity_id")
  entity       AuditableEntity @relation(
    fields: [entityId], 
    references: [id],
    onDelete: Cascade  // ← Delete audit logs when entity deleted
  )
  
  // User relationship - SET NULL to preserve audit history
  userId       String? @map("user_id")
  user         AuditUser? @relation(
    fields: [userId], 
    references: [id],
    onDelete: SetNull  // ← Keep audit log even if user deleted
  )
  
  @@index([entityId, changedAt])
  @@index([userId])
  @@index([action, changedAt])
  @@map("audit_logs")
}

model AuditUser {
  id        String @id @default(cuid())
  username  String @unique
  email     String @unique
  
  auditLogs AuditLog[]
  
  @@map("audit_users")
}
```

## Performance Considerations for Cascades

### Optimizing Cascade Operations
Design efficient cascade patterns for large datasets:

```prisma
model OptimizedParent {
  id          String @id @default(cuid())
  name        String
  status      String @default("active")
  
  // Partitioned children for better cascade performance
  children    OptimizedChild[]
  
  // Denormalized count for quick validation
  childCount  Int    @default(0) @map("child_count")
  
  @@index([status])
  @@map("optimized_parents")
}

model OptimizedChild {
  id           String @id @default(cuid())
  name         String
  data         Json   @db.JsonB
  
  // Optimized foreign key with strategic indexing
  parentId     String @map("parent_id")
  parent       OptimizedParent @relation(
    fields: [parentId], 
    references: [id],
    onDelete: Cascade
  )
  
  // Partition key for large datasets
  createdYear  Int    @map("created_year")
  createdAt    DateTime @default(now()) @map("created_at")
  
  @@index([parentId])                    // Foreign key index
  @@index([parentId, createdYear])       // Partitioned queries
  @@index([createdYear, createdAt])      // Time-based queries
  
  @@map("optimized_children")
}

// Batch processing for large cascade operations
model BatchDeletionQueue {
  id          String @id @default(cuid())
  entityType  String @map("entity_type")
  entityId    String @map("entity_id")
  action      String @default("DELETE")
  priority    Int    @default(0)
  status      String @default("pending") // pending, processing, completed, failed
  
  scheduledAt DateTime @default(now()) @map("scheduled_at")
  processedAt DateTime? @map("processed_at")
  
  @@index([status, priority, scheduledAt])
  @@index([entityType, entityId])
  @@map("batch_deletion_queue")
}
```

## Common Cascade Anti-Patterns

### ❌ Patterns to Avoid
Learn from common mistakes in cascade design:

```prisma
// ❌ Bad: Uncontrolled cascade chains
model BadCascadeParent {
  id       String @id @default(cuid())
  children BadCascadeChild[]
}

model BadCascadeChild {
  id         String @id @default(cuid())
  parentId   String
  parent     BadCascadeParent @relation(fields: [parentId], references: [id], onDelete: Cascade)
  
  // Problem: This creates an uncontrolled cascade chain
  // Deleting a parent could cascade through millions of records
  grandchildren BadCascadeGrandchild[]
}

model BadCascadeGrandchild {
  id       String @id @default(cuid())
  parentId String
  parent   BadCascadeChild @relation(fields: [parentId], references: [id], onDelete: Cascade)
  
  // Problem: Deep cascade without performance consideration
}

// ❌ Bad: Missing referential integrity
model BadNoRestrict {
  id       String @id @default(cuid())
  name     String
  orders   BadOrder[]
  
  // Problem: Customer can be deleted even with active orders
}

model BadOrder {
  id         String @id @default(cuid())
  customerId String
  customer   BadNoRestrict @relation(fields: [customerId], references: [id])
  
  // Problem: No onDelete specified - database default behavior
}

// ❌ Bad: Inconsistent cascade strategies
model InconsistentCascade {
  id       String @id @default(cuid())
  posts    InconsistentPost[]
  comments InconsistentComment[]
}

model InconsistentPost {
  id       String @id @default(cuid())
  authorId String
  author   InconsistentCascade @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model InconsistentComment {
  id       String @id @default(cuid())
  authorId String
  author   InconsistentCascade @relation(fields: [authorId], references: [id], onDelete: SetNull)
  
  // Problem: Inconsistent cascade strategy for similar relationships
}

// ✅ Good: Controlled cascade with business logic
model GoodCascadeDesign {
  id          String @id @default(cuid())
  name        String
  status      String @default("active")
  
  // Clear cascade strategy based on business requirements
  posts       GoodPost[]
  comments    GoodComment[]
  sessions    GoodSession[]
  
  @@map("good_cascade_users")
}

model GoodPost {
  id       String @id @default(cuid())
  title    String
  content  String
  
  // CASCADE: Posts are user-owned content
  authorId String @map("author_id")
  author   GoodCascadeDesign @relation(
    fields: [authorId], 
    references: [id],
    onDelete: Cascade  // ← Clear business rule: delete user's posts
  )
  
  @@index([authorId])
  @@map("good_posts")
}

model GoodComment {
  id      String @id @default(cuid())
  content String
  
  // SET NULL: Comments should remain for context
  authorId String? @map("author_id")
  author   GoodCascadeDesign? @relation(
    fields: [authorId], 
    references: [id],
    onDelete: SetNull  // ← Clear business rule: preserve comments anonymously
  )
  
  @@index([authorId])
  @@map("good_comments")
}

model GoodSession {
  id       String @id @default(cuid())
  token    String @unique
  expiresAt DateTime @map("expires_at")
  
  // CASCADE: Sessions should be cleaned up with user
  userId   String @map("user_id")
  user     GoodCascadeDesign @relation(
    fields: [userId], 
    references: [id],
    onDelete: Cascade  // ← Clear business rule: cleanup sessions
  )
  
  @@index([userId])
  @@map("good_sessions")
}
```

## Exercise: Design a Complete Cascade Strategy

Design a comprehensive project management system with proper cascade operations:

```prisma
// Your task: Create a project management platform with the following requirements:

// 1. Organizations → Workspaces → Projects → Tasks → Subtasks hierarchy
// 2. Users can be members of multiple organizations with different roles
// 3. Project templates that can be copied to create new projects
// 4. Time tracking and billing records
// 5. File attachments and comments on various entities

// Business rules for cascades:
// - Deleting organization should clean up workspace data but preserve billing records
// - Deleting projects should archive tasks, not delete them
// - Removing user access should anonymize their contributions but keep the data
// - Time tracking data must be preserved for legal/billing requirements

model PMOrganization {
  id   String @id @default(cuid())
  name String
  slug String @unique
  
  // Design the complete cascade strategy considering:
  // - Data retention requirements
  // - Performance implications
  // - Business continuity needs
  // - Audit and compliance requirements
  
  @@map("pm_organizations")
}

// Create additional models with:
// - Appropriate cascade behaviors for each relationship
// - Performance-optimized cascade chains
// - Business-rule compliant referential actions
// - Audit trail preservation strategies
```

## Key Takeaways

1. **Business Alignment**: Choose cascade behaviors that match business rules and data lifecycle requirements
2. **Performance Impact**: Consider the performance implications of cascade operations on large datasets
3. **Data Preservation**: Use SetNull or Restrict when data preservation is important for legal or business reasons
4. **Cascade Chains**: Be mindful of deep cascade chains that could impact performance or cause unexpected data loss
5. **Consistency**: Apply consistent cascade strategies across similar relationship patterns
6. **Soft Deletes**: Combine soft delete patterns with cascade operations for flexible data management
7. **Audit Trails**: Design cascade operations to preserve audit trails and compliance requirements

## Conclusion: Section 3.4 Complete

Congratulations! You've completed **Section 3.4: Relationships & Relations**. You now have comprehensive knowledge of:

- ✅ **One-to-One Relationships**: Exclusive partnerships and data separation strategies
- ✅ **One-to-Many Relationships**: Hierarchical structures and parent-child patterns  
- ✅ **Many-to-Many Relationships**: Complex associations with implicit and explicit patterns
- ✅ **Self-Relations & Hierarchical Data**: Recursive structures and tree organizations
- ✅ **Relation Fields & Foreign Keys**: Technical anatomy and performance optimization
- ✅ **Cascade Operations & Referential Actions**: Data lifecycle management and integrity

You're now ready to design sophisticated database schemas with proper relationships, optimized performance, and business-aligned data management strategies.

## Next Steps

In the next section, we'll explore **Schema Introspection & Best Practices** where you'll learn to reverse-engineer existing databases, validate schema designs, and apply advanced optimization techniques.

---

**Estimated Time:** 23 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of database relationships, foreign key constraints, and business logic implementation
