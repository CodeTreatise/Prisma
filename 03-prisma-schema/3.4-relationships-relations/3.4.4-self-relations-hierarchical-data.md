# 3.4.4 Self-Relations & Hierarchical Data

## Learning Objectives
By the end of this lesson, you will be able to:
- Design and implement self-referential relationships in Prisma
- Model tree structures and organizational hierarchies
- Handle recursive data queries and operations
- Implement adjacency lists and nested sets patterns
- Optimize performance for hierarchical queries
- Design complex hierarchical systems for real-world applications

## Introduction

Think of self-relations as **family trees, corporate org charts, or folder structures** - where entities of the same type relate to each other in hierarchical patterns. Like employees reporting to other employees, categories containing subcategories, or forum threads with nested replies. Self-relations enable you to model recursive structures where the same entity type can be both parent and child.

These patterns are essential for organizing data into natural hierarchies that reflect real-world relationships and enable powerful recursive operations.

## Basic Self-Referential Patterns

### Employee Hierarchy: Manager-Report Structure
The classic organizational hierarchy pattern:

```prisma
model Employee {
  id          String   @id @default(cuid())
  employeeId  String   @unique
  
  // Personal information
  firstName   String
  lastName    String
  email       String   @unique
  title       String
  department  String
  
  // Self-referential relationship
  managerId   String?  // Optional - CEO has no manager
  manager     Employee? @relation("ManagerReports", fields: [managerId], references: [id])
  reports     Employee[] @relation("ManagerReports")
  
  // Employment details
  hireDate    DateTime @default(now())
  salary      Decimal? @db.Decimal(10, 2)
  isActive    Boolean  @default(true)
  
  // Denormalized hierarchy information for performance
  level       Int      @default(0)      // Organizational level (0 = CEO)
  path        String   @default("/")    // Hierarchical path: "/ceo/vp-engineering/director"
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([managerId])             // Manager lookup
  @@index([department, level])     // Department hierarchy
  @@index([level, isActive])       // Organizational level
  @@index([path])                  // Hierarchical queries
  @@map("employees")
}
```

### Category Tree: Product Categorization
Nested category structures for e-commerce:

```prisma
model Category {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  
  // Self-referential hierarchy
  parentId    String?
  parent      Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  
  // Category metadata
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  level       Int      @default(0)      // Depth in hierarchy (0 = root)
  path        String   @default("/")    // Full path: "/electronics/computers/laptops"
  
  // Category counts (denormalized for performance)
  childCount    Int    @default(0)      // Number of direct children
  productCount  Int    @default(0)      // Products in this category
  totalProducts Int    @default(0)      // Products in this category + descendants
  
  // SEO and display
  metaTitle       String?
  metaDescription String?
  imageUrl        String?
  iconUrl         String?
  
  // Category relationships
  products    Product[]  // One-to-many with products
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([parentId, sortOrder])   // Children ordering
  @@index([level, isActive])       // Level-based queries
  @@index([path])                  // Path-based lookups
  @@index([slug])                  // URL routing
  @@map("categories")
}

model Product {
  id          String   @id @default(cuid())
  name        String
  sku         String   @unique
  
  // Category assignment
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  
  // Product details
  price       Decimal  @db.Decimal(10, 2)
  isActive    Boolean  @default(false)
  
  @@index([categoryId, isActive])
  @@map("products")
}
```

### Forum Structure: Threaded Discussions
Nested comment and thread systems:

```prisma
model Forum {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  
  // Forum hierarchy (forums can have sub-forums)
  parentId    String?
  parent      Forum?   @relation("ForumHierarchy", fields: [parentId], references: [id])
  children    Forum[]  @relation("ForumHierarchy")
  
  // Forum metadata
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  level       Int      @default(0)
  
  // Forum statistics (denormalized)
  threadCount Int      @default(0)
  postCount   Int      @default(0)
  lastPostAt  DateTime?
  
  // Forum permissions
  isPrivate   Boolean  @default(false)
  canPost     Boolean  @default(true)
  requiresModeration Boolean @default(false)
  
  // Relationships
  threads     Thread[]
  
  @@index([parentId, sortOrder])
  @@index([isActive, level])
  @@map("forums")
}

model Thread {
  id          String   @id @default(cuid())
  title       String
  content     String
  
  // Forum relationship
  forumId     String
  forum       Forum    @relation(fields: [forumId], references: [id], onDelete: Cascade)
  
  // Thread author
  authorId    String
  
  // Thread metadata
  isSticky    Boolean  @default(false)  // Pinned to top
  isLocked    Boolean  @default(false)  // No new replies
  isDeleted   Boolean  @default(false)
  
  // Thread statistics (denormalized)
  replyCount  Int      @default(0)
  viewCount   Int      @default(0)
  lastReplyAt DateTime?
  
  // Self-referential replies
  posts       Post[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([forumId, isSticky, lastReplyAt])  // Forum thread listing
  @@index([authorId])
  @@map("threads")
}

model Post {
  id        String   @id @default(cuid())
  content   String
  
  // Thread relationship
  threadId  String
  thread    Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
  
  // Post author
  authorId  String
  
  // Self-referential replies (posts can reply to other posts)
  parentId  String?
  parent    Post?    @relation("PostReplies", fields: [parentId], references: [id])
  replies   Post[]   @relation("PostReplies")
  
  // Post metadata
  isDeleted Boolean  @default(false)
  isEdited  Boolean  @default(false)
  editedAt  DateTime?
  
  // Post hierarchy information
  level     Int      @default(0)      // Nesting level
  path      String   @default("/")    // Reply path
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([threadId, createdAt])       // Thread post order
  @@index([parentId, createdAt])       // Reply order
  @@index([authorId])
  @@index([path])                      // Hierarchical queries
  @@map("posts")
}
```

## Advanced Hierarchical Patterns

### Menu System: Nested Navigation
Complex navigation structures for websites and applications:

```prisma
model MenuItem {
  id          String   @id @default(cuid())
  title       String
  slug        String?
  
  // Self-referential hierarchy
  parentId    String?
  parent      MenuItem? @relation("MenuHierarchy", fields: [parentId], references: [id])
  children    MenuItem[] @relation("MenuHierarchy")
  
  // Menu item configuration
  type        String   @default("link")    // link, dropdown, separator, header
  url         String?                      // External or internal URL
  route       String?                      // Internal route
  icon        String?                      // Icon identifier
  
  // Display properties
  isVisible   Boolean  @default(true)
  isEnabled   Boolean  @default(true)
  sortOrder   Int      @default(0)
  cssClass    String?                      // Custom CSS classes
  
  // Hierarchy information
  level       Int      @default(0)
  path        String   @default("/")
  hasChildren Boolean  @default(false)     // Denormalized for performance
  
  // Permissions and targeting
  requiredRole    String?                  // Minimum role required
  targetAudience  Json     @default("[]")  // Array of audience types
  
  // Menu metadata
  description String?
  tooltip     String?
  openInNewTab Boolean @default(false)
  
  // Menu system assignment
  menuSystemId String?
  menuSystem   MenuSystem? @relation(fields: [menuSystemId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([parentId, sortOrder])
  @@index([menuSystemId, level, sortOrder])
  @@index([type, isVisible])
  @@index([path])
  @@map("menu_items")
}

model MenuSystem {
  id          String     @id @default(cuid())
  name        String     @unique
  description String?
  
  // Menu system properties
  type        String     @default("navigation")  // navigation, sidebar, footer
  location    String?                            // header, sidebar, footer
  isActive    Boolean    @default(true)
  
  // Menu items
  items       MenuItem[]
  
  createdAt   DateTime   @default(now())
  
  @@map("menu_systems")
}
```

### File System: Directory Structure
Hierarchical file and folder organization:

```prisma
model FileSystemNode {
  id          String   @id @default(cuid())
  name        String
  
  // Self-referential hierarchy
  parentId    String?
  parent      FileSystemNode? @relation("DirectoryHierarchy", fields: [parentId], references: [id])
  children    FileSystemNode[] @relation("DirectoryHierarchy")
  
  // Node type and properties
  type        String   // file, directory, symlink
  mimeType    String?  // For files
  size        BigInt   @default(0)  // File size in bytes
  
  // File content (for small files, or reference to storage)
  content     Bytes?   // Direct storage for small files
  storageUrl  String?  // External storage reference
  checksum    String?  // File integrity checking
  
  // File system metadata
  permissions String   @default("644")  // Unix-style permissions
  owner       String
  group       String?
  
  // Hierarchy information
  level       Int      @default(0)
  path        String   @unique         // Full path: "/documents/projects/prisma/schema.prisma"
  
  // File system properties
  isHidden    Boolean  @default(false)
  isSystem    Boolean  @default(false)
  isReadOnly  Boolean  @default(false)
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  accessedAt  DateTime @default(now())
  
  // File version tracking
  version     Int      @default(1)
  
  @@index([parentId, name])
  @@index([type, parentId])
  @@index([path])
  @@index([owner, type])
  @@map("file_system_nodes")
}
```

### Organizational Structure: Complex Hierarchies
Multi-dimensional organizational modeling:

```prisma
model OrganizationalUnit {
  id          String   @id @default(cuid())
  name        String
  code        String   @unique
  description String?
  
  // Self-referential hierarchy
  parentId    String?
  parent      OrganizationalUnit? @relation("OrgHierarchy", fields: [parentId], references: [id])
  children    OrganizationalUnit[] @relation("OrgHierarchy")
  
  // Unit classification
  type        String   // company, division, department, team, group
  category    String?  // operational, support, strategic
  
  // Hierarchy metadata
  level       Int      @default(0)
  path        String   @default("/")
  
  // Unit properties
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  
  // Location and contact
  location    String?
  address     Json?    @db.JsonB
  phone       String?
  email       String?
  
  // Financial and operational
  budgetCode      String?
  costCenter      String?
  profitCenter    String?
  headcount       Int      @default(0)  // Current employee count
  maxHeadcount    Int?                  // Maximum allowed
  
  // Unit leadership
  managerId   String?  // Unit manager/director
  
  // Unit statistics (denormalized)
  totalEmployees    Int      @default(0)  // Including sub-units
  directEmployees   Int      @default(0)  // Direct reports only
  subunitCount      Int      @default(0)  // Number of sub-units
  
  // Unit relationships
  employees   Employee[]
  positions   Position[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([parentId, sortOrder])
  @@index([type, level])
  @@index([path])
  @@index([managerId])
  @@map("organizational_units")
}

model Employee {
  id          String   @id @default(cuid())
  employeeId  String   @unique
  
  // Personal information
  firstName   String
  lastName    String
  email       String   @unique
  
  // Organizational relationships
  organizationalUnitId String
  organizationalUnit   OrganizationalUnit @relation(fields: [organizationalUnitId], references: [id])
  
  // Direct reporting relationship (self-referential)
  managerId   String?
  manager     Employee? @relation("ManagerReports", fields: [managerId], references: [id])
  reports     Employee[] @relation("ManagerReports")
  
  // Position and role
  positionId  String?
  position    Position? @relation(fields: [positionId], references: [id])
  
  // Employee metadata
  isActive    Boolean  @default(true)
  hireDate    DateTime @default(now())
  
  @@index([organizationalUnitId])
  @@index([managerId])
  @@index([positionId])
  @@map("employees")
}

model Position {
  id          String   @id @default(cuid())
  title       String
  code        String   @unique
  description String?
  
  // Position hierarchy (positions can report to other positions)
  reportsToId String?
  reportsTo   Position? @relation("PositionHierarchy", fields: [reportsToId], references: [id])
  subordinates Position[] @relation("PositionHierarchy")
  
  // Organizational unit assignment
  organizationalUnitId String
  organizationalUnit   OrganizationalUnit @relation(fields: [organizationalUnitId], references: [id])
  
  // Position details
  level       String   // junior, mid, senior, lead, manager, director
  payGrade    String?
  minSalary   Decimal? @db.Decimal(10, 2)
  maxSalary   Decimal? @db.Decimal(10, 2)
  
  // Position requirements
  requirements Json?   @db.JsonB  // Skills, education, experience
  
  // Position status
  isActive    Boolean  @default(true)
  isPublished Boolean  @default(false)  // Available for hiring
  
  // Position occupancy
  employees   Employee[]
  maxOccupancy Int     @default(1)      // How many people can hold this position
  
  @@index([organizationalUnitId])
  @@index([reportsToId])
  @@index([level, isActive])
  @@map("positions")
}
```

## Performance Optimization for Hierarchical Data

### Denormalization Strategies
Pre-compute hierarchical information for faster queries:

```prisma
model OptimizedCategory {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  
  // Self-referential hierarchy
  parentId    String?
  parent      OptimizedCategory? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    OptimizedCategory[] @relation("CategoryHierarchy")
  
  // Denormalized hierarchy information for performance
  level       Int      @default(0)                    // Depth in tree
  path        String   @default("/")                  // Full hierarchical path
  pathIds     Json     @default("[]")                 // Array of ancestor IDs
  
  // Nested set model fields for efficient subtree queries
  leftValue   Int      @unique                        // Left boundary
  rightValue  Int      @unique                        // Right boundary
  
  // Cached counts
  childCount       Int @default(0)                    // Direct children
  descendantCount  Int @default(0)                    // All descendants
  productCount     Int @default(0)                    // Products in this category
  totalProductCount Int @default(0)                   // Products in subtree
  
  // Cached metadata
  rootId      String?                                 // Root category ID
  breadcrumbs Json     @default("[]")                 // Array of breadcrumb objects
  
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Strategic indexes for different query patterns
  @@index([parentId, sortOrder])                      // Children queries
  @@index([level, isActive])                          // Level-based filtering
  @@index([leftValue, rightValue])                    // Nested set queries
  @@index([path])                                     // Path-based lookups
  @@index([rootId, level])                            // Root subtree queries
  
  @@map("optimized_categories")
}
```

### Hierarchical Query Patterns
Common query optimizations for tree structures:

```prisma
model TreeNode {
  id          String   @id @default(cuid())
  name        String
  
  // Basic hierarchy
  parentId    String?
  parent      TreeNode? @relation("TreeHierarchy", fields: [parentId], references: [id])
  children    TreeNode[] @relation("TreeHierarchy")
  
  // Multiple hierarchy representations for different query patterns
  
  // 1. Adjacency List (standard parent-child)
  // Already covered above with parentId
  
  // 2. Path Enumeration
  path        String   @unique                        // "/1/3/7" - IDs in path
  pathNames   String   @default("/")                  // "/root/category/subcategory"
  level       Int      @default(0)                    // Depth level
  
  // 3. Nested Set Model
  leftBound   Int      @unique                        // Left boundary
  rightBound  Int      @unique                        // Right boundary
  
  // 4. Closure Table (for complex queries)
  // Implemented via separate model below
  
  // Node metadata
  isActive    Boolean  @default(true)
  nodeType    String   @default("node")               // node, leaf, root
  
  // Cached calculations
  childCount     Int   @default(0)                    // Direct children
  descendantCount Int  @default(0)                    // All descendants in subtree
  ancestorCount   Int  @default(0)                    // Depth from root
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Indexes optimized for different query patterns
  @@index([parentId])                                 // Parent-child queries
  @@index([path])                                     // Path-based lookups
  @@index([level, isActive])                          // Level-based filtering
  @@index([leftBound, rightBound])                    // Subtree queries
  @@index([nodeType, level])                          // Type-based filtering
  
  @@map("tree_nodes")
}

// Closure table for complex hierarchical queries
model TreeClosure {
  id          String   @id @default(cuid())
  ancestorId  String                                  // Ancestor node ID
  descendantId String                                 // Descendant node ID
  depth       Int                                     // Distance between nodes
  
  // Relationships
  ancestor    TreeNode @relation("TreeAncestors", fields: [ancestorId], references: [id], onDelete: Cascade)
  descendant  TreeNode @relation("TreeDescendants", fields: [descendantId], references: [id], onDelete: Cascade)
  
  @@unique([ancestorId, descendantId])
  @@index([ancestorId, depth])                        // Subtree at specific depth
  @@index([descendantId, depth])                      // Ancestors at specific depth
  @@index([depth])                                    // All relationships at depth
  
  @@map("tree_closure")
}
```

## Common Hierarchical Anti-Patterns

### ❌ Patterns to Avoid
Learn from common mistakes in hierarchical design:

```prisma
// ❌ Bad: Missing hierarchy optimization
model BadHierarchy {
  id       String @id @default(cuid())
  name     String
  parentId String?
  parent   BadHierarchy? @relation("BadHierarchy", fields: [parentId], references: [id])
  children BadHierarchy[] @relation("BadHierarchy")
  
  // Problems:
  // - No level tracking (expensive recursive queries)
  // - No path caching (difficult breadcrumb generation)
  // - No child counts (expensive counting queries)
  // - Missing strategic indexes
  // - No constraint on circular references
}

// ❌ Bad: Circular reference potential
model UnsafeHierarchy {
  id       String @id @default(cuid())
  parentId String?
  parent   UnsafeHierarchy? @relation("UnsafeHierarchy", fields: [parentId], references: [id])
  children UnsafeHierarchy[] @relation("UnsafeHierarchy")
  
  // Problem: Nothing prevents circular references (A -> B -> A)
  // Solution: Add application-level validation or database constraints
}

// ✅ Good: Optimized hierarchy with safeguards
model GoodHierarchy {
  id          String @id @default(cuid())
  name        String
  
  // Self-referential with constraints
  parentId    String?
  parent      GoodHierarchy? @relation("GoodHierarchy", fields: [parentId], references: [id])
  children    GoodHierarchy[] @relation("GoodHierarchy")
  
  // Hierarchy optimization
  level       Int      @default(0)                    // Prevents deep nesting
  path        String   @unique                        // Unique path constraint
  rootId      String                                  // Root reference
  
  // Cached metrics
  childCount  Int      @default(0)
  totalCount  Int      @default(0)
  
  // Status and ordering
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  
  // Constraints and validations
  maxDepth    Int      @default(10)                   // Application-enforced max depth
  
  @@index([parentId, sortOrder])
  @@index([level, isActive])
  @@index([path])
  @@index([rootId, level])
  
  @@map("good_hierarchy")
}
```

## Exercise: Design a Complete Hierarchical System

Design a comprehensive knowledge base system with multiple hierarchical structures:

```prisma
// Your task: Create a knowledge base with hierarchical content organization

model KnowledgeBase {
  id          String @id @default(cuid())
  title       String
  description String?
  
  // Add hierarchical structure for:
  // 1. Category hierarchy (topics -> subtopics -> articles)
  // 2. Article versioning (articles can have parent-child version relationships)
  // 3. Comment threading (nested discussion on articles)
  // 4. Organizational access control (departments can access certain sections)
  
  createdAt   DateTime @default(now())
  
  @@map("knowledge_bases")
}

// Create supporting hierarchical models:
// 1. Category - with nested categories and subcategories
// 2. Article - with version hierarchy and category assignment
// 3. Comment - with threaded discussions
// 4. AccessControl - with organizational hierarchy permissions

// Consider:
// - Performance optimization strategies (denormalization, indexing)
// - Hierarchy constraints and circular reference prevention
// - Multiple representation models (adjacency list, nested sets, closure table)
// - Caching strategies for frequently accessed hierarchy data
```

## Key Takeaways

1. **Self-Reference Pattern**: Use the same model with `parentId` and named relations
2. **Hierarchy Optimization**: Cache level, path, and counts for performance
3. **Strategic Indexing**: Index parentId, level, and path fields for common queries
4. **Circular Prevention**: Implement application-level validation to prevent cycles
5. **Multiple Representations**: Consider adjacency lists, nested sets, or closure tables
6. **Denormalization**: Store calculated hierarchy information for query performance
7. **Depth Limits**: Implement maximum depth constraints to prevent infinite nesting

## Next Steps

In the next lesson, we'll explore **Relation Fields & Foreign Keys** and learn about the technical details of how Prisma manages relationships, foreign key constraints, and referential integrity at the database level.

---

**Estimated Time:** 19 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of basic relationships, database indexing, and tree data structures
