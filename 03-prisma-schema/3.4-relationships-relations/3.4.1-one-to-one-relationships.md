# 3.4.1 One-to-One Relationships

## Learning Objectives
By the end of this lesson, you will be able to:
- Design and implement one-to-one relationships in Prisma
- Understand bidirectional vs unidirectional relationships
- Choose appropriate foreign key placement strategies
- Handle optional vs required one-to-one relationships
- Implement complex one-to-one patterns for real-world scenarios
- Optimize performance with proper indexing and constraints

## Introduction

Think of one-to-one relationships as **exclusive partnerships in the real world** - like a person and their passport, a car and its registration, or a user and their profile. Each entity has exactly one corresponding partner, creating a unique, exclusive bond. Just as your passport belongs only to you and you can have only one valid passport, one-to-one relationships ensure that each record in one table corresponds to exactly one record in another table.

One-to-one relationships are perfect for extending models, separating concerns, and organizing data into logical, manageable chunks.

## Basic One-to-One Relationship Patterns

### Simple One-to-One: User and Profile
The most common pattern - extending a core entity with additional details:

```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  
  // Core user data
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // One-to-one relationship
  profile   UserProfile?  // Optional - user may not have profile yet
  
  @@map("users")
}

model UserProfile {
  id          String   @id @default(cuid())
  
  // Foreign key to User
  userId      String   @unique  // @unique makes this one-to-one
  
  // Extended user information
  firstName   String?
  lastName    String?
  bio         String?
  avatarUrl   String?
  website     String?
  location    String?
  birthDate   DateTime?
  
  // Social media links
  twitterHandle String?
  linkedinUrl   String?
  githubHandle  String?
  
  // Preferences
  timezone      String   @default("UTC")
  language      String   @default("en")
  isPublic      Boolean  @default(true)
  
  // Relationship back to User
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("user_profiles")
}
```

### Bidirectional One-to-One: Company and CompanySettings
Both sides need to reference each other:

```prisma
model Company {
  id          String   @id @default(cuid())
  name        String
  domain      String   @unique
  email       String
  
  // Core company data
  industry    String?
  size        String?  // "startup", "small", "medium", "large", "enterprise"
  foundedYear Int?
  
  // One-to-one relationship to settings
  settings    CompanySettings?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("companies")
}

model CompanySettings {
  id        String  @id @default(cuid())
  
  // Foreign key
  companyId String  @unique
  
  // Company configuration
  allowPublicProfile     Boolean @default(true)
  requireTwoFactor       Boolean @default(false)
  passwordMinLength      Int     @default(8)
  sessionTimeoutMinutes  Int     @default(480)  // 8 hours
  
  // Billing and subscription
  billingEmail          String?
  invoicePrefix         String  @default("INV")
  taxRate               Float   @default(0.0)
  currency              String  @default("USD") @db.Char(3)
  
  // Branding
  logoUrl               String?
  primaryColor          String? @db.Char(7)  // Hex color
  secondaryColor        String? @db.Char(7)
  
  // Communication preferences
  enableEmailNotifications Boolean @default(true)
  enableSlackIntegration   Boolean @default(false)
  slackWebhookUrl          String?
  
  // Relationship back to Company
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("company_settings")
}
```

## Advanced One-to-One Patterns

### Data Separation by Concern: Sensitive Information
Separate sensitive data for security and performance:

```prisma
model Employee {
  id           String   @id @default(cuid())
  employeeId   String   @unique
  
  // Public employee information
  firstName    String
  lastName     String
  email        String   @unique
  department   String
  title        String
  startDate    DateTime @default(now())
  
  // Manager relationship
  managerId    String?
  manager      Employee? @relation("ManagerReports", fields: [managerId], references: [id])
  reports      Employee[] @relation("ManagerReports")
  
  // One-to-one to sensitive data
  sensitiveData EmployeeSensitiveData?
  
  // One-to-one to payroll data
  payrollData   EmployeePayroll?
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([managerId])
  @@map("employees")
}

model EmployeeSensitiveData {
  id           String   @id @default(cuid())
  employeeId   String   @unique
  
  // Sensitive personal information
  socialSecurityNumber String? @unique @map("ssn")
  dateOfBirth         DateTime?
  personalEmail       String?
  homeAddress         Json?    @db.JsonB
  phoneNumber         String?
  emergencyContact    Json?    @db.JsonB
  
  // Government and legal
  passportNumber      String?
  visaStatus          String?
  workEligibility     Boolean @default(true)
  
  // Background check
  backgroundCheckDate DateTime?
  backgroundCheckStatus String?
  
  // Relationship
  employee     Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("employee_sensitive_data")
}

model EmployeePayroll {
  id           String   @id @default(cuid())
  employeeId   String   @unique
  
  // Compensation
  salary       Decimal  @db.Decimal(10, 2)
  currency     String   @default("USD") @db.Char(3)
  payFrequency String   @default("monthly")  // weekly, biweekly, monthly
  
  // Benefits
  healthInsurance      Boolean @default(false)
  dentalInsurance      Boolean @default(false)
  visionInsurance      Boolean @default(false)
  lifeInsurance        Boolean @default(false)
  retirementPlan       Boolean @default(false)
  retirementMatchPercent Float? @default(0.0)
  
  // Tax information
  taxExemptions        Int     @default(0)
  additionalTaxWithholding Decimal? @db.Decimal(8, 2)
  
  // Banking
  bankAccountNumber    String?
  bankRoutingNumber    String?
  bankName            String?
  
  // Effective dates
  effectiveDate       DateTime @default(now())
  lastRaiseDate       DateTime?
  nextReviewDate      DateTime?
  
  // Relationship
  employee     Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("employee_payroll")
}
```

### Optional vs Required One-to-One Relationships
Different scenarios for relationship optionality:

```prisma
// Required one-to-one: Every order must have details
model Order {
  id           String       @id @default(cuid())
  orderNumber  String       @unique
  userId       String
  status       String       @default("pending")
  
  // Required relationship - every order has details
  details      OrderDetails  // No ? - this is required
  
  createdAt    DateTime     @default(now())
  
  @@map("orders")
}

model OrderDetails {
  id           String   @id @default(cuid())
  orderId      String   @unique
  
  // Detailed order information
  subtotal     Decimal  @db.Decimal(10, 2)
  taxAmount    Decimal  @db.Decimal(10, 2)
  shippingCost Decimal  @db.Decimal(10, 2)
  total        Decimal  @db.Decimal(10, 2)
  
  // Shipping information
  shippingAddress Json  @db.JsonB
  billingAddress  Json  @db.JsonB
  
  // Payment information
  paymentMethod   String
  paymentStatus   String @default("pending")
  
  // Special instructions
  notes           String?
  giftMessage     String?
  
  // Required relationship
  order        Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  @@map("order_details")
}

// Optional one-to-one: Product may have extended specifications
model Product {
  id           String                @id @default(cuid())
  name         String
  price        Decimal               @db.Decimal(10, 2)
  category     String
  
  // Optional relationship - not all products need detailed specs
  specifications ProductSpecifications?
  
  createdAt    DateTime              @default(now())
  
  @@map("products")
}

model ProductSpecifications {
  id           String   @id @default(cuid())
  productId    String   @unique
  
  // Technical specifications
  dimensions   Json?    @db.JsonB  // length, width, height, weight
  materials    Json?    @db.JsonB  // material composition
  features     Json?    @db.JsonB  // feature list
  
  // Performance specs
  powerRequirements String?
  operatingTemp     String?
  warranty          String?
  
  // Compliance and certifications
  certifications    Json?    @db.JsonB
  safetyStandards   Json?    @db.JsonB
  
  // Documentation
  manualUrl         String?
  videoUrl          String?
  
  // Optional relationship
  product      Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@map("product_specifications")
}
```

## Complex One-to-One Scenarios

### Multi-Table Extension Pattern
When one extension isn't enough:

```prisma
model Customer {
  id           String   @id @default(cuid())
  email        String   @unique
  firstName    String
  lastName     String
  
  // Multiple one-to-one extensions
  profile      CustomerProfile?      // Marketing and preferences
  billing      CustomerBilling?      // Payment and billing info
  shipping     CustomerShipping?     // Default shipping preferences
  loyalty      CustomerLoyalty?      // Loyalty program data
  
  createdAt    DateTime @default(now())
  
  @@map("customers")
}

model CustomerProfile {
  id           String   @id @default(cuid())
  customerId   String   @unique
  
  // Demographic information
  birthDate    DateTime?
  gender       String?
  occupation   String?
  interests    Json     @default("[]")  // Array of interests
  
  // Marketing preferences
  emailMarketing     Boolean @default(true)
  smsMarketing       Boolean @default(false)
  phoneMarketing     Boolean @default(false)
  marketingConsent   DateTime?
  
  // Behavioral data
  preferredCategories Json    @default("[]")
  averageOrderValue   Decimal? @db.Decimal(10, 2)
  totalLifetimeValue  Decimal  @default(0) @db.Decimal(12, 2)
  
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@map("customer_profiles")
}

model CustomerBilling {
  id           String   @id @default(cuid())
  customerId   String   @unique
  
  // Default payment method
  paymentMethodId      String?
  billingAddressId     String?
  
  // Billing preferences
  invoiceFormat        String  @default("pdf")  // pdf, html, email
  invoiceDelivery      String  @default("email") // email, postal, both
  billingCycle         String  @default("monthly")
  
  // Credit and payment terms
  creditLimit          Decimal? @db.Decimal(10, 2)
  paymentTerms         Int     @default(30)  // Days
  lateFeePercent       Float   @default(0.0)
  
  // Tax information
  taxExempt            Boolean @default(false)
  taxExemptNumber      String?
  taxRate              Float   @default(0.0)
  
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@map("customer_billing")
}

model CustomerShipping {
  id           String   @id @default(cuid())
  customerId   String   @unique
  
  // Default shipping preferences
  defaultAddressId     String?
  preferredCarrier     String?
  preferredServiceLevel String? // standard, express, overnight
  
  // Shipping instructions
  deliveryInstructions String?
  signatureRequired    Boolean @default(false)
  leaveAtDoor         Boolean @default(false)
  
  // Notification preferences
  trackingEmails       Boolean @default(true)
  smsNotifications     Boolean @default(false)
  
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@map("customer_shipping")
}

model CustomerLoyalty {
  id           String   @id @default(cuid())
  customerId   String   @unique
  
  // Loyalty program
  membershipLevel      String  @default("bronze")  // bronze, silver, gold, platinum
  pointsBalance        Int     @default(0)
  pointsLifetime       Int     @default(0)
  
  // Membership details
  memberSince          DateTime @default(now())
  anniversaryDate      DateTime @default(now())
  
  // Benefits and rewards
  discountPercent      Float   @default(0.0)
  freeShipping         Boolean @default(false)
  prioritySupport      Boolean @default(false)
  earlyAccess          Boolean @default(false)
  
  // Activity tracking
  lastPurchaseDate     DateTime?
  totalOrders          Int     @default(0)
  averageRating        Float   @default(0.0)
  
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@map("customer_loyalty")
}
```

### Polymorphic-Style One-to-One
One-to-one relationships that can connect to different types:

```prisma
model Document {
  id           String   @id @default(cuid())
  title        String
  content      String
  documentType String   // "contract", "invoice", "proposal"
  
  // One-to-one to specific document details based on type
  contractDetails  ContractDetails?
  invoiceDetails   InvoiceDetails?
  proposalDetails  ProposalDetails?
  
  createdAt    DateTime @default(now())
  
  @@map("documents")
}

model ContractDetails {
  id           String   @id @default(cuid())
  documentId   String   @unique
  
  // Contract-specific fields
  contractType String   // "employment", "service", "nda"
  partyA       String   // First party
  partyB       String   // Second party
  startDate    DateTime
  endDate      DateTime?
  value        Decimal? @db.Decimal(12, 2)
  
  // Legal terms
  governingLaw String?
  jurisdiction String?
  arbitration  Boolean @default(false)
  
  // Signatures and approval
  signedByPartyA   Boolean   @default(false)
  signedByPartyB   Boolean   @default(false)
  signedDate       DateTime?
  witnessRequired  Boolean   @default(false)
  notarizationRequired Boolean @default(false)
  
  document     Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@map("contract_details")
}

model InvoiceDetails {
  id           String   @id @default(cuid())
  documentId   String   @unique
  
  // Invoice-specific fields
  invoiceNumber String  @unique
  customerId    String
  dueDate       DateTime
  
  // Financial details
  subtotal      Decimal @db.Decimal(10, 2)
  taxRate       Float   @default(0.0)
  taxAmount     Decimal @db.Decimal(10, 2)
  total         Decimal @db.Decimal(10, 2)
  
  // Payment tracking
  paidAmount    Decimal @default(0) @db.Decimal(10, 2)
  paidDate      DateTime?
  paymentMethod String?
  
  // Status
  status        String  @default("draft")  // draft, sent, paid, overdue, cancelled
  
  document     Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@map("invoice_details")
}

model ProposalDetails {
  id           String   @id @default(cuid())
  documentId   String   @unique
  
  // Proposal-specific fields
  proposalNumber String  @unique
  clientId       String
  validUntil     DateTime
  
  // Proposal structure
  executiveSummary String?
  scope           Json    @db.JsonB  // Scope of work
  timeline        Json    @db.JsonB  // Project timeline
  pricing         Json    @db.JsonB  // Pricing breakdown
  
  // Proposal status
  status          String  @default("draft")  // draft, sent, accepted, rejected, expired
  sentDate        DateTime?
  responseDate    DateTime?
  acceptedDate    DateTime?
  
  // Terms
  paymentTerms    String?
  deliverables    Json?   @db.JsonB
  assumptions     String?
  
  document     Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@map("proposal_details")
}
```

## Performance Optimization for One-to-One

### Strategic Indexing and Query Patterns
Optimize for common access patterns:

```prisma
model Account {
  id           String   @id @default(cuid())
  accountNumber String  @unique
  
  // Frequently accessed together - consider denormalization
  balance      Decimal  @db.Decimal(15, 2)
  currency     String   @db.Char(3)
  status       String   @default("active")
  
  // One-to-one to detailed account information
  details      AccountDetails?
  
  // Indexes for common queries
  @@index([status, currency])
  @@map("accounts")
}

model AccountDetails {
  id           String   @id @default(cuid())
  accountId    String   @unique
  
  // Extended account information
  accountType  String   // checking, savings, investment
  interestRate Decimal? @db.Decimal(5, 4)
  minimumBalance Decimal @default(0) @db.Decimal(10, 2)
  
  // Account holder information
  holderName   String
  holderEmail  String
  holderPhone  String?
  
  // Account features
  overdraftProtection Boolean @default(false)
  onlineAccess       Boolean @default(true)
  mobileAccess       Boolean @default(true)
  checkingEnabled    Boolean @default(true)
  
  // Relationship with strategic index
  account      Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  // Indexes for filtering and reporting
  @@index([accountType, interestRate])
  @@index([holderEmail])  // Customer lookup
  @@map("account_details")
}
```

## Common One-to-One Anti-Patterns

### ❌ Patterns to Avoid
Learn from common mistakes:

```prisma
// ❌ Bad: Missing @unique constraint
model BadUserProfile {
  id     String @id @default(cuid())
  userId String  // Missing @unique - this allows multiple profiles per user!
  
  // This creates a one-to-many relationship, not one-to-one
  user   User   @relation(fields: [userId], references: [id])
}

// ❌ Bad: Unnecessary one-to-one for small amounts of data
model UnnecessaryExtension {
  id     String @id @default(cuid())
  userId String @unique
  
  // Just two simple fields - should be in the User model
  theme  String @default("light")
  locale String @default("en")
  
  user   User   @relation(fields: [userId], references: [id])
}

// ✅ Good: Proper one-to-one with meaningful separation
model ProperUserSettings {
  id     String @id @default(cuid())
  userId String @unique
  
  // Complex settings that justify separation
  notificationPreferences Json    @db.JsonB
  privacySettings        Json    @db.JsonB
  uiCustomizations       Json    @db.JsonB
  apiKeys               Json    @db.JsonB
  integrationSettings   Json    @db.JsonB
  
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_settings")
}
```

## Exercise: Design a Complete One-to-One System

Design a comprehensive blog system with proper one-to-one relationships:

```prisma
// Your task: Create a blog system with appropriate one-to-one relationships

model BlogPost {
  id       String @id @default(cuid())
  title    String
  slug     String @unique
  content  String
  authorId String
  
  // Add one-to-one relationships for:
  // - SEO metadata (title, description, keywords, og tags)
  // - Analytics data (views, engagement, performance metrics)
  // - Publishing settings (schedule, visibility, notifications)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("blog_posts")
}

// Create the related one-to-one models:
// 1. BlogPostSEO - SEO metadata and social sharing
// 2. BlogPostAnalytics - Performance metrics and statistics  
// 3. BlogPostSettings - Publishing and visibility settings

// Consider:
// - Which relationships should be optional vs required?
// - What cascade operations make sense?
// - How to organize data for optimal query performance?
// - What indexes are needed for common access patterns?
```

## Key Takeaways

1. **Unique Constraint**: Always use `@unique` on the foreign key to enforce one-to-one
2. **Cascade Operations**: Use `onDelete: Cascade` when the child cannot exist without parent
3. **Optional vs Required**: Use `?` for optional relationships where the extension may not exist
4. **Data Separation**: Use one-to-one for separating concerns, security, or performance reasons
5. **Strategic Indexing**: Index foreign keys and commonly filtered fields in related tables
6. **Avoid Over-Engineering**: Don't create one-to-one relationships for trivial data extensions
7. **Performance Consideration**: Sometimes denormalization is better than complex relationships

## Next Steps

In the next lesson, we'll explore **One-to-Many Relationships** and learn how to model hierarchical data structures where one entity can be related to multiple entities of another type.

---

**Estimated Time:** 16 minutes
**Difficulty:** Intermediate
**Prerequisites:** Understanding of foreign keys, constraints, and basic relational database concepts
