# 3.4.2 One-to-Many Relationships

## Learning Objectives
By the end of this lesson, you will be able to:
- Design and implement one-to-many relationships effectively
- Handle parent-child hierarchical data structures
- Implement cascading operations and referential integrity
- Optimize queries for one-to-many relationships
- Design complex one-to-many patterns for real-world applications
- Handle relationship constraints and data consistency

## Introduction

Think of one-to-many relationships as **a family tree or organizational hierarchy** - one parent can have multiple children, but each child has exactly one parent. Like a blog author who can write many posts, a customer who can place many orders, or a category that can contain many products. This is the most common relationship type in databases, forming the backbone of hierarchical data organization.

One-to-many relationships enable you to model natural hierarchies and collections in your application domain.

## Basic One-to-Many Patterns

### Classic Parent-Child: Author and Blog Posts
The foundational one-to-many pattern:

```prisma
model Author {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  firstName String
  lastName  String
  bio       String?
  
  // Author metadata
  isActive  Boolean  @default(true)
  joinedAt  DateTime @default(now())
  
  // One-to-many: Author has many posts
  posts     Post[]   // Array indicates "many" side
  
  @@map("authors")
}

model Post {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  content     String
  excerpt     String?
  
  // Foreign key to Author (many posts belong to one author)
  authorId    String
  
  // Post metadata
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  viewCount   Int      @default(0)
  
  // Relationship back to Author
  author      Author   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([authorId])          // Index for efficient author queries
  @@index([isPublished, publishedAt])  // Index for published posts
  @@map("posts")
}
```

### E-commerce: Customer and Orders
Essential business relationship pattern:

```prisma
model Customer {
  id          String   @id @default(cuid())
  email       String   @unique
  firstName   String
  lastName    String
  phone       String?
  
  // Customer status and metadata
  isActive    Boolean  @default(true)
  customerType String  @default("regular")  // regular, premium, vip
  
  // One-to-many relationships
  orders      Order[]  // Customer has many orders
  addresses   Address[] // Customer has many addresses
  
  // Customer lifecycle
  firstOrderDate DateTime?
  lastOrderDate  DateTime?
  totalOrders    Int      @default(0)
  lifetimeValue  Decimal  @default(0) @db.Decimal(12, 2)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([customerType, isActive])
  @@map("customers")
}

model Order {
  id           String   @id @default(cuid())
  orderNumber  String   @unique
  
  // Foreign key to Customer
  customerId   String
  
  // Order details
  status       String   @default("pending")
  subtotal     Decimal  @db.Decimal(10, 2)
  taxAmount    Decimal  @db.Decimal(8, 2)
  shippingCost Decimal  @db.Decimal(8, 2)
  total        Decimal  @db.Decimal(10, 2)
  
  // Order metadata
  currency     String   @default("USD") @db.Char(3)
  notes        String?
  
  // Relationship back to Customer
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Restrict)
  
  // One-to-many: Order has many order items
  items        OrderItem[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([customerId, createdAt])  // Customer order history
  @@index([status, createdAt])      // Order processing queries
  @@map("orders")
}

model OrderItem {
  id         String  @id @default(cuid())
  
  // Foreign key to Order
  orderId    String
  
  // Product information (denormalized for historical accuracy)
  productId  String
  productName String
  sku        String
  
  // Quantity and pricing
  quantity   Int
  unitPrice  Decimal @db.Decimal(10, 2)
  totalPrice Decimal @db.Decimal(10, 2)
  
  // Relationship back to Order
  order      Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  @@index([orderId])
  @@index([productId])  // Product sales analysis
  @@map("order_items")
}

model Address {
  id          String   @id @default(cuid())
  
  // Foreign key to Customer
  customerId  String
  
  // Address details
  type        String   // billing, shipping, both
  firstName   String
  lastName    String
  company     String?
  
  // Address fields
  address1    String
  address2    String?
  city        String
  state       String
  postalCode  String
  country     String   @db.Char(2)  // ISO country code
  
  // Address metadata
  isDefault   Boolean  @default(false)
  isActive    Boolean  @default(true)
  
  // Relationship back to Customer
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([customerId, type])
  @@map("addresses")
}
```

## Advanced One-to-Many Patterns

### Multi-Level Hierarchies: Categories
Nested hierarchical structures:

```prisma
model Category {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  
  // Self-referential relationship for hierarchy
  parentId    String?
  parent      Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  
  // Category metadata
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  level       Int      @default(0)      // Denormalized depth level
  path        String   @default("/")    // Denormalized path (e.g., "/electronics/computers/laptops")
  
  // One-to-many: Category has many products
  products    Product[]
  
  // SEO and display
  metaTitle       String?
  metaDescription String?
  imageUrl        String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([parentId, sortOrder])
  @@index([isActive, level])
  @@index([path])  // For breadcrumb queries
  @@map("categories")
}

model Product {
  id           String   @id @default(cuid())
  name         String
  slug         String   @unique
  description  String?
  
  // Foreign key to Category
  categoryId   String
  
  // Product details
  sku          String   @unique
  price        Decimal  @db.Decimal(10, 2)
  comparePrice Decimal? @db.Decimal(10, 2)
  cost         Decimal  @db.Decimal(10, 2)
  
  // Inventory
  inventory    Int      @default(0)
  lowStockThreshold Int @default(10)
  
  // Product status
  isActive     Boolean  @default(false)
  isFeatured   Boolean  @default(false)
  isDigital    Boolean  @default(false)
  
  // Relationship back to Category
  category     Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  
  // One-to-many: Product has many variants, reviews, images
  variants     ProductVariant[]
  reviews      ProductReview[]
  images       ProductImage[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([categoryId, isActive])
  @@index([isFeatured, isActive])
  @@index([price, isActive])
  @@map("products")
}

model ProductVariant {
  id         String  @id @default(cuid())
  
  // Foreign key to Product
  productId  String
  
  // Variant details
  name       String  // "Red Large", "Blue Medium"
  sku        String  @unique
  
  // Variant attributes
  color      String?
  size       String?
  material   String?
  weight     Float?
  
  // Pricing and inventory (can override product defaults)
  price      Decimal? @db.Decimal(10, 2)
  inventory  Int     @default(0)
  
  // Variant status
  isActive   Boolean @default(true)
  isDefault  Boolean @default(false)
  
  // Relationship back to Product
  product    Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@index([productId, isActive])
  @@index([sku])
  @@map("product_variants")
}

model ProductReview {
  id         String   @id @default(cuid())
  
  // Foreign key to Product
  productId  String
  
  // Review details
  customerId String
  rating     Int      // 1-5 stars
  title      String?
  content    String
  
  // Review metadata
  isVerified Boolean  @default(false)  // Verified purchase
  isPublished Boolean @default(true)
  
  // Helpful votes
  helpfulCount Int    @default(0)
  totalVotes   Int    @default(0)
  
  // Relationship back to Product
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@index([productId, isPublished])
  @@index([rating, isPublished])
  @@index([customerId])
  @@map("product_reviews")
}

model ProductImage {
  id         String  @id @default(cuid())
  
  // Foreign key to Product
  productId  String
  
  // Image details
  url        String
  altText    String?
  caption    String?
  
  // Image metadata
  sortOrder  Int     @default(0)
  isPrimary  Boolean @default(false)
  
  // Image properties
  width      Int?
  height     Int?
  fileSize   Int?    // bytes
  format     String? // jpg, png, webp
  
  // Relationship back to Product
  product    Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@index([productId, sortOrder])
  @@index([isPrimary])
  @@map("product_images")
}
```

### Complex Business Relationships: Project Management
Multiple related entities in professional contexts:

```prisma
model Project {
  id          String   @id @default(cuid())
  name        String
  code        String   @unique
  description String?
  
  // Project details
  status      String   @default("planning")  // planning, active, completed, cancelled
  priority    String   @default("medium")    // low, medium, high, critical
  
  // Project dates
  startDate   DateTime?
  endDate     DateTime?
  deadline    DateTime?
  
  // Budget and resources
  budget      Decimal? @db.Decimal(12, 2)
  currency    String   @default("USD") @db.Char(3)
  
  // Project ownership
  managerId   String
  clientId    String?
  
  // One-to-many relationships
  tasks       Task[]
  documents   ProjectDocument[]
  timeEntries TimeEntry[]
  expenses    ProjectExpense[]
  members     ProjectMember[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([status, priority])
  @@index([managerId])
  @@index([startDate, endDate])
  @@map("projects")
}

model Task {
  id          String   @id @default(cuid())
  title       String
  description String?
  
  // Foreign key to Project
  projectId   String
  
  // Task details
  status      String   @default("todo")      // todo, in_progress, review, done
  priority    String   @default("medium")
  
  // Task assignment
  assigneeId  String?
  createdById String
  
  // Task timeline
  estimatedHours Decimal? @db.Decimal(6, 2)
  actualHours    Decimal? @db.Decimal(6, 2)
  dueDate        DateTime?
  startDate      DateTime?
  completedDate  DateTime?
  
  // Task hierarchy (subtasks)
  parentTaskId String?
  parentTask   Task?   @relation("TaskHierarchy", fields: [parentTaskId], references: [id])
  subtasks     Task[]  @relation("TaskHierarchy")
  
  // Relationship back to Project
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  // One-to-many: Task has many comments, time entries
  comments    TaskComment[]
  timeEntries TimeEntry[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([projectId, status])
  @@index([assigneeId, status])
  @@index([dueDate, status])
  @@index([parentTaskId])
  @@map("tasks")
}

model TaskComment {
  id       String @id @default(cuid())
  
  // Foreign key to Task
  taskId   String
  
  // Comment details
  content  String
  authorId String
  
  // Comment metadata
  isInternal Boolean @default(false)  // Internal team comments vs client-visible
  
  // Relationship back to Task
  task     Task    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([taskId, createdAt])
  @@index([authorId])
  @@map("task_comments")
}

model TimeEntry {
  id          String   @id @default(cuid())
  
  // Foreign keys
  projectId   String
  taskId      String?
  userId      String
  
  // Time tracking
  hours       Decimal  @db.Decimal(6, 2)
  description String?
  date        DateTime @db.Date
  
  // Billing information
  billableRate   Decimal? @db.Decimal(8, 2)
  billableAmount Decimal? @db.Decimal(10, 2)
  isBillable     Boolean  @default(true)
  
  // Status
  isApproved  Boolean @default(false)
  approvedBy  String?
  approvedAt  DateTime?
  
  // Relationships
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  task        Task?   @relation(fields: [taskId], references: [id], onDelete: SetNull)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([projectId, date])
  @@index([userId, date])
  @@index([taskId])
  @@map("time_entries")
}

model ProjectMember {
  id       String @id @default(cuid())
  
  // Foreign keys
  projectId String
  userId    String
  
  // Member role and permissions
  role     String  @default("member")  // manager, member, viewer
  canEdit  Boolean @default(false)
  canInvite Boolean @default(false)
  
  // Member dates
  joinedAt DateTime @default(now())
  leftAt   DateTime?
  
  // Billing rate for this project
  hourlyRate Decimal? @db.Decimal(8, 2)
  
  // Relationship back to Project
  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@unique([projectId, userId])  // User can only be a member once per project
  @@index([userId])
  @@map("project_members")
}
```

## Cascade Operations and Data Integrity

### Strategic Cascade Configuration
Handle referential integrity with appropriate cascade operations:

```prisma
model Publisher {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  website     String?
  
  // Publisher status
  isActive    Boolean  @default(true)
  
  // One-to-many: Publisher has many books
  books       Book[]
  
  createdAt   DateTime @default(now())
  
  @@map("publishers")
}

model Book {
  id          String   @id @default(cuid())
  title       String
  isbn        String   @unique
  
  // Foreign key to Publisher
  publisherId String
  
  // Book details
  publishedAt DateTime
  pages       Int?
  language    String   @default("en")
  price       Decimal  @db.Decimal(8, 2)
  
  // Inventory
  stockQuantity Int    @default(0)
  isAvailable   Boolean @default(true)
  
  // Relationships with different cascade behaviors
  publisher   Publisher @relation(fields: [publisherId], references: [id], onDelete: Restrict)  // Don't delete publisher if books exist
  
  // One-to-many: Book has many editions, reviews, sales
  editions    BookEdition[]  // Cascade: delete editions when book is deleted
  reviews     BookReview[]   // Cascade: delete reviews when book is deleted
  salesRecords SalesRecord[] // Restrict: preserve sales history
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([publisherId, isAvailable])
  @@index([publishedAt])
  @@map("books")
}

model BookEdition {
  id          String   @id @default(cuid())
  
  // Foreign key to Book
  bookId      String
  
  // Edition details
  editionNumber Int
  format      String   // hardcover, paperback, ebook, audiobook
  
  // Edition-specific pricing
  price       Decimal  @db.Decimal(8, 2)
  
  // Availability
  isAvailable Boolean  @default(true)
  publishedAt DateTime @default(now())
  
  // Cascade delete: if book is deleted, delete all editions
  book        Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  @@unique([bookId, editionNumber])
  @@index([bookId, isAvailable])
  @@map("book_editions")
}

model BookReview {
  id         String   @id @default(cuid())
  
  // Foreign key to Book
  bookId     String
  
  // Review details
  reviewerId String
  rating     Int      // 1-5 stars
  title      String?
  content    String
  
  // Review status
  isApproved Boolean  @default(false)
  
  // Cascade delete: if book is deleted, delete all reviews
  book       Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime @default(now())
  
  @@index([bookId, isApproved])
  @@index([rating])
  @@map("book_reviews")
}

model SalesRecord {
  id         String   @id @default(cuid())
  
  // Foreign key to Book
  bookId     String
  
  // Sales details
  customerId String
  quantity   Int
  unitPrice  Decimal  @db.Decimal(8, 2)
  totalPrice Decimal  @db.Decimal(10, 2)
  
  // Sale metadata
  saleDate   DateTime @default(now())
  channel    String   // online, store, wholesale
  
  // Restrict delete: preserve sales history even if book is deleted
  book       Book     @relation(fields: [bookId], references: [id], onDelete: Restrict)
  
  @@index([bookId, saleDate])
  @@index([customerId])
  @@map("sales_records")
}
```

## Performance Optimization

### Efficient Querying Patterns
Optimize one-to-many relationships for common access patterns:

```prisma
model Blog {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  
  // Blog metadata for optimization
  postsCount     Int     @default(0)     // Denormalized count
  lastPostDate   DateTime?               // Latest post date
  
  // Blog status
  isActive    Boolean  @default(true)
  
  // One-to-many: Blog has many posts
  posts       BlogPost[]
  
  // One-to-many: Blog has many categories
  categories  BlogCategory[]
  
  createdAt   DateTime @default(now())
  
  @@index([isActive, lastPostDate])
  @@map("blogs")
}

model BlogPost {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  content     String
  excerpt     String?
  
  // Foreign key to Blog
  blogId      String
  
  // Foreign key to Category
  categoryId  String?
  
  // Post metadata optimized for queries
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  
  // Denormalized fields for performance
  viewCount   Int      @default(0)
  commentCount Int     @default(0)
  likeCount   Int      @default(0)
  
  // SEO fields
  metaTitle       String?
  metaDescription String?
  featuredImageUrl String?
  
  // Relationships
  blog        Blog         @relation(fields: [blogId], references: [id], onDelete: Cascade)
  category    BlogCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  
  // One-to-many: Post has many comments
  comments    BlogComment[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Strategic indexes for common queries
  @@index([blogId, isPublished, publishedAt])  // Blog post listing
  @@index([categoryId, isPublished, publishedAt])  // Category pages
  @@index([isPublished, publishedAt])  // Recent posts
  @@index([slug])  // Individual post lookup
  @@map("blog_posts")
}

model BlogCategory {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  
  // Foreign key to Blog
  blogId      String
  
  // Category metadata
  postsCount  Int      @default(0)  // Denormalized count
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  
  // Relationship back to Blog
  blog        Blog     @relation(fields: [blogId], references: [id], onDelete: Cascade)
  
  // One-to-many: Category has many posts
  posts       BlogPost[]
  
  @@index([blogId, isActive, sortOrder])
  @@map("blog_categories")
}

model BlogComment {
  id         String   @id @default(cuid())
  
  // Foreign key to BlogPost
  postId     String
  
  // Comment details
  authorName  String
  authorEmail String
  content     String
  
  // Comment hierarchy (replies)
  parentId   String?
  parent     BlogComment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies    BlogComment[] @relation("CommentReplies")
  
  // Comment status
  isApproved Boolean  @default(false)
  isSpam     Boolean  @default(false)
  
  // Relationship back to BlogPost
  post       BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime @default(now())
  
  @@index([postId, isApproved, createdAt])  // Post comments
  @@index([parentId])  // Comment replies
  @@map("blog_comments")
}
```

## Exercise: Design a Complete One-to-Many System

Design a comprehensive learning management system with proper one-to-many relationships:

```prisma
// Your task: Create an LMS with appropriate one-to-many relationships

model Course {
  id          String @id @default(cuid())
  title       String
  description String?
  
  // Add instructor relationship (one instructor, many courses)
  instructorId String
  
  // Add one-to-many relationships for:
  // - Lessons (course has many lessons)
  // - Enrollments (course has many student enrollments)
  // - Assignments (course has many assignments)
  // - Announcements (course has many announcements)
  
  createdAt   DateTime @default(now())
  
  @@map("courses")
}

// Create the related models:
// 1. Instructor - can teach multiple courses
// 2. Lesson - belongs to one course, has many videos/materials
// 3. StudentEnrollment - tracks student progress in courses
// 4. Assignment - belongs to one course, has many submissions
// 5. Announcement - belongs to one course

// Consider:
// - Appropriate cascade operations for each relationship
// - Denormalized counts for performance (enrollmentCount, lessonCount)
// - Strategic indexing for common query patterns
// - Hierarchical data (lesson ordering, assignment due dates)
```

## Key Takeaways

1. **Array Notation**: Use `Model[]` to indicate the "many" side of the relationship
2. **Foreign Key Indexing**: Always index foreign key fields for query performance
3. **Cascade Strategy**: Choose appropriate `onDelete` behavior (Cascade, Restrict, SetNull)
4. **Denormalization**: Consider storing counts and aggregated data for performance
5. **Strategic Indexing**: Index combinations of foreign keys with filter fields
6. **Hierarchical Data**: Use self-referential relationships for tree structures
7. **Data Consistency**: Implement proper constraints to maintain referential integrity

## Next Steps

In the next lesson, we'll explore **Many-to-Many Relationships (Implicit & Explicit)** and learn how to model complex associations where entities on both sides can have multiple relationships with each other.

---

**Estimated Time:** 18 minutes
**Difficulty:** Intermediate
**Prerequisites:** Understanding of foreign keys, indexing, and one-to-one relationships
