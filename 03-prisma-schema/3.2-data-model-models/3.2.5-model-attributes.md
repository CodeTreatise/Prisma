# 3.2.5 Model Attributes (@@map, @@index, @@unique)

## üìã Section Overview
- **Duration**: 13 minutes
- **Prerequisites**: 
  - Completed Lesson 3.2.4: Default Values & Auto-generation
  - Understanding of database indexing and constraint concepts
  - Basic knowledge of database performance optimization
- **Learning Objectives**: 
  - Master model-level attributes for database optimization and mapping
  - Implement strategic indexing patterns for query performance
  - Apply unique constraints and composite keys effectively
  - Design scalable database schemas with proper attribute configurations
  - Create production-ready models with advanced attribute patterns
- **Difficulty Level**: Intermediate

---

## üéØ What You'll Learn

By the end of this lesson, you will:
- ‚úÖ Configure database table mapping with @@map attributes
- ‚úÖ Implement strategic indexing with @@index for optimal performance
- ‚úÖ Apply unique constraints with @@unique for data integrity
- ‚úÖ Design composite indexes and multi-field constraints
- ‚úÖ Create advanced attribute patterns for production systems
- ‚úÖ Optimize database performance through intelligent attribute usage

---

## üìñ Content

### Understanding Model Attributes Architecture

Working with Prisma model attributes is like **designing the infrastructure and optimization systems for a world-class metropolitan library network**. Just as a library system has address mapping that connects each branch location to its physical address and neighborhood (@@map attributes link models to database tables), intelligent cataloging systems that create specialized indexes for different search patterns‚Äîauthor indexes for literature searches, subject indexes for academic research, ISBN indexes for exact book identification, and date indexes for new acquisitions (@@index attributes optimize specific query patterns), unique identification systems that ensure no duplicate books exist in the same branch, no two patrons have identical library cards, and no conflicting reservation numbers are issued (@@unique constraints prevent data duplication), and strategic organization that places frequently accessed materials in easily reachable locations, groups related books together for browsing efficiency, and creates specialized sections for different user needs‚ÄîPrisma model attributes create sophisticated data infrastructure with table mapping that aligns code models with database schemas, performance optimization that accelerates specific query patterns through strategic indexing, data integrity that prevents duplication and maintains consistency through unique constraints, and intelligent organization that structures data for maximum accessibility and operational efficiency.

### üèõÔ∏è Metropolitan Library Network Analogy

```
üèõÔ∏è Metropolitan Library System = üìä Prisma Model Attributes System

üó∫Ô∏è Address Mapping System (@@map Attributes)
‚îú‚îÄ‚îÄ Branch locations ‚Üí Model-to-table mapping (@@map("users"))
‚îú‚îÄ‚îÄ Department addresses ‚Üí Field-to-column mapping (@map("first_name"))
‚îú‚îÄ‚îÄ Service points ‚Üí Relationship endpoint mapping
‚îú‚îÄ‚îÄ Collection areas ‚Üí Specialized storage mapping
‚îú‚îÄ‚îÄ Digital resources ‚Üí External system integration mapping
‚îî‚îÄ‚îÄ Administrative offices ‚Üí System configuration mapping

üìö Intelligent Cataloging (@@index Attributes)
‚îú‚îÄ‚îÄ Author search index ‚Üí User name indexing (@@index([firstName, lastName]))
‚îú‚îÄ‚îÄ Subject classification ‚Üí Category-based indexing (@@index([category, subcategory]))
‚îú‚îÄ‚îÄ Publication date index ‚Üí Temporal indexing (@@index([createdAt]))
‚îú‚îÄ‚îÄ ISBN lookup system ‚Üí Unique identifier indexing (@@index([isbn]))
‚îú‚îÄ‚îÄ Popularity rankings ‚Üí Usage-based indexing (@@index([viewCount]))
‚îî‚îÄ‚îÄ Multi-criteria search ‚Üí Composite indexing (@@index([status, isActive]))

üîê Unique Identification (@@unique Attributes)
‚îú‚îÄ‚îÄ Library card numbers ‚Üí User identifier uniqueness (@@unique([email]))
‚îú‚îÄ‚îÄ Book inventory codes ‚Üí Product SKU uniqueness (@@unique([sku]))
‚îú‚îÄ‚îÄ Reservation numbers ‚Üí Transaction uniqueness (@@unique([orderNumber]))
‚îú‚îÄ‚îÄ Staff badge numbers ‚Üí Employee identification (@@unique([employeeId]))
‚îú‚îÄ‚îÄ Digital access codes ‚Üí API key uniqueness (@@unique([apiKey]))
‚îî‚îÄ‚îÄ Composite identifiers ‚Üí Multi-field uniqueness (@@unique([userId, eventId]))

‚ö° Strategic Organization (Performance Optimization)
‚îú‚îÄ‚îÄ High-traffic areas ‚Üí Frequently queried field indexing
‚îú‚îÄ‚îÄ Reference sections ‚Üí Lookup table optimization
‚îú‚îÄ‚îÄ Popular collections ‚Üí Hot data indexing strategies
‚îú‚îÄ‚îÄ Archive systems ‚Üí Historical data access patterns
‚îú‚îÄ‚îÄ Search stations ‚Üí Full-text search optimization
‚îî‚îÄ‚îÄ Digital catalogs ‚Üí Cross-reference indexing systems

üèóÔ∏è Infrastructure Planning (Scalability Design)
‚îú‚îÄ‚îÄ Expansion capacity ‚Üí Index growth planning
‚îú‚îÄ‚îÄ Service efficiency ‚Üí Query performance optimization
‚îú‚îÄ‚îÄ Resource allocation ‚Üí Storage and memory management
‚îú‚îÄ‚îÄ Network connectivity ‚Üí Distributed system considerations
‚îú‚îÄ‚îÄ Future adaptability ‚Üí Schema evolution support
‚îî‚îÄ‚îÄ Maintenance protocols ‚Üí Index maintenance and optimization
```

---

## üó∫Ô∏è Database Mapping Fundamentals

### 1. Table and Column Mapping with @@map

```prisma
// ==========================================
// DATABASE MAPPING CONFIGURATIONS
// ==========================================

/// User model with comprehensive database mapping
/// Demonstrates table and column mapping strategies
model User {
  // Primary identifier
  id        String   @id @default(cuid()) @map("user_id")
  
  // Personal information with column mapping
  email     String   @unique @map("email_address")
  username  String?  @unique @map("user_name")
  firstName String?  @map("first_name")
  lastName  String?  @map("last_name")
  fullName  String?  @map("full_name")
  
  // Contact information mapping
  phoneNumber String? @map("phone_number")
  address     String? @map("street_address")
  city        String? @map("city_name")
  state       String? @map("state_province")
  postalCode  String? @map("postal_code")
  country     String? @map("country_code")
  
  // Account status and metadata
  isActive    Boolean  @default(true) @map("is_active")
  isVerified  Boolean  @default(false) @map("is_verified")
  
  // Temporal fields with descriptive mapping
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  lastLoginAt DateTime? @map("last_login_at")
  
  // Relationships
  profile     UserProfile?
  posts       Post[]      @relation("UserPosts")
  comments    Comment[]   @relation("UserComments")
  orders      Order[]     @relation("CustomerOrders")
  
  // Map model to specific database table
  @@map("users")
  
  // Indexes for mapped fields
  @@index([email], map: "idx_users_email")
  @@index([username], map: "idx_users_username")
  @@index([firstName, lastName], map: "idx_users_name")
  @@index([isActive, createdAt], map: "idx_users_active_created")
}

/// Product model with legacy database mapping
/// Shows how to map to existing database schemas
model Product {
  // Modern field names mapped to legacy columns
  id          String   @id @default(cuid()) @map("PROD_ID")
  sku         String   @unique @map("STOCK_KEEPING_UNIT")
  name        String   @map("PRODUCT_NAME")
  description String?  @map("PROD_DESC")
  
  // Price fields with financial naming conventions
  price       Decimal  @db.Decimal(10, 2) @map("UNIT_PRICE")
  costPrice   Decimal? @db.Decimal(10, 2) @map("COST_BASIS")
  salePrice   Decimal? @db.Decimal(10, 2) @map("SALE_PRICE")
  
  // Status fields with legacy boolean mapping
  isActive    Boolean  @default(true) @map("ACTIVE_FLAG")
  isVisible   Boolean  @default(true) @map("VISIBLE_FLAG")
  isFeatured  Boolean  @default(false) @map("FEATURED_FLAG")
  
  // Inventory mapping
  stockQty    Int      @default(0) @map("STOCK_QUANTITY")
  minStock    Int      @default(5) @map("MIN_STOCK_LEVEL")
  
  // Category relationship with foreign key mapping
  categoryId  String   @map("CATEGORY_ID")
  category    Category @relation(fields: [categoryId], references: [id])
  
  // Vendor relationship
  vendorId    String   @map("VENDOR_ID")
  vendor      User     @relation("VendorProducts", fields: [vendorId], references: [id])
  
  // Temporal fields with legacy timestamp naming
  createdAt   DateTime @default(now()) @map("CREATE_DATE")
  updatedAt   DateTime @updatedAt @map("LAST_UPDATE")
  
  // Map to legacy table name
  @@map("PRODUCT_MASTER")
  
  // Named indexes for legacy compatibility
  @@index([sku], map: "IDX_PROD_SKU")
  @@index([categoryId], map: "IDX_PROD_CATEGORY")
  @@index([vendorId], map: "IDX_PROD_VENDOR")
}

/// Order model with comprehensive mapping strategy
model Order {
  // System identifiers with clear mapping
  id            String      @id @default(cuid()) @map("order_id")
  orderNumber   String      @unique @default(uuid()) @map("order_number")
  
  // Customer relationship
  customerId    String      @map("customer_id")
  customer      User        @relation("CustomerOrders", fields: [customerId], references: [id])
  
  // Order status with enum mapping
  status        OrderStatus @default(PENDING) @map("order_status")
  paymentStatus String      @default("unpaid") @map("payment_status")
  
  // Financial fields with precise mapping
  subtotal      Decimal     @default(0.00) @db.Decimal(12, 2) @map("subtotal_amount")
  taxAmount     Decimal     @default(0.00) @db.Decimal(10, 2) @map("tax_amount")
  shippingCost  Decimal     @default(0.00) @db.Decimal(8, 2) @map("shipping_cost")
  totalAmount   Decimal     @default(0.00) @db.Decimal(12, 2) @map("total_amount")
  
  // Address information
  shippingAddress String?   @map("shipping_address")
  billingAddress  String?   @map("billing_address")
  
  // Temporal tracking with business-friendly names
  orderDate     DateTime    @default(now()) @map("order_date")
  shippedDate   DateTime?   @map("shipped_date")
  deliveredDate DateTime?   @map("delivered_date")
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  
  // Relationships
  items         OrderItem[] @relation("OrderItems")
  
  // Map to orders table
  @@map("orders")
  
  // Strategic indexes with descriptive names
  @@index([customerId], map: "idx_orders_customer")
  @@index([orderDate], map: "idx_orders_date")
  @@index([status], map: "idx_orders_status")
  @@index([orderNumber], map: "idx_orders_number")
}

/// Category model with hierarchical mapping
model Category {
  // Identifier mapping
  id          String     @id @default(cuid()) @map("category_id")
  name        String     @map("category_name")
  slug        String?    @unique @map("url_slug")
  description String?    @map("category_description")
  
  // Hierarchical structure mapping
  parentId    String?    @map("parent_category_id")
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  
  // Display and sorting
  sortOrder   Int?       @map("display_order")
  isActive    Boolean    @default(true) @map("is_active")
  
  // SEO and metadata
  metaTitle   String?    @map("meta_title")
  metaDesc    String?    @map("meta_description")
  
  // Relationships
  products    Product[]
  
  // Temporal mapping
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")
  
  // Map to categories table
  @@map("product_categories")
  
  // Hierarchical and performance indexes
  @@index([parentId], map: "idx_categories_parent")
  @@index([slug], map: "idx_categories_slug")
  @@index([isActive, sortOrder], map: "idx_categories_active_sort")
}

/// Enumeration with database mapping
enum OrderStatus {
  PENDING    @map("pending")
  CONFIRMED  @map("confirmed")
  PROCESSING @map("processing")
  SHIPPED    @map("shipped")
  DELIVERED  @map("delivered")
  CANCELLED  @map("cancelled")
  REFUNDED   @map("refunded")
  
  @@map("order_status_enum")
}
```

### 2. Advanced Mapping Patterns

```typescript
// ==========================================
// ADVANCED DATABASE MAPPING STRATEGIES
// ==========================================

/// Mapping patterns for different database conventions
interface DatabaseMappingPatterns {
  
  // Convention-based mapping strategies
  conventions: {
    snake_case: {
      description: "Traditional database snake_case naming";
      example: {
        model: "UserProfile",
        table: "user_profiles",
        fields: {
          firstName: "first_name",
          lastName: "last_name",
          phoneNumber: "phone_number",
          createdAt: "created_at"
        }
      };
      prismaPattern: "@@map(\"user_profiles\")";
    };
    
    camelCase: {
      description: "Modern database camelCase naming";
      example: {
        model: "UserProfile", 
        table: "userProfiles",
        fields: {
          firstName: "firstName",
          lastName: "lastName", 
          phoneNumber: "phoneNumber",
          createdAt: "createdAt"
        }
      };
      prismaPattern: "@@map(\"userProfiles\")";
    };
    
    legacy_UPPER: {
      description: "Legacy system UPPER_CASE naming";
      example: {
        model: "Product",
        table: "PRODUCT_MASTER",
        fields: {
          productId: "PROD_ID",
          productName: "PROD_NAME",
          unitPrice: "UNIT_PRICE",
          createdDate: "CREATE_DATE"
        }
      };
      prismaPattern: "@@map(\"PRODUCT_MASTER\")";
    };
    
    prefixed: {
      description: "Prefixed table naming convention";
      example: {
        model: "User",
        table: "app_users",
        fields: {
          id: "user_id",
          email: "user_email",
          status: "user_status"
        }
      };
      prismaPattern: "@@map(\"app_users\")";
    };
  };
  
  // Multi-database mapping strategies
  crossDatabase: {
    postgresql: {
      schema: "public",
      tablePrefix: "",
      columnNaming: "snake_case",
      example: "@@map(\"public.users\")"
    };
    
    mysql: {
      database: "application_db",
      tablePrefix: "app_",
      columnNaming: "camelCase",
      example: "@@map(\"app_users\")"
    };
    
    sqlite: {
      fileLocation: "./data/app.db",
      tablePrefix: "",
      columnNaming: "mixed_case",
      example: "@@map(\"Users\")"
    };
    
    sqlserver: {
      schema: "dbo",
      tablePrefix: "tbl",
      columnNaming: "PascalCase",
      example: "@@map(\"dbo.tblUsers\")"
    };
  };
  
  // Migration and evolution patterns
  evolution: {
    version1_to_version2: {
      description: "Evolving from legacy to modern naming";
      steps: [
        "Map current models to legacy tables",
        "Create migration to new naming convention",
        "Update model mappings gradually",
        "Remove old table mappings after migration"
      ];
      example: {
        legacy: "@@map(\"USER_MASTER\")",
        transitional: "@@map(\"user_master\")",
        modern: "@@map(\"users\")"
      };
    };
    
    namespace_evolution: {
      description: "Adding namespace or schema prefixes";
      progression: [
        "@@map(\"users\")",           // Simple table
        "@@map(\"app_users\")",       // Application prefix
        "@@map(\"v2.users\")",        // Version namespace
        "@@map(\"tenant_1.users\")"   // Multi-tenant schema
      ];
    };
  };
  
  // Best practices for mapping
  bestPractices: {
    consistency: {
      rule: "Maintain consistent naming convention across all models";
      example: "If using snake_case, apply it to all tables and columns";
    };
    
    readability: {
      rule: "Choose mapping that improves code readability";
      example: "Map cryptic legacy names to descriptive model names";
    };
    
    performance: {
      rule: "Consider database performance implications of naming";
      example: "Shorter names can improve query performance in some databases";
    };
    
    migration: {
      rule: "Plan mapping strategy for smooth schema migrations";
      example: "Use temporary mapping during migration periods";
    };
  };
}
```

---

## ‚ö° Performance Indexing Strategies

### 1. Strategic Index Configuration with @@index

```prisma
// ==========================================
// STRATEGIC INDEXING CONFIGURATIONS
// ==========================================

/// User model with comprehensive indexing strategy
/// Demonstrates various indexing patterns for optimal query performance
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String?  @unique
  firstName String?
  lastName  String?
  phone     String?
  city      String?
  country   String?
  
  // Account status and metadata
  isActive    Boolean  @default(true)
  isVerified  Boolean  @default(false)
  role        UserRole @default(USER)
  
  // Temporal fields
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastLoginAt DateTime?
  
  // Relationships
  posts       Post[]
  orders      Order[]
  profile     UserProfile?
  
  @@map("users")
  
  // Single-column indexes for frequent lookups
  @@index([email], name: "idx_users_email")           // Login queries
  @@index([username], name: "idx_users_username")     // Profile lookups
  @@index([phone], name: "idx_users_phone")           // Contact searches
  
  // Composite indexes for multi-field queries
  @@index([firstName, lastName], name: "idx_users_name")           // Name searches
  @@index([city, country], name: "idx_users_location")             // Location queries
  @@index([isActive, role], name: "idx_users_active_role")         // Active user role queries
  @@index([isVerified, createdAt], name: "idx_users_verified_date") // Verification tracking
  
  // Temporal indexes for time-based queries
  @@index([createdAt], name: "idx_users_created")                  // Registration analytics
  @@index([lastLoginAt], name: "idx_users_last_login")             // Activity tracking
  
  // Status-based indexes for admin queries
  @@index([role, isActive], name: "idx_users_role_status")         // User management
  @@index([isActive, createdAt], name: "idx_users_active_created") // Active user trends
}

/// Product model with e-commerce specific indexing
model Product {
  id          String   @id @default(cuid())
  sku         String   @unique
  name        String
  description String?
  
  // Pricing fields
  price       Decimal  @db.Decimal(10, 2)
  salePrice   Decimal? @db.Decimal(10, 2)
  costPrice   Decimal? @db.Decimal(10, 2)
  
  // Categorization
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id])
  subcategory String?
  brand       String?
  
  // Status and visibility
  status      ProductStatus @default(DRAFT)
  isActive    Boolean       @default(true)
  isVisible   Boolean       @default(true)
  isFeatured  Boolean       @default(false)
  isOnSale    Boolean       @default(false)
  
  // Inventory
  stockQty    Int      @default(0)
  
  // SEO and metadata
  slug        String?  @unique
  tags        String[]
  
  // Performance metrics
  viewCount   Int      @default(0)
  saleCount   Int      @default(0)
  avgRating   Decimal? @db.Decimal(3, 2)
  
  // Temporal fields
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  vendor      User     @relation("VendorProducts", fields: [vendorId], references: [id])
  vendorId    String
  reviews     Review[]
  orderItems  OrderItem[]
  
  @@map("products")
  
  // Primary business indexes
  @@index([sku], name: "idx_products_sku")                         // Inventory lookups
  @@index([slug], name: "idx_products_slug")                       // SEO-friendly URLs
  @@index([categoryId], name: "idx_products_category")             // Category browsing
  
  // E-commerce catalog indexes
  @@index([categoryId, status, isVisible], name: "idx_products_catalog")      // Product listings
  @@index([isFeatured, status], name: "idx_products_featured")                // Featured products
  @@index([isOnSale, status], name: "idx_products_sale")                      // Sale items
  @@index([brand, categoryId], name: "idx_products_brand_category")           // Brand filtering
  
  // Pricing and inventory indexes
  @@index([price], name: "idx_products_price")                     // Price-based searches
  @@index([stockQty], name: "idx_products_stock")                  // Inventory management
  @@index([isActive, stockQty], name: "idx_products_active_stock") // Available products
  
  // Performance and analytics indexes
  @@index([viewCount], name: "idx_products_views")                 // Popular products
  @@index([avgRating], name: "idx_products_rating")                // Top-rated products
  @@index([saleCount], name: "idx_products_sales")                 // Best sellers
  
  // Vendor and admin indexes
  @@index([vendorId, status], name: "idx_products_vendor_status")  // Vendor management
  @@index([createdAt], name: "idx_products_created")               // New product tracking
  
  // Full-text search indexes (PostgreSQL specific)
  @@index([name, description], name: "idx_products_search", type: Gin)
  @@index([tags], name: "idx_products_tags", type: Gin)
}

/// Order model with comprehensive transaction indexing
model Order {
  id            String      @id @default(cuid())
  orderNumber   String      @unique @default(uuid())
  
  // Customer relationship
  customerId    String
  customer      User        @relation(fields: [customerId], references: [id])
  
  // Order status and workflow
  status        OrderStatus @default(PENDING)
  paymentStatus String      @default("unpaid")
  
  // Financial data
  subtotal      Decimal     @default(0.00) @db.Decimal(12, 2)
  taxAmount     Decimal     @default(0.00) @db.Decimal(10, 2)
  totalAmount   Decimal     @default(0.00) @db.Decimal(12, 2)
  currency      String      @default("USD")
  
  // Temporal workflow
  orderDate     DateTime    @default(now())
  shippedDate   DateTime?
  deliveredDate DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Location and delivery
  city          String?
  country       String?
  
  // Relationships
  items         OrderItem[]
  
  @@map("orders")
  
  // Customer and relationship indexes
  @@index([customerId], name: "idx_orders_customer")               // Customer order history
  @@index([customerId, orderDate], name: "idx_orders_customer_date") // Chronological customer orders
  
  // Business workflow indexes
  @@index([status], name: "idx_orders_status")                     // Order status tracking
  @@index([paymentStatus], name: "idx_orders_payment")             // Payment processing
  @@index([status, paymentStatus], name: "idx_orders_workflow")    // Complete workflow state
  
  // Financial and reporting indexes
  @@index([orderDate], name: "idx_orders_date")                    // Daily/monthly reporting
  @@index([totalAmount], name: "idx_orders_amount")                // Revenue analysis
  @@index([currency, orderDate], name: "idx_orders_currency_date") // Multi-currency reporting
  
  // Geographic and shipping indexes
  @@index([country, orderDate], name: "idx_orders_country_date")   // Geographic sales
  @@index([city, country], name: "idx_orders_location")            // Location-based analytics
  
  // Fulfillment and logistics indexes
  @@index([shippedDate], name: "idx_orders_shipped")               // Shipping tracking
  @@index([deliveredDate], name: "idx_orders_delivered")           // Delivery tracking
  @@index([status, shippedDate], name: "idx_orders_fulfillment")   // Fulfillment pipeline
  
  // Performance and analytics indexes
  @@index([orderNumber], name: "idx_orders_number")                // Order lookup
  @@index([createdAt], name: "idx_orders_created")                 // Order trends
}

/// Event model with specialized indexing for scheduling
model Event {
  id          String      @id @default(cuid())
  title       String
  description String?
  
  // Temporal scheduling
  startDate   DateTime
  endDate     DateTime?
  timezone    String      @default("UTC")
  
  // Event details
  location    String?
  isVirtual   Boolean     @default(false)
  maxAttendees Int?
  
  // Organization and categorization
  organizerId String
  organizer   User        @relation(fields: [organizerId], references: [id])
  category    String?
  tags        String[]
  
  // Status and visibility
  status      EventStatus @default(DRAFT)
  isPublic    Boolean     @default(true)
  
  // Registration
  requiresRegistration Boolean @default(false)
  registrationFee      Decimal? @db.Decimal(8, 2)
  
  // Temporal tracking
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  @@map("events")
  
  // Temporal scheduling indexes - most critical for events
  @@index([startDate], name: "idx_events_start")                   // Event calendar queries
  @@index([startDate, endDate], name: "idx_events_timespan")       // Time range queries
  @@index([startDate, timezone], name: "idx_events_start_timezone") // Timezone-aware queries
  
  // Geographic and categorization indexes
  @@index([location], name: "idx_events_location")                 // Location-based events
  @@index([category], name: "idx_events_category")                 // Category browsing
  @@index([tags], name: "idx_events_tags", type: Gin)              // Tag-based search
  
  // Organizer and management indexes
  @@index([organizerId], name: "idx_events_organizer")             // Organizer's events
  @@index([organizerId, startDate], name: "idx_events_organizer_date") // Organizer calendar
  
  // Public discovery indexes
  @@index([isPublic, startDate], name: "idx_events_public_start")  // Public event calendar
  @@index([status, isPublic], name: "idx_events_status_public")    // Published events
  
  // Registration and capacity indexes
  @@index([requiresRegistration], name: "idx_events_registration") // Registration events
  @@index([maxAttendees], name: "idx_events_capacity")             // Capacity management
  
  // Advanced composite indexes for complex queries
  @@index([category, startDate, isPublic], name: "idx_events_category_date_public")
  @@index([location, startDate, status], name: "idx_events_location_date_status")
}

/// Enums for indexed status fields
enum UserRole {
  ADMIN
  MANAGER
  USER
  GUEST
  
  @@map("user_roles")
}

enum ProductStatus {
  DRAFT
  REVIEW
  PUBLISHED
  ARCHIVED
  DELETED
  
  @@map("product_statuses")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
  
  @@map("order_statuses")
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
  
  @@map("event_statuses")
}
```

### 2. Advanced Indexing Patterns

```typescript
// ==========================================
// ADVANCED INDEXING STRATEGIES
// ==========================================

/// Advanced indexing patterns for different query scenarios
interface AdvancedIndexingPatterns {
  
  // Query pattern-based indexing
  queryPatterns: {
    equalityQueries: {
      description: "Single-value exact match queries";
      examples: ["WHERE email = ?", "WHERE status = ?", "WHERE userId = ?"];
      indexStrategy: "Single-column B-tree indexes";
      prismaPattern: "@@index([email])";
    };
    
    rangeQueries: {
      description: "Range-based queries with inequalities";
      examples: ["WHERE price BETWEEN ? AND ?", "WHERE createdAt > ?"];
      indexStrategy: "Single-column B-tree indexes on range fields";
      prismaPattern: "@@index([price]), @@index([createdAt])";
    };
    
    sortingQueries: {
      description: "Queries with ORDER BY clauses";
      examples: ["ORDER BY createdAt DESC", "ORDER BY price ASC, name ASC"];
      indexStrategy: "Indexes matching sort columns and order";
      prismaPattern: "@@index([createdAt]), @@index([price, name])";
    };
    
    filterAndSort: {
      description: "Combined filtering and sorting";
      examples: ["WHERE status = ? ORDER BY createdAt DESC"];
      indexStrategy: "Composite indexes with filter fields first";
      prismaPattern: "@@index([status, createdAt])";
    };
    
    multiColumnFilters: {
      description: "Multiple column filtering";
      examples: ["WHERE category = ? AND status = ? AND isActive = ?"];
      indexStrategy: "Composite indexes with most selective fields first";
      prismaPattern: "@@index([category, status, isActive])";
    };
  };
  
  // Database-specific indexing optimizations
  databaseOptimizations: {
    postgresql: {
      btree: {
        description: "Default B-tree indexes for most queries";
        bestFor: ["Equality", "Range", "Sorting"];
        example: "@@index([email])  // B-tree by default";
      };
      
      gin: {
        description: "Generalized Inverted Index for complex data";
        bestFor: ["JSON", "Arrays", "Full-text search"];
        example: "@@index([tags], type: Gin)";
      };
      
      gist: {
        description: "Generalized Search Tree for spatial data";
        bestFor: ["Geographic data", "Custom types"];
        example: "@@index([location], type: Gist)";
      };
      
      hash: {
        description: "Hash indexes for equality-only queries";
        bestFor: ["Exact match lookups"];
        example: "@@index([userId], type: Hash)";
      };
    };
    
    mysql: {
      btree: {
        description: "Default B-tree indexes";
        bestFor: ["Standard queries", "Range operations"];
        example: "@@index([email])";
      };
      
      fulltext: {
        description: "Full-text search indexes";
        bestFor: ["Text search operations"];
        example: "@@index([title, content], type: Fulltext)";
      };
      
      spatial: {
        description: "Spatial indexes for geographic data";
        bestFor: ["Geographic queries"];
        example: "@@index([coordinates], type: Spatial)";
      };
    };
  };
  
  // Performance considerations
  performanceStrategies: {
    indexSelectivity: {
      description: "Choose indexes based on data selectivity";
      guidelines: {
        highSelectivity: "Index fields with many unique values (email, username)",
        lowSelectivity: "Avoid indexing fields with few unique values (boolean flags)",
        compositeSelectivity: "Lead composite indexes with most selective fields"
      };
    };
    
    indexMaintenance: {
      description: "Consider write performance impact of indexes";
      guidelines: {
        readHeavy: "More indexes acceptable for read-heavy workloads",
        writeHeavy: "Minimize indexes for write-heavy workloads",
        balance: "Monitor index usage and remove unused indexes"
      };
    };
    
    memoryUsage: {
      description: "Indexes consume memory and storage";
      guidelines: {
        hotData: "Ensure critical indexes fit in memory",
        coldData: "Consider partial indexes for large tables",
        monitoring: "Monitor index size and usage statistics"
      };
    };
  };
  
  // Common indexing anti-patterns to avoid
  antiPatterns: {
    tooManyIndexes: {
      problem: "Creating indexes for every possible query";
      impact: "Slows down writes, wastes storage";
      solution: "Index only frequent, performance-critical queries";
    };
    
    wrongColumnOrder: {
      problem: "Composite indexes with columns in wrong order";
      impact: "Indexes not used for queries";
      solution: "Most selective and frequently filtered columns first";
    };
    
    duplicateIndexes: {
      problem: "Multiple indexes covering same query patterns";
      impact: "Wasted resources, maintenance overhead";
      solution: "Consolidate overlapping indexes";
    };
    
    unusedIndexes: {
      problem: "Indexes created but never used by queries";
      impact: "Write performance penalty for no benefit";
      solution: "Monitor index usage and remove unused indexes";
    };
  };
}
```

---

## üîê Unique Constraints & Data Integrity

### 1. Single and Composite Unique Constraints

```prisma
// ==========================================
// UNIQUE CONSTRAINT CONFIGURATIONS
// ==========================================

/// User model with comprehensive uniqueness constraints
/// Demonstrates various unique constraint patterns for data integrity
model User {
  id        String   @id @default(cuid())
  
  // Single-field unique constraints
  email     String   @unique                         // Primary login identifier
  username  String?  @unique                         // Public display name
  phone     String?  @unique                         // Contact verification
  
  // Personal information
  firstName String?
  lastName  String?
  
  // System-generated unique identifiers
  apiKey    String?  @unique @default(uuid())        // API access key
  
  // Account status
  isActive  Boolean  @default(true)
  
  // Temporal fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relationships
  profile   UserProfile?
  socialAccounts SocialAccount[]
  
  @@map("users")
  
  // Composite unique constraints for business rules
  @@unique([firstName, lastName, email], name: "uk_users_full_identity")
  
  // Indexes for unique fields (automatically created but can be named)
  @@index([email], name: "idx_users_email")
  @@index([username], name: "idx_users_username")
}

/// Social account model with platform-specific uniqueness
model SocialAccount {
  id         String @id @default(cuid())
  
  // Platform and user relationship
  platform   String                                   // e.g., "github", "google", "facebook"
  providerId String                                   // Platform-specific user ID
  userId     String
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Account details
  providerEmail    String?                           // Email from provider
  providerUsername String?                           // Username from provider
  
  // Metadata
  accessToken  String?
  refreshToken String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("social_accounts")
  
  // Ensure one account per platform per user
  @@unique([userId, platform], name: "uk_social_user_platform")
  
  // Ensure unique provider IDs per platform
  @@unique([platform, providerId], name: "uk_social_platform_provider")
  
  // Prevent duplicate provider emails per platform
  @@unique([platform, providerEmail], name: "uk_social_platform_email")
}

/// Product model with business-specific unique constraints
model Product {
  id          String @id @default(cuid())
  
  // Business identifiers - must be unique
  sku         String @unique                          // Stock Keeping Unit
  upc         String? @unique                         // Universal Product Code
  slug        String? @unique                         // SEO-friendly URL
  
  // Product information
  name        String
  description String?
  
  // Vendor relationship
  vendorId    String
  vendor      User   @relation("VendorProducts", fields: [vendorId], references: [id])
  
  // Categorization
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id])
  
  // Status and temporal
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("products")
  
  // Business rule: Unique product name per vendor
  @@unique([vendorId, name], name: "uk_products_vendor_name")
  
  // Business rule: Unique slug per category (for SEO)
  @@unique([categoryId, slug], name: "uk_products_category_slug")
  
  // Indexes for unique constraints
  @@index([sku], name: "idx_products_sku")
  @@index([vendorId], name: "idx_products_vendor")
}

/// Order model with transaction-specific unique constraints
model Order {
  id            String      @id @default(cuid())
  
  // Business identifiers
  orderNumber   String      @unique                   // Customer-facing order number
  invoiceNumber String?     @unique                   // Invoice reference
  
  // Customer relationship
  customerId    String
  customer      User        @relation(fields: [customerId], references: [id])
  
  // Order details
  status        OrderStatus @default(PENDING)
  totalAmount   Decimal     @default(0.00) @db.Decimal(12, 2)
  
  // External system references
  paymentId     String?     @unique                   // Payment processor ID
  trackingNumber String?    @unique                   // Shipping tracking number
  
  // Temporal
  orderDate     DateTime    @default(now())
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  // Relationships
  items         OrderItem[]
  
  @@map("orders")
  
  // Business rule: Unique tracking number when assigned
  // (handled automatically by @unique on trackingNumber)
  
  // Indexes
  @@index([customerId], name: "idx_orders_customer")
  @@index([orderDate], name: "idx_orders_date")
}

/// Order item model with line-item specific constraints
model OrderItem {
  id        String  @id @default(cuid())
  
  // Relationships
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  productId String
  product   Product @relation(fields: [productId], references: [id])
  
  // Item details
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)
  
  // Temporal
  createdAt DateTime @default(now())
  
  @@map("order_items")
  
  // Business rule: Each product can only appear once per order
  @@unique([orderId, productId], name: "uk_order_items_order_product")
  
  // Indexes
  @@index([orderId], name: "idx_order_items_order")
  @@index([productId], name: "idx_order_items_product")
}

/// Event model with scheduling-specific unique constraints
model Event {
  id          String      @id @default(cuid())
  
  // Event identification
  title       String
  slug        String?     @unique                     // SEO-friendly URL
  
  // Scheduling
  startDate   DateTime
  endDate     DateTime?
  location    String?
  
  // Organization
  organizerId String
  organizer   User        @relation(fields: [organizerId], references: [id])
  
  // Status
  status      EventStatus @default(DRAFT)
  isPublic    Boolean     @default(true)
  
  // External references
  zoomMeetingId String?   @unique                     // Zoom meeting ID
  calendarEventId String? @unique                     // Calendar integration ID
  
  // Temporal
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  // Relationships
  registrations EventRegistration[]
  
  @@map("events")
  
  // Business rule: No overlapping events at same location for same organizer
  @@unique([organizerId, location, startDate], name: "uk_events_organizer_location_time")
  
  // Business rule: Unique slug per organizer (for personal event pages)
  @@unique([organizerId, slug], name: "uk_events_organizer_slug")
  
  // Indexes
  @@index([startDate], name: "idx_events_start")
  @@index([organizerId], name: "idx_events_organizer")
}

/// Event registration with participation constraints
model EventRegistration {
  id        String   @id @default(cuid())
  
  // Relationships
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Registration details
  status    RegistrationStatus @default(PENDING)
  
  // External references
  ticketNumber String? @unique                        // Ticket number if applicable
  
  // Temporal
  registeredAt DateTime @default(now())
  
  @@map("event_registrations")
  
  // Business rule: One registration per user per event
  @@unique([eventId, userId], name: "uk_registrations_event_user")
  
  // Indexes
  @@index([eventId], name: "idx_registrations_event")
  @@index([userId], name: "idx_registrations_user")
}

/// API key model with access control constraints
model ApiKey {
  id          String   @id @default(cuid())
  
  // Key identification
  key         String   @unique @default(uuid())        // The actual API key
  name        String                                   // Human-readable name
  
  // Ownership
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Access control
  permissions String[] @default([])                    // Granted permissions
  isActive    Boolean  @default(true)
  
  // Usage tracking
  lastUsedAt  DateTime?
  usageCount  Int      @default(0)
  
  // Temporal
  createdAt   DateTime @default(now())
  expiresAt   DateTime?                                // Optional expiration
  
  @@map("api_keys")
  
  // Business rule: Unique key name per user
  @@unique([userId, name], name: "uk_api_keys_user_name")
  
  // Indexes
  @@index([key], name: "idx_api_keys_key")
  @@index([userId], name: "idx_api_keys_user")
  @@index([expiresAt], name: "idx_api_keys_expires")
}

/// Enums for status fields
enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
  
  @@map("order_statuses")
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
  
  @@map("event_statuses")
}

enum RegistrationStatus {
  PENDING
  CONFIRMED
  CANCELLED
  ATTENDED
  NO_SHOW
  
  @@map("registration_statuses")
}
```

### 2. Advanced Unique Constraint Patterns

```typescript
// ==========================================
// ADVANCED UNIQUE CONSTRAINT STRATEGIES
// ==========================================

/// Advanced patterns for complex uniqueness requirements
interface AdvancedUniquePatterns {
  
  // Conditional uniqueness patterns
  conditionalUniqueness: {
    activeRecords: {
      description: "Uniqueness only among active records";
      challenge: "Standard unique constraints apply to all records including soft-deleted";
      solution: "Partial unique indexes (database-specific) or application logic";
      example: {
        requirement: "Unique username among active users only",
        prismaLimitation: "@@unique([username]) applies to all records",
        workaround: "Application-level validation + database triggers"
      };
    };
    
    tenantIsolation: {
      description: "Uniqueness within tenant boundaries";
      pattern: "@@unique([tenantId, field])";
      example: {
        requirement: "Unique email per organization",
        implementation: "@@unique([organizationId, email])",
        benefit: "Same email can exist in different organizations"
      };
    };
    
    temporalUniqueness: {
      description: "Uniqueness within time periods";
      challenge: "Standard constraints don't consider time ranges";
      examples: {
        nonOverlappingBookings: "@@unique([resourceId, startDate, endDate])",
        uniquePerMonth: "Application logic for monthly uniqueness",
        activeSubscriptions: "One active subscription per user per service"
      };
    };
  };
  
  // Multi-table uniqueness patterns
  crossTableUniqueness: {
    globalIdentifiers: {
      description: "Unique identifiers across multiple tables";
      challenge: "Prisma unique constraints are model-specific";
      solutions: [
        "Shared identifier table",
        "Application-level validation",
        "Database triggers",
        "UUID generation strategies"
      ];
      example: {
        requirement: "Unique tracking numbers across orders and shipments",
        implementation: "Separate TrackingNumber model with references"
      };
    };
    
    hierarchicalUniqueness: {
      description: "Uniqueness within hierarchical structures";
      patterns: {
        categoryPath: "Unique category names within parent category",
        organizationalHierarchy: "Unique roles within department",
        nestedResources: "Unique names within parent resource"
      };
      prismaPattern: "@@unique([parentId, name])";
    };
  };
  
  // Performance considerations for unique constraints
  performanceOptimization: {
    indexStrategy: {
      description: "Unique constraints automatically create indexes";
      considerations: [
        "Unique constraints create underlying unique indexes",
        "Order of fields in composite constraints affects index usage",
        "Consider query patterns when ordering constraint fields"
      ];
    };
    
    largeTableOptimization: {
      description: "Unique constraint performance on large tables";
      strategies: [
        "Partial unique indexes for sparse data",
        "Hash-based uniqueness for very large strings",
        "Prefix uniqueness for long text fields"
      ];
    };
  };
  
  // Business rule enforcement patterns
  businessRuleEnforcement: {
    dataIntegrity: {
      description: "Enforce business rules through uniqueness";
      examples: {
        singleActiveSession: "@@unique([userId, isActive]) where isActive = true",
        primaryContact: "One primary contact per customer",
        defaultPaymentMethod: "One default payment method per user"
      };
    };
    
    auditAndCompliance: {
      description: "Uniqueness for audit and compliance requirements";
      examples: {
        transactionIdentifiers: "Unique transaction IDs for financial audit",
        documentVersions: "Unique version numbers per document",
        complianceRecords: "Unique compliance check per period"
      };
    };
  };
  
  // Error handling and validation
  errorHandling: {
    constraintViolations: {
      description: "Handling unique constraint violations gracefully";
      strategies: [
        "Pre-validation before database operations",
        "Graceful error handling with meaningful messages",
        "Retry logic for concurrent insertion scenarios",
        "User-friendly conflict resolution"
      ];
    };
    
    cascadeConsiderations: {
      description: "Unique constraints and cascade operations";
      considerations: [
        "Cascade deletes may free up unique values",
        "Soft deletes may prevent reuse of unique values",
        "Migration strategies for changing unique constraints"
      ];
    };
  };
}

/// Example implementations for complex unique constraint scenarios
class AdvancedUniqueConstraintImplementations {
  
  // Conditional uniqueness implementation example
  async validateConditionalUniqueness(
    organizationId: string, 
    email: string, 
    excludeUserId?: string
  ): Promise<boolean> {
    // Application-level validation for active users only
    const existingUser = await prisma.user.findFirst({
      where: {
        organizationId,
        email,
        isActive: true,
        ...(excludeUserId && { id: { not: excludeUserId } })
      }
    });
    
    return !existingUser;
  }
  
  // Cross-table uniqueness implementation
  async ensureGlobalUniqueTrackingNumber(trackingNumber: string): Promise<boolean> {
    // Check across multiple tables for tracking number uniqueness
    const [orderExists, shipmentExists] = await Promise.all([
      prisma.order.findFirst({ where: { trackingNumber } }),
      prisma.shipment.findFirst({ where: { trackingNumber } })
    ]);
    
    return !orderExists && !shipmentExists;
  }
  
  // Temporal uniqueness validation
  async validateNonOverlappingBooking(
    resourceId: string,
    startDate: Date,
    endDate: Date,
    excludeBookingId?: string
  ): Promise<boolean> {
    const overlappingBooking = await prisma.booking.findFirst({
      where: {
        resourceId,
        AND: [
          { startDate: { lt: endDate } },
          { endDate: { gt: startDate } }
        ],
        ...(excludeBookingId && { id: { not: excludeBookingId } })
      }
    });
    
    return !overlappingBooking;
  }
  
  // Hierarchical uniqueness validation
  async validateUniqueWithinParent(
    parentId: string | null,
    name: string,
    excludeId?: string
  ): Promise<boolean> {
    const existing = await prisma.category.findFirst({
      where: {
        parentId,
        name,
        ...(excludeId && { id: { not: excludeId } })
      }
    });
    
    return !existing;
  }
}
```

---

## üß† Knowledge Check

### Model Attributes Mastery Quiz

1. **What is the primary purpose of the @@map attribute in Prisma?**
   - [ ] A) To create database indexes
   - [x] B) To map model names to database table names
   - [ ] C) To define unique constraints
   - [ ] D) To specify field types

   **Explanation**: The `@@map` attribute maps Prisma model names to specific database table names, allowing for different naming conventions between code and database while maintaining clean, readable code.

2. **Which index type is best for searching within JSON arrays in PostgreSQL?**
   - [ ] A) B-tree
   - [x] B) GIN (Generalized Inverted Index)
   - [ ] C) Hash
   - [ ] D) GIST

   **Explanation**: GIN indexes are specifically designed for complex data types like JSON arrays and provide efficient searching within array contents and JSON structures.

3. **How do you create a composite unique constraint in Prisma?**
   - [ ] A) @unique([field1, field2])
   - [x] B) @@unique([field1, field2])
   - [ ] C) @composite([field1, field2])
   - [ ] D) @@constraint([field1, field2])

   **Explanation**: The `@@unique([field1, field2])` syntax creates a composite unique constraint across multiple fields at the model level, ensuring the combination of values is unique.

### Practical Exercise: E-commerce Platform Optimization

**Challenge**: Design a comprehensive e-commerce platform with optimized model attributes

**Scenario**: Create a high-performance e-commerce system with proper mapping, indexing, and constraints

**Requirements**:
1. Map models to legacy database table names
2. Implement strategic indexing for common e-commerce queries
3. Add unique constraints for business rule enforcement
4. Optimize for both read and write performance
5. Handle multi-tenant scenarios with proper constraints

**Solution Template**:
```prisma
model Organization {
  id String @id @default(cuid())
  // Add multi-tenant organization model
  
  @@map("legacy_organizations")
  // Add strategic indexes and constraints
}

model Product {
  id String @id @default(cuid())
  // Add comprehensive product model with optimization
  
  @@map("product_catalog")
  // Add e-commerce specific indexes and constraints
}

model Order {
  id String @id @default(cuid())
  // Add order model with financial transaction optimization
  
  @@map("customer_orders")
  // Add transaction and reporting indexes
}
```

**Validation Checklist**:
- [ ] Database table mapping implemented with @@map
- [ ] Strategic indexes for common query patterns
- [ ] Unique constraints for business rule enforcement
- [ ] Composite indexes for multi-field queries
- [ ] Performance optimization for read-heavy operations
- [ ] Multi-tenant isolation through proper constraints

---

## üí° Key Takeaways

- üèõÔ∏è **Infrastructure Design**: Model attributes create sophisticated database infrastructure like a metropolitan library system
- üó∫Ô∏è **Strategic Mapping**: @@map attributes align code models with database schemas for clean architecture
- ‚ö° **Performance Optimization**: Strategic indexing with @@index dramatically improves query performance
- üîê **Data Integrity**: @@unique constraints enforce business rules and prevent data duplication
- üéØ **Query Patterns**: Index design should match actual application query patterns
- üèóÔ∏è **Scalability Focus**: Proper attribute configuration enables applications to scale efficiently
- üìä **Business Logic**: Constraints and indexes enforce business rules at the database level
- üõ°Ô∏è **Production Ready**: Advanced attribute patterns create robust, enterprise-grade data models

---

## üîó Navigation

**üìç Current Location**: Module 3 ‚Üí Section 3.2 ‚Üí Lesson 3.2.5

**‚¨ÖÔ∏è Previous**: [3.2.4 Default Values & Auto-generation](./3.2.4-default-values-auto-generation.md)
**‚û°Ô∏è Next**: [3.3.1 Scalar Types](../3.3-data-types-attributes/3.3.1-scalar-types.md)

**üè† Section Home**: [3.2 Data Model & Models](./README.md)
**üìö Module Home**: [Module 3: Prisma Schema](../README.md)

**üó∫Ô∏è Quick Links**:
- [Model Attributes Reference](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#model-attributes)
- [Index Configuration Guide](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#index)
- [Unique Constraints Documentation](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#unique)
- [Database Mapping Best Practices](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#mapping-model-names-to-tables)

---

*üéâ Outstanding! You've completed Section 3.2 Data Model & Models! You've mastered model attributes for production-ready database optimization. Next, we'll explore Section 3.3 Data Types & Attributes for advanced type handling!*
