# 3.2.1 Model Declaration & Naming Conventions

## 📋 Section Overview
- **Duration**: 12 minutes
- **Prerequisites**: 
  - Completed Section 3.1: Schema Overview & Structure
  - Understanding of basic database concepts
  - Familiarity with object-oriented programming principles
- **Learning Objectives**: 
  - Master Prisma model declaration syntax and structure
  - Implement professional naming convention strategies
  - Apply database table mapping and optimization techniques
  - Understand model-to-database entity relationships
  - Create maintainable and scalable model architectures
- **Difficulty Level**: Beginner

---

## 🎯 What You'll Learn

By the end of this lesson, you will:
- ✅ Declare models with proper syntax and structure
- ✅ Apply professional naming conventions for models and fields
- ✅ Implement database table mapping strategies
- ✅ Understand model-to-entity relationships
- ✅ Create scalable and maintainable model architectures

---

## 📖 Content

### Understanding Model Declaration Architecture

Declaring Prisma models is like **designing the blueprint for a sophisticated office building**. Just as architects create detailed floor plans that define office spaces with specific purposes, structural layouts that support the building's functionality, naming systems that help people navigate efficiently, standardized conventions that ensure consistency across floors, and scalable designs that can accommodate future growth—Prisma models define data entities with clear business purposes, field structures that support application functionality, naming conventions that improve code readability, consistent patterns that enhance maintainability, and flexible architectures that scale with application requirements.

### 🏢 Office Building Blueprint Analogy

```
🏢 Office Building Blueprint = 📊 Prisma Model Declaration

🗂️ Office Space Planning (Model Structure)
├── Executive offices → Primary business entities (User, Order, Product)
├── Department areas → Feature-specific models (Profile, Review, Category)
├── Common areas → Shared utility models (Address, Contact, Settings)
├── Storage rooms → Data management models (AuditLog, File, Cache)
└── Meeting rooms → Relationship junction models (UserRole, OrderItem)

📋 Naming & Signage System (Naming Conventions)
├── Building standards → PascalCase for model names (UserProfile)
├── Room numbering → Consistent field naming (camelCase)
├── Department labels → Descriptive model purposes (PaymentMethod)
├── Navigation aids → Clear relationship naming (posts, author)
└── Emergency exits → Error-prone name avoidance (reserved words)

🔧 Infrastructure Mapping (Database Mapping)
├── Electrical systems → Primary key configuration (@id)
├── Plumbing layout → Foreign key relationships
├── HVAC zones → Index optimization (@@index)
├── Security systems → Unique constraints (@@unique)
└── Building codes → Database table mapping (@@map)

📐 Architectural Standards (Best Practices)
├── Building regulations → Model naming consistency
├── Accessibility requirements → Field accessibility patterns
├── Safety protocols → Data integrity constraints
├── Maintenance guidelines → Schema evolution strategies
└── Future expansion → Scalable design patterns
```

---

## 🏗️ Model Declaration Fundamentals

### 1. Basic Model Syntax & Structure

```prisma
// ==========================================
// BASIC MODEL DECLARATION SYNTAX
// ==========================================

/// Basic model structure following Prisma conventions
/// Models represent the core entities of your application domain
model User {
  // Primary identifier - every model needs a unique identifier
  id        String   @id @default(cuid())
  
  // Core fields - fundamental entity properties
  email     String   @unique
  username  String?  @unique
  name      String?
  
  // Timestamps - audit trail and lifecycle tracking
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Status management - entity state tracking
  isActive  Boolean  @default(true)
  
  // Relationships - connections to other entities
  profile   Profile?
  posts     Post[]
  comments  Comment[]
  
  // Database optimization
  @@map("users")           // Maps to 'users' table in database
  @@index([email])         // Index for fast email lookups
  @@index([username])      // Index for username searches
  @@index([createdAt])     // Index for chronological queries
}

/// Extended model with comprehensive field types
/// Demonstrates various field types and modifiers
model UserProfile {
  // Composite primary key relationship
  userId String @id
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Personal information fields
  firstName String?  @db.VarChar(50)    // Database-specific type
  lastName  String?  @db.VarChar(50)
  bio       String?  @db.Text           // Large text field
  avatar    String?  @db.Text           // Image URL or base64
  
  // Contact information
  phone     String?  @db.VarChar(20)
  website   String?  @db.VarChar(255)
  
  // Location and preferences
  timezone  String   @default("UTC")
  language  String   @default("en")
  country   String?  @db.VarChar(2)     // ISO country code
  
  // Privacy settings
  isPublic  Boolean  @default(true)
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("user_profiles")
  @@index([firstName, lastName])        // Composite index for name searches
}

/// Business entity model with advanced features
/// Showcases complex field relationships and constraints
model Post {
  // Unique identifier with auto-increment (alternative pattern)
  id        Int      @id @default(autoincrement())
  
  // Content fields with validation
  title     String   @db.VarChar(200)   // Limited title length
  slug      String   @unique @db.VarChar(255)  // SEO-friendly URL
  content   String   @db.Text           // Main post content
  excerpt   String?  @db.VarChar(500)   // Short description
  
  // Publishing workflow
  status    PostStatus @default(DRAFT)   // Enum for status management
  published Boolean    @default(false)
  
  // SEO and metadata
  metaTitle       String? @db.VarChar(60)
  metaDescription String? @db.VarChar(160)
  
  // Engagement metrics (denormalized for performance)
  viewCount    Int @default(0)
  likeCount    Int @default(0)
  commentCount Int @default(0)
  
  // Timestamps with automatic updates
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  publishedAt DateTime?                  // Set when published
  
  // Author relationship
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Category relationships (many-to-many)
  categories PostCategory[]
  
  // Comment relationships (one-to-many)
  comments   Comment[]
  
  // Database optimization and constraints
  @@map("posts")
  @@unique([authorId, slug])             // Unique slug per author
  @@index([status, publishedAt])         // Publishing queries
  @@index([authorId, createdAt])         // Author's posts chronologically
  @@index([slug])                        // Fast slug lookups
}

/// Enumeration for type-safe status management
/// Enums provide controlled value sets and type safety
enum PostStatus {
  DRAFT      // Work in progress
  REVIEW     // Ready for review
  PUBLISHED  // Live and visible
  ARCHIVED   // Removed from public view
  DELETED    // Soft deleted
  
  @@map("post_statuses")
}
```

### 2. Professional Naming Convention Strategies

```typescript
// ==========================================
// NAMING CONVENTION BEST PRACTICES
// ==========================================

/// Comprehensive naming convention guidelines for Prisma models
interface NamingConventionGuide {
  
  // Model Naming Standards
  modelNaming: {
    // Use PascalCase for model names
    correct: [
      "User",           // Single entity
      "UserProfile",    // Compound entity
      "BlogPost",       // Business entity
      "PaymentMethod",  // Multi-word entity
      "OrderItem"       // Junction entity
    ];
    
    incorrect: [
      "user",           // Should be capitalized
      "userProfile",    // Should start with capital
      "User_Profile",   // No underscores
      "userprofile",    // No camelCase
      "USERPROFILE"     // No all caps
    ];
    
    // Singular vs Plural
    modelForm: "singular";  // Always use singular form
    examples: {
      correct: "User",    // Not "Users"
      correct: "Post",    // Not "Posts"
      correct: "Category" // Not "Categories"
    };
  };
  
  // Field Naming Standards
  fieldNaming: {
    // Use camelCase for field names
    correct: [
      "id",             // Simple identifier
      "firstName",      // Compound field
      "createdAt",      // Timestamp field
      "isActive",       // Boolean field
      "phoneNumber",    // Multi-word field
      "authorId"        // Foreign key field
    ];
    
    incorrect: [
      "FirstName",      // No PascalCase
      "first_name",     // No snake_case
      "FIRSTNAME",      // No all caps
      "firstName_",     // No trailing underscore
      "first-name"      // No hyphens
    ];
    
    // Special Field Naming Patterns
    patterns: {
      foreignKeys: "entityId",        // authorId, categoryId
      booleans: "isCondition",        // isActive, isPublic
      timestamps: "actionedAt",       // createdAt, updatedAt
      counts: "entityCount",          // viewCount, likeCount
      arrays: "pluralEntity"          // posts, comments, tags
    };
  };
  
  // Relationship Naming Standards
  relationshipNaming: {
    oneToOne: {
      // One-to-one relationships use singular form
      parent: "profile",      // User has one profile
      child: "user"           // Profile belongs to one user
    };
    
    oneToMany: {
      // One-to-many relationships
      parent: "posts",        // User has many posts
      child: "author"         // Post belongs to one author
    };
    
    manyToMany: {
      // Many-to-many relationships use descriptive names
      through: "categories",  // Post has many categories
      back: "posts"          // Category has many posts
    };
  };
  
  // Database Mapping Standards
  databaseMapping: {
    // Table names use snake_case and plural form
    tableNaming: {
      modelName: "User",
      tableName: "users",        // Plural, snake_case
      mapping: '@@map("users")'
    };
    
    // Column names use snake_case
    columnNaming: {
      fieldName: "firstName",
      columnName: "first_name",  // snake_case in database
      mapping: '@map("first_name")'
    };
    
    // Index naming follows consistent patterns
    indexNaming: {
      single: "idx_users_email",           // idx_table_column
      composite: "idx_posts_author_status", // idx_table_col1_col2
      unique: "uk_users_username"          // uk_table_column
    };
  };
}

// Real-world naming examples
const namingExamples = {
  // E-commerce domain models
  ecommerce: {
    core: [
      "User",           // Customer or admin user
      "Product",        // Product catalog item
      "Category",       // Product categorization
      "Order",          // Purchase order
      "OrderItem",      // Individual order line item
      "Payment",        // Payment transaction
      "ShippingAddress", // Delivery address
      "Review"          // Product review
    ],
    
    extended: [
      "WishlistItem",   // User's saved products
      "ShoppingCart",   // Active shopping session
      "DiscountCode",   // Promotional codes
      "InventoryItem",  // Stock management
      "ShippingMethod", // Delivery options
      "PaymentMethod",  // Stored payment info
      "ProductVariant", // Product variations
      "CategoryTree"    // Hierarchical categories
    ]
  },
  
  // Social media domain models
  socialMedia: {
    core: [
      "User",           // Platform user
      "Post",           // Content post
      "Comment",        // Post comment
      "Like",           // Engagement action
      "Follow",         // User relationship
      "Message",        // Direct message
      "Group",          // User groups
      "Event"           // Social events
    ],
    
    extended: [
      "UserProfile",    // Extended user info
      "PostMedia",      // Attached media files
      "CommentThread", // Nested comments
      "NotificationSetting", // User preferences
      "ActivityLog",    // User activity tracking
      "ReportedContent", // Content moderation
      "UserSession",    // Login sessions
      "FriendRequest"   // Relationship requests
    ]
  }
};
```

### 3. Database Mapping & Optimization Strategies

```prisma
// ==========================================
// DATABASE MAPPING & OPTIMIZATION
// ==========================================

/// Advanced database mapping techniques for optimal performance
/// Demonstrates how to align Prisma models with database best practices

// Model with comprehensive database mappings
model User {
  // Primary key with custom database column
  id        String   @id @default(cuid()) @map("user_id")
  
  // Fields with database-specific types and mappings
  email     String   @unique @map("email_address") @db.VarChar(255)
  username  String?  @unique @map("user_name") @db.VarChar(50)
  firstName String?  @map("first_name") @db.VarChar(50)
  lastName  String?  @map("last_name") @db.VarChar(50)
  
  // Timestamps with database defaults
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz
  lastLogin DateTime? @map("last_login_at") @db.Timestamptz
  
  // Status fields with database constraints
  isActive    Boolean @default(true) @map("is_active")
  isVerified  Boolean @default(false) @map("is_verified")
  
  // JSON field for flexible data storage
  metadata    Json?   @map("user_metadata") @db.Jsonb
  
  // Relationships
  profile     UserProfile?
  posts       Post[]       @relation("UserPosts")
  comments    Comment[]    @relation("UserComments")
  
  // Database table mapping and optimization
  @@map("users")                              // Table name mapping
  @@index([email], name: "idx_users_email")   // Named email index
  @@index([username], name: "idx_users_username") // Named username index
  @@index([isActive, createdAt], name: "idx_users_active_created") // Composite index
  @@index([lastLogin], name: "idx_users_last_login") // Login analytics index
}

/// Model with advanced performance optimizations
model Product {
  // Efficient primary key strategy
  id          String   @id @default(cuid()) @map("product_id")
  
  // SKU with unique constraint and index
  sku         String   @unique @map("product_sku") @db.VarChar(50)
  
  // Text fields with appropriate database types
  name        String   @map("product_name") @db.VarChar(200)
  description String   @map("product_description") @db.Text
  shortDesc   String?  @map("short_description") @db.VarChar(500)
  
  // Pricing with precise decimal handling
  price       Decimal  @map("unit_price") @db.Decimal(10, 2)
  costPrice   Decimal? @map("cost_price") @db.Decimal(10, 2)
  
  // Inventory tracking
  stockQty    Int      @default(0) @map("stock_quantity")
  lowStock    Int      @default(5) @map("low_stock_threshold")
  
  // Status and visibility
  status      ProductStatus @default(DRAFT) @map("product_status")
  isVisible   Boolean       @default(true) @map("is_visible")
  isFeatured  Boolean       @default(false) @map("is_featured")
  
  // SEO fields
  slug        String   @unique @map("url_slug") @db.VarChar(255)
  metaTitle   String?  @map("meta_title") @db.VarChar(60)
  metaDesc    String?  @map("meta_description") @db.VarChar(160)
  
  // Categorical relationships
  categoryId  String   @map("category_id")
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  
  // Vendor relationship
  vendorId    String   @map("vendor_id")
  vendor      User     @relation("VendorProducts", fields: [vendorId], references: [id])
  
  // Performance metrics (denormalized)
  viewCount   Int      @default(0) @map("view_count")
  saleCount   Int      @default(0) @map("sale_count")
  avgRating   Decimal? @map("average_rating") @db.Decimal(3, 2)
  
  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz
  
  // Related models
  reviews     Review[]    @relation("ProductReviews")
  orderItems  OrderItem[] @relation("ProductOrders")
  
  // Advanced database optimization
  @@map("products")
  
  // Strategic indexes for common query patterns
  @@index([categoryId, status, isVisible], name: "idx_products_category_status")
  @@index([vendorId, status], name: "idx_products_vendor_status")
  @@index([slug], name: "idx_products_slug")
  @@index([price], name: "idx_products_price")
  @@index([stockQty], name: "idx_products_stock")
  @@index([isFeatured, status], name: "idx_products_featured")
  @@index([createdAt], name: "idx_products_created")
  @@index([avgRating], name: "idx_products_rating")
  
  // Full-text search index (PostgreSQL specific)
  @@index([name, description], name: "idx_products_search", type: Gin)
}

/// Enumeration with database mapping
enum ProductStatus {
  DRAFT      @map("draft")
  REVIEW     @map("review")
  PUBLISHED  @map("published")
  ARCHIVED   @map("archived")
  DELETED    @map("deleted")
  
  @@map("product_status_enum")
}

/// Junction model for many-to-many relationships
model ProductCategory {
  // Composite primary key
  productId  String  @map("product_id")
  categoryId String  @map("category_id")
  
  // Relationship fields
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  // Additional junction data
  isPrimary  Boolean  @default(false) @map("is_primary_category")
  sortOrder  Int?     @map("sort_order")
  
  // Timestamps
  createdAt  DateTime @default(now()) @map("created_at")
  
  // Composite primary key
  @@id([productId, categoryId])
  @@map("product_categories")
  
  // Indexes for efficient queries
  @@index([categoryId], name: "idx_product_categories_category")
  @@index([productId], name: "idx_product_categories_product")
}
```

### 4. Model Architecture Patterns

```typescript
// ==========================================
// SCALABLE MODEL ARCHITECTURE PATTERNS
// ==========================================

/// Advanced patterns for building maintainable and scalable model architectures
class ModelArchitecturePatterns {
  
  /// 1. Inheritance-like patterns using shared fields
  getBaseEntityPattern(): string {
    return `
      /// Base entity pattern - common fields for all models
      /// Use this pattern for consistent entity management
      
      // Abstract base fields (add to models as needed)
      // id        String   @id @default(cuid())
      // createdAt DateTime @default(now())
      // updatedAt DateTime @updatedAt
      // deletedAt DateTime? // Soft deletion support
      
      model User {
        // Base entity fields
        id        String   @id @default(cuid())
        createdAt DateTime @default(now())
        updatedAt DateTime @updatedAt
        deletedAt DateTime?
        
        // User-specific fields
        email     String   @unique
        name      String?
        
        // Relationships
        posts     Post[]
        
        @@map("users")
      }
      
      model Post {
        // Base entity fields
        id        String   @id @default(cuid())
        createdAt DateTime @default(now())
        updatedAt DateTime @updatedAt
        deletedAt DateTime?
        
        // Post-specific fields
        title     String
        content   String
        
        // Relationships
        authorId  String
        author    User     @relation(fields: [authorId], references: [id])
        
        @@map("posts")
      }
    `;
  }
  
  /// 2. Polymorphic-like relationships using discriminated unions
  getPolymorphicPattern(): string {
    return `
      /// Polymorphic-like pattern for flexible relationships
      /// Example: Comments that can belong to Posts or Products
      
      model Comment {
        id          String      @id @default(cuid())
        content     String
        
        // Polymorphic relationship fields
        targetType  TargetType  // Enum: POST, PRODUCT
        targetId    String      // ID of the target entity
        
        // Optional specific relationships (use based on targetType)
        post        Post?       @relation(fields: [targetId], references: [id])
        product     Product?    @relation(fields: [targetId], references: [id])
        
        @@map("comments")
        @@index([targetType, targetId])
      }
      
      enum TargetType {
        POST
        PRODUCT
      }
    `;
  }
  
  /// 3. Versioning pattern for evolving schemas
  getVersioningPattern(): string {
    return `
      /// Schema versioning pattern for backward compatibility
      /// Useful when migrating data structures
      
      model User {
        id          String   @id @default(cuid())
        
        // Current fields
        email       String   @unique
        profile     UserProfile?
        
        // Legacy field support (deprecated but maintained)
        legacyData  Json?    // Store old structure during migration
        
        // Version tracking
        schemaVersion Int    @default(2) // Current schema version
        
        @@map("users")
      }
      
      model UserProfile {
        userId      String   @id
        user        User     @relation(fields: [userId], references: [id])
        
        // Version 2 fields (current)
        firstName   String?
        lastName    String?
        bio         String?
        
        // Migration helper fields
        migratedAt  DateTime? // When migrated from legacy structure
        
        @@map("user_profiles")
      }
    `;
  }
  
  /// 4. Event sourcing pattern for audit trails
  getEventSourcingPattern(): string {
    return `
      /// Event sourcing pattern for comprehensive audit trails
      /// Track all changes to critical business entities
      
      model User {
        id          String   @id @default(cuid())
        email       String   @unique
        name        String?
        
        // Current state
        currentState Json    // Computed from events
        version      Int     @default(1) // Optimistic locking
        
        // Event relationships
        events       UserEvent[]
        
        @@map("users")
      }
      
      model UserEvent {
        id          String      @id @default(cuid())
        
        // Event metadata
        eventType   EventType   // CREATED, UPDATED, DELETED
        eventData   Json        // Event payload
        
        // Audit information
        occurredAt  DateTime    @default(now())
        triggeredBy String?     // User who triggered the event
        
        // Target entity
        userId      String
        user        User        @relation(fields: [userId], references: [id])
        
        @@map("user_events")
        @@index([userId, occurredAt])
      }
      
      enum EventType {
        CREATED
        UPDATED
        DELETED
        RESTORED
      }
    `;
  }
  
  /// 5. Multi-tenancy pattern for SaaS applications
  getMultiTenancyPattern(): string {
    return `
      /// Multi-tenancy pattern for SaaS applications
      /// Isolate data by organization/tenant
      
      model Organization {
        id          String   @id @default(cuid())
        name        String
        subdomain   String   @unique
        
        // Subscription and billing
        plan        String   @default("free")
        isActive    Boolean  @default(true)
        
        // Tenant relationships
        users       User[]
        projects    Project[]
        
        @@map("organizations")
      }
      
      model User {
        id             String   @id @default(cuid())
        email          String   @unique
        
        // Multi-tenant isolation
        organizationId String
        organization   Organization @relation(fields: [organizationId], references: [id])
        
        // User data
        projects       Project[]
        
        @@map("users")
        @@index([organizationId])
      }
      
      model Project {
        id             String   @id @default(cuid())
        name           String
        
        // Multi-tenant isolation
        organizationId String
        organization   Organization @relation(fields: [organizationId], references: [id])
        
        // Project owner
        ownerId        String
        owner          User     @relation(fields: [ownerId], references: [id])
        
        @@map("projects")
        @@index([organizationId])
        @@index([ownerId])
      }
    `;
  }
}
```

---

## 🧠 Knowledge Check

### Model Declaration Mastery Quiz

1. **What is the correct naming convention for Prisma models?**
   - [ ] A) snake_case
   - [x] B) PascalCase
   - [ ] C) camelCase
   - [ ] D) UPPER_CASE

   **Explanation**: Prisma models use PascalCase following standard conventions. Models represent entities and should be named like classes in object-oriented programming.

2. **Which attribute is used to map a model to a database table?**
   - [ ] A) @map
   - [x] B) @@map
   - [ ] C) @table
   - [ ] D) @@table

   **Explanation**: The `@@map` attribute is used to map a Prisma model to a specific table name in the database, allowing for different naming conventions between code and database.

3. **What is the recommended approach for model names?**
   - [x] A) Singular form (User, not Users)
   - [ ] B) Plural form (Users, not User)
   - [ ] C) Either singular or plural
   - [ ] D) Depends on the database type

   **Explanation**: Prisma models should use singular form as they represent a single entity instance. The database table can be plural using `@@map` if needed.

### Practical Exercise: Model Architecture Design

**Challenge**: Design a comprehensive model architecture for a project management system

**Requirements**:
1. Create models for Users, Projects, Tasks, and Teams
2. Apply proper naming conventions throughout
3. Implement database mapping for optimization
4. Include relationship definitions
5. Add appropriate indexes for performance

**Solution Template**:
```prisma
// Your model declarations here
model User {
  // Implement user model with proper conventions
}

model Project {
  // Implement project model with relationships
}

// Add more models...
```

**Validation Checklist**:
- [ ] Models use PascalCase naming
- [ ] Fields use camelCase naming
- [ ] Database mapping implemented with @@map
- [ ] Primary keys properly defined
- [ ] Indexes added for performance
- [ ] Relationships clearly defined

---

## 💡 Key Takeaways

- 🏢 **Blueprint Architecture**: Model declaration is like creating detailed office building blueprints
- 📝 **Naming Consistency**: Use PascalCase for models and camelCase for fields consistently
- 🗄️ **Database Mapping**: Leverage @@map to align with database naming conventions
- 🔗 **Relationship Clarity**: Define clear relationships between models for data integrity
- ⚡ **Performance Focus**: Strategic indexing improves query performance significantly
- 📐 **Scalable Patterns**: Apply architectural patterns for maintainable and scalable schemas
- 🎯 **Business Alignment**: Model names should reflect business domain concepts clearly

---

## 🔗 Navigation

**📍 Current Location**: Module 3 → Section 3.2 → Lesson 3.2.1

**⬅️ Previous**: [3.1.5 Multi-file Schema Organization](../3.1-schema-overview-structure/3.1.5-multi-file-schema-organization.md)
**➡️ Next**: [3.2.2 Field Types & Modifiers](./3.2.2-field-types-modifiers.md)

**🏠 Section Home**: [3.2 Data Model & Models](./README.md)
**📚 Module Home**: [Module 3: Prisma Schema](../README.md)

**🗺️ Quick Links**:
- [Previous Section: Schema Organization](../3.1-schema-overview-structure/README.md)
- [Next: Field Types & Modifiers](./3.2.2-field-types-modifiers.md)
- [Prisma Model Reference](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#model)
- [Naming Conventions Guide](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#naming-conventions)

---

*🏗️ Excellent! You've mastered model declaration and naming conventions. Next, we'll dive deep into field types and modifiers for robust data modeling!*
