# 3.1.3 Comments & Documentation Best Practices

## 📋 Section Overview
- **Duration**: 10 minutes
- **Prerequisites**: 
  - Completed lessons 3.1.1 and 3.1.2 (Schema Organization & Configuration)
  - Understanding of schema file structure
  - Basic knowledge of team collaboration practices
- **Learning Objectives**: 
  - Master effective schema documentation strategies
  - Implement comment patterns for team collaboration
  - Create self-documenting schema designs
  - Apply documentation standards for maintainability
  - Develop schema communication best practices
- **Difficulty Level**: Beginner

---

## 🎯 What You'll Learn

By the end of this lesson, you will:
- ✅ Write clear and effective schema comments and documentation
- ✅ Implement team collaboration comment strategies
- ✅ Create self-documenting schema patterns
- ✅ Apply documentation standards for long-term maintainability
- ✅ Use advanced documentation techniques for complex schemas

---

## 📖 Content

### Understanding Schema Documentation Strategy

Creating effective Prisma schema documentation is like **building a detailed architectural manual for a complex skyscraper**. Just as architects create comprehensive blueprints that include detailed annotations explaining structural purposes, material specifications that guide construction teams, safety protocols that ensure building integrity, maintenance instructions that enable long-term care, and design rationale that helps future architects understand decisions—Prisma schema documentation provides clear field explanations that guide developers, business logic annotations that explain data relationships, validation rules that ensure data integrity, usage examples that demonstrate proper implementation, and design decisions that help future maintainers understand the schema evolution.

### 🏗️ Architectural Documentation Analogy

```
🏗️ Skyscraper Blueprint Manual = 📚 Prisma Schema Documentation

📐 Structural Annotations (Schema Comments)
├── Foundation details → Database configuration comments
├── Floor specifications → Model and field descriptions
├── Room purposes → Business logic explanations
├── Safety systems → Validation and constraint notes
└── Building codes → Compliance and standard references

📋 Material Specifications (Type Documentation)
├── Steel grades → Data type explanations
├── Concrete mixes → Field attribute purposes
├── Glass properties → Relationship descriptions
├── Insulation types → Performance considerations
└── Finishing materials → UI/UX integration notes

🔧 Construction Guidelines (Implementation Notes)
├── Assembly instructions → Usage examples
├── Tool requirements → Required dependencies
├── Quality checks → Validation procedures
├── Safety protocols → Error handling patterns
└── Inspection points → Testing strategies

📝 Maintenance Manual (Evolution Documentation)
├── Inspection schedules → Schema review cycles
├── Replacement procedures → Migration strategies
├── Upgrade pathways → Version compatibility notes
├── Troubleshooting guides → Common issue solutions
└── Contact information → Team responsibility mapping
```

---

## 💬 Comment Types & Strategies

### 1. Schema-Level Documentation

```prisma
// ==========================================
// E-COMMERCE PLATFORM SCHEMA
// ==========================================
// Version: 2.1.0
// Created: 2024-01-15
// Last Updated: 2024-08-07
// Team: Backend Development Team
// 
// Purpose: Core data models for multi-vendor e-commerce platform
// supporting B2B and B2C transactions with inventory management,
// order processing, and customer relationship management.
//
// Key Features:
// - Multi-vendor marketplace support
// - Real-time inventory tracking
// - Advanced pricing strategies
// - Comprehensive audit trails
// - GDPR compliance ready
//
// Dependencies:
// - PostgreSQL 14+ (JSONB support required)
// - Redis for session management
// - Elasticsearch for search functionality
//
// Related Documentation:
// - API Documentation: /docs/api/v2
// - Database ERD: /docs/database/erd.png
// - Business Rules: /docs/business/rules.md
// ==========================================

generator client {
  provider = "prisma-client-js"
  output   = "./src/generated/prisma-client"
  
  // Performance optimization for large datasets
  previewFeatures = ["fieldReference", "fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  
  // Direct connection for serverless deployments
  // Bypasses connection pooling for Vercel/Netlify
  directUrl = env("DIRECT_DATABASE_URL")
}
```

### 2. Model Documentation Patterns

```prisma
// ==========================================
// CORE BUSINESS ENTITIES
// ==========================================

/// User account management for customers and vendors
/// Supports both B2B (business) and B2C (individual) users
/// 
/// Key Features:
/// - Role-based access control (RBAC)
/// - Email verification workflow
/// - Multi-factor authentication support
/// - GDPR compliance with data retention policies
/// 
/// Business Rules:
/// - Email must be unique across the platform
/// - Soft deletion preserves referential integrity
/// - Created accounts require email verification within 24h
/// - Inactive accounts are archived after 2 years
/// 
/// Related Models: Profile, Order, Review, Vendor
/// API Endpoints: /api/users, /api/auth
/// Last Updated: 2024-08-07 by Backend Team
model User {
  // Primary identification
  id        String   @id @default(cuid()) /// Collision-resistant unique identifier
  email     String   @unique             /// Primary contact and login identifier
  
  // Authentication & Security
  password  String                       /// Hashed using bcrypt with salt rounds=12
  isActive  Boolean  @default(true)      /// Account status - false = soft deleted
  
  // Verification & Compliance
  emailVerified    Boolean   @default(false)  /// Email ownership confirmation
  emailVerifiedAt  DateTime?                  /// Timestamp of email verification
  
  // Account Management
  role      UserRole @default(CUSTOMER)       /// RBAC: CUSTOMER, VENDOR, ADMIN, MODERATOR
  createdAt DateTime @default(now())          /// Account creation timestamp
  updatedAt DateTime @updatedAt               /// Last profile modification
  
  // Soft Deletion Support
  deletedAt DateTime?                         /// Soft deletion timestamp (GDPR compliance)
  
  // ==========================================
  // RELATIONSHIPS
  // ==========================================
  
  /// User profile information (1:1 relationship)
  /// Contains personal data subject to GDPR
  profile Profile?
  
  /// Orders placed by this user (1:many)
  /// Preserved for audit trails even after user deletion
  orders  Order[]
  
  /// Product reviews written by user (1:many)
  /// Anonymized upon account deletion
  reviews Review[]
  
  /// Vendor account if user is a seller (1:1 optional)
  /// Separate business entity with additional compliance requirements
  vendor  Vendor?
  
  // ==========================================
  // CONSTRAINTS & INDEXES
  // ==========================================
  
  @@map("users")                              /// Database table name
  @@index([email])                           /// Fast email lookups for auth
  @@index([role])                            /// Role-based query optimization
  @@index([createdAt])                       /// Chronological user analysis
  @@index([deletedAt])                       /// Soft deletion queries
}

/// User role enumeration for access control
/// Defines permission levels across the platform
enum UserRole {
  CUSTOMER   /// Standard user - can browse and purchase
  VENDOR     /// Seller account - can list and sell products  
  ADMIN      /// Platform administrator - full system access
  MODERATOR  /// Content moderator - review and approval permissions
  
  @@map("user_roles")
}

/// Extended user profile information
/// Separated for performance and privacy compliance
/// 
/// Privacy Notes:
/// - Contains PII subject to GDPR Article 17 (Right to Erasure)
/// - Data retention policy: 7 years for tax purposes
/// - Anonymization process available via /api/privacy/anonymize
/// 
/// Performance Notes:
/// - Profile data loaded separately to optimize user authentication
/// - Large text fields (bio) stored with compression
model Profile {
  // Primary relationship
  userId String @id /// Foreign key to User.id (1:1 relationship)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Personal Information (PII - Handle with care)
  firstName String?  @db.VarChar(50)    /// Given name (optional for privacy)
  lastName  String?  @db.VarChar(50)    /// Family name (optional for privacy)
  
  // Contact Information
  phone     String?  @db.VarChar(20)    /// Phone number with country code
  
  // Address Information (Nested JSON for flexibility)
  address   Json?                       /// Structured address data {street, city, country, postal}
  
  // Profile Enhancement
  avatar    String?  @db.Text          /// Profile image URL or base64 data
  bio       String?  @db.Text          /// User description (max 1000 chars in app logic)
  
  // Preferences & Settings
  language  String   @default("en")    /// Preferred language code (ISO 639-1)
  timezone  String   @default("UTC")   /// User timezone (IANA format)
  currency  String   @default("USD")   /// Preferred currency code (ISO 4217)
  
  // Marketing & Communication
  marketingOptIn Boolean @default(false) /// Email marketing consent (GDPR compliant)
  
  // Timestamps
  createdAt DateTime @default(now())   /// Profile creation
  updatedAt DateTime @updatedAt        /// Last profile update
  
  @@map("user_profiles")
  @@index([firstName, lastName])       /// Name-based search optimization
  @@index([phone])                     /// Phone number lookup
}
```

### 3. Field-Level Documentation Patterns

```prisma
/// Product catalog management for multi-vendor marketplace
/// Supports variable pricing, inventory tracking, and SEO optimization
model Product {
  // ==========================================
  // CORE IDENTIFICATION
  // ==========================================
  
  /// Unique product identifier - stable across all operations
  /// Format: Collision-resistant 25-character string
  /// Usage: API routes, internal references, cache keys
  /// Never changes: Safe for external API consumption
  id String @id @default(cuid())
  
  /// Human-readable product identifier for vendors
  /// Format: Vendor-defined alphanumeric code (e.g., "TSHIRT-001")
  /// Constraints: Unique per vendor, 3-50 characters
  /// Usage: Vendor management, customer service, inventory systems
  sku String @db.VarChar(50)
  
  /// SEO-friendly URL identifier for product pages
  /// Format: Lowercase, hyphen-separated (e.g., "wireless-bluetooth-headphones")
  /// Auto-generated from title but manually editable
  /// Constraints: Unique globally, URL-safe characters only
  /// Usage: Product page routing, breadcrumbs, social sharing
  slug String @unique @db.VarChar(100)
  
  // ==========================================
  // CONTENT & PRESENTATION
  // ==========================================
  
  /// Primary product name for display across the platform
  /// Constraints: 5-200 characters, supports Unicode for international products
  /// SEO Impact: Used in meta titles, product listings, search results
  /// Content Guidelines: Include key features, avoid excessive capitalization
  title String @db.VarChar(200)
  
  /// Detailed product description with rich formatting support
  /// Format: Markdown-compatible HTML subset
  /// SEO Impact: Primary content for search ranking
  /// Content Guidelines: Focus on benefits, include specifications
  /// Length: 100-5000 characters recommended for SEO
  description String @db.Text
  
  /// Brief product summary for cards and listings
  /// Format: Plain text, single paragraph
  /// Usage: Category pages, search results, mobile views
  /// Length: 50-300 characters optimal for UI layouts
  summary String? @db.VarChar(500)
  
  // ==========================================
  // PRICING & FINANCIAL
  // ==========================================
  
  /// Base product price in platform currency (USD cents)
  /// Storage: Integer to avoid floating-point precision issues
  /// Format: Price in smallest currency unit (e.g., 2999 = $29.99)
  /// Business Rule: Cannot be negative, required for active products
  /// Display: Convert to decimal for UI (price / 100)
  price Int
  
  /// Original price before any discounts (USD cents)
  /// Usage: Strike-through pricing, discount calculations
  /// Business Rule: Must be >= price when set, null = no original price
  /// Display: Shows discount percentage in UI
  originalPrice Int?
  
  /// Product cost for vendor profit calculations (USD cents)
  /// Privacy: Vendor-only field, never exposed to customers
  /// Usage: Profit margin reports, pricing recommendations
  /// Business Rule: Should be <= price for positive margins
  cost Int?
  
  // ==========================================
  // INVENTORY & LOGISTICS
  // ==========================================
  
  /// Current available inventory count
  /// Updates: Real-time via order processing and stock adjustments
  /// Business Rules: Non-negative, triggers low-stock alerts at 5 units
  /// Performance: Indexed for fast availability queries
  stock Int @default(0)
  
  /// Minimum inventory level before reorder alerts
  /// Usage: Automatic vendor notifications, inventory management
  /// Business Rule: Should be > 0 for products requiring stock management
  lowStockThreshold Int @default(5)
  
  /// Enable inventory tracking for this product
  /// Usage: Digital products, services may not require tracking
  /// Impact: When false, stock checks are bypassed in order processing
  trackInventory Boolean @default(true)
  
  /// Physical dimensions for shipping calculations
  /// Format: JSON object {length, width, height, unit}
  /// Units: Supports "cm", "in" - converted internally to metric
  /// Usage: Shipping cost calculation, packaging optimization
  dimensions Json?
  
  /// Product weight for shipping calculations
  /// Format: Decimal value with unit (e.g., {value: 1.5, unit: "kg"})
  /// Usage: Shipping cost calculation, logistics planning
  weight Json?
  
  // ==========================================
  // PRODUCT STATUS & LIFECYCLE
  // ==========================================
  
  /// Product publication status in the marketplace
  /// DRAFT: Work in progress, vendor-only visibility
  /// PUBLISHED: Live and discoverable by customers
  /// ARCHIVED: Removed from listings, orders still processable
  /// BANNED: Violates platform policies, completely hidden
  status ProductStatus @default(DRAFT)
  
  /// Product visibility in search and categories
  /// Business Rule: Even published products can be hidden temporarily
  /// Usage: A/B testing, seasonal products, maintenance
  isVisible Boolean @default(true)
  
  /// Allow customer orders for this product
  /// Usage: Sold-out products, coming soon items, discontinued items
  /// Business Rule: Can be false even when stock > 0 (manual control)
  isOrderable Boolean @default(true)
  
  /// Product requires age verification before purchase
  /// Usage: Alcohol, tobacco, adult content, restricted items
  /// Legal: Compliance with regional age verification laws
  /// Impact: Adds verification step in checkout process
  ageRestricted Boolean @default(false)
  
  // ==========================================
  // SEO & MARKETING
  // ==========================================
  
  /// Custom meta title for search engines
  /// Usage: Overrides default title in HTML meta tags
  /// SEO Best Practice: 50-60 characters, include primary keyword
  /// Fallback: Uses 'title' field when null
  metaTitle String? @db.VarChar(60)
  
  /// Meta description for search engine results
  /// Usage: SERP snippet text, social media previews
  /// SEO Best Practice: 150-160 characters, compelling and descriptive
  /// Fallback: Truncated 'description' field when null
  metaDescription String? @db.VarChar(160)
  
  /// Structured search keywords for internal search optimization
  /// Format: Comma-separated list of relevant terms
  /// Usage: Search algorithm boosting, auto-complete suggestions
  /// Management: Auto-generated from title/description + manual additions
  searchKeywords String[] @default([])
  
  /// Featured product flag for promotional placement
  /// Usage: Homepage carousels, category highlights, special promotions
  /// Business Rule: Limited number per category, admin/vendor configurable
  isFeatured Boolean @default(false)
  
  // ==========================================
  // AUDIT & COMPLIANCE
  // ==========================================
  
  /// Product creation timestamp (immutable)
  /// Usage: Analytics, vendor reporting, platform metrics
  /// Timezone: Always stored in UTC for consistency
  createdAt DateTime @default(now())
  
  /// Last modification timestamp (auto-updated)
  /// Usage: Change tracking, cache invalidation, sync operations
  /// Triggers: Any field modification updates this timestamp
  updatedAt DateTime @updatedAt
  
  /// Product publication timestamp
  /// Usage: "New arrival" badges, chronological sorting
  /// Business Rule: Set when status changes to PUBLISHED
  publishedAt DateTime?
  
  /// Soft deletion timestamp for data retention compliance
  /// Usage: GDPR compliance, data recovery, audit trails
  /// Business Rule: Soft deleted products retain order history
  deletedAt DateTime?
  
  // ==========================================
  // RELATIONSHIPS & FOREIGN KEYS
  // ==========================================
  
  /// Vendor who owns and manages this product
  /// Constraint: Required - every product must have an owner
  /// Cascade: Products are deleted when vendor is removed
  /// Usage: Revenue tracking, vendor dashboards, support tickets
  vendorId String
  vendor   Vendor @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  
  /// Primary product category for navigation and filtering
  /// Business Rule: Required for published products
  /// Usage: Category pages, filtered search, analytics
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  
  /// Product image gallery for visual presentation
  /// Relationship: One product can have multiple images
  /// Order: First image serves as primary/thumbnail
  /// Constraints: At least one image required for published products
  images ProductImage[]
  
  /// Customer reviews and ratings for social proof
  /// Business Rule: Only verified purchasers can review
  /// Moderation: Reviews subject to platform content policies
  /// Impact: Average rating affects search ranking and conversions
  reviews Review[]
  
  /// Shopping cart entries for purchase intent tracking
  /// Usage: Abandoned cart recovery, inventory reservations
  /// Cleanup: Entries older than 30 days are automatically removed
  cartItems CartItem[]
  
  /// Order line items for sales tracking and fulfillment
  /// Relationship: Many-to-many through OrderItem join table
  /// Retention: Preserved indefinitely for financial/legal compliance
  orderItems OrderItem[]
  
  // ==========================================
  // DATABASE OPTIMIZATION
  // ==========================================
  
  @@map("products")                           /// Physical table name in database
  @@unique([vendorId, sku])                  /// Vendor-scoped SKU uniqueness
  @@index([status, isVisible])               /// Product listing queries
  @@index([categoryId, status])              /// Category page optimization
  @@index([vendorId, status])                /// Vendor dashboard queries
  @@index([price])                           /// Price-based sorting and filtering
  @@index([createdAt])                       /// Chronological queries (new arrivals)
  @@index([stock, lowStockThreshold])        /// Inventory management queries
  @@index([searchKeywords])                  /// Search optimization (GIN index in PostgreSQL)
  @@index([isFeatured, status])              /// Featured product queries
  @@index([deletedAt])                       /// Soft deletion filtering
}

/// Product lifecycle and visibility states
/// Controls product availability and discoverability
enum ProductStatus {
  DRAFT     /// Work in progress - vendor only
  PUBLISHED /// Live and available to customers
  ARCHIVED  /// Removed from listings but orders still valid
  BANNED    /// Policy violation - completely hidden
  
  @@map("product_statuses")
}
```

### 4. Relationship Documentation

```prisma
/// Order management system with comprehensive audit trails
/// Supports multi-vendor orders with split payment processing
model Order {
  // Core identification
  id        String @id @default(cuid())
  
  /// Human-readable order number for customer service
  /// Format: ORD-YYYY-NNNNNN (e.g., "ORD-2024-000001")
  /// Generation: Sequential per year, zero-padded to 6 digits
  /// Usage: Customer communication, support tickets, invoices
  orderNumber String @unique @db.VarChar(20)
  
  // ==========================================
  // RELATIONSHIP DOCUMENTATION PATTERNS
  // ==========================================
  
  /// Customer who placed this order
  /// 
  /// Relationship Type: Many-to-One (Many orders → One customer)
  /// Cascade Behavior: Restrict deletion (preserve order history)
  /// Business Rule: Required - anonymous orders not supported
  /// 
  /// Data Flow:
  /// 1. Customer browses → adds items to cart
  /// 2. Checkout process → creates order with customer reference
  /// 3. Order processing → customer receives notifications
  /// 4. Post-purchase → customer can view order history
  /// 
  /// Performance Considerations:
  /// - Indexed for fast customer order lookup
  /// - Consider denormalizing customer email for search
  /// 
  /// Privacy & GDPR:
  /// - Customer data subject to right of erasure
  /// - Order preserved but customer info anonymized
  /// - Retention: 7 years for tax/legal compliance
  customerId String
  customer   User   @relation(fields: [customerId], references: [id], onDelete: Restrict)
  
  /// Individual product line items in this order
  /// 
  /// Relationship Type: One-to-Many (One order → Many items)
  /// Join Pattern: Direct foreign key in OrderItem
  /// Cascade Behavior: Delete all items when order deleted
  /// 
  /// Business Logic:
  /// - Order total = sum of all item totals
  /// - Each item links to specific product + pricing snapshot
  /// - Supports quantity, discounts, tax calculations per item
  /// 
  /// Data Integrity:
  /// - Order cannot exist without items (business rule)
  /// - Item prices frozen at order time (no retroactive changes)
  /// - Product changes don't affect historical orders
  /// 
  /// Query Patterns:
  /// ```typescript
  /// // Load order with all items and product details
  /// const order = await prisma.order.findUnique({
  ///   where: { id: orderId },
  ///   include: {
  ///     items: {
  ///       include: { product: true }
  ///     }
  ///   }
  /// })
  /// ```
  items OrderItem[]
  
  /// Payment transactions for this order
  /// 
  /// Relationship Type: One-to-Many (One order → Many payments)
  /// Support Pattern: Split payments, partial payments, refunds
  /// Cascade Behavior: Restrict deletion (financial audit trail)
  /// 
  /// Payment Scenarios:
  /// 1. Single payment: One successful charge
  /// 2. Split payment: Multiple payment methods/cards
  /// 3. Partial payment: Deposit + balance due later
  /// 4. Failed payment: Multiple attempts, eventual success/failure
  /// 5. Refund scenario: Original charge + refund transactions
  /// 
  /// Financial Integrity:
  /// - Sum of successful payments = order total
  /// - Failed payments tracked for fraud analysis
  /// - Refunds linked to original payment references
  /// 
  /// Compliance Requirements:
  /// - PCI DSS: No sensitive card data in application
  /// - SOX: Immutable financial transaction records
  /// - GDPR: Customer payment history subject to data protection
  payments Payment[]
  
  /// Shipping and fulfillment information
  /// 
  /// Relationship Type: One-to-One (One order → One shipment)
  /// Optional: Digital orders may not require shipping
  /// Cascade Behavior: Delete shipment when order deleted
  /// 
  /// Fulfillment Workflow:
  /// 1. Order confirmed → Shipment record created
  /// 2. Items picked → Shipment status updated
  /// 3. Package shipped → Tracking info added
  /// 4. Delivery confirmed → Order marked complete
  /// 
  /// Multi-vendor Considerations:
  /// - Complex orders may require multiple shipments
  /// - Each vendor handles their own fulfillment
  /// - Customer sees unified tracking experience
  /// 
  /// International Shipping:
  /// - Customs documentation requirements
  /// - Duty and tax calculations
  /// - Address validation and formatting
  shipment Shipment?
  
  // Additional fields...
  status      OrderStatus @default(PENDING)
  totalAmount Int                           /// Total in cents
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  @@map("orders")
  @@index([customerId, createdAt])          /// Customer order history
  @@index([status, createdAt])              /// Order processing queues
  @@index([orderNumber])                    /// Customer service lookup
}

/// Bridge table for order-product relationships with pricing snapshots
/// Preserves historical pricing and product information at order time
model OrderItem {
  // Composite primary key
  orderId   String
  productId String
  
  /// Parent order containing this line item
  /// Cascade: Delete item when order is deleted
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  /// Product being ordered (at time of order)
  /// Cascade: Restrict deletion (preserve order history)
  /// Note: Product info snapshotted to prevent retroactive changes
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)
  
  /// Quantity of this product ordered
  /// Constraint: Must be positive integer
  /// Business Rule: Checked against available inventory at order time
  quantity Int
  
  /// Product price at time of order (cents)
  /// Snapshot: Frozen from Product.price when order created
  /// Purpose: Protects against price changes affecting historical orders
  priceAtOrder Int
  
  /// Line item total (quantity × priceAtOrder)
  /// Calculated: Auto-computed, stored for performance
  /// Currency: Same as order currency (USD cents)
  totalAmount Int
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@id([orderId, productId])                /// Composite primary key
  @@map("order_items")
  @@index([productId])                      /// Product sales analysis
  @@index([orderId])                        /// Order item lookup
}
```

### 5. Enum & Type Documentation

```prisma
/// Comprehensive order lifecycle status tracking
/// Supports complex fulfillment workflows and customer communication
/// 
/// Status Flow:
/// PENDING → CONFIRMED → PROCESSING → SHIPPED → DELIVERED
///     ↓         ↓           ↓          ↓
/// CANCELLED CANCELLED  CANCELLED   RETURNED
/// 
/// Business Rules:
/// - Orders can be cancelled until PROCESSING stage
/// - Returns only allowed after DELIVERED status
/// - Failed payments automatically move to CANCELLED
/// - Customer notifications sent on each status change
enum OrderStatus {
  /// Order created but payment not yet processed
  /// Customer Action: Complete payment within 15 minutes
  /// System Action: Auto-cancel if payment timeout exceeded
  /// Inventory: Items reserved but not yet allocated
  PENDING      
  
  /// Payment successful, order ready for fulfillment
  /// Vendor Action: Begin order processing within 24 hours
  /// System Action: Send confirmation email to customer
  /// Inventory: Items allocated, stock decremented
  CONFIRMED    
  
  /// Order being prepared for shipment
  /// Vendor Action: Pick, pack, and prepare shipping label
  /// Customer Action: Cancellation no longer available
  /// System Action: Estimated shipping date calculated
  PROCESSING   
  
  /// Order dispatched to shipping carrier
  /// System Action: Tracking number sent to customer
  /// Customer Action: Track package via carrier website
  /// Vendor Action: Monitor delivery for issues
  SHIPPED      
  
  /// Order successfully delivered to customer
  /// System Action: Request review, process vendor payment
  /// Customer Action: Return window opens (30 days)
  /// Analytics: Order marked complete for reporting
  DELIVERED    
  
  /// Order cancelled before fulfillment
  /// Triggers: Customer request, payment failure, vendor issue
  /// System Action: Restore inventory, process refund
  /// Customer Action: May reorder with corrected information
  CANCELLED    
  
  /// Order returned after delivery
  /// Customer Action: Initiated return request
  /// System Action: Process return shipping, inspect items
  /// Vendor Action: Quality check, restock or dispose
  RETURNED     
  
  @@map("order_statuses")
}

/// User role hierarchy for platform access control
/// Implements principle of least privilege with clear permission boundaries
/// 
/// Permission Matrix:
/// Action          | CUSTOMER | VENDOR | MODERATOR | ADMIN
/// Browse Products |    ✅    |   ✅   |     ✅    |   ✅
/// Place Orders    |    ✅    |   ❌   |     ✅    |   ✅
/// Sell Products   |    ❌    |   ✅   |     ❌    |   ✅
/// Review Content  |    ❌    |   ❌   |     ✅    |   ✅
/// User Management |    ❌    |   ❌   |     ❌    |   ✅
/// System Config   |    ❌    |   ❌   |     ❌    |   ✅
enum UserRole {
  /// Standard platform user with purchasing capabilities
  /// Permissions: Browse, search, purchase, review products
  /// Restrictions: Cannot sell products or access admin features
  /// Registration: Open registration with email verification
  CUSTOMER   
  
  /// Verified seller with product management capabilities  
  /// Permissions: Sell products, manage inventory, view sales analytics
  /// Restrictions: Cannot moderate content or manage other users
  /// Registration: Application process with business verification
  VENDOR     
  
  /// Content moderation role for community management
  /// Permissions: Review/approve content, moderate reviews, handle disputes
  /// Restrictions: Cannot access financial data or system configuration
  /// Assignment: Promoted from trusted community members
  MODERATOR  
  
  /// Full platform administration access
  /// Permissions: All system functions, user management, configuration
  /// Restrictions: None - full platform control
  /// Assignment: Internal team members only
  ADMIN      
  
  @@map("user_roles")
}

/// Product categorization for navigation and organization
/// Hierarchical structure supporting nested categories
/// 
/// Category Hierarchy Examples:
/// Electronics → Computers → Laptops → Gaming Laptops
/// Clothing → Men's → Shirts → Casual Shirts
/// Home & Garden → Furniture → Bedroom → Beds
/// 
/// SEO Considerations:
/// - Category pages optimized for search engines
/// - URL structure: /category/electronics/computers/laptops
/// - Breadcrumb navigation for user experience
enum CategoryStatus {
  /// Category is active and visible to customers
  /// Products: Can be assigned to active categories
  /// Navigation: Appears in category menus and filters
  /// SEO: Indexed by search engines
  ACTIVE     
  
  /// Category temporarily hidden from customers
  /// Products: Existing assignments preserved
  /// Navigation: Removed from public menus
  /// Usage: Seasonal categories, maintenance periods
  HIDDEN     
  
  /// Category marked for removal but contains products
  /// Products: Must be reassigned before deletion
  /// Navigation: Hidden from public areas
  /// Admin: Shows warning about existing product assignments
  DEPRECATED 
  
  @@map("category_statuses")
}
```

---

## 📝 Advanced Documentation Techniques

### 1. Business Logic Documentation

```prisma
/// E-commerce pricing engine with dynamic pricing support
/// Implements complex pricing strategies for competitive advantage
model ProductPricing {
  id        String @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])
  
  // ==========================================
  // DYNAMIC PRICING DOCUMENTATION
  // ==========================================
  
  /// Base price before any dynamic adjustments (USD cents)
  /// 
  /// Business Logic:
  /// This represents the "anchor" price that serves as the foundation
  /// for all pricing calculations. Dynamic pricing algorithms apply
  /// multipliers and adjustments to this base value.
  /// 
  /// Calculation Dependencies:
  /// - Vendor cost + desired margin percentage
  /// - Competitor price analysis (updated hourly)
  /// - Historical demand patterns
  /// - Seasonal adjustment factors
  /// 
  /// Example Calculation:
  /// ```
  /// basePrice = vendorCost * (1 + marginPercentage)
  /// if (competitorPrice < basePrice * 1.1) {
  ///   basePrice = competitorPrice * 0.95  // Slight undercut
  /// }
  /// ```
  /// 
  /// Business Rules:
  /// - Cannot be less than vendor cost (prevents losses)
  /// - Cannot exceed 300% of cost (platform policy)
  /// - Must be updated within 24h of cost changes
  basePrice Int
  
  /// Current active price after dynamic adjustments (USD cents)
  /// 
  /// Dynamic Factors Applied:
  /// 1. Demand Multiplier (0.8x - 1.5x based on recent sales velocity)
  /// 2. Inventory Level (higher price when stock < 10 units)
  /// 3. Time-based (surge pricing during peak hours)
  /// 4. Customer Segment (loyalty discounts, bulk pricing)
  /// 5. Competitive Position (match or undercut competitors)
  /// 
  /// Update Frequency:
  /// - Real-time for high-velocity products
  /// - Hourly for standard products  
  /// - Daily for low-turnover items
  /// 
  /// Price Change Limits:
  /// - Maximum 20% increase per 24-hour period
  /// - Maximum 50% decrease per 24-hour period
  /// - Prevents price shock to customers
  /// 
  /// Algorithm Example:
  /// ```typescript
  /// const demandMultiplier = calculateDemandMultiplier(salesVelocity)
  /// const inventoryMultiplier = stock < 10 ? 1.1 : 1.0
  /// const timeMultiplier = isPeakHours() ? 1.05 : 1.0
  /// 
  /// currentPrice = basePrice * demandMultiplier * inventoryMultiplier * timeMultiplier
  /// currentPrice = Math.min(currentPrice, previousPrice * 1.2) // 20% daily limit
  /// ```
  currentPrice Int
  
  /// Lowest price in the last 30 days (regulatory compliance)
  /// 
  /// Legal Requirement:
  /// EU Omnibus Directive requires showing lowest price in previous 30 days
  /// when displaying discount prices. This field tracks that requirement.
  /// 
  /// Update Logic:
  /// - Checked daily at midnight UTC
  /// - Rolling 30-day window (not calendar month)
  /// - Excludes temporary promotional prices < 24 hours
  /// 
  /// Usage in Promotions:
  /// When showing "Was $X, Now $Y" pricing, $X must be either:
  /// 1. The previous regular price, OR
  /// 2. The 30-day minimum price (whichever is higher)
  /// 
  /// Compliance Note:
  /// Failure to properly track this can result in regulatory fines
  /// in EU markets. Automated compliance checking recommended.
  lowestPrice30Days Int
  
  /// Price change audit trail for regulatory compliance
  /// 
  /// Regulatory Requirements:
  /// - Price discrimination monitoring
  /// - Anti-competitive practice detection  
  /// - Consumer protection compliance
  /// - Tax authority audit trails
  /// 
  /// Storage Format:
  /// ```json
  /// [
  ///   {
  ///     "timestamp": "2024-08-07T10:30:00Z",
  ///     "oldPrice": 2999,
  ///     "newPrice": 3299,
  ///     "reason": "demand_increase",
  ///     "algorithm": "dynamic_pricing_v2.1",
  ///     "triggeredBy": "automated_system",
  ///     "factors": {
  ///       "demandMultiplier": 1.1,
  ///       "inventoryLevel": 5,
  ///       "competitorPrice": 3399
  ///     }
  ///   }
  /// ]
  /// ```
  /// 
  /// Retention Policy:
  /// - Keep 7 years for tax compliance
  /// - Archive to cold storage after 2 years
  /// - Anonymize customer-specific data after 3 years
  priceHistory Json[]
  
  // Timestamps with business context
  createdAt DateTime @default(now())        /// Initial pricing setup
  updatedAt DateTime @updatedAt             /// Last price recalculation
  
  @@map("product_pricing")
  @@index([productId, updatedAt])           /// Price history queries
  @@index([currentPrice])                   /// Price range filtering
}
```

### 2. Performance & Optimization Comments

```prisma
/// High-performance product search and filtering system
/// Optimized for e-commerce catalog queries with sub-100ms response times
model ProductSearch {
  // ==========================================
  // SEARCH OPTIMIZATION DOCUMENTATION
  // ==========================================
  
  /// Denormalized search data for performance optimization
  /// 
  /// Performance Strategy:
  /// Instead of JOIN-heavy queries across multiple tables, we denormalize
  /// frequently searched data into this dedicated search table. This trades
  /// storage space for query performance.
  /// 
  /// Update Strategy:
  /// - Real-time updates via database triggers
  /// - Batch rebuild nightly for consistency
  /// - Change detection prevents unnecessary updates
  /// 
  /// Query Performance:
  /// - Target: <100ms for complex searches
  /// - Indexed fields support range queries
  /// - Full-text search via PostgreSQL GIN indexes
  /// 
  /// Memory Usage:
  /// - Each record ~2KB average
  /// - 1M products = ~2GB table size
  /// - Frequently accessed, keep in memory pool
  productId String @id
  
  /// Pre-computed search text for full-text search optimization
  /// 
  /// Content Composition:
  /// - Product title (weight: 4x)
  /// - Product description (weight: 2x)  
  /// - Category names (weight: 3x)
  /// - Brand name (weight: 3x)
  /// - Product tags (weight: 1x)
  /// 
  /// Text Processing:
  /// - Stemming for language variants ("running" matches "runs")
  /// - Synonym expansion ("phone" matches "smartphone")  
  /// - Stop word removal for relevance
  /// - Accent normalization for international support
  /// 
  /// Update Triggers:
  /// ```sql
  /// CREATE TRIGGER update_search_text 
  /// AFTER UPDATE ON products
  /// FOR EACH ROW EXECUTE FUNCTION rebuild_search_text();
  /// ```
  /// 
  /// Query Example:
  /// ```sql
  /// SELECT product_id, ts_rank(search_text, plainto_tsquery('wireless headphones'))
  /// FROM product_search 
  /// WHERE search_text @@ plainto_tsquery('wireless headphones')
  /// ORDER BY ts_rank DESC;
  /// ```
  searchText String @db.Text                /// PostgreSQL tsvector for full-text search
  
  /// Numeric filters denormalized for range queries
  /// 
  /// Index Strategy:
  /// Compound B-tree indexes on (category_id, price) enable efficient
  /// category + price range queries without table scans
  /// 
  /// Query Pattern:
  /// ```sql
  /// SELECT * FROM product_search 
  /// WHERE category_id = $1 
  /// AND price BETWEEN $2 AND $3
  /// AND rating >= $4
  /// ORDER BY price ASC
  /// LIMIT 20;
  /// ```
  /// 
  /// Performance Target: <50ms for filtered category pages
  categoryId   String                       /// Primary category for filtering
  price        Int                          /// Current price in cents  
  rating       Float                        /// Average rating (0.0-5.0)
  reviewCount  Int                          /// Number of reviews for sorting
  salesCount   Int                          /// Total sales for popularity sort
  
  /// Boolean filters for checkbox-style filtering
  /// 
  /// UI Integration:
  /// These fields power the sidebar filters on category pages
  /// - "In Stock" checkbox → inStock filter
  /// - "On Sale" checkbox → onSale filter  
  /// - "Free Shipping" checkbox → freeShipping filter
  /// 
  /// Query Optimization:
  /// Boolean fields are highly compressible and cache-friendly
  /// Multiple boolean filters combined with AND/OR operations
  inStock      Boolean @default(true)       /// Available for immediate shipping
  onSale       Boolean @default(false)      /// Currently discounted
  freeShipping Boolean @default(false)      /// Qualifies for free shipping
  
  /// Last update timestamp for cache invalidation
  /// 
  /// Cache Strategy:
  /// - Redis cache with 5-minute TTL for search results
  /// - Cache key includes filters + sort + pagination
  /// - Invalidate cache when updatedAt changes
  /// 
  /// Monitoring:
  /// - Alert if records not updated >6 hours (indicates sync issues)
  /// - Track update frequency for capacity planning
  updatedAt DateTime @updatedAt
  
  // ==========================================
  // PERFORMANCE-CRITICAL INDEXES
  // ==========================================
  
  @@map("product_search")
  
  /// Primary search index - supports text search with ranking
  /// PostgreSQL GIN index for tsvector full-text search
  /// Estimated size: ~500MB for 1M products
  @@index([searchText], type: Gin)
  
  /// Category browsing index - most common query pattern
  /// Covers: Category pages with price sorting
  /// Usage: 60% of all product queries
  @@index([categoryId, price])
  
  /// Popular products index - homepage and recommendations
  /// Covers: "Best sellers" and "Trending" sections
  /// Sort order: Highest sales first
  @@index([salesCount, rating])
  
  /// Price range filtering - essential for price-sensitive searches
  /// Covers: Price slider widgets and "Under $X" filters
  /// Range scans: Very efficient for price bounds
  @@index([price, inStock])
  
  /// Multi-filter index - complex search scenarios
  /// Covers: Multiple checkbox filters + category
  /// Trade-off: Larger index size for better query performance
  @@index([categoryId, inStock, onSale, freeShipping])
  
  /// Rating-based sorting - quality-focused customers
  /// Covers: "Highest rated" sorting with minimum review threshold
  /// Filter: Only products with 5+ reviews
  @@index([rating, reviewCount])
}
```

---

## 🧠 Knowledge Check

### Documentation Mastery Quiz

1. **What is the primary purpose of schema documentation?**
   - [ ] A) To satisfy compliance requirements
   - [x] B) To enable team collaboration and maintainability
   - [ ] C) To improve database performance
   - [ ] D) To reduce file size

   **Explanation**: While compliance and performance are benefits, the primary purpose is enabling effective team collaboration and long-term maintainability through clear communication of intent and business logic.

2. **Which comment pattern is most effective for field documentation?**
   - [ ] A) Single line comments only
   - [x] B) Multi-line comments with business context
   - [ ] C) Code comments in separate files
   - [ ] D) No comments (self-documenting code)

   **Explanation**: Multi-line comments with business context provide the most value by explaining not just what a field is, but why it exists, how it's used, and what business rules apply.

3. **What should be included in relationship documentation?**
   - [ ] A) Only the foreign key reference
   - [ ] B) Only the cascade behavior
   - [x] C) Relationship type, business rules, and performance considerations
   - [ ] D) Just the database constraint

   **Explanation**: Comprehensive relationship documentation should include the relationship type, business rules that govern the relationship, performance considerations, and any special behaviors or constraints.

### Practical Exercise: Documentation Challenge

**Challenge**: Document a complex e-commerce schema section

**Requirements**:
1. Create a `ShoppingCart` model with comprehensive documentation
2. Include field-level comments with business rules
3. Document relationships with clear explanations
4. Add performance and security considerations
5. Include business logic documentation

**Solution Template**:
```prisma
/// Your documented model here
model ShoppingCart {
  // Document each field with purpose, constraints, and business rules
}
```

**Documentation Checklist**:
- [ ] Model purpose and business context explained
- [ ] Each field has clear purpose and constraints
- [ ] Relationships include business rules and performance notes
- [ ] Security considerations documented
- [ ] Business logic patterns explained
- [ ] Performance optimization strategies noted

---

## 💡 Key Takeaways

- 📚 **Architectural Manual**: Schema documentation is like a detailed building manual for your data architecture
- 🤝 **Team Collaboration**: Clear documentation enables effective teamwork and knowledge transfer
- 🔍 **Business Context**: Document not just what fields do, but why they exist and how they're used
- 🚀 **Performance Awareness**: Include performance considerations and optimization strategies
- 🛡️ **Security & Compliance**: Document privacy, security, and regulatory requirements
- 🔄 **Maintenance Ready**: Write documentation that helps future maintainers understand decisions
- 📝 **Consistency Matters**: Use consistent documentation patterns across your entire schema

---

## 🔗 Navigation

**📍 Current Location**: Module 3 → Section 3.1 → Lesson 3.1.3

**⬅️ Previous**: [3.1.2 Generator & Datasource Blocks Configuration](./3.1.2-generator-datasource-blocks.md)
**➡️ Next**: [3.1.4 Schema Formatting & Validation](./3.1.4-schema-formatting-validation.md)

**🏠 Section Home**: [3.1 Schema Overview & Structure](./README.md)
**📚 Module Home**: [Module 3: Prisma Schema](../README.md)

**🗺️ Quick Links**:
- [Previous: Configuration Blocks](./3.1.2-generator-datasource-blocks.md)
- [Next: Formatting & Validation](./3.1.4-schema-formatting-validation.md)
- [Schema Comments Guide](https://www.prisma.io/docs/concepts/components/prisma-schema#comments)
- [Documentation Best Practices](https://www.prisma.io/docs/guides/development-environment/editor-setup)

---

*📚 Excellent work! You've mastered the art of schema documentation. Next, we'll learn how to format and validate your schemas for professional-grade quality!*
