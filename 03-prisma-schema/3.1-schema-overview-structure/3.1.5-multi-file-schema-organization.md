# 3.1.5 Multi-file Schema Organization (Preview)

## 📋 Section Overview
- **Duration**: 8 minutes
- **Prerequisites**: 
  - Completed lessons 3.1.1-3.1.4 (Complete Section 3.1 foundation)
  - Understanding of schema organization principles
  - Experience with large-scale application development
- **Learning Objectives**: 
  - Explore multi-file schema organization patterns (Preview feature)
  - Implement modular schema architecture strategies
  - Master import/export patterns for schema components
  - Apply enterprise-scale schema organization techniques
  - Understand preview feature considerations and limitations
- **Difficulty Level**: Intermediate

---

## 🎯 What You'll Learn

By the end of this lesson, you will:
- ✅ Understand multi-file schema organization concepts and benefits
- ✅ Implement modular schema architecture patterns
- ✅ Master schema component import/export strategies
- ✅ Apply enterprise-scale organization techniques
- ✅ Navigate preview feature considerations and best practices

---

## 📖 Content

### Understanding Multi-file Schema Architecture

Implementing multi-file schema organization is like **designing a modular city planning system**. Just as urban planners organize cities into specialized districts with residential zones that house different communities, commercial districts that serve specific business functions, transportation networks that connect all areas seamlessly, utility systems that provide shared infrastructure, and governance structures that coordinate between districts—multi-file schemas organize data models into domain-specific modules with user management components that handle authentication and profiles, business logic modules that encapsulate core functionality, shared utilities that provide common types and enums, infrastructure components that define connections and generators, and integration patterns that coordinate between all modules.

### 🏙️ Modular City Planning Analogy

```
🏙️ Modular City Planning = 📁 Multi-file Schema Organization

🏘️ Residential Districts (User Domain)
├── User profiles → user-models.prisma
├── Authentication → auth-models.prisma
├── Preferences → user-preferences.prisma
├── Social connections → social-models.prisma
└── Privacy settings → privacy-models.prisma

🏢 Commercial Districts (Business Domain)
├── Product catalog → product-models.prisma
├── Order processing → order-models.prisma
├── Payment systems → payment-models.prisma
├── Inventory management → inventory-models.prisma
└── Vendor operations → vendor-models.prisma

🚇 Transportation Networks (Shared Components)
├── Common types → shared-types.prisma
├── Base enumerations → enums.prisma
├── Utility functions → utilities.prisma
├── Cross-cutting concerns → common.prisma
└── Integration patterns → integrations.prisma

⚡ Utility Systems (Infrastructure)
├── Database connections → datasource.prisma
├── Client generators → generators.prisma
├── Performance indexes → indexes.prisma
├── Migration configs → migrations.prisma
└── Environment settings → environment.prisma

🏛️ Governance Structure (Schema Coordination)
├── Master schema file → schema.prisma (imports all)
├── Domain boundaries → module-definitions.prisma
├── Relationship mappings → cross-module-relations.prisma
├── Validation rules → schema-validation.prisma
└── Documentation → schema-docs.prisma
```

---

## 📁 Multi-file Organization Patterns

### 1. Domain-Driven Design (DDD) Organization

```prisma
// ==========================================
// DOMAIN-DRIVEN SCHEMA ORGANIZATION
// ==========================================

// schema.prisma (Master file - imports all modules)
generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Import all domain modules
import "./domains/user/user.prisma"
import "./domains/product/product.prisma"
import "./domains/order/order.prisma"
import "./domains/payment/payment.prisma"
import "./shared/common.prisma"
import "./shared/enums.prisma"

// ==========================================
// domains/user/user.prisma (User Domain)
// ==========================================

/// User management domain - handles authentication, profiles, and preferences
/// 
/// Domain Boundaries:
/// - User accounts and authentication
/// - User profiles and personal information
/// - User preferences and settings
/// - Social connections and relationships
/// 
/// External Dependencies:
/// - Order domain (user orders)
/// - Review domain (user reviews)
/// - Payment domain (user payment methods)

// Export user-related models
export model User {
  id       String   @id @default(cuid())
  email    String   @unique
  username String?  @unique
  
  // Domain-specific fields
  isActive    Boolean   @default(true)
  lastLoginAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Cross-domain relationships (imported)
  profile     UserProfile?
  preferences UserPreferences?
  orders      Order[]      // from order domain
  reviews     Review[]     // from review domain
  
  @@map("users")
  @@index([email])
  @@index([username])
}

export model UserProfile {
  userId    String @id
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  firstName String?  @db.VarChar(50)
  lastName  String?  @db.VarChar(50)
  avatar    String?
  bio       String?  @db.Text
  
  // Address information
  address   Json?    // Structured address data
  phone     String?  @db.VarChar(20)
  
  // Preferences
  language  String   @default("en")
  timezone  String   @default("UTC")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("user_profiles")
}

export model UserPreferences {
  userId String @id
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Communication preferences
  emailNotifications  Boolean @default(true)
  smsNotifications    Boolean @default(false)
  pushNotifications   Boolean @default(true)
  
  // Privacy preferences
  profileVisibility   PrivacyLevel @default(PUBLIC)
  activityVisibility  PrivacyLevel @default(FRIENDS)
  
  // Content preferences
  contentLanguage     String   @default("en")
  contentRegion       String   @default("US")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("user_preferences")
}

// ==========================================
// domains/product/product.prisma (Product Domain)
// ==========================================

/// Product catalog domain - handles product management and categorization
/// 
/// Domain Boundaries:
/// - Product catalog and information
/// - Category and taxonomy management
/// - Product variants and options
/// - Inventory tracking and management
/// 
/// External Dependencies:
/// - Vendor domain (product ownership)
/// - Order domain (product orders)
/// - Review domain (product reviews)

import { ProductStatus, CategoryStatus } from "../../shared/enums.prisma"
import { AuditableEntity } from "../../shared/common.prisma"

export model Product extends AuditableEntity {
  id          String        @id @default(cuid())
  sku         String        @unique @db.VarChar(50)
  slug        String        @unique @db.VarChar(100)
  
  // Product information
  title       String        @db.VarChar(200)
  description String        @db.Text
  summary     String?       @db.VarChar(500)
  
  // Pricing
  price         Int         // Price in cents
  originalPrice Int?        // Original price before discounts
  cost          Int?        // Vendor cost (private)
  
  // Inventory
  stock                Int     @default(0)
  lowStockThreshold    Int     @default(5)
  trackInventory       Boolean @default(true)
  
  // Status and visibility
  status      ProductStatus @default(DRAFT)
  isVisible   Boolean       @default(true)
  isOrderable Boolean       @default(true)
  
  // SEO and marketing
  metaTitle       String?   @db.VarChar(60)
  metaDescription String?   @db.VarChar(160)
  searchKeywords  String[]  @default([])
  isFeatured      Boolean   @default(false)
  
  // Relationships
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  
  vendorId String
  vendor   Vendor   @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  
  // Cross-domain relationships
  images     ProductImage[]
  variants   ProductVariant[]
  reviews    Review[]         // from review domain
  orderItems OrderItem[]      // from order domain
  
  @@map("products")
  @@unique([vendorId, sku])
  @@index([status, isVisible])
  @@index([categoryId, status])
  @@index([price])
  @@index([searchKeywords])
}

export model Category {
  id          String         @id @default(cuid())
  name        String         @db.VarChar(100)
  slug        String         @unique @db.VarChar(100)
  description String?        @db.Text
  
  // Hierarchy support
  parentId String?
  parent   Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")
  
  // Category management
  status      CategoryStatus @default(ACTIVE)
  sortOrder   Int            @default(0)
  
  // SEO
  metaTitle       String? @db.VarChar(60)
  metaDescription String? @db.VarChar(160)
  
  // Relationships
  products Product[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("categories")
  @@index([parentId])
  @@index([status, sortOrder])
}

// ==========================================
// domains/order/order.prisma (Order Domain)
// ==========================================

/// Order processing domain - handles order lifecycle and fulfillment
/// 
/// Domain Boundaries:
/// - Order creation and management
/// - Order item tracking
/// - Order status and workflow
/// - Shipping and fulfillment
/// 
/// External Dependencies:
/// - User domain (customer information)
/// - Product domain (ordered products)
/// - Payment domain (order payments)

import { OrderStatus, PaymentStatus } from "../../shared/enums.prisma"
import { AuditableEntity } from "../../shared/common.prisma"
import { User } from "../user/user.prisma"
import { Product } from "../product/product.prisma"

export model Order extends AuditableEntity {
  id          String @id @default(cuid())
  orderNumber String @unique @db.VarChar(20)
  
  // Customer information
  customerId String
  customer   User   @relation(fields: [customerId], references: [id], onDelete: Restrict)
  
  // Order details
  status      OrderStatus @default(PENDING)
  totalAmount Int                           // Total in cents
  taxAmount   Int         @default(0)       // Tax in cents
  
  // Shipping information
  shippingAddress Json                      // Structured address
  billingAddress  Json?                     // Optional separate billing
  
  // Order management
  notes         String?  @db.Text          // Internal notes
  customerNotes String?  @db.Text          // Customer notes
  
  // Fulfillment
  estimatedDelivery DateTime?              // Estimated delivery date
  actualDelivery    DateTime?              // Actual delivery date
  
  // Relationships
  items     OrderItem[]
  payments  Payment[]    // from payment domain
  shipments Shipment[]
  
  @@map("orders")
  @@index([customerId, createdAt])
  @@index([status, createdAt])
  @@index([orderNumber])
}

export model OrderItem {
  orderId   String
  productId String
  
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)
  
  // Item details
  quantity       Int
  priceAtOrder   Int    // Price when ordered (cents)
  totalAmount    Int    // quantity × priceAtOrder
  
  // Product snapshot (preserve product info at order time)
  productTitle       String @db.VarChar(200)
  productDescription String @db.Text
  productSku         String @db.VarChar(50)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@id([orderId, productId])
  @@map("order_items")
  @@index([productId])
}

// ==========================================
// shared/common.prisma (Shared Components)
// ==========================================

/// Shared components and base models for cross-domain functionality
/// Contains common patterns, utilities, and base classes used across domains

/// Base auditable entity with standard timestamp fields
/// Use this as a base for models requiring audit trails
abstract model AuditableEntity {
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?              // Soft deletion support
  
  // Audit fields
  createdBy String?               // User who created this record
  updatedBy String?               // User who last updated this record
}

/// Base model for entities requiring approval workflow
abstract model ApprovableEntity extends AuditableEntity {
  approvalStatus ApprovalStatus @default(PENDING)
  approvedAt     DateTime?
  approvedBy     String?
  rejectedAt     DateTime?
  rejectedBy     String?
  rejectionReason String? @db.Text
}

/// Standard address structure for consistent address handling
type Address {
  street1    String
  street2    String?
  city       String
  state      String
  postalCode String
  country    String
  
  // Additional fields
  isDefault  Boolean @default(false)
  label      String? // "Home", "Work", "Billing", etc.
}

/// Money type for consistent currency handling
type Money {
  amount   Int     // Amount in smallest currency unit (cents)
  currency String  // ISO 4217 currency code
}

// ==========================================
// shared/enums.prisma (Shared Enumerations)
// ==========================================

/// Shared enumerations used across multiple domains
/// Centralized location for consistent value definitions

export enum UserRole {
  CUSTOMER
  VENDOR
  ADMIN
  MODERATOR
  
  @@map("user_roles")
}

export enum PrivacyLevel {
  PUBLIC
  FRIENDS
  PRIVATE
  
  @@map("privacy_levels")
}

export enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
  BANNED
  
  @@map("product_statuses")
}

export enum CategoryStatus {
  ACTIVE
  HIDDEN
  DEPRECATED
  
  @@map("category_statuses")
}

export enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
  
  @@map("order_statuses")
}

export enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
  
  @@map("payment_statuses")
}

export enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  REQUIRES_CHANGES
  
  @@map("approval_statuses")
}
```

### 2. Layer-Based Organization

```prisma
// ==========================================
// LAYER-BASED SCHEMA ORGANIZATION
// ==========================================

// schema.prisma (Master orchestrator)
generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Import layers in dependency order
import "./layers/01-foundation/foundation.prisma"
import "./layers/02-core/core.prisma"
import "./layers/03-business/business.prisma"
import "./layers/04-application/application.prisma"
import "./layers/05-presentation/presentation.prisma"

// ==========================================
// layers/01-foundation/foundation.prisma
// ==========================================

/// Foundation layer - basic types, enums, and infrastructure
/// No dependencies on other layers

// Base types and utilities
export type Timestamp {
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

export type SoftDelete {
  deletedAt DateTime?
  isDeleted Boolean @default(false)
}

export type Audit {
  createdBy String?
  updatedBy String?
  version   Int     @default(1)
}

// Foundation enums
export enum Status {
  ACTIVE
  INACTIVE
  PENDING
  ARCHIVED
}

export enum Priority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Infrastructure models
export model SystemConfiguration {
  key         String @id
  value       String @db.Text
  description String? @db.Text
  category    String @default("general")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("system_config")
  @@index([category])
}

// ==========================================
// layers/02-core/core.prisma
// ==========================================

/// Core layer - fundamental business entities
/// Depends on: Foundation layer only

import { Timestamp, SoftDelete, Audit, Status } from "../01-foundation/foundation.prisma"

// Core user entity
export model User {
  id       String @id @default(cuid())
  email    String @unique
  username String? @unique
  
  // Include foundation mixins
  ...Timestamp
  ...SoftDelete
  ...Audit
  
  status Status @default(ACTIVE)
  
  @@map("users")
  @@index([email])
  @@index([status])
}

// Core organization entity
export model Organization {
  id          String @id @default(cuid())
  name        String @db.VarChar(200)
  slug        String @unique @db.VarChar(100)
  description String? @db.Text
  
  ...Timestamp
  ...SoftDelete
  
  status Status @default(ACTIVE)
  
  @@map("organizations")
  @@index([slug])
  @@index([status])
}

// ==========================================
// layers/03-business/business.prisma
// ==========================================

/// Business layer - domain-specific business logic
/// Depends on: Foundation + Core layers

import { User, Organization } from "../02-core/core.prisma"
import { Timestamp, Priority, Status } from "../01-foundation/foundation.prisma"

// Business domain models
export model Project {
  id             String @id @default(cuid())
  name           String @db.VarChar(200)
  description    String? @db.Text
  
  // Business properties
  priority       Priority @default(MEDIUM)
  status         Status   @default(ACTIVE)
  startDate      DateTime?
  endDate        DateTime?
  budget         Int?     // Budget in cents
  
  // Core relationships
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id])
  
  ownerId String
  owner   User   @relation("ProjectOwner", fields: [ownerId], references: [id])
  
  // Team relationships
  members ProjectMember[]
  tasks   Task[]
  
  ...Timestamp
  
  @@map("projects")
  @@index([organizationId])
  @@index([ownerId])
  @@index([status])
}

export model Task {
  id          String @id @default(cuid())
  title       String @db.VarChar(200)
  description String? @db.Text
  
  // Task properties
  priority    Priority @default(MEDIUM)
  status      Status   @default(ACTIVE)
  dueDate     DateTime?
  estimatedHours Int?
  actualHours    Int?
  
  // Relationships
  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  assigneeId String?
  assignee   User?   @relation("TaskAssignee", fields: [assigneeId], references: [id])
  
  createdById String
  createdBy   User   @relation("TaskCreator", fields: [createdById], references: [id])
  
  ...Timestamp
  
  @@map("tasks")
  @@index([projectId])
  @@index([assigneeId])
  @@index([status])
  @@index([dueDate])
}

// ==========================================
// layers/04-application/application.prisma
// ==========================================

/// Application layer - application-specific features and workflows
/// Depends on: Foundation + Core + Business layers

import { User, Project, Task } from "../03-business/business.prisma"
import { Timestamp } from "../01-foundation/foundation.prisma"

// Application features
export model Notification {
  id        String @id @default(cuid())
  title     String @db.VarChar(200)
  message   String @db.Text
  type      NotificationType
  
  // Notification state
  isRead    Boolean  @default(false)
  readAt    DateTime?
  
  // Recipient
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Optional relationships to business entities
  projectId String?
  project   Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  taskId String?
  task   Task?   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  ...Timestamp
  
  @@map("notifications")
  @@index([userId, isRead])
  @@index([createdAt])
}

export enum NotificationType {
  INFO
  WARNING
  ERROR
  SUCCESS
  REMINDER
  
  @@map("notification_types")
}

// ==========================================
// layers/05-presentation/presentation.prisma
// ==========================================

/// Presentation layer - UI/UX related data and user preferences
/// Depends on: All previous layers

import { User } from "../02-core/core.prisma"
import { Timestamp } from "../01-foundation/foundation.prisma"

// UI/UX preferences
export model UserInterfacePreferences {
  userId String @id
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Theme preferences
  theme           String  @default("light")    // "light", "dark", "auto"
  colorScheme     String  @default("blue")     // Primary color preference
  fontSize        String  @default("medium")   // "small", "medium", "large"
  
  // Layout preferences
  sidebarCollapsed Boolean @default(false)
  dashboardLayout  String  @default("grid")    // "grid", "list", "card"
  
  // Notification preferences
  browserNotifications Boolean @default(true)
  emailDigestFrequency String  @default("daily") // "off", "daily", "weekly"
  
  ...Timestamp
  
  @@map("ui_preferences")
}

export model UserDashboard {
  id     String @id @default(cuid())
  name   String @db.VarChar(100)
  config Json                      // Dashboard configuration
  
  // Ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Dashboard properties
  isDefault Boolean @default(false)
  isShared  Boolean @default(false)
  sortOrder Int     @default(0)
  
  ...Timestamp
  
  @@map("user_dashboards")
  @@index([userId])
  @@index([userId, isDefault])
}
```

---

## 🔧 Import/Export Strategies

### 1. Selective Import Patterns

```prisma
// ==========================================
// SELECTIVE IMPORT STRATEGIES
// ==========================================

// Import specific models only
import { User, UserProfile } from "./domains/user/user.prisma"
import { Product, Category } from "./domains/product/product.prisma"

// Import with aliasing to avoid conflicts
import { Status as UserStatus } from "./domains/user/enums.prisma"
import { Status as ProductStatus } from "./domains/product/enums.prisma"

// Import all exports from a module
import * from "./shared/common.prisma"

// Conditional imports based on environment
#if NODE_ENV === "development"
  import "./development/debug-models.prisma"
#endif

#if FEATURE_ANALYTICS === "enabled"
  import "./features/analytics/analytics.prisma"
#endif

// Versioned imports for schema evolution
import { UserV2 as User } from "./domains/user/user-v2.prisma"
import { LegacyUser } from "./domains/user/user-v1.prisma" // For migration compatibility
```

### 2. Export Management Patterns

```prisma
// ==========================================
// EXPORT MANAGEMENT STRATEGIES
// ==========================================

// domains/user/user.prisma - Explicit exports
/// User domain exports - carefully curated public API

// Public models (available for import)
export model User {
  // User implementation
}

export model UserProfile {
  // Profile implementation
}

// Public enums
export enum UserRole {
  CUSTOMER
  ADMIN
  MODERATOR
}

// Private models (internal to domain only)
model UserSession {
  // Internal session tracking - not exported
}

model UserSecurityLog {
  // Internal security audit - not exported
}

// Utility exports
export type UserAddress = {
  street: String
  city: String
  country: String
}

// Re-exports from other domains
export { Order } from "../order/order.prisma"  // Re-export for convenience

// ==========================================
// Module interface definition
// ==========================================

// domains/user/index.prisma - Module interface
/// User domain public interface
/// This file defines what's available to other domains

// Core entities
export { User, UserProfile, UserPreferences } from "./models/user.prisma"

// Supporting types
export { UserRole, PrivacyLevel } from "./types/enums.prisma"
export { UserAddress, ContactInfo } from "./types/common.prisma"

// Domain services (if applicable)
export { UserService } from "./services/user-service.prisma"

// Migration exports (for schema evolution)
export { UserMigrationHelpers } from "./migrations/user-migrations.prisma"

// Documentation exports
export { UserDomainDocumentation } from "./docs/user-docs.prisma"
```

### 3. Cross-Domain Relationship Management

```typescript
// schema-relationship-manager.ts
class CrossDomainRelationshipManager {
  
  async validateCrossDomainReferences(schemaPath: string): Promise<ValidationResult> {
    const validation: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: [],
      crossDomainRelations: []
    }
    
    // Parse all schema files
    const schemas = await this.parseSchemaFiles(schemaPath)
    
    // Extract all models and their relationships
    const modelMap = this.buildModelMap(schemas)
    
    // Validate cross-domain references
    for (const [modelName, model] of modelMap.entries()) {
      for (const relation of model.relations) {
        const targetDomain = this.getDomainForModel(relation.targetModel)
        const sourceDomain = this.getDomainForModel(modelName)
        
        if (targetDomain !== sourceDomain) {
          // Cross-domain relationship found
          const crossDomainRelation: CrossDomainRelation = {
            sourceModel: modelName,
            sourceDomain,
            targetModel: relation.targetModel,
            targetDomain,
            relationType: relation.type,
            isValid: await this.validateCrossDomainRelation(relation)
          }
          
          validation.crossDomainRelations.push(crossDomainRelation)
          
          if (!crossDomainRelation.isValid) {
            validation.errors.push(
              `Invalid cross-domain relation: ${modelName} -> ${relation.targetModel}`
            )
            validation.isValid = false
          }
        }
      }
    }
    
    // Check for circular dependencies
    const circularDeps = this.detectCircularDependencies(validation.crossDomainRelations)
    if (circularDeps.length > 0) {
      validation.errors.push(`Circular dependencies detected: ${circularDeps.join(' -> ')}`)
      validation.isValid = false
    }
    
    return validation
  }
  
  private async validateCrossDomainRelation(relation: Relation): Promise<boolean> {
    // Validate that target model is properly exported
    const targetModule = await this.getModuleForModel(relation.targetModel)
    if (!targetModule.exports.includes(relation.targetModel)) {
      return false
    }
    
    // Validate that source domain imports target domain
    const sourceDomain = await this.getDomainForModel(relation.sourceModel)
    const targetDomain = await this.getDomainForModel(relation.targetModel)
    
    const sourceDomainImports = await this.getDomainImports(sourceDomain)
    if (!sourceDomainImports.includes(targetDomain)) {
      return false
    }
    
    // Validate relationship constraints
    return this.validateRelationshipConstraints(relation)
  }
  
  async generateDependencyGraph(schemaPath: string): Promise<DependencyGraph> {
    const schemas = await this.parseSchemaFiles(schemaPath)
    const graph: DependencyGraph = {
      nodes: [],
      edges: [],
      layers: []
    }
    
    // Build nodes (domains/modules)
    for (const schema of schemas) {
      const domain = this.extractDomainFromPath(schema.path)
      graph.nodes.push({
        id: domain,
        label: domain,
        type: this.getDomainType(domain),
        modelCount: schema.models.length
      })
    }
    
    // Build edges (dependencies)
    for (const schema of schemas) {
      const sourceDomain = this.extractDomainFromPath(schema.path)
      
      for (const importStatement of schema.imports) {
        const targetDomain = this.extractDomainFromPath(importStatement.path)
        
        graph.edges.push({
          source: sourceDomain,
          target: targetDomain,
          type: importStatement.type,
          strength: importStatement.modelCount
        })
      }
    }
    
    // Calculate dependency layers
    graph.layers = this.calculateDependencyLayers(graph)
    
    return graph
  }
}

interface CrossDomainRelation {
  sourceModel: string
  sourceDomain: string
  targetModel: string
  targetDomain: string
  relationType: 'one-to-one' | 'one-to-many' | 'many-to-many'
  isValid: boolean
}

interface ValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
  crossDomainRelations: CrossDomainRelation[]
}

interface DependencyGraph {
  nodes: DomainNode[]
  edges: DependencyEdge[]
  layers: DomainLayer[]
}
```

---

## ⚠️ Preview Feature Considerations

### 1. Current Limitations & Workarounds

```typescript
// multi-file-limitations.ts
class MultiFileSchemaLimitations {
  
  /// Current limitations of multi-file schema organization
  getCurrentLimitations(): SchemaLimitation[] {
    return [
      {
        category: 'Import/Export Syntax',
        limitation: 'No native import/export syntax in Prisma',
        impact: 'Must use file concatenation or custom tooling',
        workaround: 'Build-time schema compilation',
        severity: 'high'
      },
      {
        category: 'Circular Dependencies',
        limitation: 'Difficult to resolve circular imports',
        impact: 'Complex domain relationships hard to model',
        workaround: 'Intermediate join tables or event sourcing',
        severity: 'medium'
      },
      {
        category: 'IDE Support',
        limitation: 'Limited IntelliSense across files',
        impact: 'Reduced developer experience',
        workaround: 'Custom VS Code extensions or language server',
        severity: 'medium'
      },
      {
        category: 'Validation',
        limitation: 'No cross-file validation in Prisma CLI',
        impact: 'Must build custom validation tools',
        workaround: 'Custom schema validation pipeline',
        severity: 'high'
      },
      {
        category: 'Migration Generation',
        limitation: 'Migrations generated from single file only',
        impact: 'Must compile schema before migration',
        workaround: 'Pre-migration compilation step',
        severity: 'high'
      }
    ]
  }
  
  /// Recommended workarounds for current limitations
  getRecommendedWorkarounds(): WorkaroundStrategy[] {
    return [
      {
        name: 'Schema Compilation Pipeline',
        description: 'Build-time compilation of multi-file schemas',
        implementation: `
          // schema-compiler.ts
          class SchemaCompiler {
            async compileSchema(sourceDir: string, outputFile: string): Promise<void> {
              const files = await this.discoverSchemaFiles(sourceDir)
              const compiled = await this.resolveImports(files)
              await this.writeCompiledSchema(outputFile, compiled)
            }
          }
        `,
        complexity: 'medium',
        maintenance: 'ongoing'
      },
      {
        name: 'Domain Boundary Enforcement',
        description: 'Automated validation of domain boundaries',
        implementation: `
          // domain-validator.ts
          class DomainBoundaryValidator {
            validateDomainAccess(sourceModel: string, targetModel: string): boolean {
              const rules = this.loadDomainRules()
              return rules.isAllowed(sourceModel, targetModel)
            }
          }
        `,
        complexity: 'low',
        maintenance: 'low'
      },
      {
        name: 'Custom Language Server',
        description: 'Enhanced IDE support for multi-file schemas',
        implementation: `
          // Custom VS Code extension for multi-file Prisma support
          // Provides cross-file IntelliSense and validation
        `,
        complexity: 'high',
        maintenance: 'high'
      }
    ]
  }
}

interface SchemaLimitation {
  category: string
  limitation: string
  impact: string
  workaround: string
  severity: 'low' | 'medium' | 'high'
}

interface WorkaroundStrategy {
  name: string
  description: string
  implementation: string
  complexity: 'low' | 'medium' | 'high'
  maintenance: 'low' | 'medium' | 'high' | 'ongoing'
}
```

### 2. Migration and Deployment Strategies

```typescript
// multi-file-deployment.ts
class MultiFileSchemaDeployment {
  
  async deployMultiFileSchema(config: DeploymentConfig): Promise<DeploymentResult> {
    console.log('🚀 Deploying multi-file schema...')
    
    const result: DeploymentResult = {
      success: false,
      steps: [],
      compiledSchemaPath: '',
      migrationFiles: [],
      warnings: []
    }
    
    try {
      // Step 1: Compile multi-file schema
      result.steps.push(await this.compileSchema(config))
      
      // Step 2: Validate compiled schema
      result.steps.push(await this.validateCompiledSchema(config))
      
      // Step 3: Generate migrations
      result.steps.push(await this.generateMigrations(config))
      
      // Step 4: Apply migrations
      result.steps.push(await this.applyMigrations(config))
      
      // Step 5: Verify deployment
      result.steps.push(await this.verifyDeployment(config))
      
      result.success = result.steps.every(step => step.success)
      
      return result
      
    } catch (error) {
      result.steps.push({
        name: 'deployment_process',
        success: false,
        message: `Deployment failed: ${error.message}`,
        duration: 0
      })
      
      return result
    }
  }
  
  private async compileSchema(config: DeploymentConfig): Promise<DeploymentStep> {
    const startTime = Date.now()
    
    try {
      // Discover all schema files
      const schemaFiles = await this.discoverSchemaFiles(config.sourceDirectory)
      
      // Resolve imports and dependencies
      const dependencyGraph = await this.buildDependencyGraph(schemaFiles)
      
      // Compile in dependency order
      const compiledSchema = await this.compileInDependencyOrder(
        schemaFiles, 
        dependencyGraph
      )
      
      // Write compiled schema
      const outputPath = path.join(config.outputDirectory, 'schema.prisma')
      await fs.writeFile(outputPath, compiledSchema)
      
      return {
        name: 'schema_compilation',
        success: true,
        message: `Schema compiled successfully to ${outputPath}`,
        duration: Date.now() - startTime,
        artifacts: [outputPath]
      }
      
    } catch (error) {
      return {
        name: 'schema_compilation',
        success: false,
        message: `Schema compilation failed: ${error.message}`,
        duration: Date.now() - startTime,
        artifacts: []
      }
    }
  }
  
  private async compileInDependencyOrder(
    schemaFiles: SchemaFile[], 
    dependencyGraph: DependencyGraph
  ): Promise<string> {
    
    const compiledSections: string[] = []
    
    // Add header with generator and datasource
    compiledSections.push(this.generateSchemaHeader())
    
    // Process layers in dependency order
    for (const layer of dependencyGraph.layers) {
      compiledSections.push(`\n// ========== ${layer.name.toUpperCase()} LAYER ==========\n`)
      
      for (const domain of layer.domains) {
        const domainFiles = schemaFiles.filter(f => f.domain === domain)
        
        compiledSections.push(`\n// ${domain} domain\n`)
        
        for (const file of domainFiles) {
          const processedContent = await this.processSchemaFile(file)
          compiledSections.push(processedContent)
        }
      }
    }
    
    return compiledSections.join('')
  }
  
  private async processSchemaFile(file: SchemaFile): Promise<string> {
    let content = await fs.readFile(file.path, 'utf8')
    
    // Remove import statements
    content = content.replace(/^import .+$/gm, '')
    
    // Remove export keywords
    content = content.replace(/^export\s+/gm, '')
    
    // Add source file comment
    content = `// Source: ${file.path}\n${content}`
    
    // Resolve type references
    content = await this.resolveTypeReferences(content, file)
    
    return content
  }
}

interface DeploymentConfig {
  sourceDirectory: string
  outputDirectory: string
  environment: 'development' | 'staging' | 'production'
  validateBeforeDeployment: boolean
  backupBeforeDeployment: boolean
  rollbackOnFailure: boolean
}

interface DeploymentResult {
  success: boolean
  steps: DeploymentStep[]
  compiledSchemaPath: string
  migrationFiles: string[]
  warnings: string[]
}

interface DeploymentStep {
  name: string
  success: boolean
  message: string
  duration: number
  artifacts: string[]
}
```

---

## 🧠 Knowledge Check

### Multi-file Organization Mastery Quiz

1. **What is the primary benefit of multi-file schema organization?**
   - [ ] A) Faster database queries
   - [x] B) Better code organization and team collaboration
   - [ ] C) Smaller file sizes
   - [ ] D) Automatic performance optimization

   **Explanation**: Multi-file organization improves code maintainability, enables better team collaboration through domain separation, and makes large schemas more manageable, though it requires additional tooling.

2. **Which organization pattern is best for large enterprise applications?**
   - [ ] A) Single file with comments
   - [x] B) Domain-driven design (DDD) organization
   - [ ] C) Alphabetical model organization
   - [ ] D) Random file distribution

   **Explanation**: Domain-driven design organization aligns schema structure with business domains, making it easier for teams to work on specific areas without conflicts and improving code maintainability.

3. **What is a key limitation of multi-file schemas in Prisma?**
   - [ ] A) Cannot use relationships
   - [x] B) No native import/export syntax (preview feature)
   - [ ] C) Limited to 5 files maximum
   - [ ] D) Cannot use enums across files

   **Explanation**: Multi-file schema organization is currently a preview feature requiring custom tooling for import/export functionality, as Prisma doesn't natively support file imports.

### Practical Exercise: Multi-file Architecture Design

**Challenge**: Design a multi-file schema architecture for a comprehensive e-learning platform

**Requirements**:
1. Design domain-driven organization structure
2. Create import/export strategy for shared components
3. Plan cross-domain relationship management
4. Address preview feature limitations
5. Design deployment and compilation strategy

**Solution Template**:
```
/schemas
  /domains
    /user
    /course
    /assessment
    /payment
  /shared
  /infrastructure
```

**Architecture Checklist**:
- [ ] Domain boundaries clearly defined
- [ ] Shared components properly organized
- [ ] Cross-domain relationships minimized
- [ ] Import/export strategy documented
- [ ] Compilation pipeline designed
- [ ] Deployment strategy planned

---

## 💡 Key Takeaways

- 🏙️ **Modular Architecture**: Multi-file schemas are like modular city planning systems
- 📁 **Domain Organization**: Organize schemas by business domains for better team collaboration
- 🔗 **Import/Export Strategy**: Plan careful import/export patterns for maintainable architecture
- ⚠️ **Preview Limitations**: Current limitations require custom tooling and workarounds
- 🔄 **Compilation Pipeline**: Build-time compilation enables deployment of multi-file schemas
- 🎯 **Enterprise Ready**: Layer-based organization scales for large enterprise applications
- 🛠️ **Tooling Required**: Success requires investment in custom tooling and processes

---

## 🔗 Navigation

**📍 Current Location**: Module 3 → Section 3.1 → Lesson 3.1.5

**⬅️ Previous**: [3.1.4 Schema Formatting & Validation](./3.1.4-schema-formatting-validation.md)
**➡️ Next**: [3.2 Data Model & Models](../3.2-data-model-models/README.md)

**🏠 Section Home**: [3.1 Schema Overview & Structure](./README.md)
**📚 Module Home**: [Module 3: Prisma Schema](../README.md)

**🗺️ Quick Links**:
- [Previous: Formatting & Validation](./3.1.4-schema-formatting-validation.md)
- [Next Section: Data Models](../3.2-data-model-models/README.md)
- [Multi-file Schema Preview](https://www.prisma.io/docs/concepts/components/prisma-schema/generators#preview-features)
- [Domain-Driven Design Guide](https://martinfowler.com/bliki/DomainDrivenDesign.html)

---

*🎉 Congratulations! You've completed Section 3.1 and mastered advanced schema organization. Next, we'll dive deep into data modeling with Section 3.2!*
