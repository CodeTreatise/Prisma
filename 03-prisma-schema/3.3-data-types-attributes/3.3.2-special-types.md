# 3.3.2 Special Types (Json, Bytes, Decimal)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master Json and Jsonb types for flexible data storage
- Handle binary data with Bytes type effectively
- Implement precise financial calculations with Decimal
- Choose between special types based on use cases
- Optimize performance with appropriate type selection
- Handle type-specific querying and operations

## Introduction

Think of special types as **specialized tools in a craftsman's workshop** - while basic scalar types are like hammers and screwdrivers (essential for most jobs), special types are like precision instruments designed for specific, complex tasks. Json handles flexible data structures, Bytes manages binary content, and Decimal ensures mathematical precision where approximation isn't acceptable.

These types unlock advanced capabilities that go beyond simple scalar data, enabling rich applications with complex requirements.

## Json Type: Flexible Data Storage

### Basic Json Usage
Store unstructured or semi-structured data directly in your database:

```prisma
model UserProfile {
  id          String  @id @default(cuid())
  userId      String  @unique
  
  // Flexible preference storage
  preferences Json?   // User settings, theme preferences, etc.
  metadata    Json?   // Dynamic user attributes
  
  // Complex nested data
  socialLinks Json?   // Array of social media links
  settings    Json    @default("{}")  // Default empty JSON object
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("user_profiles")
}

model Product {
  id          String   @id @default(cuid())
  name        String
  price       Decimal  @db.Decimal(10, 2)
  
  // Product variants and specifications
  variants    Json?    // Color, size, style options
  specs       Json?    // Technical specifications
  seo         Json?    // SEO metadata (title, description, keywords)
  
  // Analytics and tracking
  analytics   Json     @default("{}")  // View counts, conversion data
  
  @@map("products")
}
```

### Json Data Examples
```javascript
// User preferences example
{
  "theme": "dark",
  "language": "en",
  "notifications": {
    "email": true,
    "push": false,
    "sms": true
  },
  "dashboard": {
    "layout": "grid",
    "widgets": ["sales", "analytics", "tasks"]
  }
}

// Product variants example
{
  "colors": ["red", "blue", "green"],
  "sizes": ["S", "M", "L", "XL"],
  "materials": {
    "primary": "cotton",
    "secondary": "polyester",
    "percentage": {"cotton": 80, "polyester": 20}
  }
}

// SEO metadata example
{
  "title": "Premium Cotton T-Shirt - Comfortable & Stylish",
  "description": "High-quality cotton t-shirt perfect for casual wear...",
  "keywords": ["cotton", "t-shirt", "casual", "comfortable"],
  "og": {
    "title": "Premium Cotton T-Shirt",
    "image": "/images/tshirt-preview.jpg",
    "type": "product"
  }
}
```

### Advanced Json Patterns
```prisma
model Campaign {
  id            String    @id @default(cuid())
  name          String
  
  // Campaign configuration
  targeting     Json      // Audience targeting rules
  content       Json      // Email/ad content variations
  schedule      Json      // Complex scheduling rules
  
  // Results and analytics
  metrics       Json      @default("{}")  // Performance metrics
  abTest        Json?     // A/B testing configurations
  
  // Audit trail
  configHistory Json      @default("[]")  // Array of configuration changes
  
  createdAt     DateTime  @default(now())
  
  @@map("campaigns")
}

// Example targeting configuration
{
  "demographics": {
    "ageRange": [25, 45],
    "locations": ["US", "CA", "UK"],
    "interests": ["technology", "fitness", "travel"]
  },
  "behavioral": {
    "purchaseHistory": true,
    "engagementLevel": "high",
    "lastActivity": "30days"
  },
  "custom": {
    "segment": "premium_users",
    "excludeList": ["churned_users"]
  }
}
```

## PostgreSQL: Json vs Jsonb

### Performance and Storage Differences
```prisma
// PostgreSQL-specific Json optimization
model PostgreSQLJsonExample {
  id              String   @id @default(cuid())
  
  // Standard JSON (text-based storage)
  standardJson    Json     @db.Json        // Faster to insert, slower to query
  
  // Binary JSON (optimized binary storage)
  binaryJson      Json     @db.JsonB       // Slower to insert, faster to query
  
  // Use JsonB for:
  // - Frequent querying and filtering
  // - Complex nested operations
  // - GIN indexing requirements
  searchableData  Json     @db.JsonB
  
  // Use Json for:
  // - Write-heavy operations
  // - Simple storage without complex queries
  logData         Json     @db.Json
  
  @@map("postgres_json_examples")
}
```

### Indexing Json Fields
```prisma
model IndexedJsonModel {
  id          String  @id @default(cuid())
  metadata    Json    @db.JsonB
  
  // PostgreSQL supports GIN indexes on JsonB
  // Create index manually: CREATE INDEX idx_metadata_gin ON table_name USING gin(metadata);
  
  @@map("indexed_json_models")
}
```

## Bytes Type: Binary Data Storage

### Binary Data Use Cases
```prisma
model FileUpload {
  id          String    @id @default(cuid())
  filename    String
  mimeType    String
  fileSize    Int
  
  // Binary file content
  content     Bytes     // Direct binary storage
  
  // File metadata
  checksum    String    // MD5 or SHA hash
  encoding    String?   // File encoding if applicable
  
  // Upload tracking
  uploadedBy  String
  uploadedAt  DateTime  @default(now())
  
  @@map("file_uploads")
}

model UserAvatar {
  id          String  @id @default(cuid())
  userId      String  @unique
  
  // Image data
  imageData   Bytes   // Original image bytes
  thumbnail   Bytes?  // Compressed thumbnail
  
  // Image metadata
  format      String  // jpg, png, webp
  width       Int
  height      Int
  fileSize    Int
  
  updatedAt   DateTime @updatedAt
  
  @@map("user_avatars")
}

model DigitalSignature {
  id            String    @id @default(cuid())
  documentId    String
  
  // Cryptographic data
  signature     Bytes     // Digital signature bytes
  publicKey     Bytes     // Signer's public key
  certificate   Bytes?    // X.509 certificate
  
  // Signature metadata
  algorithm     String    // RSA, ECDSA, etc.
  hashAlgorithm String    // SHA-256, SHA-512
  timestamp     DateTime  @default(now())
  
  // Verification status
  isVerified    Boolean   @default(false)
  verifiedAt    DateTime?
  
  @@map("digital_signatures")
}
```

### Bytes Handling Patterns
```prisma
model SecurityToken {
  id          String    @id @default(cuid())
  userId      String
  
  // Security-related binary data
  tokenHash   Bytes     // Hashed token value
  salt        Bytes     // Cryptographic salt
  iv          Bytes?    // Initialization vector for encryption
  
  // Token metadata
  tokenType   String    // access, refresh, reset
  expiresAt   DateTime
  isRevoked   Boolean   @default(false)
  
  // Security tracking
  createdAt   DateTime  @default(now())
  lastUsedAt  DateTime?
  ipAddress   String?
  userAgent   String?
  
  @@map("security_tokens")
}
```

## Decimal Type: Precision Mathematics

### Financial Calculations
```prisma
model FinancialTransaction {
  id              String    @id @default(cuid())
  accountId       String
  
  // Precise monetary values
  amount          Decimal   @db.Decimal(15, 4)  // Up to 99,999,999,999.9999
  fee             Decimal   @db.Decimal(10, 4)  // Transaction fees
  exchangeRate    Decimal?  @db.Decimal(20, 8)  // Currency exchange rates
  
  // Financial metadata
  currency        String    @db.Char(3)          // ISO currency codes
  transactionType String                         // debit, credit, transfer
  description     String?
  
  // Audit trail
  processedAt     DateTime  @default(now())
  reconciled      Boolean   @default(false)
  reconciledAt    DateTime?
  
  @@map("financial_transactions")
}

model PricingTier {
  id              String    @id @default(cuid())
  name            String
  
  // Precise pricing with different scales
  monthlyPrice    Decimal   @db.Decimal(8, 2)   // $999,999.99 max
  yearlyPrice     Decimal   @db.Decimal(8, 2)   // Annual pricing
  setupFee        Decimal   @db.Decimal(8, 2)   // One-time fees
  
  // Usage-based pricing
  pricePerUnit    Decimal   @db.Decimal(10, 6)  // Micro-pricing: $9999.999999
  minimumCharge   Decimal   @db.Decimal(8, 2)   // Minimum billing amount
  
  // Discounts and promotions
  discountPercent Decimal?  @db.Decimal(5, 4)   // Up to 99.9999%
  
  @@map("pricing_tiers")
}
```

### Scientific and Measurement Data
```prisma
model ScientificMeasurement {
  id            String    @id @default(cuid())
  experimentId  String
  
  // High-precision measurements
  value         Decimal   @db.Decimal(20, 10)  // Scientific precision
  uncertainty   Decimal?  @db.Decimal(20, 10)  // Measurement uncertainty
  
  // Calibration data
  calibration   Decimal   @db.Decimal(15, 8)   // Calibration factor
  temperature   Decimal?  @db.Decimal(6, 2)    // Environmental temperature
  pressure      Decimal?  @db.Decimal(8, 3)    // Environmental pressure
  
  // Measurement metadata
  unit          String                          // SI units
  method        String                          // Measurement method
  instrument    String                          // Measuring instrument
  
  measuredAt    DateTime  @default(now())
  measuredBy    String                          // Researcher ID
  
  @@map("scientific_measurements")
}

model GeospatialData {
  id          String  @id @default(cuid())
  
  // High-precision coordinates
  latitude    Decimal @db.Decimal(10, 8)  // ±90.12345678 degrees
  longitude   Decimal @db.Decimal(11, 8)  // ±180.12345678 degrees
  altitude    Decimal? @db.Decimal(8, 3)   // Meters above sea level
  
  // Precision metadata
  accuracy    Decimal? @db.Decimal(6, 3)   // GPS accuracy in meters
  heading     Decimal? @db.Decimal(6, 3)   // Compass heading 0-359.999
  speed       Decimal? @db.Decimal(6, 3)   // Speed in m/s
  
  recordedAt  DateTime @default(now())
  
  @@map("geospatial_data")
}
```

## Advanced Special Type Combinations

### E-commerce Product with All Special Types
```prisma
model AdvancedProduct {
  id            String    @id @default(cuid())
  sku           String    @unique
  name          String
  
  // Pricing with precision
  basePrice     Decimal   @db.Decimal(10, 2)
  costPrice     Decimal   @db.Decimal(10, 2)
  taxRate       Decimal   @db.Decimal(5, 4)   // Tax percentage
  
  // Flexible product data
  attributes    Json      @db.JsonB            // Searchable product attributes
  inventory     Json      @default("{}")       // Inventory tracking
  seo           Json?                          // SEO and marketing data
  
  // Binary assets
  thumbnail     Bytes?                         // Product thumbnail
  manual        Bytes?                         // Product manual PDF
  
  // Analytics
  analytics     Json      @default("{}")       // Performance metrics
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@map("advanced_products")
}
```

### Configuration Management System
```prisma
model ConfigurationItem {
  id            String    @id @default(cuid())
  name          String    @unique
  category      String
  
  // Configuration data
  configuration Json      @db.JsonB            // Main config data
  schema        Json?                          // JSON schema for validation
  defaults      Json      @default("{}")       // Default values
  
  // Version control
  version       Decimal   @db.Decimal(10, 3)   // Semantic versioning
  checksum      Bytes                          // Configuration checksum
  
  // Metadata
  description   String?
  tags          Json      @default("[]")       // Array of tags
  
  // Lifecycle
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@map("configuration_items")
}
```

## Performance Considerations and Best Practices

### ✅ Good Practices
```prisma
model BestPracticesSpecialTypes {
  id          String    @id @default(cuid())
  
  // ✅ Use appropriate Json type for database
  searchData  Json      @db.JsonB      // PostgreSQL: JsonB for queries
  logData     Json      @db.Json       // PostgreSQL: Json for write-heavy
  
  // ✅ Provide sensible defaults for Json
  settings    Json      @default("{}")
  metrics     Json      @default("[]")
  
  // ✅ Use appropriate Decimal precision
  price       Decimal   @db.Decimal(10, 2)  // Currency: 2 decimal places
  percentage  Decimal   @db.Decimal(5, 4)   // Percentages: 4 decimal places
  
  // ✅ Consider size limits for Bytes
  avatar      Bytes?                          // Nullable for optional files
  
  @@map("best_practices_special")
}
```

### ❌ Common Pitfalls
```prisma
model AvoidThesePatterns {
  id          String    @id @default(cuid())
  
  // ❌ Over-using Json for simple structured data
  // firstName Json                             // Use String instead
  
  // ❌ Wrong Decimal precision for use case
  // price    Decimal   @db.Decimal(5, 8)      // Too many decimal places
  
  // ❌ Storing large files directly in Bytes
  // videoFile Bytes                           // Use file storage service
  
  // ❌ No defaults for Json fields that should have them
  // settings Json                             // Should have @default("{}")
  
  @@map("avoid_patterns")
}
```

## Type Selection Guidelines

### When to Use Each Special Type

**Json/JsonB:**
- ✅ Configuration and settings
- ✅ Flexible schemas and metadata
- ✅ API response caching
- ✅ Dynamic form field definitions
- ❌ Highly relational data (use proper relations)
- ❌ Frequently searched exact values (use scalar types)

**Bytes:**
- ✅ Small binary files (images, documents)
- ✅ Cryptographic data (hashes, keys, signatures)
- ✅ Binary tokens and identifiers
- ❌ Large files (use external storage)
- ❌ Text data (use String types)

**Decimal:**
- ✅ Financial calculations and currency
- ✅ Scientific measurements and precision data
- ✅ Percentages and rates requiring exactness
- ❌ Approximate calculations (use Float)
- ❌ Simple counting (use Int)

## Exercise: Design a Multi-Type Schema

Create a comprehensive digital marketplace schema using all special types:

```prisma
// Your task: Complete this schema with appropriate special types
model DigitalMarketplace {
  id              String    @id @default(cuid())
  name            String
  
  // Pricing (use appropriate Decimal precision)
  listingPrice    // Choose precision for currency
  commissionRate  // Choose precision for percentages
  
  // Flexible content (use Json appropriately)
  productDetails  // Product specifications and features
  vendorInfo      // Vendor profile and ratings
  shippingRules   // Complex shipping calculations
  
  // Binary assets (use Bytes for appropriate data)
  productImage    // Small thumbnail image
  licenseFile     // Digital license or certificate
  
  // Metadata and tracking
  analytics       // Performance and sales data
  customFields    // Dynamic marketplace fields
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@map("digital_marketplace")
}
```

## Key Takeaways

1. **Json Strategy**: Use JsonB for query-heavy data, Json for write-heavy operations
2. **Decimal Precision**: Match decimal places to business requirements (2 for currency, 4+ for rates)
3. **Bytes Limitations**: Keep binary data small; use external storage for large files
4. **Default Values**: Always provide sensible defaults for Json fields
5. **Type Selection**: Choose based on access patterns and precision requirements
6. **Performance Impact**: Index JsonB fields appropriately, consider storage costs for Bytes

## Next Steps

In the next lesson, we'll explore **Field Attributes (@id, @unique, @default, @map)** and learn how to add constraints, relationships, and database mappings to your fields for enhanced functionality and optimization.

---

**Estimated Time:** 14 minutes
**Difficulty:** Intermediate-Advanced
**Prerequisites:** Understanding of scalar types and basic database concepts
