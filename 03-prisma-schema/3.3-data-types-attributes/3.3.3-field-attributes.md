# 3.3.3 Field Attributes (@id, @unique, @default, @map)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master essential field attributes for data integrity and optimization
- Implement proper primary key strategies with @id
- Ensure data uniqueness with @unique constraints
- Set intelligent defaults with @default functions
- Map Prisma fields to database columns with @map
- Combine attributes for robust schema design
- Understand attribute interactions and conflicts

## Introduction

Think of field attributes as **quality control systems in a manufacturing plant** - while the field type determines what kind of product you're making, attributes ensure quality standards, uniqueness, proper labeling, and automated processes. Just as a factory needs quality checks, automated stamping, and proper routing, your database fields need constraints, defaults, and mappings to maintain data integrity and performance.

Field attributes are the mechanisms that transform basic field declarations into robust, production-ready database schemas.

## @id Attribute: Primary Key Strategy

### Single Field Primary Keys
The foundation of data identity and relationships:

```prisma
model User {
  // Auto-generated string ID (recommended)
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  createdAt DateTime @default(now())
  
  @@map("users")
}

model Product {
  // Auto-incrementing integer ID
  id          Int      @id @default(autoincrement())
  name        String
  price       Decimal  @db.Decimal(10, 2)
  createdAt   DateTime @default(now())
  
  @@map("products")
}

model Order {
  // UUID primary key
  id          String   @id @default(uuid())
  userId      String
  total       Decimal  @db.Decimal(10, 2)
  status      String   @default("pending")
  
  // Relations
  user        User     @relation(fields: [userId], references: [id])
  
  @@map("orders")
}

model Session {
  // Custom string ID
  id          String   @id  // Manually assigned session tokens
  userId      String
  expiresAt   DateTime
  isActive    Boolean  @default(true)
  
  @@map("sessions")
}
```

### Composite Primary Keys
Multiple fields forming a unique identifier:

```prisma
model UserRole {
  userId      String
  roleId      String
  assignedAt  DateTime @default(now())
  assignedBy  String
  
  // Composite primary key
  @@id([userId, roleId])
  @@map("user_roles")
}

model ProductVariant {
  productId   String
  color       String
  size        String
  sku         String   @unique
  price       Decimal  @db.Decimal(10, 2)
  inventory   Int      @default(0)
  
  // Composite primary key ensuring unique color/size per product
  @@id([productId, color, size])
  @@map("product_variants")
}

model TimeSeriesData {
  deviceId    String
  timestamp   DateTime
  sensorType  String
  value       Float
  unit        String
  
  // Time series composite key
  @@id([deviceId, timestamp, sensorType])
  @@map("time_series_data")
}
```

## @unique Attribute: Data Integrity

### Single Field Uniqueness
Ensuring no duplicate values:

```prisma
model User {
  id          String   @id @default(cuid())
  
  // Unique constraints for business logic
  email       String   @unique                    // No duplicate emails
  username    String   @unique                    // No duplicate usernames
  phone       String?  @unique                    // Optional but unique when provided
  socialId    String?  @unique @map("social_security_id")  // Mapped unique field
  
  // Regular fields
  firstName   String
  lastName    String
  isActive    Boolean  @default(true)
  
  @@map("users")
}

model Product {
  id          String   @id @default(cuid())
  name        String
  
  // Business-critical unique fields
  sku         String   @unique                    // Stock keeping unit
  barcode     String?  @unique                    // Product barcode
  slug        String   @unique                    // URL-friendly identifier
  
  price       Decimal  @db.Decimal(10, 2)
  
  @@map("products")
}
```

### Composite Unique Constraints
Multiple fields that must be unique together:

```prisma
model Course {
  id            String   @id @default(cuid())
  title         String
  instructor    String
  semester      String
  year          Int
  department    String
  courseNumber  String
  
  // Composite unique: same course number can't be offered twice in same semester/year
  @@unique([courseNumber, semester, year])
  
  // Another composite unique: same title can't be taught by same instructor in same semester
  @@unique([title, instructor, semester, year])
  
  @@map("courses")
}

model Booking {
  id          String   @id @default(cuid())
  userId      String
  roomId      String
  startTime   DateTime
  endTime     DateTime
  status      String   @default("confirmed")
  
  // Prevent double-booking: same room can't be booked at overlapping times
  // Note: This requires application logic for time overlap checking
  @@unique([roomId, startTime])
  
  @@map("bookings")
}

model ShippingRate {
  id            String  @id @default(cuid())
  carrierName   String
  serviceType   String
  originZip     String
  destinationZip String
  weightMin     Float
  weightMax     Float
  rate          Decimal @db.Decimal(8, 2)
  
  // Composite unique for shipping rate lookup
  @@unique([carrierName, serviceType, originZip, destinationZip, weightMin, weightMax])
  
  @@map("shipping_rates")
}
```

## @default Attribute: Intelligent Automation

### Static Default Values
Fixed values assigned at creation:

```prisma
model User {
  id          String   @id @default(cuid())
  email       String   @unique
  name        String
  
  // Static defaults
  role        String   @default("user")           // Default role
  isActive    Boolean  @default(true)             // Active by default
  timezone    String   @default("UTC")            // Default timezone
  locale      String   @default("en")             // Default language
  
  // Numeric defaults
  credits     Int      @default(0)                // Starting credits
  points      BigInt   @default(0)                // Gamification points
  rating      Float    @default(0.0)              // Initial rating
  
  // JSON defaults
  preferences Json     @default("{}")             // Empty preferences object
  tags        Json     @default("[]")             // Empty tags array
  
  @@map("users")
}

model Product {
  id          String   @id @default(cuid())
  name        String
  price       Decimal  @db.Decimal(10, 2)
  
  // Inventory and status defaults
  inventory   Int      @default(0)                // No stock initially
  isActive    Boolean  @default(false)            // Inactive until approved
  isFeatured  Boolean  @default(false)            // Not featured by default
  
  // Categorization defaults
  category    String   @default("uncategorized")  // Default category
  tags        Json     @default("[]")             // Empty tags
  
  @@map("products")
}
```

### Dynamic Default Functions
Generated values using Prisma functions:

```prisma
model Order {
  id          String   @id @default(cuid())       // Unique string ID
  orderNumber String   @unique @default(uuid())   // UUID order number
  userId      String
  
  // Timestamp defaults
  createdAt   DateTime @default(now())            // Current timestamp
  updatedAt   DateTime @updatedAt                 // Auto-updating timestamp
  
  // Status and tracking
  status      String   @default("pending")
  total       Decimal  @db.Decimal(10, 2)
  
  @@map("orders")
}

model AuditLog {
  id          String   @id @default(cuid())
  
  // Automatic audit trail
  action      String
  userId      String?
  resourceId  String
  resourceType String
  changes     Json     @default("{}")
  
  // Automatic timestamps
  timestamp   DateTime @default(now())            // When action occurred
  
  // Tracking information
  ipAddress   String?
  userAgent   String?
  sessionId   String?
  
  @@map("audit_logs")
}

model FileUpload {
  id          String   @id @default(cuid())
  filename    String
  originalName String
  
  // Auto-generated fields
  uploadId    String   @unique @default(uuid())   // Public upload identifier
  uploadPath  String   @default("")               // Storage path
  
  // Metadata with defaults
  fileSize    BigInt   @default(0)
  mimeType    String   @default("application/octet-stream")
  isProcessed Boolean  @default(false)
  
  // Timestamps
  uploadedAt  DateTime @default(now())
  processedAt DateTime?
  
  @@map("file_uploads")
}
```

### Advanced Default Patterns
```prisma
model Campaign {
  id            String   @id @default(cuid())
  name          String
  
  // Campaign settings with intelligent defaults
  budget        Decimal  @db.Decimal(10, 2)
  dailyBudget   Decimal? @db.Decimal(8, 2)       // Optional daily limit
  
  // Status management
  status        String   @default("draft")        // Start as draft
  isActive      Boolean  @default(false)          // Inactive until launched
  
  // Schedule defaults
  startDate     DateTime?                         // Optional start date
  endDate       DateTime?                         // Optional end date
  timezone      String   @default("UTC")          // Campaign timezone
  
  // Performance tracking
  impressions   BigInt   @default(0)              // Impression counter
  clicks        BigInt   @default(0)              // Click counter
  conversions   Int      @default(0)              // Conversion counter
  
  // Configuration defaults
  targeting     Json     @default("{}")           // Targeting rules
  creatives     Json     @default("[]")           // Creative assets
  
  // Audit trail
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("campaigns")
}
```

## @map Attribute: Database Column Mapping

### Column Name Mapping
Bridge between Prisma field names and database columns:

```prisma
model User {
  id          String   @id @default(cuid())
  
  // Map to snake_case database columns
  firstName   String   @map("first_name")
  lastName    String   @map("last_name")
  emailAddress String  @unique @map("email_address")
  phoneNumber String?  @map("phone_number")
  
  // Map to legacy column names
  birthDate   DateTime? @map("date_of_birth")
  isActive    Boolean  @default(true) @map("active_flag")
  joinDate    DateTime @default(now()) @map("registration_date")
  
  // Map to abbreviated columns
  profilePicture String? @map("profile_pic_url")
  lastLoginTime  DateTime? @map("last_login_ts")
  
  @@map("users")
}

model Product {
  id              String   @id @default(cuid())
  name            String   @map("product_name")
  description     String?  @map("product_description")
  
  // Financial field mappings
  listPrice       Decimal  @db.Decimal(10, 2) @map("list_price_usd")
  costPrice       Decimal  @db.Decimal(10, 2) @map("cost_price_usd")
  discountPercent Float?   @map("discount_pct")
  
  // Inventory mappings
  stockQuantity   Int      @default(0) @map("qty_on_hand")
  reorderLevel    Int      @default(0) @map("reorder_point")
  
  // Status mappings
  isActive        Boolean  @default(true) @map("active_ind")
  isDiscontinued  Boolean  @default(false) @map("discontinued_ind")
  
  // Timestamp mappings
  createdAt       DateTime @default(now()) @map("created_timestamp")
  updatedAt       DateTime @updatedAt @map("last_modified_timestamp")
  
  @@map("products")
}
```

### Legacy Database Integration
Working with existing database schemas:

```prisma
model LegacyOrder {
  id              String   @id @default(cuid()) @map("order_id")
  
  // Customer information mapping
  customerId      String   @map("cust_id")
  customerEmail   String   @map("cust_email_addr")
  customerName    String   @map("cust_full_name")
  
  // Order details mapping
  orderNumber     String   @unique @map("order_nbr")
  orderTotal      Decimal  @db.Decimal(12, 2) @map("total_amount")
  taxAmount       Decimal  @db.Decimal(8, 2) @map("tax_amt")
  shippingCost    Decimal  @db.Decimal(8, 2) @map("shipping_amt")
  
  // Status and dates mapping
  orderStatus     String   @map("order_status_cd")
  orderDate       DateTime @default(now()) @map("order_dt")
  shippedDate     DateTime? @map("ship_dt")
  deliveredDate   DateTime? @map("delivery_dt")
  
  // Flags and indicators
  isPaid          Boolean  @default(false) @map("paid_ind")
  isShipped       Boolean  @default(false) @map("shipped_ind")
  isGift          Boolean  @default(false) @map("gift_order_ind")
  
  @@map("customer_orders")  // Map to legacy table name
}

model EmployeeRecord {
  id              String   @id @default(cuid()) @map("emp_id")
  
  // Personal information
  employeeNumber  String   @unique @map("emp_nbr")
  socialSecurity  String?  @unique @map("ssn")
  firstName       String   @map("fname")
  lastName        String   @map("lname")
  middleInitial   String?  @map("mi")
  
  // Employment details
  hireDate        DateTime @map("hire_dt")
  terminationDate DateTime? @map("term_dt")
  jobTitle        String   @map("job_title_desc")
  department      String   @map("dept_cd")
  salary          Decimal  @db.Decimal(10, 2) @map("annual_salary_amt")
  
  // Status flags
  isActive        Boolean  @default(true) @map("active_employee_ind")
  isFullTime      Boolean  @default(true) @map("full_time_ind")
  isSalaried      Boolean  @default(true) @map("salaried_ind")
  
  @@map("hr_employees")
}
```

## Attribute Combinations and Patterns

### Complex Field Definitions
Combining multiple attributes for robust schemas:

```prisma
model UserAccount {
  id              String   @id @default(cuid())
  
  // Unique identifier with mapping
  username        String   @unique @map("user_name")
  email           String   @unique @map("email_address")
  
  // Optional unique fields with defaults
  phone           String?  @unique @map("phone_number")
  employeeId      String?  @unique @default(uuid()) @map("employee_id")
  
  // Status with defaults and mapping
  accountStatus   String   @default("active") @map("account_status_cd")
  isVerified      Boolean  @default(false) @map("email_verified_ind")
  isLocked        Boolean  @default(false) @map("account_locked_ind")
  
  // Timestamps with auto-generation and mapping
  createdAt       DateTime @default(now()) @map("created_timestamp")
  updatedAt       DateTime @updatedAt @map("last_updated_timestamp")
  lastLoginAt     DateTime? @map("last_login_timestamp")
  passwordChangedAt DateTime @default(now()) @map("password_changed_timestamp")
  
  // Counters with defaults
  loginAttempts   Int      @default(0) @map("failed_login_attempts")
  passwordResets  Int      @default(0) @map("password_reset_count")
  
  @@map("user_accounts")
}

model ProductCatalog {
  id              String   @id @default(cuid())
  
  // Business identifiers
  sku             String   @unique @map("stock_keeping_unit")
  upc             String?  @unique @map("universal_product_code")
  manufacturerCode String? @map("mfg_part_number")
  
  // Product information with defaults
  productName     String   @map("product_name")
  brand           String   @default("Generic") @map("brand_name")
  category        String   @default("Uncategorized") @map("product_category")
  
  // Pricing with precision and mapping
  msrp            Decimal  @db.Decimal(10, 2) @map("manufacturer_suggested_retail_price")
  cost            Decimal  @db.Decimal(10, 2) @map("unit_cost")
  margin          Float    @default(0.0) @map("profit_margin_pct")
  
  // Inventory with defaults
  stockLevel      Int      @default(0) @map("current_stock_level")
  minimumStock    Int      @default(0) @map("minimum_stock_threshold")
  maxStock        Int      @default(1000) @map("maximum_stock_level")
  
  // Status flags with defaults and mapping
  isActive        Boolean  @default(false) @map("active_product_ind")
  isDiscontinued  Boolean  @default(false) @map("discontinued_ind")
  allowBackorder  Boolean  @default(false) @map("backorder_allowed_ind")
  
  // Timestamps
  addedDate       DateTime @default(now()) @map("date_added")
  lastUpdated     DateTime @updatedAt @map("last_modified_date")
  discontinuedDate DateTime? @map("discontinued_date")
  
  @@map("product_catalog")
}
```

## Performance and Best Practices

### ✅ Attribute Best Practices
```prisma
model BestPracticeExample {
  id          String   @id @default(cuid())
  
  // ✅ Use appropriate ID generation strategy
  publicId    String   @unique @default(uuid())    // Public-facing ID
  
  // ✅ Unique constraints on business-critical fields
  email       String   @unique
  username    String   @unique
  
  // ✅ Sensible defaults for required fields
  role        String   @default("user")
  isActive    Boolean  @default(true)
  
  // ✅ Auto-managed timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // ✅ Clear field-to-column mapping
  firstName   String   @map("first_name")
  lastName    String   @map("last_name")
  
  @@map("users")
}
```

### ❌ Common Attribute Mistakes
```prisma
model AvoidThesePatterns {
  id          String   @id @default(cuid())
  
  // ❌ Missing unique constraint on business identifier
  // email    String                    // Should be @unique
  
  // ❌ No default for fields that should have them
  // isActive Boolean                   // Should have @default(true/false)
  
  // ❌ Inconsistent mapping strategy
  // firstName String  @map("first_name")
  // lastname  String                   // Should also be mapped consistently
  
  // ❌ Wrong ID strategy for use case
  // id       Int  @id                  // Consider cuid() for distributed systems
  
  @@map("anti_patterns")
}
```

## Exercise: Design a Complete User Management Schema

Create a comprehensive user management system with all attribute types:

```prisma
// Your task: Add appropriate attributes to create a robust schema
model UserProfile {
  // Add appropriate @id attribute
  id              // Choose ID strategy and add @id
  
  // Add unique constraints and mappings
  email           // Make unique with database mapping
  username        // Make unique with appropriate mapping
  socialSecurityNumber // Optional unique field with mapping
  
  // Add defaults and mappings for personal info
  firstName       // Add mapping to snake_case
  lastName        // Add mapping to snake_case
  displayName     // Add default and mapping
  
  // Add status fields with defaults
  accountStatus   // Add default value and mapping
  isVerified      // Add boolean default and mapping
  isActive        // Add boolean default and mapping
  
  // Add timestamps with auto-generation
  createdAt       // Add auto timestamp and mapping
  updatedAt       // Add auto-updating timestamp and mapping
  lastLoginAt     // Add optional timestamp and mapping
  
  // Add counters with defaults
  loginCount      // Add default counter and mapping
  profileViews    // Add default counter and mapping
  
  // Map table name appropriately
  // Add @@map directive
}
```

## Key Takeaways

1. **ID Strategy**: Choose appropriate primary key generation (@default(cuid()), autoincrement(), uuid())
2. **Unique Constraints**: Apply @unique to business-critical fields that must be distinct
3. **Intelligent Defaults**: Use @default for fields that should have initial values
4. **Consistent Mapping**: Use @map for clear field-to-column relationships
5. **Composite Keys**: Use @@id([field1, field2]) for multi-field primary keys
6. **Composite Unique**: Use @@unique([field1, field2]) for business rule enforcement
7. **Timestamp Automation**: Leverage @default(now()) and @updatedAt for audit trails

## Next Steps

In the next lesson, we'll explore **PostgreSQL-Specific Types (Json vs Jsonb)** and learn how to optimize for PostgreSQL's advanced type system and performance characteristics.

---

**Estimated Time:** 15 minutes
**Difficulty:** Intermediate
**Prerequisites:** Understanding of data types and basic database constraints
