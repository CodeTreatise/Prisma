# 3.3.4 PostgreSQL-Specific Types (Json vs Jsonb)

## Learning Objectives
By the end of this lesson, you will be able to:
- Understand the fundamental differences between Json and Jsonb types
- Choose the optimal JSON type based on access patterns
- Implement efficient JSON querying and indexing strategies
- Leverage PostgreSQL's advanced JSON operators and functions
- Design high-performance schemas with appropriate JSON types
- Handle JSON migrations and transformations effectively

## Introduction

Think of PostgreSQL's JSON types as **two different filing systems in a corporate office**. The `Json` type is like a traditional paper filing system - documents are stored exactly as received, preserving original formatting, quick to file but slower to search through. The `Jsonb` type is like a modern digital filing system - documents are processed, indexed, and optimized for fast retrieval, taking more time to file initially but offering lightning-fast search capabilities.

Understanding when to use each type is crucial for building performant, scalable applications with PostgreSQL.

## Json vs Jsonb: Core Differences

### Storage and Performance Characteristics

```prisma
model JsonComparisonExample {
  id                String   @id @default(cuid())
  
  // JSON: Text-based storage, preserves exact input
  standardJson      Json     @db.Json
  
  // JSONB: Binary storage, optimized for operations
  binaryJson        Json     @db.JsonB
  
  // Use cases for different access patterns
  writeHeavyData    Json     @db.Json    // Logs, audit trails, append-only data
  readHeavyData     Json     @db.JsonB   // User preferences, searchable content
  
  createdAt         DateTime @default(now())
  
  @@map("json_comparison")
}
```

### Performance Trade-offs Matrix

| Operation | Json (@db.Json) | Jsonb (@db.JsonB) |
|-----------|-----------------|-------------------|
| **Insert Speed** | âš¡ Faster | ðŸŒ Slower (processing overhead) |
| **Storage Size** | ðŸ“¦ Larger (text format) | ðŸ“¦ Smaller (binary format) |
| **Query Speed** | ðŸŒ Slower | âš¡ Faster |
| **Indexing** | âŒ Limited support | âœ… Full GIN/GiST support |
| **Operators** | âŒ Basic operators only | âœ… Rich operator set |
| **Ordering** | âœ… Preserves key order | âŒ No key order guarantee |
| **Duplicate Keys** | âœ… Preserves duplicates | âŒ Removes duplicates |

## When to Use Json (@db.Json)

### Write-Heavy Scenarios
Perfect for high-volume write operations where query performance is secondary:

```prisma
model AuditLog {
  id          String   @id @default(cuid())
  action      String
  userId      String?
  resourceId  String
  
  // Raw audit data - written frequently, queried rarely
  payload     Json     @db.Json     // Fast writes for audit trails
  metadata    Json     @db.Json     // Request metadata, headers, etc.
  
  // Simple fields for basic filtering
  timestamp   DateTime @default(now())
  level       String   @default("info")
  source      String
  
  @@index([timestamp, level])  // Index simple fields, not JSON
  @@map("audit_logs")
}

model EventStream {
  id          String   @id @default(cuid())
  eventType   String
  source      String
  
  // High-frequency event data
  eventData   Json     @db.Json     // Raw event payload
  headers     Json     @db.Json     // HTTP headers, routing info
  
  // Indexable fields extracted from JSON for filtering
  userId      String?              // Extracted for efficient querying
  sessionId   String?              // Extracted for session tracking
  timestamp   DateTime @default(now())
  
  @@index([eventType, timestamp])
  @@index([userId, timestamp])
  @@map("event_stream")
}

model ImportLog {
  id            String   @id @default(cuid())
  importType    String
  status        String   @default("processing")
  
  // Import configuration and results
  sourceConfig  Json     @db.Json     // Import source configuration
  mapping       Json     @db.Json     // Field mapping rules
  errors        Json     @db.Json     // Error details and validation issues
  statistics    Json     @db.Json     // Import statistics and counters
  
  // Simple fields for filtering and reporting
  recordCount   Int      @default(0)
  errorCount    Int      @default(0)
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  
  @@index([importType, status, startedAt])
  @@map("import_logs")
}
```

### Document Preservation Use Cases
When exact JSON structure and key ordering matter:

```prisma
model ApiResponse {
  id          String   @id @default(cuid())
  endpoint    String
  method      String
  statusCode  Int
  
  // Preserve exact API response structure
  response    Json     @db.Json     // Exact response from external API
  headers     Json     @db.Json     // Response headers as received
  
  // Extracted fields for efficient querying
  requestId   String?
  timestamp   DateTime @default(now())
  duration    Int?                  // Response time in milliseconds
  
  @@index([endpoint, statusCode, timestamp])
  @@map("api_responses")
}

model LegalDocument {
  id            String   @id @default(cuid())
  documentType  String
  version       String
  
  // Legal content requiring exact preservation
  content       Json     @db.Json     // Original document structure
  signatures    Json     @db.Json     // Digital signature data
  metadata      Json     @db.Json     // Document metadata
  
  // Searchable extracted fields
  title         String
  createdBy     String
  effectiveDate DateTime
  expiryDate    DateTime?
  
  @@index([documentType, effectiveDate])
  @@map("legal_documents")
}
```

## When to Use Jsonb (@db.JsonB)

### Query-Heavy Applications
Optimized for complex querying and filtering:

```prisma
model UserProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  
  // Frequently queried user data
  preferences Json     @db.JsonB    // Theme, notifications, privacy settings
  settings    Json     @db.JsonB    // Application configuration
  profile     Json     @db.JsonB    // Bio, interests, social links
  
  // Search and filtering requirements
  tags        Json     @db.JsonB    // User tags for categorization
  attributes  Json     @db.JsonB    // Custom user attributes
  
  updatedAt   DateTime @updatedAt
  
  @@map("user_profiles")
}

model Product {
  id            String   @id @default(cuid())
  name          String
  price         Decimal  @db.Decimal(10, 2)
  
  // Rich product data for search and filtering
  specifications Json    @db.JsonB   // Technical specs, dimensions, features
  variants      Json     @db.JsonB   // Colors, sizes, styles
  seo           Json     @db.JsonB   // Meta tags, descriptions, keywords
  
  // Inventory and pricing variations
  pricing       Json     @db.JsonB   // Tiered pricing, discounts, regional prices
  inventory     Json     @db.JsonB   // Stock levels by location/variant
  
  // Analytics and metrics
  analytics     Json     @db.JsonB   // Views, conversions, ratings
  
  @@map("products")
}

model Campaign {
  id          String   @id @default(cuid())
  name        String
  status      String   @default("draft")
  
  // Complex campaign configuration requiring queries
  targeting   Json     @db.JsonB    // Audience targeting rules
  content     Json     @db.JsonB    // Campaign content variations
  schedule    Json     @db.JsonB    // Complex scheduling rules
  
  // Performance data for analytics
  metrics     Json     @db.JsonB    // Performance metrics and KPIs
  segments    Json     @db.JsonB    // Audience segment performance
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("campaigns")
}
```

### Advanced Query Examples with Jsonb

```prisma
model EcommerceAnalytics {
  id            String   @id @default(cuid())
  sessionId     String
  userId        String?
  
  // Rich analytics data optimized for querying
  events        Json     @db.JsonB   // User interaction events
  pageViews     Json     @db.JsonB   // Page view tracking
  purchases     Json     @db.JsonB   // Purchase behavior
  
  // Device and location data
  device        Json     @db.JsonB   // Device information
  location      Json     @db.JsonB   // Geographic data
  
  // Attribution and marketing
  attribution   Json     @db.JsonB   // Marketing attribution data
  referrer      Json     @db.JsonB   // Traffic source information
  
  sessionStart  DateTime @default(now())
  sessionEnd    DateTime?
  
  @@index([userId, sessionStart])
  @@map("ecommerce_analytics")
}

// Query examples for the above model:
// 1. Find users who viewed specific product categories:
// WHERE events @> '{"product_views": [{"category": "electronics"}]}'
//
// 2. Find sessions from mobile devices:
// WHERE device @> '{"type": "mobile"}'
//
// 3. Find purchases above certain amount:
// WHERE purchases @> '{"total": {"amount": {"$gt": 100}}}'
```

## Advanced PostgreSQL JSON Operations

### Indexing Strategies for Jsonb

```prisma
model SearchableContent {
  id          String   @id @default(cuid())
  title       String
  category    String
  
  // Heavily indexed JSON content
  content     Json     @db.JsonB
  metadata    Json     @db.JsonB
  tags        Json     @db.JsonB
  
  createdAt   DateTime @default(now())
  
  // PostgreSQL indexes (created via migration SQL):
  // CREATE INDEX idx_content_gin ON searchable_content USING gin(content);
  // CREATE INDEX idx_metadata_gin ON searchable_content USING gin(metadata);
  // CREATE INDEX idx_tags_path ON searchable_content USING gin((tags->'categories'));
  
  @@map("searchable_content")
}

model UserBehavior {
  id            String   @id @default(cuid())
  userId        String
  
  // Behavior tracking optimized for analytics
  interactions  Json     @db.JsonB
  preferences   Json     @db.JsonB
  history       Json     @db.JsonB
  
  recordedAt    DateTime @default(now())
  
  // Partial indexes for specific JSON paths:
  // CREATE INDEX idx_user_preferences_theme ON user_behavior 
  // USING gin((preferences->'theme')) WHERE preferences ? 'theme';
  
  @@index([userId, recordedAt])
  @@map("user_behavior")
}
```

### JSON Path Queries and Performance

```prisma
model ConfigurationStore {
  id            String   @id @default(cuid())
  namespace     String
  environment   String   @default("production")
  
  // Complex configuration requiring path-based queries
  configuration Json     @db.JsonB
  schema        Json     @db.JsonB
  validation    Json     @db.JsonB
  
  version       String   @default("1.0.0")
  isActive      Boolean  @default(true)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@unique([namespace, environment, version])
  @@map("configuration_store")
}

// Common JsonB query patterns:
// 1. Exact match: configuration @> '{"database": {"host": "localhost"}}'
// 2. Key exists: configuration ? 'database'
// 3. Path exists: configuration #> '{database,host}' IS NOT NULL
// 4. Array contains: configuration @> '{"features": ["analytics"]}'
// 5. Text search: configuration @@ 'database & host'
```

## Migration and Data Transformation Patterns

### Converting Between Json and Jsonb

```prisma
model DataMigrationExample {
  id              String   @id @default(cuid())
  
  // During migration: convert Json to Jsonb for better performance
  oldFormat       Json     @db.Json     // Legacy JSON data
  newFormat       Json     @db.JsonB    // Optimized JSONB data
  
  // Hybrid approach during transition
  writeOnlyJsonb  Json     @db.JsonB    // New writes go to JSONB
  legacyData      Json     @db.Json     // Keep old data in JSON
  
  migrationStatus String   @default("pending")  // Track migration progress
  migratedAt      DateTime?
  
  @@map("data_migration_example")
}

// Migration SQL examples:
// 1. Convert Json to Jsonb:
// UPDATE table SET new_format = old_format::jsonb;
//
// 2. Extract and index specific paths:
// UPDATE table SET extracted_field = (data->>'field_name')::text;
//
// 3. Cleanup and optimize:
// ALTER TABLE table DROP COLUMN old_format;
// VACUUM FULL table;
```

### Schema Evolution Patterns

```prisma
model EvolvingSchema {
  id            String   @id @default(cuid())
  
  // Version-aware JSON schemas
  data          Json     @db.JsonB
  schemaVersion String   @default("1.0")
  
  // Migration tracking
  lastMigrated  DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([schemaVersion])
  @@map("evolving_schema")
}

// Schema versioning in JSON:
// Version 1.0: {"name": "John", "age": 30}
// Version 2.0: {"profile": {"name": "John", "age": 30, "email": "john@example.com"}}
// Version 3.0: {"profile": {"personalInfo": {"name": "John", "age": 30}, "contact": {"email": "john@example.com"}}}
```

## Performance Optimization Strategies

### Choosing the Right Type Based on Usage

```prisma
model OptimizedJsonUsage {
  id              String   @id @default(cuid())
  
  // High-write, low-read: use Json
  auditTrail      Json     @db.Json     // Append-only audit data
  errorLogs       Json     @db.Json     // Error logging
  rawImports      Json     @db.Json     // Bulk import data
  
  // High-read, complex queries: use Jsonb
  userPreferences Json     @db.JsonB    // Frequently filtered preferences
  productCatalog  Json     @db.JsonB    // Searchable product data
  analytics       Json     @db.JsonB    // Complex analytical queries
  
  // Hybrid: extract frequently queried fields
  title           String                // Extracted from JSON for indexing
  category        String                // Extracted from JSON for filtering
  status          String                // Extracted from JSON for queries
  
  // Keep complex nested data in JSONB
  complexData     Json     @db.JsonB    // Rich nested structures
  
  @@index([category, status])           // Index extracted fields
  @@map("optimized_json_usage")
}
```

### Best Practices Summary

```prisma
model JsonBestPractices {
  id          String   @id @default(cuid())
  
  // âœ… Use Json for write-heavy, append-only data
  logs        Json     @db.Json
  
  // âœ… Use JsonB for read-heavy, query-intensive data
  searchable  Json     @db.JsonB
  
  // âœ… Extract frequently filtered fields
  extractedField String              // From JSON for efficient indexing
  
  // âœ… Use appropriate defaults
  config      Json     @db.JsonB @default("{}")
  metadata    Json     @db.Json  @default("{}")
  
  // âœ… Consider storage and query patterns
  readOnlyData  Json   @db.JsonB      // Complex queries, infrequent updates
  writeOnlyData Json   @db.Json       // High-volume writes, rare queries
  
  @@map("json_best_practices")
}

model JsonAntiPatterns {
  id          String   @id @default(cuid())
  
  // âŒ Don't use Jsonb for write-heavy scenarios without query needs
  // highVolumeWrites Json @db.JsonB    // Should be @db.Json
  
  // âŒ Don't use Json for complex query requirements
  // searchableData Json @db.Json       // Should be @db.JsonB
  
  // âŒ Don't store relational data in JSON
  // userRelations Json                 // Use proper foreign keys
  
  // âŒ Don't ignore indexing opportunities
  // unindexedJsonb Json @db.JsonB      // Should have GIN indexes
  
  @@map("json_anti_patterns")
}
```

## Real-World Implementation Examples

### E-commerce Product Catalog

```prisma
model ProductCatalog {
  id              String   @id @default(cuid())
  sku             String   @unique
  name            String
  basePrice       Decimal  @db.Decimal(10, 2)
  
  // Search-optimized product data
  specifications  Json     @db.JsonB    // Technical specs for filtering
  features        Json     @db.JsonB    // Feature list for search
  seo             Json     @db.JsonB    // SEO metadata for content queries
  
  // Inventory by location/variant (query-heavy)
  inventory       Json     @db.JsonB    // Stock levels, locations, variants
  
  // Pricing rules (complex calculations)
  pricingRules    Json     @db.JsonB    // Tiered pricing, discounts, regions
  
  // Analytics data (read-heavy for dashboards)
  performanceData Json     @db.JsonB    // Sales metrics, conversion rates
  
  // Audit trail (write-heavy, rarely queried)
  changeHistory   Json     @db.Json     // Product change audit trail
  
  // Extracted fields for efficient indexing
  category        String               // Extracted for category filtering
  brand           String               // Extracted for brand filtering
  isActive        Boolean  @default(true)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([category, brand, isActive])
  @@map("product_catalog")
}

// Query examples:
// 1. Find products with specific features:
// WHERE features @> '{"wireless": true, "waterproof": true}'
//
// 2. Find products in price range:
// WHERE pricingRules @> '{"basePrice": {"min": 100, "max": 500}}'
//
// 3. Check inventory at specific location:
// WHERE inventory @> '{"locations": [{"store": "NYC", "quantity": {"$gt": 0}}]}'
```

### User Analytics Platform

```prisma
model UserAnalytics {
  id              String   @id @default(cuid())
  userId          String
  sessionId       String
  
  // Real-time event tracking (write-heavy)
  rawEvents       Json     @db.Json     // High-volume event stream
  
  // Processed analytics (query-heavy)
  processedData   Json     @db.JsonB    // Aggregated and enriched data
  segments        Json     @db.JsonB    // User segmentation data
  preferences     Json     @db.JsonB    // Behavioral preferences
  
  // Device and context (frequently filtered)
  deviceInfo      Json     @db.JsonB    // Device characteristics
  locationData    Json     @db.JsonB    // Geographic information
  
  // Extracted dimensions for efficient querying
  platform        String               // ios, android, web
  country         String               // Country code
  userTier        String               // free, premium, enterprise
  
  recordedAt      DateTime @default(now())
  processedAt     DateTime?
  
  @@index([userId, recordedAt])
  @@index([platform, country, userTier])
  @@map("user_analytics")
}
```

## Exercise: Design an Optimal JSON Schema

Design a content management system that uses both Json and Jsonb appropriately:

```prisma
// Your task: Choose appropriate JSON types for different use cases
model ContentManagementSystem {
  id              String   @id @default(cuid())
  title           String
  contentType     String
  status          String   @default("draft")
  
  // Content data - choose Json or JsonB and justify
  content         // Rich text content with complex formatting
  metadata        // SEO data, tags, categories (searchable)
  settings        // Publishing settings, permissions
  
  // Versioning and history - choose Json or JsonB and justify  
  revisionHistory // Complete content change history
  draftChanges    // Temporary draft modifications
  
  // Analytics and performance - choose Json or JsonB and justify
  viewMetrics     // Page views, engagement data
  searchKeywords  // Keywords and search performance
  
  // System data - choose Json or JsonB and justify
  systemLogs      // Content management audit trail
  cacheConfig     // Caching configuration and rules
  
  // Add appropriate extracted fields for indexing
  // Add appropriate indexes
  // Add appropriate table mapping
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}
```

## Key Takeaways

1. **Json (@db.Json)**: Choose for write-heavy, append-only scenarios where query performance is secondary
2. **Jsonb (@db.JsonB)**: Choose for read-heavy applications requiring complex queries and filtering
3. **Storage Trade-offs**: Json preserves formatting but uses more space; Jsonb optimizes storage and performance
4. **Query Performance**: Jsonb offers rich operators and indexing; Json has limited query capabilities
5. **Indexing Strategy**: Use GIN indexes for Jsonb fields that are frequently queried
6. **Data Extraction**: Extract frequently filtered fields as separate columns for optimal performance
7. **Migration Planning**: Consider data access patterns when choosing types and plan for future migrations

## Next Steps

In the next lesson, we'll explore **Enums & Custom Types** and learn how to create type-safe, constrained data models that enforce business rules at the schema level.

---

**Estimated Time:** 16 minutes
**Difficulty:** Advanced
**Prerequisites:** PostgreSQL knowledge, understanding of JSON data structures, and query optimization concepts
