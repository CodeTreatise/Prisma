# 3.3.1 Scalar Types (String, Int, Boolean, DateTime, etc.)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master all Prisma scalar types and their use cases
- Choose appropriate data types for different scenarios
- Understand type validation and constraints
- Apply database-specific type optimizations
- Handle type conversion and compatibility issues

## Introduction

Think of scalar types as the **fundamental building blocks** of your data architecture - like choosing the right materials when constructing a building. Just as you wouldn't use wood for a foundation or steel for insulation, selecting the correct scalar type for each field is crucial for performance, storage efficiency, and data integrity.

Prisma provides a comprehensive set of scalar types that map to database-specific types while maintaining cross-database compatibility.

## Core Scalar Types

### String Types
The most versatile type for text data:

```prisma
model User {
  id          String   @id @default(cuid())
  email       String   @unique
  firstName   String
  lastName    String?
  bio         String?  // Can be null for optional biographical info
  slug        String   @unique @map("url_slug")
  
  // Database-specific length constraints
  shortCode   String   @db.Char(6)      // Fixed length
  description String   @db.VarChar(500) // Variable length with limit
  content     String   @db.Text         // Unlimited text
}
```

**Use Cases:**
- `String` (default): General text, names, emails
- `@db.Char(n)`: Fixed-length codes (postal codes, country codes)
- `@db.VarChar(n)`: Limited text with known maximum length
- `@db.Text`: Long content without length restrictions

### Numeric Types
Precision matters for numbers:

```prisma
model Product {
  id          String   @id @default(cuid())
  name        String
  
  // Integer types
  quantity    Int                    // Standard integer
  views       Int      @default(0)   // Counter with default
  sortOrder   Int      @db.SmallInt  // Small numbers (-32K to +32K)
  bigNumber   BigInt                 // Large integers beyond Int range
  
  // Decimal types
  price       Decimal  @db.Decimal(10, 2) // Currency: 10 digits, 2 decimal places
  weight      Float                       // Approximate numbers
  percentage  Float    @db.DoublePrecision // Higher precision floats
  
  // Boolean
  isActive    Boolean  @default(true)
  isFeatured  Boolean  @default(false)
}
```

**Type Selection Guidelines:**
- `Int`: Counters, IDs, small to medium whole numbers
- `BigInt`: Large numbers that exceed Int limits
- `Decimal`: Exact precision needed (money, measurements)
- `Float`: Scientific calculations, approximate values
- `Boolean`: True/false flags and toggles

### Date and Time Types
Temporal data with timezone considerations:

```prisma
model Event {
  id          String    @id @default(cuid())
  title       String
  
  // Date/Time types
  createdAt   DateTime  @default(now())                    // Timestamp with timezone
  updatedAt   DateTime  @updatedAt                         // Auto-updating timestamp
  scheduledAt DateTime?                                    // Optional future date
  eventDate   DateTime  @map("event_start_time")          // Mapped database column
  
  // Date only (no time component)
  birthDate   DateTime  @db.Date                          // PostgreSQL date type
  
  // Time only (no date component)  
  startTime   DateTime  @db.Time                          // PostgreSQL time type
}
```

### Advanced Scalar Examples

```prisma
// E-commerce product with comprehensive scalar usage
model Product {
  id            String      @id @default(cuid())
  
  // Text fields with appropriate constraints
  name          String      @db.VarChar(200)
  description   String?     @db.Text
  sku           String      @unique @db.Char(12)
  slug          String      @unique @db.VarChar(250)
  
  // Numeric fields with business logic
  price         Decimal     @db.Decimal(10, 2)  // Max $99,999,999.99
  comparePrice  Decimal?    @db.Decimal(10, 2)  // Optional compare-at price
  cost          Decimal?    @db.Decimal(10, 2)  // Internal cost tracking
  
  // Inventory and metrics
  inventory     Int         @default(0)
  weight        Float?                           // Shipping calculations
  views         BigInt      @default(0)          // Large view counts
  
  // Status and flags
  isActive      Boolean     @default(true)
  isFeatured    Boolean     @default(false)
  isDigital     Boolean     @default(false)
  
  // Timestamps
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  publishedAt   DateTime?                        // Optional publish date
  
  @@map("products")
}

// User profile demonstrating string variety
model UserProfile {
  id          String    @id @default(cuid())
  userId      String    @unique
  
  // Personal information
  firstName   String    @db.VarChar(50)
  lastName    String    @db.VarChar(50)
  bio         String?   @db.Text
  website     String?   @db.VarChar(200)
  
  // Contact and location
  phone       String?   @db.VarChar(20)
  timezone    String    @default("UTC") @db.VarChar(50)
  locale      String    @default("en") @db.Char(5)
  
  // Preferences (using appropriate numeric types)
  age         Int?      @db.SmallInt            // 0-150 range
  rating      Float     @default(0.0)           // User rating average
  points      BigInt    @default(0)             // Gamification points
  
  // Status tracking
  isVerified  Boolean   @default(false)
  isPrivate   Boolean   @default(false)
  
  // Timestamps
  birthDate   DateTime? @db.Date
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastActiveAt DateTime?
  
  @@map("user_profiles")
}
```

## Database-Specific Optimizations

### PostgreSQL Specific Types
```prisma
model PostgreSQLExample {
  id        String   @id @default(cuid())
  
  // PostgreSQL-specific optimizations
  smallNum  Int      @db.SmallInt       // 2 bytes vs 4 bytes for Int
  bigNum    BigInt   @db.BigInt         // 8 bytes for large numbers
  money     Decimal  @db.Money          // PostgreSQL money type
  
  // Text optimizations
  code      String   @db.Char(3)        // Fixed 3-character codes
  title     String   @db.VarChar(100)   // Limited variable text
  content   String   @db.Text           // Unlimited text
  
  // Precise decimals
  price     Decimal  @db.Decimal(12, 4) // Financial precision
  
  @@map("postgres_examples")
}
```

### MySQL Specific Types
```prisma
model MySQLExample {
  id          String    @id @default(cuid())
  
  // MySQL-specific optimizations
  tinyNum     Int       @db.TinyInt       // 1 byte integer
  mediumNum   Int       @db.MediumInt     // 3 byte integer
  
  // Text types
  shortText   String    @db.VarChar(255)  // MySQL varchar limit
  mediumText  String    @db.MediumText    // Up to 16MB
  longText    String    @db.LongText      // Up to 4GB
  
  // Date/time
  timestamp   DateTime  @db.Timestamp     // MySQL timestamp
  year        Int       @db.Year          // Year only (1901-2155)
  
  @@map("mysql_examples")
}
```

## Type Validation and Best Practices

### Choosing the Right Type
```prisma
model BestPracticesExample {
  id          String    @id @default(cuid())
  
  // ✅ Good: Appropriate string lengths
  email       String    @db.VarChar(320)  // RFC 5322 max email length
  firstName   String    @db.VarChar(50)   // Reasonable name length
  
  // ✅ Good: Precise decimal for money
  price       Decimal   @db.Decimal(10, 2)
  
  // ✅ Good: Small int for bounded values
  rating      Int       @db.SmallInt      // 1-5 star rating
  
  // ✅ Good: Boolean for binary states
  isActive    Boolean   @default(true)
  
  // ❌ Avoid: Over-sized types
  // age      BigInt                      // Overkill for human age
  // name     String    @db.Text          // Wasteful for names
  
  @@map("best_practices")
}
```

### Performance Considerations
```prisma
// Optimized for performance and storage
model OptimizedModel {
  id          String    @id @default(cuid())
  
  // Use smallest appropriate numeric types
  status      Int       @db.TinyInt       // 0-255 range
  priority    Int       @db.SmallInt      // -32K to +32K range
  
  // Fixed-length strings for codes
  countryCode String    @db.Char(2)       // ISO country codes
  currencyCode String   @db.Char(3)       // ISO currency codes
  
  // Appropriate text field sizes
  title       String    @db.VarChar(200)  // SEO-friendly title length
  slug        String    @db.VarChar(250)  // URL slug with buffer
  
  // Indexed fields should be appropriately sized
  searchTag   String    @db.VarChar(50)   // Searchable tags
  
  @@index([status, priority])               // Composite index
  @@map("optimized_models")
}
```

## Common Patterns and Anti-Patterns

### ✅ Good Patterns
```prisma
model GoodPatterns {
  id          String    @id @default(cuid())
  
  // Consistent ID strategy
  userId      String                      // Reference to User.id
  
  // Appropriate nullability
  email       String    @unique           // Required business field
  phone       String?                     // Optional contact method
  
  // Sensible defaults
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  
  // Type-appropriate constraints
  age         Int?      @db.SmallInt      // Human age doesn't need BigInt
  percentage  Float                       // 0.0 to 100.0 range
  
  @@map("good_patterns")
}
```

### ❌ Anti-Patterns to Avoid
```prisma
model AntiPatterns {
  id          String    @id @default(cuid())
  
  // ❌ Over-engineering with BigInt for small numbers
  // age      BigInt                      // Use Int or SmallInt
  
  // ❌ Using Float for exact values
  // price    Float                       // Use Decimal for money
  
  // ❌ Unlimited text for bounded content
  // name     String    @db.Text          // Use VarChar with limit
  
  // ❌ Missing appropriate defaults
  // isActive Boolean                     // Should have @default(true/false)
  
  @@map("anti_patterns")
}
```

## Exercise: Design a Complete Schema

Create a comprehensive e-learning platform schema that demonstrates proper scalar type usage:

```prisma
// Your task: Complete this schema with appropriate scalar types
model Course {
  id            String    @id @default(cuid())
  title         // Choose appropriate string type and length
  description   // Choose appropriate text type
  price         // Choose appropriate numeric type for money
  duration      // Choose appropriate type for minutes
  difficulty    // Choose appropriate type for 1-5 scale
  isPublished   // Choose appropriate boolean with default
  studentCount  // Choose appropriate type for large counts
  rating        // Choose appropriate type for decimal ratings
  createdAt     // Choose appropriate timestamp
  updatedAt     // Choose appropriate auto-updating timestamp
  publishedAt   // Choose appropriate optional timestamp
  
  @@map("courses")
}
```

## Key Takeaways

1. **Choose Precision Over Size**: Use `Decimal` for exact values, `Float` for approximations
2. **Size Appropriately**: Match field sizes to business requirements (SmallInt vs Int vs BigInt)
3. **String Strategy**: Use VarChar with limits for bounded text, Text for unlimited content
4. **Default Wisely**: Provide sensible defaults for boolean and timestamp fields
5. **Database Optimization**: Leverage database-specific types for performance gains
6. **Validation Consideration**: Choose types that naturally enforce business constraints

## Next Steps

In the next lesson, we'll explore **Special Types (Json, Bytes, Decimal)** and learn how to handle complex data structures and specialized use cases that go beyond basic scalar types.

---

**Estimated Time:** 12 minutes
**Difficulty:** Intermediate
**Prerequisites:** Understanding of basic Prisma models and database concepts
