# 4.5.4 `$queryRawUnsafe` for Dynamic Queries

*Think like a master locksmith who can craft custom keys for unique locks - `$queryRawUnsafe` gives you the power to create dynamic queries, but requires expert knowledge to use safely.*

## Learning Objectives
- Master `$queryRawUnsafe` for dynamic query construction
- Understand security implications and SQL injection prevention
- Learn dynamic filtering and reporting systems
- Build expertise in flexible query generation while maintaining safety

## The Locksmith's Custom Tools Analogy

Just as a master locksmith can craft custom tools for unique situations but must understand the security implications, `$queryRawUnsafe` allows dynamic query construction but requires deep understanding of SQL injection prevention and security best practices.

## 1. Understanding `$queryRawUnsafe`

### When to Use (With Extreme Caution)

```typescript
// Dynamic Query Builder Service
class DynamicQueryService {
  // ‚ö†Ô∏è DANGER ZONE: Only use with trusted, validated inputs
  async buildDynamicReport(filters: {
    tableName: 'users' | 'orders' | 'products';  // Restricted enum
    columns: string[];  // Must be validated
    conditions: Array<{
      field: string;
      operator: '=' | '>' | '<' | 'LIKE' | 'IN';
      value: any;
    }>;
    orderBy?: string;
    limit?: number;
  }) {
    // üö® CRITICAL: Validate table name against whitelist
    const allowedTables = ['users', 'orders', 'products'];
    if (!allowedTables.includes(filters.tableName)) {
      throw new Error('Invalid table name');
    }

    // üö® CRITICAL: Validate column names against schema
    const allowedColumns = await this.getTableColumns(filters.tableName);
    const invalidColumns = filters.columns.filter(col => !allowedColumns.includes(col));
    if (invalidColumns.length > 0) {
      throw new Error(`Invalid columns: ${invalidColumns.join(', ')}`);
    }

    // Build SELECT clause safely
    const selectClause = filters.columns.map(col => `"${col}"`).join(', ');
    
    // Build WHERE clause with parameterized values
    let whereClause = '';
    const values: any[] = [];
    
    if (filters.conditions.length > 0) {
      const conditions = filters.conditions.map((condition, index) => {
        const placeholder = `$${values.length + 1}`;
        values.push(condition.value);
        return `"${condition.field}" ${condition.operator} ${placeholder}`;
      });
      whereClause = `WHERE ${conditions.join(' AND ')}`;
    }

    // Build ORDER BY clause safely
    let orderByClause = '';
    if (filters.orderBy && allowedColumns.includes(filters.orderBy)) {
      orderByClause = `ORDER BY "${filters.orderBy}"`;
    }

    // Build LIMIT clause safely
    let limitClause = '';
    if (filters.limit && filters.limit > 0 && filters.limit <= 1000) {
      limitClause = `LIMIT ${filters.limit}`;
    }

    // Construct final query
    const query = `
      SELECT ${selectClause}
      FROM "${filters.tableName}"
      ${whereClause}
      ${orderByClause}
      ${limitClause}
    `;

    // Execute with proper error handling
    try {
      return await prisma.$queryRawUnsafe(query, ...values);
    } catch (error) {
      console.error('Dynamic query failed:', { query, values, error });
      throw new Error('Query execution failed');
    }
  }

  private async getTableColumns(tableName: string): Promise<string[]> {
    // Get column names from information_schema
    const columns = await prisma.$queryRaw<{ column_name: string }[]>`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_name = ${tableName}
      AND table_schema = 'public'
    `;
    
    return columns.map(col => col.column_name);
  }
}
```

## 2. Safe Dynamic Query Patterns

### Query Builder with Validation

```typescript
class SafeQueryBuilder {
  private readonly tableSchemas = {
    users: {
      columns: ['id', 'email', 'first_name', 'last_name', 'created_at', 'last_login'],
      searchableColumns: ['email', 'first_name', 'last_name'],
      sortableColumns: ['email', 'created_at', 'last_login'],
      filterableColumns: ['email', 'created_at', 'last_login']
    },
    orders: {
      columns: ['id', 'user_id', 'amount', 'status', 'created_at'],
      searchableColumns: ['status'],
      sortableColumns: ['amount', 'created_at', 'status'],
      filterableColumns: ['user_id', 'amount', 'status', 'created_at']
    },
    products: {
      columns: ['id', 'name', 'price', 'category_id', 'stock_quantity', 'is_active'],
      searchableColumns: ['name'],
      sortableColumns: ['name', 'price', 'stock_quantity'],
      filterableColumns: ['category_id', 'price', 'is_active', 'stock_quantity']
    }
  };

  async searchWithFilters(params: {
    table: keyof typeof this.tableSchemas;
    search?: string;
    filters?: Record<string, any>;
    sort?: { field: string; direction: 'ASC' | 'DESC' };
    pagination?: { page: number; size: number };
  }) {
    const schema = this.tableSchemas[params.table];
    if (!schema) {
      throw new Error('Invalid table specified');
    }

    let query = `SELECT ${schema.columns.map(col => `"${col}"`).join(', ')} FROM "${params.table}"`;
    const queryParams: any[] = [];
    const conditions: string[] = [];

    // Add search conditions
    if (params.search && params.search.trim()) {
      const searchConditions = schema.searchableColumns.map(col => {
        queryParams.push(`%${params.search!.trim()}%`);
        return `"${col}"::text ILIKE $${queryParams.length}`;
      });
      
      if (searchConditions.length > 0) {
        conditions.push(`(${searchConditions.join(' OR ')})`);
      }
    }

    // Add filter conditions
    if (params.filters) {
      for (const [field, value] of Object.entries(params.filters)) {
        if (!schema.filterableColumns.includes(field)) {
          throw new Error(`Field ${field} is not filterable`);
        }

        if (value !== null && value !== undefined) {
          if (Array.isArray(value)) {
            // Handle IN conditions
            const placeholders = value.map(() => {
              queryParams.push(value[queryParams.length]);
              return `$${queryParams.length}`;
            });
            conditions.push(`"${field}" IN (${placeholders.join(', ')})`);
          } else {
            // Handle equality conditions
            queryParams.push(value);
            conditions.push(`"${field}" = $${queryParams.length}`);
          }
        }
      }
    }

    // Add WHERE clause if we have conditions
    if (conditions.length > 0) {
      query += ` WHERE ${conditions.join(' AND ')}`;
    }

    // Add sorting
    if (params.sort && schema.sortableColumns.includes(params.sort.field)) {
      query += ` ORDER BY "${params.sort.field}" ${params.sort.direction}`;
    }

    // Add pagination
    if (params.pagination) {
      const offset = (params.pagination.page - 1) * params.pagination.size;
      query += ` LIMIT ${params.pagination.size} OFFSET ${offset}`;
    }

    return await prisma.$queryRawUnsafe(query, ...queryParams);
  }

  async getAggregatedData(params: {
    table: keyof typeof this.tableSchemas;
    aggregations: Array<{
      function: 'COUNT' | 'SUM' | 'AVG' | 'MIN' | 'MAX';
      field?: string;
      alias: string;
    }>;
    groupBy?: string[];
    filters?: Record<string, any>;
  }) {
    const schema = this.tableSchemas[params.table];
    if (!schema) {
      throw new Error('Invalid table specified');
    }

    // Build aggregation SELECT
    const aggregationClauses = params.aggregations.map(agg => {
      if (agg.function === 'COUNT' && !agg.field) {
        return `COUNT(*) as "${agg.alias}"`;
      }
      
      if (agg.field && !schema.columns.includes(agg.field)) {
        throw new Error(`Invalid aggregation field: ${agg.field}`);
      }

      return `${agg.function}("${agg.field}") as "${agg.alias}"`;
    });

    let query = `SELECT ${aggregationClauses.join(', ')}`;

    // Add GROUP BY fields
    if (params.groupBy && params.groupBy.length > 0) {
      const validGroupFields = params.groupBy.filter(field => schema.columns.includes(field));
      if (validGroupFields.length !== params.groupBy.length) {
        throw new Error('Invalid GROUP BY fields');
      }
      
      const groupFields = validGroupFields.map(field => `"${field}"`);
      query = `SELECT ${groupFields.join(', ')}, ${aggregationClauses.join(', ')}`;
    }

    query += ` FROM "${params.table}"`;

    // Add filters
    const queryParams: any[] = [];
    const conditions: string[] = [];

    if (params.filters) {
      for (const [field, value] of Object.entries(params.filters)) {
        if (!schema.filterableColumns.includes(field)) {
          throw new Error(`Field ${field} is not filterable`);
        }

        if (value !== null && value !== undefined) {
          queryParams.push(value);
          conditions.push(`"${field}" = $${queryParams.length}`);
        }
      }
    }

    if (conditions.length > 0) {
      query += ` WHERE ${conditions.join(' AND ')}`;
    }

    // Add GROUP BY clause
    if (params.groupBy && params.groupBy.length > 0) {
      const groupFields = params.groupBy.map(field => `"${field}"`);
      query += ` GROUP BY ${groupFields.join(', ')}`;
    }

    return await prisma.$queryRawUnsafe(query, ...queryParams);
  }
}
```

## 3. Advanced Dynamic Reporting

### Flexible Analytics Dashboard

```typescript
class AdvancedAnalyticsService {
  async generateCustomReport(config: {
    metrics: Array<{
      name: string;
      aggregation: 'sum' | 'count' | 'avg' | 'min' | 'max';
      field?: string;
      table: string;
      conditions?: Array<{ field: string; operator: string; value: any }>;
    }>;
    dimensions?: Array<{
      name: string;
      field: string;
      table: string;
      dateFormat?: 'day' | 'week' | 'month' | 'quarter' | 'year';
    }>;
    timeRange?: {
      start: Date;
      end: Date;
      field: string;
    };
    filters?: Record<string, any>;
  }) {
    // Validate configuration
    await this.validateReportConfig(config);

    // Build complex CTE-based query
    const ctes: string[] = [];
    const queryParams: any[] = [];

    // Build metric CTEs
    for (const metric of config.metrics) {
      const cteName = `metric_${metric.name}`;
      let metricQuery = `SELECT `;
      
      // Add dimensions to metric query if specified
      if (config.dimensions) {
        const dimensionSelects = config.dimensions.map(dim => {
          if (dim.dateFormat && dim.field.includes('_at')) {
            return `DATE_TRUNC('${dim.dateFormat}', "${dim.field}") as "${dim.name}"`;
          }
          return `"${dim.field}" as "${dim.name}"`;
        });
        metricQuery += `${dimensionSelects.join(', ')}, `;
      }

      // Add metric aggregation
      if (metric.aggregation === 'count' && !metric.field) {
        metricQuery += `COUNT(*) as "${metric.name}"`;
      } else {
        metricQuery += `${metric.aggregation.toUpperCase()}("${metric.field}") as "${metric.name}"`;
      }

      metricQuery += ` FROM "${metric.table}"`;

      // Add metric-specific conditions
      const conditions: string[] = [];
      
      if (metric.conditions) {
        for (const condition of metric.conditions) {
          queryParams.push(condition.value);
          conditions.push(`"${condition.field}" ${condition.operator} $${queryParams.length}`);
        }
      }

      // Add time range filter
      if (config.timeRange) {
        queryParams.push(config.timeRange.start, config.timeRange.end);
        conditions.push(`"${config.timeRange.field}" BETWEEN $${queryParams.length - 1} AND $${queryParams.length}`);
      }

      // Add general filters
      if (config.filters) {
        for (const [field, value] of Object.entries(config.filters)) {
          queryParams.push(value);
          conditions.push(`"${field}" = $${queryParams.length}`);
        }
      }

      if (conditions.length > 0) {
        metricQuery += ` WHERE ${conditions.join(' AND ')}`;
      }

      // Add GROUP BY if dimensions exist
      if (config.dimensions) {
        const groupFields = config.dimensions.map((dim, index) => `${index + 1}`);
        metricQuery += ` GROUP BY ${groupFields.join(', ')}`;
      }

      ctes.push(`${cteName} AS (${metricQuery})`);
    }

    // Build final query combining all metrics
    let finalQuery = '';
    if (ctes.length > 0) {
      finalQuery = `WITH ${ctes.join(', ')} `;
    }

    // Select from first metric CTE and join others
    if (config.metrics.length === 1) {
      finalQuery += `SELECT * FROM metric_${config.metrics[0].name}`;
    } else {
      // Complex join for multiple metrics
      const baseMetric = config.metrics[0];
      finalQuery += `SELECT `;
      
      if (config.dimensions) {
        const dimensionSelects = config.dimensions.map(dim => `m1."${dim.name}"`);
        finalQuery += `${dimensionSelects.join(', ')}, `;
      }

      const metricSelects = config.metrics.map((metric, index) => 
        `m${index + 1}."${metric.name}"`
      );
      finalQuery += metricSelects.join(', ');

      finalQuery += ` FROM metric_${baseMetric.name} m1`;

      // Join other metrics
      for (let i = 1; i < config.metrics.length; i++) {
        const metric = config.metrics[i];
        finalQuery += ` FULL OUTER JOIN metric_${metric.name} m${i + 1}`;
        
        if (config.dimensions) {
          const joinConditions = config.dimensions.map(dim => 
            `m1."${dim.name}" = m${i + 1}."${dim.name}"`
          );
          finalQuery += ` ON ${joinConditions.join(' AND ')}`;
        }
      }
    }

    // Add final ordering
    if (config.dimensions) {
      finalQuery += ` ORDER BY ${config.dimensions.map(dim => `"${dim.name}"`).join(', ')}`;
    }

    return await prisma.$queryRawUnsafe(finalQuery, ...queryParams);
  }

  private async validateReportConfig(config: any) {
    // Validate tables exist
    const validTables = ['users', 'orders', 'products', 'order_items'];
    
    for (const metric of config.metrics) {
      if (!validTables.includes(metric.table)) {
        throw new Error(`Invalid table: ${metric.table}`);
      }
    }

    if (config.dimensions) {
      for (const dimension of config.dimensions) {
        if (!validTables.includes(dimension.table)) {
          throw new Error(`Invalid dimension table: ${dimension.table}`);
        }
      }
    }

    // Additional validation logic...
  }

  async buildCustomDashboard(dashboardConfig: {
    widgets: Array<{
      type: 'metric' | 'chart' | 'table';
      title: string;
      query: {
        sql: string;
        params?: any[];
      };
      filters?: Record<string, any>;
    }>;
    globalFilters?: Record<string, any>;
  }) {
    const results: Record<string, any> = {};

    for (const widget of dashboardConfig.widgets) {
      try {
        // Apply global filters to widget query
        let { sql, params = [] } = widget.query;
        
        if (dashboardConfig.globalFilters) {
          // This is a simplified example - in production, you'd need more sophisticated filter merging
          for (const [key, value] of Object.entries(dashboardConfig.globalFilters)) {
            if (sql.includes(`{{${key}}}`)) {
              sql = sql.replace(`{{${key}}}`, `$${params.length + 1}`);
              params.push(value);
            }
          }
        }

        // Execute widget query
        const data = await prisma.$queryRawUnsafe(sql, ...params);
        results[widget.title] = {
          type: widget.type,
          data,
          success: true
        };

      } catch (error) {
        console.error(`Widget ${widget.title} failed:`, error);
        results[widget.title] = {
          type: widget.type,
          error: error.message,
          success: false
        };
      }
    }

    return results;
  }
}
```

## 4. Security Best Practices

### Input Validation and Sanitization

```typescript
class SecureQueryService {
  private readonly SQL_INJECTION_PATTERNS = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE)\b)/i,
    /(;|\-\-|\/\*|\*\/)/,
    /(\b(UNION|OR|AND)\s+\d+\s*=\s*\d+)/i,
    /(CONCAT|CHAR|ASCII)/i
  ];

  private readonly ALLOWED_OPERATORS = [
    '=', '!=', '<>', '<', '>', '<=', '>=', 
    'LIKE', 'ILIKE', 'IN', 'NOT IN', 'IS NULL', 'IS NOT NULL'
  ];

  private validateInput(input: string, type: 'column' | 'value' | 'operator'): boolean {
    if (!input || typeof input !== 'string') {
      return false;
    }

    // Check for SQL injection patterns
    for (const pattern of this.SQL_INJECTION_PATTERNS) {
      if (pattern.test(input)) {
        throw new Error(`Potentially malicious input detected: ${input}`);
      }
    }

    // Type-specific validation
    switch (type) {
      case 'column':
        // Column names should only contain letters, numbers, underscores
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(input);
      
      case 'operator':
        return this.ALLOWED_OPERATORS.includes(input.toUpperCase());
      
      case 'value':
        // Basic sanitization - remove dangerous characters
        return !/(;|--|\/\*|\*\/|xp_|sp_)/i.test(input);
      
      default:
        return false;
    }
  }

  async secureSearch(params: {
    table: string;
    columns: string[];
    conditions: Array<{
      column: string;
      operator: string;
      value: any;
    }>;
    orderBy?: string;
    limit?: number;
  }) {
    // Validate table name against whitelist
    const allowedTables = ['users', 'orders', 'products', 'categories'];
    if (!allowedTables.includes(params.table)) {
      throw new Error('Invalid table name');
    }

    // Validate columns
    for (const column of params.columns) {
      if (!this.validateInput(column, 'column')) {
        throw new Error(`Invalid column name: ${column}`);
      }
    }

    // Validate conditions
    for (const condition of params.conditions) {
      if (!this.validateInput(condition.column, 'column')) {
        throw new Error(`Invalid condition column: ${condition.column}`);
      }
      
      if (!this.validateInput(condition.operator, 'operator')) {
        throw new Error(`Invalid operator: ${condition.operator}`);
      }

      if (typeof condition.value === 'string' && !this.validateInput(condition.value, 'value')) {
        throw new Error(`Invalid condition value: ${condition.value}`);
      }
    }

    // Validate order by
    if (params.orderBy && !this.validateInput(params.orderBy, 'column')) {
      throw new Error(`Invalid order by column: ${params.orderBy}`);
    }

    // Validate limit
    if (params.limit && (params.limit < 1 || params.limit > 10000)) {
      throw new Error('Invalid limit: must be between 1 and 10000');
    }

    // Build safe query
    const selectClause = params.columns.map(col => `"${col}"`).join(', ');
    
    let query = `SELECT ${selectClause} FROM "${params.table}"`;
    const queryParams: any[] = [];

    // Add WHERE conditions
    if (params.conditions.length > 0) {
      const whereConditions = params.conditions.map(condition => {
        queryParams.push(condition.value);
        return `"${condition.column}" ${condition.operator} $${queryParams.length}`;
      });
      
      query += ` WHERE ${whereConditions.join(' AND ')}`;
    }

    // Add ORDER BY
    if (params.orderBy) {
      query += ` ORDER BY "${params.orderBy}"`;
    }

    // Add LIMIT
    if (params.limit) {
      query += ` LIMIT ${params.limit}`;
    }

    return await prisma.$queryRawUnsafe(query, ...queryParams);
  }

  async executeWhitelistedQuery(queryName: string, params: Record<string, any>) {
    // Pre-defined safe queries
    const whitelistedQueries = {
      usersByRole: `
        SELECT id, email, first_name, last_name, created_at 
        FROM users 
        WHERE role = $1 
        ORDER BY created_at DESC 
        LIMIT $2
      `,
      ordersByDateRange: `
        SELECT o.id, o.amount, o.status, o.created_at, u.email
        FROM orders o
        JOIN users u ON o.user_id = u.id
        WHERE o.created_at BETWEEN $1 AND $2
        ORDER BY o.created_at DESC
      `,
      productsByCategory: `
        SELECT p.id, p.name, p.price, p.stock_quantity, c.name as category_name
        FROM products p
        JOIN categories c ON p.category_id = c.id
        WHERE c.id = $1 AND p.is_active = true
        ORDER BY p.name
      `
    };

    const query = whitelistedQueries[queryName as keyof typeof whitelistedQueries];
    if (!query) {
      throw new Error('Query not found in whitelist');
    }

    // Extract parameters in order
    const paramValues = Object.values(params);
    
    return await prisma.$queryRawUnsafe(query, ...paramValues);
  }
}
```

## Key Takeaways

1. **`$queryRawUnsafe` is powerful but dangerous** - use with extreme caution
2. **Always validate and sanitize inputs** before building dynamic queries
3. **Use whitelisting approach** for tables, columns, and operations
4. **Parameterize values** even with unsafe queries
5. **Consider query builders** for complex dynamic requirements
6. **Security is paramount** - prefer safe alternatives when possible

## Exercises

1. **Safe Query Builder**: Create a query builder with comprehensive validation
2. **Dynamic Dashboard**: Build a flexible reporting system with security controls
3. **Input Validation**: Implement robust input sanitization for user queries
4. **Query Whitelisting**: Create a system of pre-approved dynamic queries

---

**Duration**: 26 minutes
**Next**: [4.5.5 Type Safety with Raw Queries](./4.5.5-type-safety-raw-queries.md)
**Previous**: [4.5.3 `$executeRaw` for INSERT/UPDATE/DELETE](./4.5.3-executeraw-insert-update-delete.md)
