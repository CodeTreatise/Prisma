# 4.5.2 `$queryRaw` for SELECT Operations

*Think like a master chef who knows when to use precision instruments vs standard tools - `$queryRaw` is your precision instrument for complex SELECT operations.*

## Learning Objectives
- Master `$queryRaw` for complex SELECT operations
- Understand type safety with raw SQL queries
- Learn parameter binding and SQL injection prevention
- Build expertise in complex analytics and reporting queries

## The Chef's Precision Tools Analogy

Just as a master chef uses precision instruments like mandoline slicers for specific cuts that regular knives can't achieve, `$queryRaw` gives you surgical precision for SELECT operations that generated queries can't handle efficiently.

## 1. Basic `$queryRaw` Syntax

### Simple SELECT Queries

```typescript
// Database Service for Analytics
class AnalyticsQueryService {
  async getBasicMetrics() {
    // Simple count query
    const userCount = await prisma.$queryRaw<{ count: bigint }[]>`
      SELECT COUNT(*) as count FROM users
    `;

    // Multiple columns
    const summary = await prisma.$queryRaw<{
      total_users: bigint;
      active_users: bigint;
      total_orders: bigint;
      total_revenue: number;
    }[]>`
      SELECT 
        (SELECT COUNT(*) FROM users) as total_users,
        (SELECT COUNT(*) FROM users WHERE last_login >= NOW() - INTERVAL '30 days') as active_users,
        (SELECT COUNT(*) FROM orders) as total_orders,
        (SELECT COALESCE(SUM(amount), 0) FROM orders WHERE status = 'completed') as total_revenue
    `;

    return {
      userCount: Number(userCount[0].count),
      summary: summary[0]
    };
  }

  async getUserRegistrationTrends() {
    // Date-based analytics
    type TrendData = {
      registration_date: Date;
      daily_registrations: bigint;
      cumulative_users: bigint;
    };

    const trends = await prisma.$queryRaw<TrendData[]>`
      SELECT 
        DATE(created_at) as registration_date,
        COUNT(*) as daily_registrations,
        SUM(COUNT(*)) OVER (ORDER BY DATE(created_at)) as cumulative_users
      FROM users 
      WHERE created_at >= NOW() - INTERVAL '30 days'
      GROUP BY DATE(created_at)
      ORDER BY registration_date
    `;

    return trends;
  }
}
```

## 2. Parameter Binding and Safety

### Safe Parameter Binding

```typescript
class SecureQueryService {
  // ✅ CORRECT: Using parameter binding
  async getUsersByStatus(status: string, limit: number) {
    return await prisma.$queryRaw<{
      id: string;
      email: string;
      created_at: Date;
      last_login: Date | null;
    }[]>`
      SELECT id, email, created_at, last_login
      FROM users 
      WHERE status = ${status}
      ORDER BY created_at DESC
      LIMIT ${limit}
    `;
  }

  // ✅ CORRECT: Complex parameter binding
  async getOrdersByDateRange(
    startDate: Date, 
    endDate: Date, 
    minAmount?: number,
    userIds?: string[]
  ) {
    let query = `
      SELECT 
        o.id,
        o.amount,
        o.created_at,
        u.email as user_email,
        COUNT(oi.id) as item_count
      FROM orders o
      JOIN users u ON o.user_id = u.id
      LEFT JOIN order_items oi ON o.id = oi.order_id
      WHERE o.created_at BETWEEN ${startDate} AND ${endDate}
    `;

    // Add optional filters
    if (minAmount !== undefined) {
      query += ` AND o.amount >= ${minAmount}`;
    }

    if (userIds && userIds.length > 0) {
      query += ` AND o.user_id = ANY(${userIds})`;
    }

    query += `
      GROUP BY o.id, o.amount, o.created_at, u.email
      ORDER BY o.created_at DESC
    `;

    type OrderResult = {
      id: string;
      amount: number;
      created_at: Date;
      user_email: string;
      item_count: bigint;
    };

    return await prisma.$queryRaw<OrderResult[]>`${query}`;
  }

  // ❌ DANGEROUS: Never do this (SQL injection risk)
  async dangerousQuery(userInput: string) {
    // DON'T DO THIS!
    // return await prisma.$queryRaw`
    //   SELECT * FROM users WHERE email = '${userInput}'
    // `;
  }

  // ✅ CORRECT: Safe dynamic queries
  async buildDynamicQuery(filters: {
    email?: string;
    status?: string;
    registrationAfter?: Date;
  }) {
    const conditions: string[] = [];
    const params: any[] = [];

    if (filters.email) {
      conditions.push(`email ILIKE $${params.length + 1}`);
      params.push(`%${filters.email}%`);
    }

    if (filters.status) {
      conditions.push(`status = $${params.length + 1}`);
      params.push(filters.status);
    }

    if (filters.registrationAfter) {
      conditions.push(`created_at >= $${params.length + 1}`);
      params.push(filters.registrationAfter);
    }

    const whereClause = conditions.length > 0 ? 
      `WHERE ${conditions.join(' AND ')}` : '';

    return await prisma.$queryRaw`
      SELECT id, email, status, created_at
      FROM users 
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT 100
    `;
  }
}
```

## 3. Complex Analytics Queries

### Advanced Reporting

```typescript
class ReportingService {
  async getSalesAnalytics(timeframe: 'week' | 'month' | 'quarter') {
    let interval: string;
    let truncFunction: string;

    switch (timeframe) {
      case 'week':
        interval = '7 days';
        truncFunction = 'week';
        break;
      case 'month':
        interval = '30 days';
        truncFunction = 'month';
        break;
      case 'quarter':
        interval = '90 days';
        truncFunction = 'quarter';
        break;
    }

    type SalesAnalytics = {
      period: Date;
      total_sales: number;
      order_count: bigint;
      unique_customers: bigint;
      avg_order_value: number;
      top_category: string;
      growth_rate: number;
    };

    return await prisma.$queryRaw<SalesAnalytics[]>`
      WITH period_sales AS (
        SELECT 
          DATE_TRUNC(${truncFunction}, o.created_at) as period,
          SUM(o.amount) as total_sales,
          COUNT(o.id) as order_count,
          COUNT(DISTINCT o.user_id) as unique_customers,
          AVG(o.amount) as avg_order_value
        FROM orders o
        WHERE o.created_at >= NOW() - INTERVAL ${interval}
        AND o.status = 'completed'
        GROUP BY DATE_TRUNC(${truncFunction}, o.created_at)
      ),
      period_categories AS (
        SELECT 
          DATE_TRUNC(${truncFunction}, o.created_at) as period,
          c.name as category_name,
          COUNT(*) as category_orders,
          ROW_NUMBER() OVER (
            PARTITION BY DATE_TRUNC(${truncFunction}, o.created_at) 
            ORDER BY COUNT(*) DESC
          ) as category_rank
        FROM orders o
        JOIN order_items oi ON o.id = oi.order_id
        JOIN products p ON oi.product_id = p.id
        JOIN categories c ON p.category_id = c.id
        WHERE o.created_at >= NOW() - INTERVAL ${interval}
        AND o.status = 'completed'
        GROUP BY DATE_TRUNC(${truncFunction}, o.created_at), c.name
      ),
      growth_calculation AS (
        SELECT 
          period,
          total_sales,
          order_count,
          unique_customers,
          avg_order_value,
          LAG(total_sales) OVER (ORDER BY period) as prev_period_sales,
          CASE 
            WHEN LAG(total_sales) OVER (ORDER BY period) > 0 THEN
              ((total_sales - LAG(total_sales) OVER (ORDER BY period)) / 
               LAG(total_sales) OVER (ORDER BY period)) * 100
            ELSE 0
          END as growth_rate
        FROM period_sales
      )
      SELECT 
        gc.period,
        gc.total_sales,
        gc.order_count,
        gc.unique_customers,
        gc.avg_order_value,
        COALESCE(pc.category_name, 'Unknown') as top_category,
        COALESCE(gc.growth_rate, 0) as growth_rate
      FROM growth_calculation gc
      LEFT JOIN period_categories pc ON gc.period = pc.period AND pc.category_rank = 1
      ORDER BY gc.period DESC
    `;
  }

  async getCustomerSegmentAnalysis() {
    type CustomerSegment = {
      segment: string;
      customer_count: bigint;
      avg_order_value: number;
      avg_order_frequency: number;
      total_revenue: number;
      retention_rate: number;
    };

    return await prisma.$queryRaw<CustomerSegment[]>`
      WITH customer_metrics AS (
        SELECT 
          u.id,
          COUNT(o.id) as order_count,
          COALESCE(SUM(o.amount), 0) as total_spent,
          COALESCE(AVG(o.amount), 0) as avg_order_value,
          MAX(o.created_at) as last_order_date,
          MIN(o.created_at) as first_order_date,
          CASE 
            WHEN COUNT(o.id) = 0 THEN 'never_purchased'
            WHEN MAX(o.created_at) < NOW() - INTERVAL '180 days' THEN 'churned'
            WHEN COUNT(o.id) >= 20 AND SUM(o.amount) >= 5000 THEN 'vip'
            WHEN COUNT(o.id) >= 10 AND SUM(o.amount) >= 2000 THEN 'loyal'
            WHEN COUNT(o.id) >= 3 THEN 'repeat'
            WHEN COUNT(o.id) >= 1 THEN 'one_time'
            ELSE 'prospect'
          END as segment
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed'
        WHERE u.created_at >= NOW() - INTERVAL '2 years'
        GROUP BY u.id
      ),
      segment_stats AS (
        SELECT 
          segment,
          COUNT(*) as customer_count,
          AVG(avg_order_value) as avg_order_value,
          AVG(order_count) as avg_order_frequency,
          SUM(total_spent) as total_revenue
        FROM customer_metrics
        GROUP BY segment
      ),
      retention_calc AS (
        SELECT 
          cm.segment,
          COUNT(CASE WHEN cm.last_order_date >= NOW() - INTERVAL '90 days' THEN 1 END) * 100.0 / 
          COUNT(*) as retention_rate
        FROM customer_metrics cm
        WHERE cm.segment != 'never_purchased'
        GROUP BY cm.segment
      )
      SELECT 
        ss.segment,
        ss.customer_count,
        ROUND(ss.avg_order_value::numeric, 2) as avg_order_value,
        ROUND(ss.avg_order_frequency::numeric, 2) as avg_order_frequency,
        ss.total_revenue,
        COALESCE(ROUND(rc.retention_rate::numeric, 2), 0) as retention_rate
      FROM segment_stats ss
      LEFT JOIN retention_calc rc ON ss.segment = rc.segment
      ORDER BY ss.total_revenue DESC
    `;
  }
}
```

## 4. Performance Optimization

### Query Optimization Techniques

```typescript
class OptimizedQueryService {
  async getProductPerformance(categoryId?: string) {
    // Optimized with proper indexing and CTEs
    type ProductPerformance = {
      product_id: string;
      product_name: string;
      category_name: string;
      total_sales: number;
      units_sold: bigint;
      avg_rating: number;
      inventory_level: number;
      performance_score: number;
    };

    let categoryFilter = '';
    if (categoryId) {
      categoryFilter = `AND p.category_id = ${categoryId}`;
    }

    return await prisma.$queryRaw<ProductPerformance[]>`
      WITH product_sales AS (
        SELECT 
          p.id as product_id,
          p.name as product_name,
          c.name as category_name,
          COALESCE(SUM(oi.quantity * oi.price), 0) as total_sales,
          COALESCE(SUM(oi.quantity), 0) as units_sold,
          p.stock_quantity as inventory_level
        FROM products p
        JOIN categories c ON p.category_id = c.id
        LEFT JOIN order_items oi ON p.id = oi.product_id
        LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 'completed'
        WHERE p.is_active = true ${categoryFilter}
        GROUP BY p.id, p.name, c.name, p.stock_quantity
      ),
      product_ratings AS (
        SELECT 
          product_id,
          COALESCE(AVG(rating), 0) as avg_rating
        FROM product_reviews
        WHERE created_at >= NOW() - INTERVAL '6 months'
        GROUP BY product_id
      ),
      performance_calc AS (
        SELECT 
          ps.*,
          COALESCE(pr.avg_rating, 0) as avg_rating,
          -- Performance score calculation
          (
            LEAST(ps.total_sales / NULLIF((SELECT AVG(total_sales) FROM product_sales), 0), 2) * 40 +
            LEAST(ps.units_sold / NULLIF((SELECT AVG(units_sold) FROM product_sales), 0), 2) * 30 +
            COALESCE(pr.avg_rating, 0) / 5 * 30
          ) as performance_score
        FROM product_sales ps
        LEFT JOIN product_ratings pr ON ps.product_id = pr.product_id
      )
      SELECT 
        product_id,
        product_name,
        category_name,
        total_sales,
        units_sold,
        ROUND(avg_rating::numeric, 2) as avg_rating,
        inventory_level,
        ROUND(performance_score::numeric, 2) as performance_score
      FROM performance_calc
      ORDER BY performance_score DESC, total_sales DESC
      LIMIT 50
    `;
  }

  async getInventoryAlerts() {
    // Efficient query for inventory management
    type InventoryAlert = {
      product_id: string;
      product_name: string;
      current_stock: number;
      reorder_level: number;
      days_until_stockout: number;
      avg_daily_sales: number;
      alert_level: 'critical' | 'warning' | 'normal';
    };

    return await prisma.$queryRaw<InventoryAlert[]>`
      WITH daily_sales AS (
        SELECT 
          oi.product_id,
          AVG(daily_quantity) as avg_daily_sales
        FROM (
          SELECT 
            oi.product_id,
            DATE(o.created_at) as sale_date,
            SUM(oi.quantity) as daily_quantity
          FROM order_items oi
          JOIN orders o ON oi.order_id = o.id
          WHERE o.status = 'completed'
          AND o.created_at >= NOW() - INTERVAL '30 days'
          GROUP BY oi.product_id, DATE(o.created_at)
        ) daily_totals
        GROUP BY product_id
      ),
      stock_analysis AS (
        SELECT 
          p.id as product_id,
          p.name as product_name,
          p.stock_quantity as current_stock,
          p.reorder_level,
          COALESCE(ds.avg_daily_sales, 0) as avg_daily_sales,
          CASE 
            WHEN COALESCE(ds.avg_daily_sales, 0) > 0 THEN
              p.stock_quantity / ds.avg_daily_sales
            ELSE 999
          END as days_until_stockout
        FROM products p
        LEFT JOIN daily_sales ds ON p.id = ds.product_id
        WHERE p.is_active = true
      )
      SELECT 
        product_id,
        product_name,
        current_stock,
        reorder_level,
        ROUND(days_until_stockout::numeric, 1) as days_until_stockout,
        ROUND(avg_daily_sales::numeric, 2) as avg_daily_sales,
        CASE 
          WHEN current_stock <= reorder_level AND days_until_stockout <= 7 THEN 'critical'
          WHEN current_stock <= reorder_level OR days_until_stockout <= 14 THEN 'warning'
          ELSE 'normal'
        END as alert_level
      FROM stock_analysis
      WHERE current_stock <= reorder_level * 1.5  -- Only show items approaching reorder
      ORDER BY days_until_stockout ASC, current_stock ASC
    `;
  }
}
```

## 5. Type Safety Best Practices

### Defining Result Types

```typescript
// Type Definitions for Query Results
namespace QueryTypes {
  export type UserMetrics = {
    user_id: string;
    email: string;
    registration_date: Date;
    last_login: Date | null;
    order_count: bigint;
    total_spent: number;
    avg_order_value: number;
    favorite_category: string | null;
  };

  export type SalesMetrics = {
    period: Date;
    revenue: number;
    order_count: bigint;
    unique_customers: bigint;
    avg_order_value: number;
    top_product: string;
    growth_rate: number;
  };

  export type InventoryStatus = {
    product_id: string;
    sku: string;
    name: string;
    current_stock: number;
    reserved_stock: number;
    available_stock: number;
    reorder_point: number;
    status: 'in_stock' | 'low_stock' | 'out_of_stock' | 'discontinued';
  };
}

class TypedQueryService {
  async getUserMetrics(limit: number = 100): Promise<QueryTypes.UserMetrics[]> {
    return await prisma.$queryRaw<QueryTypes.UserMetrics[]>`
      SELECT 
        u.id as user_id,
        u.email,
        u.created_at as registration_date,
        u.last_login,
        COUNT(o.id) as order_count,
        COALESCE(SUM(o.amount), 0) as total_spent,
        COALESCE(AVG(o.amount), 0) as avg_order_value,
        (
          SELECT c.name 
          FROM categories c
          JOIN products p ON c.id = p.category_id
          JOIN order_items oi ON p.id = oi.product_id
          JOIN orders ord ON oi.order_id = ord.id
          WHERE ord.user_id = u.id AND ord.status = 'completed'
          GROUP BY c.id, c.name
          ORDER BY COUNT(*) DESC
          LIMIT 1
        ) as favorite_category
      FROM users u
      LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed'
      GROUP BY u.id, u.email, u.created_at, u.last_login
      ORDER BY total_spent DESC
      LIMIT ${limit}
    `;
  }

  async getPerformanceMetrics(startDate: Date, endDate: Date): Promise<QueryTypes.SalesMetrics[]> {
    return await prisma.$queryRaw<QueryTypes.SalesMetrics[]>`
      WITH period_data AS (
        SELECT 
          DATE_TRUNC('day', o.created_at) as period,
          SUM(o.amount) as revenue,
          COUNT(o.id) as order_count,
          COUNT(DISTINCT o.user_id) as unique_customers,
          AVG(o.amount) as avg_order_value
        FROM orders o
        WHERE o.created_at BETWEEN ${startDate} AND ${endDate}
        AND o.status = 'completed'
        GROUP BY DATE_TRUNC('day', o.created_at)
      ),
      top_products AS (
        SELECT 
          DATE_TRUNC('day', o.created_at) as period,
          p.name as product_name,
          ROW_NUMBER() OVER (
            PARTITION BY DATE_TRUNC('day', o.created_at)
            ORDER BY SUM(oi.quantity) DESC
          ) as product_rank
        FROM orders o
        JOIN order_items oi ON o.id = oi.order_id
        JOIN products p ON oi.product_id = p.id
        WHERE o.created_at BETWEEN ${startDate} AND ${endDate}
        AND o.status = 'completed'
        GROUP BY DATE_TRUNC('day', o.created_at), p.name
      )
      SELECT 
        pd.period,
        pd.revenue,
        pd.order_count,
        pd.unique_customers,
        pd.avg_order_value,
        COALESCE(tp.product_name, 'No sales') as top_product,
        COALESCE(
          (pd.revenue - LAG(pd.revenue) OVER (ORDER BY pd.period)) / 
          NULLIF(LAG(pd.revenue) OVER (ORDER BY pd.period), 0) * 100,
          0
        ) as growth_rate
      FROM period_data pd
      LEFT JOIN top_products tp ON pd.period = tp.period AND tp.product_rank = 1
      ORDER BY pd.period DESC
    `;
  }
}
```

## Key Takeaways

1. **Always use parameter binding** to prevent SQL injection
2. **Define proper TypeScript types** for query results
3. **Use CTEs** for complex analytics queries
4. **Optimize with proper indexing** in mind
5. **Handle bigint conversion** when needed
6. **Test query performance** with realistic data sizes

## Exercises

1. **Analytics Dashboard**: Create a complex analytics query using CTEs and window functions
2. **Type Safety**: Define comprehensive TypeScript types for your query results
3. **Performance Testing**: Compare `$queryRaw` vs generated queries for complex operations
4. **Dynamic Queries**: Build a flexible reporting system with safe parameter binding

---

**Duration**: 25 minutes
**Next**: [4.5.3 `$executeRaw` for INSERT/UPDATE/DELETE](./4.5.3-executeraw-insert-update-delete.md)
**Previous**: [4.5.1 When to Use Raw SQL vs Generated Queries](./4.5.1-when-to-use-raw-sql.md)
