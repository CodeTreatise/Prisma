# 4.5.5 Type Safety with Raw Queries

*Think like a master engineer who designs precise blueprints - type safety with raw queries requires careful planning and robust type definitions to maintain the benefits of TypeScript while using SQL's power.*

## Learning Objectives
- Master type safety techniques for raw SQL queries
- Understand TypeScript integration with dynamic query results
- Learn runtime validation and type assertion patterns
- Build expertise in maintaining type safety across complex query scenarios

## The Engineer's Blueprint Analogy

Just as a master engineer creates detailed blueprints that specify exact measurements and materials, type safety with raw queries requires precise type definitions and validation to ensure your code remains predictable and maintainable.

## 1. Defining Result Types

### Comprehensive Type Definitions

```typescript
// Core Query Result Types
namespace QueryResultTypes {
  // User-related query results
  export interface UserSummary {
    id: string;
    email: string;
    full_name: string;
    registration_date: Date;
    last_login: Date | null;
    is_active: boolean;
  }

  export interface UserMetrics {
    user_id: string;
    email: string;
    order_count: bigint;
    total_spent: number;
    avg_order_value: number;
    last_order_date: Date | null;
    customer_segment: 'new' | 'regular' | 'vip' | 'churned';
  }

  // Sales and Analytics
  export interface SalesReport {
    period: Date;
    total_revenue: number;
    order_count: bigint;
    unique_customers: bigint;
    avg_order_value: number;
    growth_rate: number;
    top_category: string | null;
  }

  export interface ProductPerformance {
    product_id: string;
    product_name: string;
    category_name: string;
    total_sales: number;
    units_sold: bigint;
    avg_rating: number;
    inventory_level: number;
    performance_score: number;
    trending_direction: 'up' | 'down' | 'stable';
  }

  // Inventory and Operations
  export interface InventoryAlert {
    product_id: string;
    sku: string;
    product_name: string;
    current_stock: number;
    reorder_level: number;
    days_until_stockout: number;
    avg_daily_sales: number;
    alert_level: 'critical' | 'warning' | 'normal';
    recommended_order_quantity: number;
  }

  // Financial Analytics
  export interface RevenueBreakdown {
    revenue_source: string;
    amount: number;
    percentage_of_total: number;
    month_over_month_change: number;
    year_over_year_change: number;
  }
}
```

### Type-Safe Query Service

```typescript
class TypeSafeQueryService {
  async getUserMetrics(filters: {
    dateRange?: { start: Date; end: Date };
    segments?: string[];
    limit?: number;
  }): Promise<QueryResultTypes.UserMetrics[]> {
    let whereClause = '1=1';
    const params: any[] = [];

    if (filters.dateRange) {
      whereClause += ` AND u.created_at BETWEEN $${params.length + 1} AND $${params.length + 2}`;
      params.push(filters.dateRange.start, filters.dateRange.end);
    }

    if (filters.segments && filters.segments.length > 0) {
      whereClause += ` AND customer_segment = ANY($${params.length + 1})`;
      params.push(filters.segments);
    }

    const limitClause = filters.limit ? `LIMIT ${filters.limit}` : 'LIMIT 1000';

    const results = await prisma.$queryRaw<QueryResultTypes.UserMetrics[]>`
      WITH user_order_stats AS (
        SELECT 
          u.id as user_id,
          u.email,
          COUNT(o.id) as order_count,
          COALESCE(SUM(o.amount), 0) as total_spent,
          COALESCE(AVG(o.amount), 0) as avg_order_value,
          MAX(o.created_at) as last_order_date,
          CASE 
            WHEN COUNT(o.id) = 0 THEN 'new'
            WHEN COUNT(o.id) >= 10 AND SUM(o.amount) >= 1000 THEN 'vip'
            WHEN COUNT(o.id) >= 3 THEN 'regular'
            WHEN MAX(o.created_at) < NOW() - INTERVAL '180 days' THEN 'churned'
            ELSE 'new'
          END as customer_segment
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed'
        WHERE ${whereClause}
        GROUP BY u.id, u.email
      )
      SELECT 
        user_id,
        email,
        order_count,
        total_spent,
        avg_order_value,
        last_order_date,
        customer_segment
      FROM user_order_stats
      ORDER BY total_spent DESC
      ${limitClause}
    `;

    // Type assertion with validation
    return this.validateUserMetrics(results);
  }

  async getSalesReport(
    period: 'daily' | 'weekly' | 'monthly',
    startDate: Date,
    endDate: Date
  ): Promise<QueryResultTypes.SalesReport[]> {
    const truncFunction = period === 'daily' ? 'day' : 
                         period === 'weekly' ? 'week' : 'month';

    const results = await prisma.$queryRaw<QueryResultTypes.SalesReport[]>`
      WITH period_sales AS (
        SELECT 
          DATE_TRUNC(${truncFunction}, o.created_at) as period,
          SUM(o.amount) as total_revenue,
          COUNT(o.id) as order_count,
          COUNT(DISTINCT o.user_id) as unique_customers,
          AVG(o.amount) as avg_order_value
        FROM orders o
        WHERE o.created_at BETWEEN ${startDate} AND ${endDate}
        AND o.status = 'completed'
        GROUP BY DATE_TRUNC(${truncFunction}, o.created_at)
      ),
      period_categories AS (
        SELECT 
          DATE_TRUNC(${truncFunction}, o.created_at) as period,
          c.name as category_name,
          ROW_NUMBER() OVER (
            PARTITION BY DATE_TRUNC(${truncFunction}, o.created_at)
            ORDER BY SUM(oi.quantity) DESC
          ) as rank
        FROM orders o
        JOIN order_items oi ON o.id = oi.order_id
        JOIN products p ON oi.product_id = p.id
        JOIN categories c ON p.category_id = c.id
        WHERE o.created_at BETWEEN ${startDate} AND ${endDate}
        AND o.status = 'completed'
        GROUP BY DATE_TRUNC(${truncFunction}, o.created_at), c.name
      )
      SELECT 
        ps.period,
        ps.total_revenue,
        ps.order_count,
        ps.unique_customers,
        ps.avg_order_value,
        COALESCE(
          (ps.total_revenue - LAG(ps.total_revenue) OVER (ORDER BY ps.period)) / 
          NULLIF(LAG(ps.total_revenue) OVER (ORDER BY ps.period), 0) * 100,
          0
        ) as growth_rate,
        pc.category_name as top_category
      FROM period_sales ps
      LEFT JOIN period_categories pc ON ps.period = pc.period AND pc.rank = 1
      ORDER BY ps.period DESC
    `;

    return this.validateSalesReport(results);
  }

  // Type validation methods
  private validateUserMetrics(data: any[]): QueryResultTypes.UserMetrics[] {
    return data.map(item => {
      if (!item.user_id || !item.email) {
        throw new Error('Invalid user metrics data: missing required fields');
      }

      return {
        user_id: String(item.user_id),
        email: String(item.email),
        order_count: BigInt(item.order_count || 0),
        total_spent: Number(item.total_spent || 0),
        avg_order_value: Number(item.avg_order_value || 0),
        last_order_date: item.last_order_date ? new Date(item.last_order_date) : null,
        customer_segment: this.validateSegment(item.customer_segment)
      };
    });
  }

  private validateSalesReport(data: any[]): QueryResultTypes.SalesReport[] {
    return data.map(item => ({
      period: new Date(item.period),
      total_revenue: Number(item.total_revenue || 0),
      order_count: BigInt(item.order_count || 0),
      unique_customers: BigInt(item.unique_customers || 0),
      avg_order_value: Number(item.avg_order_value || 0),
      growth_rate: Number(item.growth_rate || 0),
      top_category: item.top_category ? String(item.top_category) : null
    }));
  }

  private validateSegment(segment: any): 'new' | 'regular' | 'vip' | 'churned' {
    const validSegments = ['new', 'regular', 'vip', 'churned'];
    return validSegments.includes(segment) ? segment : 'new';
  }
}
```

## 2. Generic Query Builders

### Reusable Type-Safe Patterns

```typescript
// Generic Query Result Handler
class GenericQueryService {
  async executeTypedQuery<T>(
    query: string,
    params: any[],
    validator: (data: any[]) => T[]
  ): Promise<T[]> {
    try {
      const rawResults = await prisma.$queryRawUnsafe(query, ...params);
      return validator(rawResults as any[]);
    } catch (error) {
      console.error('Query execution failed:', { query, params, error });
      throw new Error(`Query failed: ${error.message}`);
    }
  }

  async executeCountQuery(
    table: string,
    conditions: Record<string, any> = {}
  ): Promise<number> {
    const whereClause = Object.keys(conditions).length > 0 ?
      `WHERE ${Object.keys(conditions).map((key, index) => `"${key}" = $${index + 1}`).join(' AND ')}` :
      '';

    const result = await this.executeTypedQuery<{ count: bigint }>(
      `SELECT COUNT(*) as count FROM "${table}" ${whereClause}`,
      Object.values(conditions),
      (data) => data.map(item => ({ count: BigInt(item.count) }))
    );

    return Number(result[0].count);
  }

  async executeAggregationQuery<T extends Record<string, any>>(
    config: {
      table: string;
      aggregations: Array<{
        function: 'SUM' | 'AVG' | 'MIN' | 'MAX' | 'COUNT';
        field?: string;
        alias: string;
      }>;
      groupBy?: string[];
      conditions?: Record<string, any>;
      validator: (data: any[]) => T[];
    }
  ): Promise<T[]> {
    const selectClauses = config.aggregations.map(agg => {
      if (agg.function === 'COUNT' && !agg.field) {
        return `COUNT(*) as "${agg.alias}"`;
      }
      return `${agg.function}("${agg.field}") as "${agg.alias}"`;
    });

    const groupByClauses = config.groupBy ? 
      config.groupBy.map(field => `"${field}"`).join(', ') : '';

    const whereClause = config.conditions && Object.keys(config.conditions).length > 0 ?
      `WHERE ${Object.keys(config.conditions).map((key, index) => `"${key}" = $${index + 1}`).join(' AND ')}` :
      '';

    const query = `
      SELECT ${config.groupBy ? `${groupByClauses}, ` : ''}${selectClauses.join(', ')}
      FROM "${config.table}"
      ${whereClause}
      ${config.groupBy ? `GROUP BY ${groupByClauses}` : ''}
    `;

    return await this.executeTypedQuery(
      query,
      config.conditions ? Object.values(config.conditions) : [],
      config.validator
    );
  }
}
```

## 3. Runtime Type Validation

### Comprehensive Validation Framework

```typescript
// Type Validation Utilities
class TypeValidator {
  static validateString(value: any, fieldName: string): string {
    if (typeof value !== 'string') {
      throw new Error(`${fieldName} must be a string, got ${typeof value}`);
    }
    return value;
  }

  static validateNumber(value: any, fieldName: string): number {
    const num = Number(value);
    if (isNaN(num)) {
      throw new Error(`${fieldName} must be a number, got ${typeof value}`);
    }
    return num;
  }

  static validateBigInt(value: any, fieldName: string): bigint {
    try {
      return BigInt(value);
    } catch {
      throw new Error(`${fieldName} must be convertible to BigInt, got ${typeof value}`);
    }
  }

  static validateDate(value: any, fieldName: string): Date {
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      throw new Error(`${fieldName} must be a valid date, got ${value}`);
    }
    return date;
  }

  static validateOptionalDate(value: any, fieldName: string): Date | null {
    if (value === null || value === undefined) {
      return null;
    }
    return this.validateDate(value, fieldName);
  }

  static validateEnum<T extends string>(
    value: any,
    allowedValues: readonly T[],
    fieldName: string
  ): T {
    if (!allowedValues.includes(value)) {
      throw new Error(`${fieldName} must be one of [${allowedValues.join(', ')}], got ${value}`);
    }
    return value;
  }

  static validateArray<T>(
    value: any,
    itemValidator: (item: any, index: number) => T,
    fieldName: string
  ): T[] {
    if (!Array.isArray(value)) {
      throw new Error(`${fieldName} must be an array, got ${typeof value}`);
    }
    return value.map((item, index) => itemValidator(item, index));
  }
}

// Specific Validators for Query Results
class QueryResultValidator {
  static validateProductPerformance(data: any[]): QueryResultTypes.ProductPerformance[] {
    return TypeValidator.validateArray(data, (item, index) => {
      try {
        return {
          product_id: TypeValidator.validateString(item.product_id, `item[${index}].product_id`),
          product_name: TypeValidator.validateString(item.product_name, `item[${index}].product_name`),
          category_name: TypeValidator.validateString(item.category_name, `item[${index}].category_name`),
          total_sales: TypeValidator.validateNumber(item.total_sales, `item[${index}].total_sales`),
          units_sold: TypeValidator.validateBigInt(item.units_sold, `item[${index}].units_sold`),
          avg_rating: TypeValidator.validateNumber(item.avg_rating, `item[${index}].avg_rating`),
          inventory_level: TypeValidator.validateNumber(item.inventory_level, `item[${index}].inventory_level`),
          performance_score: TypeValidator.validateNumber(item.performance_score, `item[${index}].performance_score`),
          trending_direction: TypeValidator.validateEnum(
            item.trending_direction, 
            ['up', 'down', 'stable'] as const,
            `item[${index}].trending_direction`
          )
        };
      } catch (error) {
        throw new Error(`Validation failed for ProductPerformance item ${index}: ${error.message}`);
      }
    }, 'ProductPerformance data');
  }

  static validateInventoryAlert(data: any[]): QueryResultTypes.InventoryAlert[] {
    return TypeValidator.validateArray(data, (item, index) => {
      try {
        return {
          product_id: TypeValidator.validateString(item.product_id, `item[${index}].product_id`),
          sku: TypeValidator.validateString(item.sku, `item[${index}].sku`),
          product_name: TypeValidator.validateString(item.product_name, `item[${index}].product_name`),
          current_stock: TypeValidator.validateNumber(item.current_stock, `item[${index}].current_stock`),
          reorder_level: TypeValidator.validateNumber(item.reorder_level, `item[${index}].reorder_level`),
          days_until_stockout: TypeValidator.validateNumber(item.days_until_stockout, `item[${index}].days_until_stockout`),
          avg_daily_sales: TypeValidator.validateNumber(item.avg_daily_sales, `item[${index}].avg_daily_sales`),
          alert_level: TypeValidator.validateEnum(
            item.alert_level, 
            ['critical', 'warning', 'normal'] as const,
            `item[${index}].alert_level`
          ),
          recommended_order_quantity: TypeValidator.validateNumber(item.recommended_order_quantity, `item[${index}].recommended_order_quantity`)
        };
      } catch (error) {
        throw new Error(`Validation failed for InventoryAlert item ${index}: ${error.message}`);
      }
    }, 'InventoryAlert data');
  }
}
```

## 4. Advanced Type Patterns

### Complex Type Composition

```typescript
// Advanced Type Patterns for Complex Queries
namespace AdvancedQueryTypes {
  // Union types for dynamic results
  export type DashboardWidget = 
    | { type: 'metric'; data: { label: string; value: number; change: number } }
    | { type: 'chart'; data: { labels: string[]; values: number[] } }
    | { type: 'table'; data: Record<string, any>[] }
    | { type: 'alert'; data: { level: 'info' | 'warning' | 'error'; message: string } };

  // Conditional types for query results
  export type QueryResult<T extends string> = 
    T extends 'users' ? QueryResultTypes.UserMetrics[] :
    T extends 'sales' ? QueryResultTypes.SalesReport[] :
    T extends 'products' ? QueryResultTypes.ProductPerformance[] :
    T extends 'inventory' ? QueryResultTypes.InventoryAlert[] :
    Record<string, any>[];

  // Mapped types for dynamic field selection
  export type FieldSelection<T> = {
    [K in keyof T]?: boolean;
  };

  export type SelectedFields<T, S extends FieldSelection<T>> = {
    [K in keyof T as S[K] extends true ? K : never]: T[K];
  };
}

class AdvancedTypedQueryService {
  async getTypedQueryResult<T extends 'users' | 'sales' | 'products' | 'inventory'>(
    queryType: T,
    params: Record<string, any> = {}
  ): Promise<AdvancedQueryTypes.QueryResult<T>> {
    const queryConfig = {
      users: {
        query: `
          SELECT user_id, email, order_count, total_spent, avg_order_value, 
                 last_order_date, customer_segment
          FROM user_metrics_view
          WHERE 1=1
        `,
        validator: QueryResultValidator.validateUserMetrics
      },
      sales: {
        query: `
          SELECT period, total_revenue, order_count, unique_customers, 
                 avg_order_value, growth_rate, top_category
          FROM sales_report_view
          WHERE period >= $1 AND period <= $2
        `,
        validator: (data: any[]) => data as QueryResultTypes.SalesReport[]
      },
      products: {
        query: `
          SELECT product_id, product_name, category_name, total_sales, 
                 units_sold, avg_rating, inventory_level, performance_score,
                 trending_direction
          FROM product_performance_view
          WHERE 1=1
        `,
        validator: QueryResultValidator.validateProductPerformance
      },
      inventory: {
        query: `
          SELECT product_id, sku, product_name, current_stock, reorder_level,
                 days_until_stockout, avg_daily_sales, alert_level,
                 recommended_order_quantity
          FROM inventory_alerts_view
          WHERE alert_level != 'normal'
        `,
        validator: QueryResultValidator.validateInventoryAlert
      }
    };

    const config = queryConfig[queryType];
    const result = await prisma.$queryRawUnsafe(config.query, ...Object.values(params));
    
    return config.validator(result as any[]) as AdvancedQueryTypes.QueryResult<T>;
  }

  async buildDynamicDashboard(
    widgets: Array<{
      id: string;
      type: 'metric' | 'chart' | 'table' | 'alert';
      query: string;
      params?: any[];
    }>
  ): Promise<Record<string, AdvancedQueryTypes.DashboardWidget>> {
    const results: Record<string, AdvancedQueryTypes.DashboardWidget> = {};

    await Promise.allSettled(
      widgets.map(async (widget) => {
        try {
          const data = await prisma.$queryRawUnsafe(widget.query, ...(widget.params || []));
          
          switch (widget.type) {
            case 'metric':
              results[widget.id] = {
                type: 'metric',
                data: this.processMetricData(data)
              };
              break;
            case 'chart':
              results[widget.id] = {
                type: 'chart',
                data: this.processChartData(data)
              };
              break;
            case 'table':
              results[widget.id] = {
                type: 'table',
                data: data as Record<string, any>[]
              };
              break;
            case 'alert':
              results[widget.id] = {
                type: 'alert',
                data: this.processAlertData(data)
              };
              break;
          }
        } catch (error) {
          console.error(`Widget ${widget.id} failed:`, error);
          results[widget.id] = {
            type: 'alert',
            data: { level: 'error', message: `Widget failed: ${error.message}` }
          };
        }
      })
    );

    return results;
  }

  private processMetricData(data: any[]): { label: string; value: number; change: number } {
    if (!data.length) {
      return { label: 'No Data', value: 0, change: 0 };
    }
    
    const item = data[0];
    return {
      label: String(item.label || 'Metric'),
      value: Number(item.value || 0),
      change: Number(item.change || 0)
    };
  }

  private processChartData(data: any[]): { labels: string[]; values: number[] } {
    return {
      labels: data.map(item => String(item.label || '')),
      values: data.map(item => Number(item.value || 0))
    };
  }

  private processAlertData(data: any[]): { level: 'info' | 'warning' | 'error'; message: string } {
    if (!data.length) {
      return { level: 'info', message: 'No alerts' };
    }

    const item = data[0];
    const level = ['info', 'warning', 'error'].includes(item.level) ? item.level : 'info';
    
    return {
      level: level as 'info' | 'warning' | 'error',
      message: String(item.message || 'Unknown alert')
    };
  }
}
```

## Key Takeaways

1. **Define comprehensive types** for all query results
2. **Use runtime validation** to ensure type safety
3. **Create reusable validators** for common patterns
4. **Handle BigInt conversion** properly in PostgreSQL
5. **Validate enum values** against allowed options
6. **Build generic query builders** for type safety
7. **Use proper error handling** for validation failures

## Exercises

1. **Type Definition**: Create comprehensive types for your domain queries
2. **Validation Framework**: Build runtime validators for your query results
3. **Generic Builder**: Create a type-safe query builder for your use cases
4. **Error Handling**: Implement robust validation with proper error messages

---

**Duration**: 24 minutes
**Next**: [4.5.6 SQL Injection Prevention](./4.5.6-sql-injection-prevention.md)
**Previous**: [4.5.4 `$queryRawUnsafe` for Dynamic Queries](./4.5.4-queryrawunsafe-dynamic-queries.md)
