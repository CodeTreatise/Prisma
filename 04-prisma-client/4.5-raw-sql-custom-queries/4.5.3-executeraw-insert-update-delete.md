# 4.5.3 `$executeRaw` for INSERT/UPDATE/DELETE

*Think like a master surgeon who uses specialized instruments for precise operations - `$executeRaw` is your surgical tool for data modification operations.*

## Learning Objectives
- Master `$executeRaw` for INSERT, UPDATE, and DELETE operations
- Understand transaction safety with raw SQL modifications
- Learn bulk operations and performance optimization
- Build expertise in complex data manipulation scenarios

## The Surgeon's Precision Analogy

Just as a surgeon uses specialized instruments for precise operations that require exact control, `$executeRaw` gives you surgical precision for data modifications that generated queries can't handle efficiently or at all.

## 1. Basic `$executeRaw` Operations

### INSERT Operations

```typescript
// Data Management Service
class DataManagementService {
  async insertUserBatch(users: Array<{
    email: string;
    firstName: string;
    lastName: string;
    role: string;
  }>) {
    // Bulk insert with conflict resolution
    const result = await prisma.$executeRaw`
      INSERT INTO users (id, email, first_name, last_name, role, created_at)
      SELECT 
        gen_random_uuid(),
        email,
        first_name,
        last_name,
        role,
        NOW()
      FROM (VALUES
        ${users.map(user => `(${user.email}, ${user.firstName}, ${user.lastName}, ${user.role})`).join(',')}
      ) AS v(email, first_name, last_name, role)
      ON CONFLICT (email) DO UPDATE SET
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        updated_at = NOW()
    `;

    return result; // Returns count of affected rows
  }

  async insertProductVariants(productId: string, variants: Array<{
    sku: string;
    size: string;
    color: string;
    price: number;
    stock: number;
  }>) {
    // Complex insert with calculated fields
    const result = await prisma.$executeRaw`
      INSERT INTO product_variants (
        id, product_id, sku, size, color, price, stock_quantity, 
        is_active, created_at
      )
      SELECT 
        gen_random_uuid(),
        ${productId},
        sku,
        size,
        color,
        price,
        stock_quantity,
        CASE WHEN stock_quantity > 0 THEN true ELSE false END,
        NOW()
      FROM (VALUES
        ${variants.map(v => `(${v.sku}, ${v.size}, ${v.color}, ${v.price}, ${v.stock})`).join(',')}
      ) AS v(sku, size, color, price, stock_quantity)
      ON CONFLICT (sku) DO NOTHING
    `;

    return result;
  }

  async insertAuditLog(tableName: string, recordId: string, operation: string, changes: Record<string, any>) {
    // Insert with JSON data
    const result = await prisma.$executeRaw`
      INSERT INTO audit_logs (
        id, table_name, record_id, operation, 
        changes, user_id, timestamp
      ) VALUES (
        gen_random_uuid(),
        ${tableName},
        ${recordId},
        ${operation},
        ${JSON.stringify(changes)}::jsonb,
        current_setting('app.current_user_id', true)::uuid,
        NOW()
      )
    `;

    return result;
  }
}
```

### UPDATE Operations

```typescript
class DataUpdateService {
  async updateInventoryBatch(updates: Array<{
    productId: string;
    quantityChange: number;
    reason: string;
  }>) {
    // Bulk update with calculations
    const result = await prisma.$executeRaw`
      UPDATE products 
      SET 
        stock_quantity = products.stock_quantity + updates.quantity_change,
        updated_at = NOW(),
        last_inventory_update = NOW()
      FROM (VALUES
        ${updates.map(u => `(${u.productId}::uuid, ${u.quantityChange}, ${u.reason})`).join(',')}
      ) AS updates(product_id, quantity_change, reason)
      WHERE products.id = updates.product_id
      AND products.stock_quantity + updates.quantity_change >= 0  -- Prevent negative stock
    `;

    // Log inventory changes
    await prisma.$executeRaw`
      INSERT INTO inventory_logs (id, product_id, quantity_change, reason, timestamp)
      SELECT 
        gen_random_uuid(),
        product_id,
        quantity_change,
        reason,
        NOW()
      FROM (VALUES
        ${updates.map(u => `(${u.productId}::uuid, ${u.quantityChange}, ${u.reason})`).join(',')}
      ) AS log_data(product_id, quantity_change, reason)
    `;

    return result;
  }

  async updateUserPreferences(userId: string, preferences: Record<string, any>) {
    // Update JSONB fields
    const result = await prisma.$executeRaw`
      UPDATE user_profiles 
      SET 
        preferences = preferences || ${JSON.stringify(preferences)}::jsonb,
        updated_at = NOW()
      WHERE user_id = ${userId}
    `;

    return result;
  }

  async updatePricesWithFormula(categoryId: string, adjustmentType: 'percentage' | 'fixed', adjustmentValue: number) {
    // Complex price updates with business logic
    const result = await prisma.$executeRaw`
      UPDATE products 
      SET 
        price = CASE 
          WHEN ${adjustmentType} = 'percentage' THEN 
            ROUND((price * (1 + ${adjustmentValue} / 100))::numeric, 2)
          WHEN ${adjustmentType} = 'fixed' THEN 
            ROUND((price + ${adjustmentValue})::numeric, 2)
          ELSE price
        END,
        previous_price = price,
        price_updated_at = NOW(),
        updated_at = NOW()
      WHERE category_id = ${categoryId}
      AND is_active = true
      AND price > 0
    `;

    return result;
  }

  async reconcileOrderTotals() {
    // Complex update with subqueries
    const result = await prisma.$executeRaw`
      UPDATE orders 
      SET 
        total_amount = calculated_totals.new_total,
        updated_at = NOW()
      FROM (
        SELECT 
          o.id as order_id,
          COALESCE(SUM(oi.quantity * oi.price), 0) + 
          COALESCE(o.shipping_cost, 0) + 
          COALESCE(o.tax_amount, 0) as new_total
        FROM orders o
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE o.status IN ('pending', 'confirmed')
        GROUP BY o.id, o.shipping_cost, o.tax_amount
      ) calculated_totals
      WHERE orders.id = calculated_totals.order_id
      AND ABS(orders.total_amount - calculated_totals.new_total) > 0.01  -- Only update if difference exists
    `;

    return result;
  }
}
```

### DELETE Operations

```typescript
class DataCleanupService {
  async cleanupExpiredSessions(daysOld: number = 30) {
    // Cleanup with date calculations
    const result = await prisma.$executeRaw`
      DELETE FROM user_sessions 
      WHERE (
        ended_at IS NOT NULL AND ended_at < NOW() - INTERVAL '${daysOld} days'
      ) OR (
        ended_at IS NULL AND created_at < NOW() - INTERVAL '7 days'  -- Orphaned sessions
      )
    `;

    return result;
  }

  async archiveOldOrders(monthsOld: number = 12) {
    // Archive before delete
    await prisma.$executeRaw`
      INSERT INTO archived_orders 
      SELECT * FROM orders 
      WHERE status = 'completed' 
      AND created_at < NOW() - INTERVAL '${monthsOld} months'
      ON CONFLICT (id) DO NOTHING
    `;

    // Archive order items
    await prisma.$executeRaw`
      INSERT INTO archived_order_items 
      SELECT oi.* FROM order_items oi
      JOIN orders o ON oi.order_id = o.id
      WHERE o.status = 'completed' 
      AND o.created_at < NOW() - INTERVAL '${monthsOld} months'
      ON CONFLICT (id) DO NOTHING
    `;

    // Delete from main tables
    const itemsDeleted = await prisma.$executeRaw`
      DELETE FROM order_items 
      WHERE order_id IN (
        SELECT id FROM orders 
        WHERE status = 'completed' 
        AND created_at < NOW() - INTERVAL '${monthsOld} months'
      )
    `;

    const ordersDeleted = await prisma.$executeRaw`
      DELETE FROM orders 
      WHERE status = 'completed' 
      AND created_at < NOW() - INTERVAL '${monthsOld} months'
    `;

    return { ordersDeleted, itemsDeleted };
  }

  async deleteUserData(userId: string, softDelete: boolean = true) {
    if (softDelete) {
      // Soft delete with data anonymization
      const result = await prisma.$executeRaw`
        UPDATE users 
        SET 
          email = 'deleted_' || id || '@example.com',
          first_name = 'Deleted',
          last_name = 'User',
          is_deleted = true,
          deleted_at = NOW(),
          updated_at = NOW()
        WHERE id = ${userId}
        AND is_deleted = false
      `;

      // Anonymize related data
      await prisma.$executeRaw`
        UPDATE user_profiles 
        SET 
          phone = NULL,
          address = NULL,
          preferences = '{}'::jsonb,
          updated_at = NOW()
        WHERE user_id = ${userId}
      `;

      return result;
    } else {
      // Hard delete cascade
      const profileDeleted = await prisma.$executeRaw`
        DELETE FROM user_profiles WHERE user_id = ${userId}
      `;

      const sessionsDeleted = await prisma.$executeRaw`
        DELETE FROM user_sessions WHERE user_id = ${userId}
      `;

      const userDeleted = await prisma.$executeRaw`
        DELETE FROM users WHERE id = ${userId}
      `;

      return { userDeleted, profileDeleted, sessionsDeleted };
    }
  }
}
```

## 2. Transaction Safety

### Atomic Operations

```typescript
class TransactionalService {
  async transferInventory(fromProductId: string, toProductId: string, quantity: number) {
    // Use transactions with $executeRaw
    return await prisma.$transaction(async (tx) => {
      // Check source inventory
      const sourceStock = await tx.$queryRaw<{ stock_quantity: number }[]>`
        SELECT stock_quantity FROM products WHERE id = ${fromProductId}
      `;

      if (!sourceStock.length || sourceStock[0].stock_quantity < quantity) {
        throw new Error('Insufficient inventory for transfer');
      }

      // Decrease source inventory
      const sourceUpdate = await tx.$executeRaw`
        UPDATE products 
        SET 
          stock_quantity = stock_quantity - ${quantity},
          updated_at = NOW()
        WHERE id = ${fromProductId}
        AND stock_quantity >= ${quantity}
      `;

      if (sourceUpdate === 0) {
        throw new Error('Failed to update source inventory');
      }

      // Increase destination inventory
      const destUpdate = await tx.$executeRaw`
        UPDATE products 
        SET 
          stock_quantity = stock_quantity + ${quantity},
          updated_at = NOW()
        WHERE id = ${toProductId}
      `;

      if (destUpdate === 0) {
        throw new Error('Failed to update destination inventory');
      }

      // Log the transfer
      await tx.$executeRaw`
        INSERT INTO inventory_transfers (
          id, from_product_id, to_product_id, quantity, 
          transfer_date, created_by
        ) VALUES (
          gen_random_uuid(),
          ${fromProductId},
          ${toProductId},
          ${quantity},
          NOW(),
          current_setting('app.current_user_id', true)::uuid
        )
      `;

      return { sourceUpdate, destUpdate };
    });
  }

  async processOrderRefund(orderId: string, refundAmount: number, reason: string) {
    return await prisma.$transaction(async (tx) => {
      // Update order status
      const orderUpdate = await tx.$executeRaw`
        UPDATE orders 
        SET 
          status = 'refunded',
          refund_amount = ${refundAmount},
          refund_reason = ${reason},
          refunded_at = NOW(),
          updated_at = NOW()
        WHERE id = ${orderId}
        AND status IN ('completed', 'shipped')
      `;

      if (orderUpdate === 0) {
        throw new Error('Order not eligible for refund');
      }

      // Restore inventory
      await tx.$executeRaw`
        UPDATE products 
        SET stock_quantity = stock_quantity + restore_data.quantity
        FROM (
          SELECT oi.product_id, SUM(oi.quantity) as quantity
          FROM order_items oi
          WHERE oi.order_id = ${orderId}
          GROUP BY oi.product_id
        ) restore_data
        WHERE products.id = restore_data.product_id
      `;

      // Create refund record
      await tx.$executeRaw`
        INSERT INTO refunds (
          id, order_id, amount, reason, status, 
          processed_at, created_by
        ) VALUES (
          gen_random_uuid(),
          ${orderId},
          ${refundAmount},
          ${reason},
          'completed',
          NOW(),
          current_setting('app.current_user_id', true)::uuid
        )
      `;

      return orderUpdate;
    });
  }
}
```

## 3. Performance Optimization

### Bulk Operations

```typescript
class BulkOperationsService {
  async bulkUpdateProductPrices(priceUpdates: Array<{
    productId: string;
    newPrice: number;
    effectiveDate: Date;
  }>) {
    // Efficient bulk update using VALUES and JOIN
    const result = await prisma.$executeRaw`
      UPDATE products 
      SET 
        price = price_updates.new_price,
        previous_price = products.price,
        price_effective_date = price_updates.effective_date,
        updated_at = NOW()
      FROM (VALUES
        ${priceUpdates.map(u => 
          `(${u.productId}::uuid, ${u.newPrice}, ${u.effectiveDate}::timestamp)`
        ).join(',')}
      ) AS price_updates(product_id, new_price, effective_date)
      WHERE products.id = price_updates.product_id
      AND products.is_active = true
    `;

    // Log price changes
    await prisma.$executeRaw`
      INSERT INTO price_history (
        id, product_id, old_price, new_price, 
        effective_date, changed_by, created_at
      )
      SELECT 
        gen_random_uuid(),
        p.id,
        p.previous_price,
        p.price,
        p.price_effective_date,
        current_setting('app.current_user_id', true)::uuid,
        NOW()
      FROM products p
      WHERE p.id IN (
        ${priceUpdates.map(u => `${u.productId}::uuid`).join(',')}
      )
    `;

    return result;
  }

  async bulkInsertAnalyticsEvents(events: Array<{
    userId: string;
    eventType: string;
    properties: Record<string, any>;
    timestamp: Date;
  }>) {
    // Efficient bulk insert for analytics
    const result = await prisma.$executeRaw`
      INSERT INTO analytics_events (
        id, user_id, event_type, properties, timestamp, created_at
      )
      SELECT 
        gen_random_uuid(),
        user_id::uuid,
        event_type,
        properties::jsonb,
        event_timestamp,
        NOW()
      FROM (VALUES
        ${events.map(e => 
          `(${e.userId}, ${e.eventType}, ${JSON.stringify(e.properties)}, ${e.timestamp})`
        ).join(',')}
      ) AS events(user_id, event_type, properties, event_timestamp)
    `;

    return result;
  }

  async bulkArchiveInactiveUsers(daysSinceLastLogin: number = 365) {
    // Bulk archive with complex conditions
    const result = await prisma.$executeRaw`
      WITH inactive_users AS (
        SELECT id FROM users 
        WHERE (
          last_login < NOW() - INTERVAL '${daysSinceLastLogin} days'
          OR last_login IS NULL AND created_at < NOW() - INTERVAL '90 days'
        )
        AND is_active = true
        AND is_deleted = false
      )
      UPDATE users 
      SET 
        is_active = false,
        archived_at = NOW(),
        updated_at = NOW()
      WHERE id IN (SELECT id FROM inactive_users)
    `;

    return result;
  }
}
```

## 4. Error Handling and Validation

### Robust Operation Handling

```typescript
class SafeDataService {
  async safeUpdateWithValidation(productId: string, updates: {
    price?: number;
    stock?: number;
    status?: string;
  }) {
    try {
      // Validate before update
      const validation = await prisma.$queryRaw<{
        exists: boolean;
        current_price: number;
        current_stock: number;
        is_active: boolean;
      }[]>`
        SELECT 
          true as exists,
          price as current_price,
          stock_quantity as current_stock,
          is_active
        FROM products 
        WHERE id = ${productId}
      `;

      if (!validation.length) {
        throw new Error('Product not found');
      }

      const product = validation[0];

      // Business rule validations
      if (updates.price !== undefined && updates.price <= 0) {
        throw new Error('Price must be positive');
      }

      if (updates.stock !== undefined && updates.stock < 0) {
        throw new Error('Stock cannot be negative');
      }

      // Build dynamic update
      const updateFields: string[] = [];
      const logChanges: Record<string, any> = {};

      if (updates.price !== undefined) {
        updateFields.push(`price = ${updates.price}, previous_price = ${product.current_price}`);
        logChanges.price = { from: product.current_price, to: updates.price };
      }

      if (updates.stock !== undefined) {
        updateFields.push(`stock_quantity = ${updates.stock}`);
        logChanges.stock = { from: product.current_stock, to: updates.stock };
      }

      if (updates.status !== undefined) {
        updateFields.push(`status = ${updates.status}`);
        logChanges.status = { to: updates.status };
      }

      if (updateFields.length === 0) {
        return 0; // No updates to apply
      }

      updateFields.push('updated_at = NOW()');

      const result = await prisma.$executeRaw`
        UPDATE products 
        SET ${updateFields.join(', ')}
        WHERE id = ${productId}
        AND is_active = true
      `;

      // Log the changes
      if (result > 0) {
        await prisma.$executeRaw`
          INSERT INTO product_change_log (
            id, product_id, changes, changed_by, created_at
          ) VALUES (
            gen_random_uuid(),
            ${productId},
            ${JSON.stringify(logChanges)}::jsonb,
            current_setting('app.current_user_id', true)::uuid,
            NOW()
          )
        `;
      }

      return result;

    } catch (error) {
      console.error('Update failed:', error);
      throw error;
    }
  }

  async safeDeleteWithDependencyCheck(categoryId: string) {
    return await prisma.$transaction(async (tx) => {
      // Check for dependencies
      const dependencies = await tx.$queryRaw<{
        product_count: bigint;
        subcategory_count: bigint;
      }[]>`
        SELECT 
          (SELECT COUNT(*) FROM products WHERE category_id = ${categoryId}) as product_count,
          (SELECT COUNT(*) FROM categories WHERE parent_id = ${categoryId}) as subcategory_count
      `;

      const deps = dependencies[0];

      if (Number(deps.product_count) > 0) {
        throw new Error(`Cannot delete category: ${deps.product_count} products depend on it`);
      }

      if (Number(deps.subcategory_count) > 0) {
        throw new Error(`Cannot delete category: ${deps.subcategory_count} subcategories depend on it`);
      }

      // Safe to delete
      const result = await tx.$executeRaw`
        DELETE FROM categories 
        WHERE id = ${categoryId}
        AND id NOT IN (
          SELECT DISTINCT category_id FROM products WHERE category_id IS NOT NULL
          UNION
          SELECT DISTINCT parent_id FROM categories WHERE parent_id IS NOT NULL
        )
      `;

      return result;
    });
  }
}
```

## Key Takeaways

1. **Use `$executeRaw` for complex data modifications** that generated queries can't handle
2. **Always use transactions** for multi-step operations
3. **Validate data before operations** to prevent inconsistencies
4. **Bulk operations are more efficient** than individual queries
5. **Proper error handling is crucial** for data integrity
6. **Log important changes** for audit trails

## Exercises

1. **Bulk Operations**: Create a service for bulk inventory updates with validation
2. **Transaction Safety**: Implement a complex business process using transactions
3. **Data Archival**: Build a system to archive old data safely
4. **Error Handling**: Add comprehensive validation to your data operations

---

**Duration**: 28 minutes
**Next**: [4.5.4 `$queryRawUnsafe` for Dynamic Queries](./4.5.4-queryrawunsafe-dynamic-queries.md)
**Previous**: [4.5.2 `$queryRaw` for SELECT Operations](./4.5.2-queryraw-select-operations.md)
