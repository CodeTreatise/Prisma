# 4.5.6 SQL Injection Prevention

*Think like a master cybersecurity expert who builds impenetrable fortresses - SQL injection prevention requires multiple layers of defense, vigilant monitoring, and zero tolerance for vulnerabilities.*

## Learning Objectives
- Master comprehensive SQL injection prevention techniques
- Understand attack vectors and defense strategies
- Learn secure coding patterns for dynamic queries
- Build expertise in creating bulletproof database interactions

## The Cybersecurity Fortress Analogy

Just as a cybersecurity expert builds multi-layered defenses with firewalls, intrusion detection, and access controls, preventing SQL injection requires multiple security layers: input validation, parameterized queries, least privilege access, and continuous monitoring.

## 1. Understanding SQL Injection Attacks

### Common Attack Patterns

```typescript
// âš ï¸ VULNERABLE CODE EXAMPLES - NEVER DO THIS!
class VulnerableExamples {
  // âŒ DANGEROUS: String concatenation
  async dangerousUserSearch(userInput: string) {
    // DON'T DO THIS - Direct string interpolation
    const query = `SELECT * FROM users WHERE email = '${userInput}'`;
    // Attacker input: "'; DROP TABLE users; --"
    // Results in: SELECT * FROM users WHERE email = ''; DROP TABLE users; --'
    
    return await prisma.$queryRawUnsafe(query);
  }

  // âŒ DANGEROUS: Template literal with user input
  async dangerousOrderQuery(orderId: string, status: string) {
    // DON'T DO THIS - Template literals with unsanitized input
    return await prisma.$queryRawUnsafe`
      SELECT * FROM orders 
      WHERE id = '${orderId}' AND status = '${status}'
    `;
    // Attacker input: "1' OR '1'='1"
    // Results in bypassing the WHERE clause
  }

  // âŒ DANGEROUS: Dynamic query building
  async dangerousDynamicQuery(tableName: string, columnName: string, value: string) {
    // DON'T DO THIS - User-controlled table/column names
    const query = `SELECT * FROM ${tableName} WHERE ${columnName} = '${value}'`;
    // Attacker can control table and column names
    
    return await prisma.$queryRawUnsafe(query);
  }
}

// ðŸš¨ ATTACK EXAMPLES - What attackers might try:
const attackExamples = {
  // Union-based attacks
  unionAttack: "1' UNION SELECT password FROM admin_users WHERE '1'='1",
  
  // Boolean-based blind attacks
  booleanAttack: "1' AND (SELECT COUNT(*) FROM users) > 100 AND '1'='1",
  
  // Time-based blind attacks
  timeBasedAttack: "1'; WAITFOR DELAY '00:00:05'; --",
  
  // Stacked queries
  stackedQuery: "1'; INSERT INTO logs (message) VALUES ('hacked'); --",
  
  // Information schema attacks
  schemaAttack: "1' UNION SELECT table_name FROM information_schema.tables WHERE '1'='1"
};
```

## 2. Secure Defense Patterns

### Input Validation and Sanitization

```typescript
class SecureInputValidator {
  private static readonly DANGEROUS_PATTERNS = [
    // SQL keywords
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE|UNION|OR|AND)\b)/gi,
    
    // SQL comment patterns
    /(--|\/\*|\*\/|#)/g,
    
    // SQL injection patterns
    /(\b(OR|AND)\s+\d+\s*=\s*\d+)/gi,
    /(\b(OR|AND)\s+['"]?\d+['"]?\s*=\s*['"]?\d+['"]?)/gi,
    
    // Function calls
    /(\b(CONCAT|CHAR|ASCII|SUBSTRING|CAST|CONVERT|EXEC|EXECUTE)\s*\()/gi,
    
    // Hex/binary patterns
    /(0x[0-9a-fA-F]+)/g,
    
    // WAITFOR and sleep attacks
    /(\b(WAITFOR|SLEEP|BENCHMARK)\b)/gi
  ];

  private static readonly ALLOWED_CHARACTERS = {
    alphanumeric: /^[a-zA-Z0-9_]+$/,
    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
    uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
    numeric: /^[0-9]+(\.[0-9]+)?$/,
    safeString: /^[a-zA-Z0-9\s\-_.,!?()]+$/
  };

  static validateTableName(tableName: string): string {
    // Whitelist approach - only allow known table names
    const allowedTables = [
      'users', 'orders', 'products', 'categories', 'order_items',
      'user_profiles', 'product_reviews', 'inventory_logs'
    ];

    if (!allowedTables.includes(tableName)) {
      throw new Error(`Invalid table name: ${tableName}`);
    }

    return tableName;
  }

  static validateColumnName(columnName: string, tableName: string): string {
    // Define allowed columns per table
    const tableColumns: Record<string, string[]> = {
      users: ['id', 'email', 'first_name', 'last_name', 'created_at', 'updated_at', 'is_active'],
      orders: ['id', 'user_id', 'amount', 'status', 'created_at', 'updated_at'],
      products: ['id', 'name', 'price', 'category_id', 'stock_quantity', 'is_active'],
      categories: ['id', 'name', 'parent_id', 'is_active']
    };

    const allowedColumns = tableColumns[tableName];
    if (!allowedColumns || !allowedColumns.includes(columnName)) {
      throw new Error(`Invalid column name: ${columnName} for table: ${tableName}`);
    }

    return columnName;
  }

  static validateOperator(operator: string): string {
    const allowedOperators = [
      '=', '!=', '<>', '<', '>', '<=', '>=',
      'LIKE', 'ILIKE', 'IN', 'NOT IN', 'IS NULL', 'IS NOT NULL',
      'BETWEEN', 'NOT BETWEEN'
    ];

    const normalizedOperator = operator.toUpperCase().trim();
    if (!allowedOperators.includes(normalizedOperator)) {
      throw new Error(`Invalid operator: ${operator}`);
    }

    return normalizedOperator;
  }

  static sanitizeStringInput(input: string, type: keyof typeof SecureInputValidator.ALLOWED_CHARACTERS = 'safeString'): string {
    if (typeof input !== 'string') {
      throw new Error('Input must be a string');
    }

    // Check for dangerous patterns
    for (const pattern of this.DANGEROUS_PATTERNS) {
      if (pattern.test(input)) {
        throw new Error(`Potentially dangerous input detected: ${input}`);
      }
    }

    // Validate against allowed character patterns
    const pattern = this.ALLOWED_CHARACTERS[type];
    if (!pattern.test(input)) {
      throw new Error(`Input contains invalid characters for type ${type}: ${input}`);
    }

    // Additional length validation
    if (input.length > 1000) {
      throw new Error('Input too long');
    }

    return input;
  }

  static validateNumericInput(input: any): number {
    const num = Number(input);
    if (isNaN(num) || !isFinite(num)) {
      throw new Error(`Invalid numeric input: ${input}`);
    }

    // Prevent extremely large numbers that could cause issues
    if (Math.abs(num) > Number.MAX_SAFE_INTEGER) {
      throw new Error('Numeric input too large');
    }

    return num;
  }

  static validateUUID(input: string): string {
    const sanitized = this.sanitizeStringInput(input, 'uuid');
    return sanitized;
  }

  static validateEmail(input: string): string {
    const sanitized = this.sanitizeStringInput(input, 'email');
    return sanitized;
  }
}
```

### Safe Query Patterns

```typescript
class SecureQueryService {
  // âœ… SAFE: Parameterized queries
  async safeUserSearch(email: string): Promise<any[]> {
    // Validate input first
    const validatedEmail = SecureInputValidator.validateEmail(email);

    // Use parameterized query
    return await prisma.$queryRaw`
      SELECT id, email, first_name, last_name, created_at
      FROM users 
      WHERE email = ${validatedEmail}
      AND is_active = true
    `;
  }

  // âœ… SAFE: Whitelisted dynamic queries
  async safeOrderSearch(filters: {
    status?: string;
    userId?: string;
    dateRange?: { start: Date; end: Date };
    amountRange?: { min: number; max: number };
  }): Promise<any[]> {
    const conditions: string[] = [];
    const params: any[] = [];

    // Build WHERE conditions safely
    if (filters.status) {
      // Validate against enum
      const allowedStatuses = ['pending', 'confirmed', 'shipped', 'delivered', 'cancelled'];
      if (!allowedStatuses.includes(filters.status)) {
        throw new Error(`Invalid status: ${filters.status}`);
      }
      conditions.push(`status = $${params.length + 1}`);
      params.push(filters.status);
    }

    if (filters.userId) {
      const validatedUserId = SecureInputValidator.validateUUID(filters.userId);
      conditions.push(`user_id = $${params.length + 1}`);
      params.push(validatedUserId);
    }

    if (filters.dateRange) {
      conditions.push(`created_at BETWEEN $${params.length + 1} AND $${params.length + 2}`);
      params.push(filters.dateRange.start, filters.dateRange.end);
    }

    if (filters.amountRange) {
      const minAmount = SecureInputValidator.validateNumericInput(filters.amountRange.min);
      const maxAmount = SecureInputValidator.validateNumericInput(filters.amountRange.max);
      conditions.push(`amount BETWEEN $${params.length + 1} AND $${params.length + 2}`);
      params.push(minAmount, maxAmount);
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    const query = `
      SELECT id, user_id, amount, status, created_at
      FROM orders
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT 1000
    `;

    return await prisma.$queryRawUnsafe(query, ...params);
  }

  // âœ… SAFE: Prepared statement pattern
  async safeComplexQuery(params: {
    tableName: string;
    columns: string[];
    filters: Record<string, any>;
    sortBy?: string;
    sortOrder?: 'ASC' | 'DESC';
    limit?: number;
  }): Promise<any[]> {
    // Validate table name
    const validatedTable = SecureInputValidator.validateTableName(params.tableName);

    // Validate columns
    const validatedColumns = params.columns.map(col => 
      SecureInputValidator.validateColumnName(col, validatedTable)
    );

    // Build SELECT clause
    const selectClause = validatedColumns.map(col => `"${col}"`).join(', ');

    // Build WHERE clause with parameterized values
    const whereConditions: string[] = [];
    const queryParams: any[] = [];

    for (const [column, value] of Object.entries(params.filters)) {
      const validatedColumn = SecureInputValidator.validateColumnName(column, validatedTable);
      whereConditions.push(`"${validatedColumn}" = $${queryParams.length + 1}`);
      queryParams.push(value);
    }

    const whereClause = whereConditions.length > 0 ? 
      `WHERE ${whereConditions.join(' AND ')}` : '';

    // Build ORDER BY clause
    let orderByClause = '';
    if (params.sortBy) {
      const validatedSortColumn = SecureInputValidator.validateColumnName(params.sortBy, validatedTable);
      const sortOrder = params.sortOrder === 'DESC' ? 'DESC' : 'ASC';
      orderByClause = `ORDER BY "${validatedSortColumn}" ${sortOrder}`;
    }

    // Build LIMIT clause
    const limit = params.limit ? 
      Math.min(SecureInputValidator.validateNumericInput(params.limit), 10000) : 1000;
    const limitClause = `LIMIT ${limit}`;

    const query = `
      SELECT ${selectClause}
      FROM "${validatedTable}"
      ${whereClause}
      ${orderByClause}
      ${limitClause}
    `;

    return await prisma.$queryRawUnsafe(query, ...queryParams);
  }
}
```

## 3. Advanced Security Patterns

### Query Builder with Security Controls

```typescript
class SecureQueryBuilder {
  private tableName: string = '';
  private selectedColumns: string[] = [];
  private whereConditions: Array<{ column: string; operator: string; value: any }> = [];
  private orderByColumn: string = '';
  private orderDirection: 'ASC' | 'DESC' = 'ASC';
  private limitValue: number = 1000;

  static create(): SecureQueryBuilder {
    return new SecureQueryBuilder();
  }

  table(tableName: string): this {
    this.tableName = SecureInputValidator.validateTableName(tableName);
    return this;
  }

  select(columns: string[]): this {
    this.selectedColumns = columns.map(col => 
      SecureInputValidator.validateColumnName(col, this.tableName)
    );
    return this;
  }

  where(column: string, operator: string, value: any): this {
    const validatedColumn = SecureInputValidator.validateColumnName(column, this.tableName);
    const validatedOperator = SecureInputValidator.validateOperator(operator);
    
    this.whereConditions.push({
      column: validatedColumn,
      operator: validatedOperator,
      value
    });
    return this;
  }

  orderBy(column: string, direction: 'ASC' | 'DESC' = 'ASC'): this {
    this.orderByColumn = SecureInputValidator.validateColumnName(column, this.tableName);
    this.orderDirection = direction === 'DESC' ? 'DESC' : 'ASC';
    return this;
  }

  limit(count: number): this {
    this.limitValue = Math.min(SecureInputValidator.validateNumericInput(count), 10000);
    return this;
  }

  async execute(): Promise<any[]> {
    if (!this.tableName) {
      throw new Error('Table name is required');
    }

    if (this.selectedColumns.length === 0) {
      throw new Error('At least one column must be selected');
    }

    // Build query components
    const selectClause = this.selectedColumns.map(col => `"${col}"`).join(', ');
    
    let query = `SELECT ${selectClause} FROM "${this.tableName}"`;
    const params: any[] = [];

    // Add WHERE conditions
    if (this.whereConditions.length > 0) {
      const conditions = this.whereConditions.map(condition => {
        params.push(condition.value);
        return `"${condition.column}" ${condition.operator} $${params.length}`;
      });
      query += ` WHERE ${conditions.join(' AND ')}`;
    }

    // Add ORDER BY
    if (this.orderByColumn) {
      query += ` ORDER BY "${this.orderByColumn}" ${this.orderDirection}`;
    }

    // Add LIMIT
    query += ` LIMIT ${this.limitValue}`;

    // Execute query
    return await prisma.$queryRawUnsafe(query, ...params);
  }

  getQuery(): { query: string; params: any[] } {
    // For debugging/logging purposes
    const selectClause = this.selectedColumns.map(col => `"${col}"`).join(', ');
    let query = `SELECT ${selectClause} FROM "${this.tableName}"`;
    const params: any[] = [];

    if (this.whereConditions.length > 0) {
      const conditions = this.whereConditions.map(condition => {
        params.push(condition.value);
        return `"${condition.column}" ${condition.operator} $${params.length}`;
      });
      query += ` WHERE ${conditions.join(' AND ')}`;
    }

    if (this.orderByColumn) {
      query += ` ORDER BY "${this.orderByColumn}" ${this.orderDirection}`;
    }

    query += ` LIMIT ${this.limitValue}`;

    return { query, params };
  }
}

// Usage example
class SecureDataService {
  async getUserOrders(userId: string, status?: string): Promise<any[]> {
    const builder = SecureQueryBuilder
      .create()
      .table('orders')
      .select(['id', 'amount', 'status', 'created_at'])
      .where('user_id', '=', userId);

    if (status) {
      builder.where('status', '=', status);
    }

    return await builder
      .orderBy('created_at', 'DESC')
      .limit(100)
      .execute();
  }

  async getProductsByCategory(categoryId: string, priceRange?: { min: number; max: number }): Promise<any[]> {
    const builder = SecureQueryBuilder
      .create()
      .table('products')
      .select(['id', 'name', 'price', 'stock_quantity'])
      .where('category_id', '=', categoryId)
      .where('is_active', '=', true);

    if (priceRange) {
      builder
        .where('price', '>=', priceRange.min)
        .where('price', '<=', priceRange.max);
    }

    return await builder
      .orderBy('name', 'ASC')
      .limit(200)
      .execute();
  }
}
```

## 4. Monitoring and Detection

### Security Monitoring Service

```typescript
class SecurityMonitoringService {
  private static readonly ALERT_PATTERNS = [
    // Suspicious query patterns
    /(\bUNION\b.*\bSELECT\b)/gi,
    /(\bOR\b\s+\d+\s*=\s*\d+)/gi,
    /(\bAND\b\s+\d+\s*=\s*\d+)/gi,
    /(';.*--)/gi,
    /(\bWAITFOR\b|\bSLEEP\b|\bBENCHMARK\b)/gi,
    /(\binformation_schema\b)/gi,
    /(\bsysobjects\b|\bsyscolumns\b)/gi
  ];

  static async logQuery(query: string, params: any[], userId?: string, ip?: string): Promise<void> {
    // Check for suspicious patterns
    const suspiciousPatterns = this.ALERT_PATTERNS.filter(pattern => pattern.test(query));
    
    if (suspiciousPatterns.length > 0) {
      await this.logSecurityAlert({
        type: 'suspicious_query',
        query,
        params: JSON.stringify(params),
        userId,
        ip,
        patterns: suspiciousPatterns.map(p => p.toString()),
        timestamp: new Date(),
        severity: 'high'
      });
    }

    // Log all queries for audit trail
    await this.logQueryExecution({
      query,
      paramCount: params.length,
      userId,
      ip,
      timestamp: new Date()
    });
  }

  private static async logSecurityAlert(alert: {
    type: string;
    query: string;
    params: string;
    userId?: string;
    ip?: string;
    patterns: string[];
    timestamp: Date;
    severity: 'low' | 'medium' | 'high' | 'critical';
  }): Promise<void> {
    // Log to security monitoring system
    console.error('ðŸš¨ SECURITY ALERT:', alert);
    
    // In production, send to security information and event management (SIEM) system
    // await siem.sendAlert(alert);
    
    // Store in security logs table
    await prisma.$executeRaw`
      INSERT INTO security_logs (
        id, alert_type, query_text, query_params, user_id, ip_address,
        suspicious_patterns, severity, created_at
      ) VALUES (
        gen_random_uuid(),
        ${alert.type},
        ${alert.query},
        ${alert.params},
        ${alert.userId || null},
        ${alert.ip || null},
        ${JSON.stringify(alert.patterns)}::jsonb,
        ${alert.severity},
        ${alert.timestamp}
      )
    `;
  }

  private static async logQueryExecution(execution: {
    query: string;
    paramCount: number;
    userId?: string;
    ip?: string;
    timestamp: Date;
  }): Promise<void> {
    // Log to audit trail
    await prisma.$executeRaw`
      INSERT INTO query_audit_log (
        id, query_hash, param_count, user_id, ip_address, executed_at
      ) VALUES (
        gen_random_uuid(),
        MD5(${execution.query}),
        ${execution.paramCount},
        ${execution.userId || null},
        ${execution.ip || null},
        ${execution.timestamp}
      )
    `;
  }

  static async analyzeQueryPatterns(): Promise<{
    suspiciousQueries: number;
    topFailedPatterns: Array<{ pattern: string; count: number }>;
    riskUsers: Array<{ userId: string; alertCount: number }>;
  }> {
    // Analyze security logs for patterns
    const results = await prisma.$queryRaw<Array<{
      suspicious_queries: bigint;
      failed_patterns: string;
      risk_users: string;
    }>>`
      WITH security_stats AS (
        SELECT 
          COUNT(*) as suspicious_queries,
          JSON_AGG(DISTINCT suspicious_patterns) as failed_patterns,
          JSON_AGG(DISTINCT jsonb_build_object('userId', user_id, 'count', alert_count)) as risk_users
        FROM (
          SELECT 
            suspicious_patterns,
            user_id,
            COUNT(*) as alert_count
          FROM security_logs 
          WHERE created_at >= NOW() - INTERVAL '24 hours'
          AND severity IN ('high', 'critical')
          GROUP BY suspicious_patterns, user_id
        ) recent_alerts
      )
      SELECT * FROM security_stats
    `;

    const stats = results[0];
    return {
      suspiciousQueries: Number(stats.suspicious_queries),
      topFailedPatterns: JSON.parse(stats.failed_patterns || '[]'),
      riskUsers: JSON.parse(stats.risk_users || '[]')
    };
  }
}

// Middleware for automatic monitoring
class SecurePrismaWrapper {
  static async queryRaw<T>(query: string, ...params: any[]): Promise<T> {
    // Log the query for monitoring
    await SecurityMonitoringService.logQuery(query, params);
    
    try {
      return await prisma.$queryRawUnsafe<T>(query, ...params);
    } catch (error) {
      // Log failed queries
      console.error('Query execution failed:', { query, params, error });
      throw error;
    }
  }

  static async executeRaw(query: string, ...params: any[]): Promise<number> {
    // Log the query for monitoring
    await SecurityMonitoringService.logQuery(query, params);
    
    try {
      return await prisma.$executeRawUnsafe(query, ...params);
    } catch (error) {
      // Log failed queries
      console.error('Query execution failed:', { query, params, error });
      throw error;
    }
  }
}
```

## 5. Database Security Configuration

### Additional Security Measures

```typescript
class DatabaseSecurityConfig {
  // Database connection security
  static getDatabaseConfig(): {
    connectionString: string;
    ssl: boolean;
    connectionLimit: number;
    queryTimeout: number;
  } {
    return {
      connectionString: process.env.DATABASE_URL!,
      ssl: process.env.NODE_ENV === 'production',
      connectionLimit: 10, // Limit concurrent connections
      queryTimeout: 30000, // 30 second timeout
    };
  }

  // Database user permissions (to be applied at DB level)
  static getRecommendedPermissions(): {
    applicationUser: string[];
    readOnlyUser: string[];
    adminUser: string[];
  } {
    return {
      // Application user - minimal permissions
      applicationUser: [
        'CONNECT',
        'SELECT ON application_tables',
        'INSERT ON application_tables',
        'UPDATE ON application_tables',
        'DELETE ON application_tables',
        'USAGE ON SEQUENCES'
      ],
      
      // Read-only user for reports
      readOnlyUser: [
        'CONNECT',
        'SELECT ON application_tables'
      ],
      
      // Admin user - full permissions
      adminUser: [
        'ALL PRIVILEGES'
      ]
    };
  }

  // Network security recommendations
  static getNetworkSecurityConfig(): {
    allowedIPs: string[];
    portConfiguration: Record<string, number>;
    firewallRules: string[];
  } {
    return {
      allowedIPs: [
        '10.0.0.0/8',     // Internal network
        '172.16.0.0/12',  // Private network
        '192.168.0.0/16'  // Local network
      ],
      
      portConfiguration: {
        postgresql: 5432,
        pgbouncer: 6432  // Connection pooler
      },
      
      firewallRules: [
        'DENY ALL by default',
        'ALLOW application servers on port 5432',
        'ALLOW monitoring on port 5432 from specific IPs',
        'LOG all connection attempts'
      ]
    };
  }
}
```

## Key Takeaways

1. **Never trust user input** - validate and sanitize everything
2. **Use parameterized queries** exclusively for user data
3. **Implement whitelist validation** for table/column names
4. **Monitor and log** all database interactions
5. **Apply principle of least privilege** to database users
6. **Use multiple layers of defense** - input validation, query parameterization, monitoring
7. **Regular security audits** of queries and patterns

## Exercises

1. **Security Audit**: Review your existing queries for injection vulnerabilities
2. **Monitoring System**: Implement query monitoring and alerting
3. **Secure Query Builder**: Create a builder that enforces security by design
4. **Penetration Testing**: Test your defenses with common injection techniques

---

**Duration**: 27 minutes
**Next**: [4.6.1 Generated Types & Interfaces](../4.6-type-safety-field-selection/4.6.1-generated-types-interfaces.md)
**Previous**: [4.5.5 Type Safety with Raw Queries](./4.5.5-type-safety-raw-queries.md)
