# 4.5.1 When to Use Raw SQL vs Generated Queries

*Think like a master carpenter who knows when to use power tools vs hand tools - each has its perfect moment.*

## Learning Objectives
- Master decision framework for raw SQL vs generated queries
- Understand performance implications and trade-offs
- Learn when type safety should be prioritized vs flexibility
- Build expertise in choosing the right tool for each scenario

## The Carpenter's Workshop Analogy

Just as a master carpenter chooses between a precision router and a hand chisel based on the task, Prisma developers must choose between generated queries and raw SQL based on specific requirements.

## 1. The Decision Framework

### When to Use Generated Queries (The Power Tools)

**âœ… Perfect for:**
- Standard CRUD operations
- Type-safe operations
- Rapid development
- Team consistency
- Relationship handling
- Migration compatibility

```typescript
// Perfect for generated queries - clean, type-safe, maintainable
const user = await prisma.user.findUnique({
  where: { email: 'user@example.com' },
  include: {
    posts: {
      where: { published: true },
      orderBy: { createdAt: 'desc' },
      take: 10
    },
    profile: true
  }
});
```

### When to Use Raw SQL (The Hand Tools)

**âœ… Perfect for:**
- Complex analytics and reporting
- Database-specific features
- Performance-critical operations
- Legacy system integration
- Advanced SQL functions
- Complex aggregations

```typescript
// Perfect for raw SQL - complex analytics not easily expressed in Prisma
const salesAnalytics = await prisma.$queryRaw`
  WITH monthly_sales AS (
    SELECT 
      DATE_TRUNC('month', created_at) as month,
      SUM(amount) as total_sales,
      COUNT(*) as order_count,
      AVG(amount) as avg_order_value
    FROM orders 
    WHERE created_at >= NOW() - INTERVAL '12 months'
    GROUP BY DATE_TRUNC('month', created_at)
  ),
  growth_rates AS (
    SELECT 
      month,
      total_sales,
      LAG(total_sales) OVER (ORDER BY month) as prev_month_sales,
      (total_sales - LAG(total_sales) OVER (ORDER BY month)) / 
        LAG(total_sales) OVER (ORDER BY month) * 100 as growth_rate
    FROM monthly_sales
  )
  SELECT * FROM growth_rates ORDER BY month DESC
`;
```

## 2. Performance Considerations

### Generated Query Performance

```typescript
// Query Analysis Service
class QueryAnalysisService {
  async analyzeQueryPerformance() {
    // Good: Simple queries with predictable performance
    const recentUsers = await prisma.user.findMany({
      where: {
        createdAt: {
          gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
        }
      },
      select: {
        id: true,
        email: true,
        createdAt: true
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    });

    // Potential issue: N+1 queries without proper includes
    const usersWithPostCounts = await Promise.all(
      recentUsers.map(async (user) => ({
        ...user,
        postCount: await prisma.post.count({
          where: { authorId: user.id }
        })
      }))
    ); // ðŸš¨ This creates N+1 queries!

    return { recentUsers, usersWithPostCounts };
  }

  async optimizedQueryPerformance() {
    // Better: Single query with aggregation
    const usersWithCounts = await prisma.user.findMany({
      where: {
        createdAt: {
          gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
        }
      },
      select: {
        id: true,
        email: true,
        createdAt: true,
        _count: {
          select: {
            posts: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    });

    return usersWithCounts;
  }
}
```

### Raw SQL Performance

```typescript
// High-Performance Analytics Service
class AnalyticsService {
  async getDashboardMetrics() {
    // Raw SQL for complex analytics that would be inefficient with generated queries
    const metrics = await prisma.$queryRaw<{
      total_users: bigint;
      active_users: bigint;
      total_revenue: number;
      avg_session_duration: number;
      top_categories: string;
    }[]>`
      WITH user_stats AS (
        SELECT 
          COUNT(*) as total_users,
          COUNT(CASE WHEN last_login >= NOW() - INTERVAL '30 days' THEN 1 END) as active_users
        FROM users
      ),
      revenue_stats AS (
        SELECT 
          COALESCE(SUM(amount), 0) as total_revenue
        FROM orders 
        WHERE status = 'completed'
      ),
      session_stats AS (
        SELECT 
          AVG(EXTRACT(EPOCH FROM (ended_at - started_at))/60) as avg_session_duration
        FROM user_sessions 
        WHERE ended_at IS NOT NULL
      ),
      category_stats AS (
        SELECT 
          JSON_AGG(
            JSON_BUILD_OBJECT('name', name, 'count', product_count)
            ORDER BY product_count DESC
          ) as top_categories
        FROM (
          SELECT c.name, COUNT(p.id) as product_count
          FROM categories c
          LEFT JOIN products p ON c.id = p.category_id
          GROUP BY c.id, c.name
          ORDER BY product_count DESC
          LIMIT 5
        ) top_cats
      )
      SELECT 
        u.total_users,
        u.active_users,
        r.total_revenue,
        s.avg_session_duration,
        c.top_categories
      FROM user_stats u
      CROSS JOIN revenue_stats r
      CROSS JOIN session_stats s
      CROSS JOIN category_stats c
    `;

    return metrics[0];
  }

  async getCustomerSegmentation() {
    // Complex segmentation that's much cleaner in raw SQL
    return await prisma.$queryRaw`
      WITH customer_metrics AS (
        SELECT 
          u.id,
          u.email,
          COUNT(o.id) as order_count,
          COALESCE(SUM(o.amount), 0) as lifetime_value,
          MAX(o.created_at) as last_order_date,
          CASE 
            WHEN COUNT(o.id) = 0 THEN 'never_purchased'
            WHEN MAX(o.created_at) < NOW() - INTERVAL '90 days' THEN 'churned'
            WHEN COUNT(o.id) >= 10 AND SUM(o.amount) >= 1000 THEN 'vip'
            WHEN COUNT(o.id) >= 5 THEN 'loyal'
            WHEN COUNT(o.id) >= 2 THEN 'repeat'
            ELSE 'new'
          END as segment
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed'
        GROUP BY u.id, u.email
      )
      SELECT 
        segment,
        COUNT(*) as customer_count,
        AVG(order_count) as avg_orders,
        AVG(lifetime_value) as avg_lifetime_value,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY lifetime_value) as median_ltv
      FROM customer_metrics
      GROUP BY segment
      ORDER BY avg_lifetime_value DESC
    `;
  }
}
```

## 3. Type Safety vs Flexibility Trade-offs

### Type-Safe Generated Queries

```typescript
// Type Safety Champion
class TypeSafeService {
  async getUserWithPosts(userId: string) {
    // Full type safety - IDE autocomplete, compile-time checks
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        posts: {
          select: {
            id: true,
            title: true,
            content: true,
            publishedAt: true,
            categories: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        profile: true
      }
    });

    // TypeScript knows exact shape:
    // user: User & { posts: Array<{ id: string, title: string, ... }>, profile: Profile | null }
    
    if (user) {
      console.log(user.email); // âœ… Type-safe
      console.log(user.posts[0]?.title); // âœ… Type-safe
      // console.log(user.posts[0]?.author); // âŒ TypeScript error!
    }

    return user;
  }

  async searchUsers(query: string) {
    // Type-safe search with known performance characteristics
    return await prisma.user.findMany({
      where: {
        OR: [
          { email: { contains: query, mode: 'insensitive' } },
          { profile: { 
            is: { 
              OR: [
                { firstName: { contains: query, mode: 'insensitive' } },
                { lastName: { contains: query, mode: 'insensitive' } }
              ]
            }
          }}
        ]
      },
      include: {
        profile: {
          select: {
            firstName: true,
            lastName: true,
            avatar: true
          }
        }
      },
      take: 20
    });
  }
}
```

### Flexible Raw SQL Queries

```typescript
// Flexibility Champion
class FlexibleQueryService {
  async dynamicReporting(filters: {
    dateRange?: { start: Date; end: Date };
    categories?: string[];
    minAmount?: number;
    groupBy?: 'day' | 'week' | 'month';
  }) {
    // Build dynamic query based on filters
    let whereClause = '1=1';
    let groupByClause = '';
    const params: any[] = [];

    if (filters.dateRange) {
      whereClause += ` AND o.created_at BETWEEN $${params.length + 1} AND $${params.length + 2}`;
      params.push(filters.dateRange.start, filters.dateRange.end);
    }

    if (filters.categories?.length) {
      whereClause += ` AND c.name = ANY($${params.length + 1})`;
      params.push(filters.categories);
    }

    if (filters.minAmount) {
      whereClause += ` AND o.amount >= $${params.length + 1}`;
      params.push(filters.minAmount);
    }

    switch (filters.groupBy) {
      case 'day':
        groupByClause = "DATE_TRUNC('day', o.created_at)";
        break;
      case 'week':
        groupByClause = "DATE_TRUNC('week', o.created_at)";
        break;
      case 'month':
        groupByClause = "DATE_TRUNC('month', o.created_at)";
        break;
      default:
        groupByClause = "DATE_TRUNC('day', o.created_at)";
    }

    // Note: Need manual type definition for complex dynamic results
    type ReportResult = {
      period: Date;
      total_sales: number;
      order_count: bigint;
      unique_customers: bigint;
      avg_order_value: number;
      top_category: string;
    };

    return await prisma.$queryRaw<ReportResult[]>`
      SELECT 
        ${groupByClause} as period,
        SUM(o.amount) as total_sales,
        COUNT(o.id) as order_count,
        COUNT(DISTINCT o.user_id) as unique_customers,
        AVG(o.amount) as avg_order_value,
        (
          SELECT c.name 
          FROM categories c
          JOIN order_items oi ON c.id = oi.category_id
          WHERE oi.order_id = o.id
          GROUP BY c.name
          ORDER BY COUNT(*) DESC
          LIMIT 1
        ) as top_category
      FROM orders o
      LEFT JOIN order_items oi ON o.id = oi.order_id
      LEFT JOIN categories c ON oi.category_id = c.id
      WHERE ${whereClause}
      GROUP BY ${groupByClause}
      ORDER BY period DESC
    `;
  }
}
```

## 4. Decision Matrix

### Use Generated Queries When:

| Scenario | Generated Query Advantage |
|----------|---------------------------|
| **CRUD Operations** | Type safety, maintainability |
| **Relationship Queries** | Built-in joins, includes |
| **Rapid Development** | Less code, faster iteration |
| **Team Consistency** | Uniform patterns across team |
| **Schema Evolution** | Automatic updates with migrations |
| **Simple Aggregations** | Built-in count, sum, avg |

### Use Raw SQL When:

| Scenario | Raw SQL Advantage |
|----------|-------------------|
| **Complex Analytics** | Window functions, CTEs |
| **Performance Critical** | Optimized for specific use case |
| **Database Features** | PostgreSQL-specific functions |
| **Legacy Integration** | Existing SQL procedures |
| **Advanced Aggregations** | Complex mathematical operations |
| **Bulk Operations** | Efficient batch processing |

## 5. Hybrid Approach - Best of Both Worlds

```typescript
// Smart Query Router
class SmartQueryService {
  async getUserDashboard(userId: string) {
    // Use generated queries for standard data fetching
    const [user, recentActivity] = await Promise.all([
      // Type-safe user data
      prisma.user.findUnique({
        where: { id: userId },
        include: {
          profile: true,
          subscription: true
        }
      }),

      // Type-safe recent activity
      prisma.userActivity.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: 10,
        include: {
          activityType: true
        }
      })
    ]);

    // Use raw SQL for complex analytics
    const analytics = await prisma.$queryRaw<{
      total_sessions: bigint;
      avg_session_duration: number;
      most_used_features: { feature: string; usage_count: bigint }[];
      engagement_score: number;
    }[]>`
      WITH user_sessions AS (
        SELECT 
          COUNT(*) as total_sessions,
          AVG(EXTRACT(EPOCH FROM (ended_at - started_at))/60) as avg_session_duration
        FROM user_sessions 
        WHERE user_id = ${userId}
        AND created_at >= NOW() - INTERVAL '30 days'
      ),
      feature_usage AS (
        SELECT 
          JSON_AGG(
            JSON_BUILD_OBJECT('feature', feature_name, 'usage_count', usage_count)
            ORDER BY usage_count DESC
          ) as most_used_features
        FROM (
          SELECT feature_name, COUNT(*) as usage_count
          FROM user_feature_usage
          WHERE user_id = ${userId}
          AND created_at >= NOW() - INTERVAL '30 days'
          GROUP BY feature_name
          ORDER BY usage_count DESC
          LIMIT 5
        ) features
      ),
      engagement AS (
        SELECT 
          LEAST(100, (
            COUNT(DISTINCT DATE(created_at)) * 10 +  -- Daily usage
            COUNT(*) / 10                             -- Total activities
          )) as engagement_score
        FROM user_activities
        WHERE user_id = ${userId}
        AND created_at >= NOW() - INTERVAL '30 days'
      )
      SELECT 
        s.total_sessions,
        s.avg_session_duration,
        f.most_used_features,
        e.engagement_score
      FROM user_sessions s
      CROSS JOIN feature_usage f
      CROSS JOIN engagement e
    `;

    return {
      user,
      recentActivity,
      analytics: analytics[0]
    };
  }
}
```

## Key Takeaways

1. **Generated queries excel at**: Type safety, relationships, rapid development
2. **Raw SQL excels at**: Complex analytics, performance optimization, database-specific features
3. **Use the decision matrix** to choose the right tool for each scenario
4. **Hybrid approaches** often provide the best solution
5. **Consider team expertise** and maintenance requirements
6. **Performance testing** should guide final decisions

## Exercises

1. **Decision Analysis**: Review your current queries and categorize them as candidates for generated vs raw SQL
2. **Performance Comparison**: Create the same complex query using both approaches and benchmark
3. **Hybrid Implementation**: Build a service that uses both generated queries and raw SQL appropriately
4. **Team Guidelines**: Create decision criteria for your team on when to use each approach

---

**Duration**: 22 minutes
**Next**: [4.5.2 `$queryRaw` for SELECT Operations](./4.5.2-queryraw-select-operations.md)
**Previous**: [4.4.6 Connect & Disconnect Operations](../4.4-relations-nested-operations/4.4.6-connect-disconnect-operations.md)
