# 4.3.3 String & Text Filtering (contains, startsWith, endsWith)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master string pattern matching with contains, startsWith, and endsWith operators
- Implement case-sensitive and case-insensitive text searching strategies
- Design advanced text search systems with multiple criteria and ranking
- Build full-text search capabilities with PostgreSQL and database-specific features
- Handle Unicode, special characters, and international text searching
- Optimize string filtering queries for performance and scalability
- Create flexible text search APIs that adapt to user requirements
- Implement search suggestion systems and autocomplete functionality

## Introduction

Think of Prisma's string filtering capabilities as **a master librarian's sophisticated cataloging and search system** - like an expert researcher in the world's largest digital library who has developed advanced techniques to find exactly the right documents from millions of texts. Just as a skilled librarian uses different search strategies (keyword searching for specific terms, title browsing for documents starting with certain words, subject classification for content containing specific topics, and cross-referencing for related materials), Prisma's string operators provide you with powerful tools to search, filter, and discover text data with precision and flexibility. Whether you're looking for exact phrases, content patterns, or partial matches, these operators help you navigate through textual data like a seasoned information scientist.

Understanding string filtering is essential for building search features, content management systems, and user-friendly data discovery interfaces.

## Basic String Pattern Matching

### Contains Operator - Finding Text Anywhere
Searching for substrings within larger text content:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Basic contains search
async function searchPostsByTitle(searchTerm: string) {
  const posts = await prisma.post.findMany({
    where: {
      title: {
        contains: searchTerm,
        mode: 'insensitive' // Case-insensitive search
      }
    }
  })
  
  return posts
}

// Multiple field contains search
async function searchContent(query: string) {
  const posts = await prisma.post.findMany({
    where: {
      OR: [
        {
          title: {
            contains: query,
            mode: 'insensitive'
          }
        },
        {
          content: {
            contains: query,
            mode: 'insensitive'
          }
        },
        {
          excerpt: {
            contains: query,
            mode: 'insensitive'
          }
        }
      ]
    }
  })
  
  return posts
}

// Case-sensitive contains search
async function exactContentSearch(searchTerm: string) {
  const posts = await prisma.post.findMany({
    where: {
      content: {
        contains: searchTerm,
        mode: 'default' // Case-sensitive (default behavior)
      }
    }
  })
  
  return posts
}

// Contains with additional filters
async function searchPublishedPosts(searchTerm: string, authorId?: number) {
  const where: any = {
    published: true,
    title: {
      contains: searchTerm,
      mode: 'insensitive'
    }
  }
  
  if (authorId) {
    where.authorId = authorId
  }
  
  const posts = await prisma.post.findMany({
    where
  })
  
  return posts
}

// Advanced contains with ranking
async function searchWithRelevance(searchTerm: string) {
  const posts = await prisma.post.findMany({
    where: {
      OR: [
        {
          title: {
            contains: searchTerm,
            mode: 'insensitive'
          }
        },
        {
          content: {
            contains: searchTerm,
            mode: 'insensitive'
          }
        }
      ]
    }
  })
  
  // Simple relevance scoring in application layer
  const scored = posts.map(post => {
    let score = 0
    const term = searchTerm.toLowerCase()
    const title = post.title.toLowerCase()
    const content = post.content?.toLowerCase() || ''
    
    // Title matches get higher score
    if (title.includes(term)) {
      score += title.startsWith(term) ? 10 : 5
    }
    
    // Content matches
    const contentMatches = (content.match(new RegExp(term, 'gi')) || []).length
    score += contentMatches
    
    return { ...post, relevanceScore: score }
  })
  
  return scored
    .filter(post => post.relevanceScore > 0)
    .sort((a, b) => b.relevanceScore - a.relevanceScore)
}
```

### StartsWith Operator - Prefix Matching
Finding content that begins with specific text:

```typescript
// Basic prefix search
async function getUsersByNamePrefix(prefix: string) {
  const users = await prisma.user.findMany({
    where: {
      name: {
        startsWith: prefix,
        mode: 'insensitive'
      }
    }
  })
  
  return users
}

// Email domain filtering
async function getUsersByEmailDomain(domain: string) {
  const users = await prisma.user.findMany({
    where: {
      email: {
        endsWith: `@${domain}`,
        mode: 'insensitive'
      }
    }
  })
  
  return users
}

// URL path filtering
async function getPagesByPath(pathPrefix: string) {
  const pages = await prisma.page.findMany({
    where: {
      url: {
        startsWith: pathPrefix
      }
    }
  })
  
  return pages
}

// Autocomplete functionality
async function getNameSuggestions(prefix: string, limit: number = 10) {
  if (prefix.length < 2) {
    return [] // Minimum prefix length for performance
  }
  
  const users = await prisma.user.findMany({
    where: {
      name: {
        startsWith: prefix,
        mode: 'insensitive'
      }
    },
    select: {
      id: true,
      name: true,
      email: true
    },
    take: limit,
    orderBy: {
      name: 'asc'
    }
  })
  
  return users
}

// Category hierarchy navigation
async function getCategoriesByPath(pathPrefix: string) {
  const categories = await prisma.category.findMany({
    where: {
      path: {
        startsWith: pathPrefix
      }
    },
    orderBy: {
      path: 'asc'
    }
  })
  
  return categories
}

// Product code filtering
async function getProductsByCodePrefix(codePrefix: string) {
  const products = await prisma.product.findMany({
    where: {
      code: {
        startsWith: codePrefix.toUpperCase()
      }
    }
  })
  
  return products
}

// Smart autocomplete with multiple fields
async function getSmartSuggestions(query: string, limit: number = 10) {
  if (query.length < 2) return []
  
  // Search across multiple models and fields
  const [users, products, categories] = await Promise.all([
    prisma.user.findMany({
      where: {
        OR: [
          { name: { startsWith: query, mode: 'insensitive' } },
          { email: { startsWith: query, mode: 'insensitive' } }
        ]
      },
      select: { id: true, name: true, email: true },
      take: Math.ceil(limit / 3)
    }),
    
    prisma.product.findMany({
      where: {
        name: { startsWith: query, mode: 'insensitive' }
      },
      select: { id: true, name: true, category: true },
      take: Math.ceil(limit / 3)
    }),
    
    prisma.category.findMany({
      where: {
        name: { startsWith: query, mode: 'insensitive' }
      },
      select: { id: true, name: true },
      take: Math.ceil(limit / 3)
    })
  ])
  
  // Combine and format results
  const suggestions = [
    ...users.map(u => ({ type: 'user', id: u.id, text: u.name, detail: u.email })),
    ...products.map(p => ({ type: 'product', id: p.id, text: p.name, detail: p.category?.name })),
    ...categories.map(c => ({ type: 'category', id: c.id, text: c.name, detail: 'Category' }))
  ]
  
  return suggestions.slice(0, limit)
}
```

### EndsWith Operator - Suffix Matching
Finding content that ends with specific text:

```typescript
// File extension filtering
async function getFilesByExtension(extension: string) {
  const files = await prisma.file.findMany({
    where: {
      filename: {
        endsWith: `.${extension}`,
        mode: 'insensitive'
      }
    }
  })
  
  return files
}

// Domain-based user filtering
async function getUsersByEmailDomain(domain: string) {
  const users = await prisma.user.findMany({
    where: {
      email: {
        endsWith: `@${domain}`,
        mode: 'insensitive'
      }
    }
  })
  
  return users
}

// URL suffix routing
async function getPagesBySuffix(suffix: string) {
  const pages = await prisma.page.findMany({
    where: {
      slug: {
        endsWith: suffix
      }
    }
  })
  
  return pages
}

// Phone number country code filtering
async function getUsersByCountryCode(countryCode: string) {
  const users = await prisma.user.findMany({
    where: {
      phone: {
        startsWith: `+${countryCode}`
      }
    }
  })
  
  return users
}

// Language-specific content
async function getContentByLanguage(languageCode: string) {
  const posts = await prisma.post.findMany({
    where: {
      slug: {
        endsWith: `-${languageCode}`
      }
    }
  })
  
  return posts
}

// Advanced pattern matching with multiple suffixes
async function getMediaFiles(mediaTypes: string[] = ['jpg', 'png', 'gif', 'webp']) {
  const orConditions = mediaTypes.map(type => ({
    filename: {
      endsWith: `.${type}`,
      mode: 'insensitive' as const
    }
  }))
  
  const files = await prisma.file.findMany({
    where: {
      OR: orConditions
    }
  })
  
  return files
}
```

## Advanced Text Search Patterns

### Multi-Field Text Search
Comprehensive search across multiple content fields:

```typescript
// Comprehensive content search
async function advancedContentSearch(
  query: string,
  options: {
    includeUnpublished?: boolean
    authorId?: number
    categoryId?: number
    dateRange?: { start: Date; end: Date }
  } = {}
) {
  const searchTerms = query.split(' ').filter(term => term.length > 2)
  
  if (searchTerms.length === 0) {
    return []
  }
  
  // Build search conditions for each term
  const searchConditions = searchTerms.map(term => ({
    OR: [
      { title: { contains: term, mode: 'insensitive' as const } },
      { content: { contains: term, mode: 'insensitive' as const } },
      { excerpt: { contains: term, mode: 'insensitive' as const } },
      { 
        tags: {
          some: {
            name: { contains: term, mode: 'insensitive' as const }
          }
        }
      },
      {
        author: {
          name: { contains: term, mode: 'insensitive' as const }
        }
      }
    ]
  }))
  
  const baseConditions: any[] = []
  
  // Publication status
  if (!options.includeUnpublished) {
    baseConditions.push({ published: true })
  }
  
  // Author filter
  if (options.authorId) {
    baseConditions.push({ authorId: options.authorId })
  }
  
  // Category filter
  if (options.categoryId) {
    baseConditions.push({ categoryId: options.categoryId })
  }
  
  // Date range filter
  if (options.dateRange) {
    baseConditions.push({
      createdAt: {
        gte: options.dateRange.start,
        lte: options.dateRange.end
      }
    })
  }
  
  const posts = await prisma.post.findMany({
    where: {
      AND: [
        ...baseConditions,
        ...searchConditions
      ]
    },
    include: {
      author: {
        select: { id: true, name: true }
      },
      category: {
        select: { id: true, name: true }
      },
      tags: {
        select: { id: true, name: true }
      }
    }
  })
  
  return posts
}

// Weighted search with field priority
async function weightedSearch(query: string) {
  const posts = await prisma.post.findMany({
    where: {
      published: true,
      OR: [
        { title: { contains: query, mode: 'insensitive' } },
        { content: { contains: query, mode: 'insensitive' } },
        { excerpt: { contains: query, mode: 'insensitive' } }
      ]
    },
    include: {
      author: true,
      category: true,
      _count: {
        select: {
          likes: true,
          comments: true,
          shares: true
        }
      }
    }
  })
  
  // Calculate relevance score
  const scoredPosts = posts.map(post => {
    let score = 0
    const queryLower = query.toLowerCase()
    
    // Title matches (highest weight)
    if (post.title.toLowerCase().includes(queryLower)) {
      score += post.title.toLowerCase().startsWith(queryLower) ? 100 : 50
    }
    
    // Excerpt matches (medium weight)
    if (post.excerpt?.toLowerCase().includes(queryLower)) {
      score += 25
    }
    
    // Content matches (lower weight)
    const contentMatches = (post.content?.toLowerCase().match(new RegExp(queryLower, 'g')) || []).length
    score += contentMatches * 5
    
    // Engagement boost
    score += post._count.likes * 0.5
    score += post._count.comments * 1
    score += post._count.shares * 2
    
    return { ...post, relevanceScore: score }
  })
  
  return scoredPosts
    .filter(post => post.relevanceScore > 0)
    .sort((a, b) => b.relevanceScore - a.relevanceScore)
}

// Fuzzy search implementation
async function fuzzySearch(query: string, threshold: number = 0.6) {
  // Simple Levenshtein distance implementation
  function levenshteinDistance(str1: string, str2: string): number {
    const matrix = []
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i]
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1]
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          )
        }
      }
    }
    
    return matrix[str2.length][str1.length]
  }
  
  function similarity(str1: string, str2: string): number {
    const longer = str1.length > str2.length ? str1 : str2
    const shorter = str1.length > str2.length ? str2 : str1
    
    if (longer.length === 0) return 1.0
    
    return (longer.length - levenshteinDistance(longer, shorter)) / longer.length
  }
  
  // Get potential matches
  const posts = await prisma.post.findMany({
    where: { published: true },
    select: {
      id: true,
      title: true,
      excerpt: true,
      createdAt: true
    }
  })
  
  // Filter by similarity
  const fuzzyMatches = posts
    .map(post => ({
      ...post,
      similarity: Math.max(
        similarity(query.toLowerCase(), post.title.toLowerCase()),
        similarity(query.toLowerCase(), post.excerpt?.toLowerCase() || '')
      )
    }))
    .filter(post => post.similarity >= threshold)
    .sort((a, b) => b.similarity - a.similarity)
  
  return fuzzyMatches
}
```

### Database-Specific Advanced Search
Leveraging database-specific features for enhanced text search:

```typescript
// PostgreSQL full-text search
async function postgresqlFullTextSearch(query: string) {
  // Using raw SQL for PostgreSQL's full-text search capabilities
  const posts = await prisma.$queryRaw`
    SELECT 
      p.*,
      ts_rank(
        to_tsvector('english', p.title || ' ' || COALESCE(p.content, '') || ' ' || COALESCE(p.excerpt, '')),
        plainto_tsquery('english', ${query})
      ) AS rank
    FROM posts p
    WHERE 
      p.published = true
      AND to_tsvector('english', p.title || ' ' || COALESCE(p.content, '') || ' ' || COALESCE(p.excerpt, ''))
      @@ plainto_tsquery('english', ${query})
    ORDER BY rank DESC
    LIMIT 50
  `
  
  return posts
}

// MySQL full-text search
async function mysqlFullTextSearch(query: string) {
  // Using raw SQL for MySQL's MATCH...AGAINST
  const posts = await prisma.$queryRaw`
    SELECT 
      *,
      MATCH(title, content, excerpt) AGAINST(${query} IN NATURAL LANGUAGE MODE) AS relevance
    FROM posts
    WHERE 
      published = 1
      AND MATCH(title, content, excerpt) AGAINST(${query} IN NATURAL LANGUAGE MODE)
    ORDER BY relevance DESC
    LIMIT 50
  `
  
  return posts
}

// PostgreSQL trigram similarity search
async function trigramSimilaritySearch(query: string) {
  // Requires pg_trgm extension
  const posts = await prisma.$queryRaw`
    SELECT 
      *,
      similarity(title, ${query}) AS title_similarity,
      similarity(COALESCE(content, ''), ${query}) AS content_similarity
    FROM posts
    WHERE 
      published = true
      AND (
        similarity(title, ${query}) > 0.3
        OR similarity(COALESCE(content, ''), ${query}) > 0.1
      )
    ORDER BY 
      GREATEST(similarity(title, ${query}), similarity(COALESCE(content, ''), ${query})) DESC
    LIMIT 50
  `
  
  return posts
}
```

## Search Performance Optimization

### Efficient String Filtering
Optimizing text search for better performance:

```typescript
// Optimized text search with pagination
async function optimizedTextSearch(
  query: string,
  page: number = 1,
  limit: number = 20
) {
  const skip = (page - 1) * limit
  
  // Pre-filter with length check
  if (query.length < 3) {
    throw new Error('Query must be at least 3 characters long')
  }
  
  // Use database indexes effectively
  const [posts, total] = await Promise.all([
    prisma.post.findMany({
      where: {
        published: true, // Indexed field first
        title: {
          contains: query,
          mode: 'insensitive'
        }
      },
      skip,
      take: limit,
      orderBy: {
        createdAt: 'desc' // Use indexed field for ordering
      },
      select: {
        id: true,
        title: true,
        excerpt: true,
        createdAt: true,
        author: {
          select: {
            id: true,
            name: true
          }
        }
      }
    }),
    
    prisma.post.count({
      where: {
        published: true,
        title: {
          contains: query,
          mode: 'insensitive'
        }
      }
    })
  ])
  
  return {
    posts,
    pagination: {
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    }
  }
}

// Cached search with Redis-like caching
const searchCache = new Map<string, { data: any; expires: number }>()

async function cachedTextSearch(
  query: string,
  options: any = {},
  ttlMs: number = 5 * 60 * 1000 // 5 minutes
) {
  const cacheKey = `search:${query}:${JSON.stringify(options)}`
  
  // Check cache
  const cached = searchCache.get(cacheKey)
  if (cached && Date.now() < cached.expires) {
    return cached.data
  }
  
  // Perform search
  const results = await optimizedTextSearch(query, options.page, options.limit)
  
  // Cache results
  searchCache.set(cacheKey, {
    data: results,
    expires: Date.now() + ttlMs
  })
  
  return results
}

// Search with debouncing for real-time search
class DebouncedSearch {
  private timeouts = new Map<string, NodeJS.Timeout>()
  private cache = new Map<string, any>()
  
  async search(
    query: string,
    callback: (results: any) => void,
    debounceMs: number = 300
  ) {
    // Clear existing timeout
    const existingTimeout = this.timeouts.get(query)
    if (existingTimeout) {
      clearTimeout(existingTimeout)
    }
    
    // Check cache first
    const cached = this.cache.get(query)
    if (cached) {
      callback(cached)
      return
    }
    
    // Set new timeout
    const timeout = setTimeout(async () => {
      try {
        const results = await optimizedTextSearch(query)
        this.cache.set(query, results)
        callback(results)
      } catch (error) {
        callback({ error: error.message })
      }
      
      this.timeouts.delete(query)
    }, debounceMs)
    
    this.timeouts.set(query, timeout)
  }
}
```

### Search Analytics and Monitoring
Tracking search performance and user behavior:

```typescript
// Search analytics system
class SearchAnalytics {
  private searchLogs: any[] = []
  
  async logSearch(query: string, results: number, userId?: number) {
    const searchLog = {
      query,
      resultsCount: results,
      userId,
      timestamp: new Date(),
      sessionId: this.generateSessionId()
    }
    
    this.searchLogs.push(searchLog)
    
    // Persist to database
    await prisma.searchLog.create({
      data: searchLog
    })
  }
  
  async getPopularSearches(limit: number = 10) {
    const popularSearches = await prisma.searchLog.groupBy({
      by: ['query'],
      _count: {
        query: true
      },
      orderBy: {
        _count: {
          query: 'desc'
        }
      },
      take: limit,
      where: {
        timestamp: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
        }
      }
    })
    
    return popularSearches
  }
  
  async getSearchPerformanceMetrics() {
    const metrics = await prisma.searchLog.aggregate({
      _avg: {
        resultsCount: true
      },
      _count: {
        query: true
      },
      where: {
        timestamp: {
          gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
        }
      }
    })
    
    return {
      totalSearches: metrics._count.query,
      averageResults: metrics._avg.resultsCount,
      period: '7 days'
    }
  }
  
  private generateSessionId(): string {
    return Math.random().toString(36).substr(2, 9)
  }
}

// Search suggestion system
async function getSearchSuggestions(partialQuery: string, limit: number = 5) {
  if (partialQuery.length < 2) return []
  
  // Get popular searches that start with the partial query
  const suggestions = await prisma.searchLog.groupBy({
    by: ['query'],
    _count: {
      query: true
    },
    where: {
      query: {
        startsWith: partialQuery,
        mode: 'insensitive'
      },
      timestamp: {
        gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
      }
    },
    orderBy: {
      _count: {
        query: 'desc'
      }
    },
    take: limit
  })
  
  return suggestions.map(s => ({
    query: s.query,
    popularity: s._count.query
  }))
}
```

## Exercise: Advanced Text Search System

Build a comprehensive text search and filtering system:

```typescript
// Your task: Create a production-ready text search system

// Requirements:
// 1. Support all string operators with proper performance optimization
// 2. Implement fuzzy search and typo tolerance
// 3. Add search analytics and user behavior tracking
// 4. Support multiple languages and Unicode handling
// 5. Include search suggestions and autocomplete
// 6. Implement search result ranking and relevance scoring
// 7. Add caching and performance monitoring
// 8. Support advanced query syntax (quotes, operators, etc.)

interface TextSearchSystem {
  // Define the comprehensive text search interface
}

class AdvancedTextSearchEngine {
  // Implement the advanced text search system
  
  // Methods to implement:
  // - search(query: string, options: SearchOptions): Promise<SearchResults>
  // - suggest(partialQuery: string): Promise<string[]>
  // - fuzzySearch(query: string, threshold: number): Promise<SearchResults>
  // - fullTextSearch(query: string): Promise<SearchResults>
  // - analyzeSearchPerformance(): Promise<AnalyticsReport>
  // - indexContent(content: any[]): Promise<void>
  // - optimizeSearchIndexes(): Promise<void>
  // - generateSearchSuggestions(): Promise<void>
}

// Bonus features:
// - Machine learning-based search result ranking
// - Real-time search with WebSocket updates
// - Search result highlighting and snippets
// - Voice search integration
// - Multi-modal search (text + images)
// - Collaborative filtering for personalized results
```

## Key Takeaways

1. **Pattern Matching**: Use contains, startsWith, endsWith for flexible text filtering
2. **Case Sensitivity**: Choose appropriate mode (insensitive/default) based on requirements
3. **Multi-Field Search**: Search across multiple fields for comprehensive results
4. **Performance**: Optimize queries with proper indexing and caching strategies
5. **Relevance Scoring**: Implement ranking systems for better user experience
6. **Database Features**: Leverage database-specific full-text search capabilities
7. **Analytics**: Track search behavior to improve functionality and user experience

## Next Steps

Excellent work! You've mastered comprehensive text searching and filtering techniques. In the next lesson, **4.3.4 Numeric & Date Filtering**, we'll explore advanced filtering for numerical data and temporal queries with sophisticated range and comparison operations.

---

**Estimated Time:** 25 minutes
**Difficulty:** Intermediate to Advanced
**Prerequisites:** Understanding of text processing, database indexing, and search algorithms
