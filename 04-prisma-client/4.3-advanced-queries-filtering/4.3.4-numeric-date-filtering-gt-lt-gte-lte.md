# 4.3.4 Numeric & Date Filtering (gt, lt, gte, lte)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master numeric comparison operators (gt, lt, gte, lte) for precise range filtering
- Implement sophisticated date and time filtering with timezone awareness
- Design advanced temporal queries for analytics and reporting systems
- Build dynamic range filtering systems that adapt to user requirements
- Handle numeric precision, floating-point comparisons, and edge cases safely
- Optimize numeric and date queries for performance and scalability
- Create time-based data analysis and trend detection systems
- Implement complex business logic with numeric and temporal constraints

## Introduction

Think of Prisma's numeric and date filtering capabilities as **a master financial analyst's precision toolkit** - like an expert quantitative researcher who analyzes market data, economic trends, and financial metrics with mathematical precision. Just as a skilled analyst uses different analytical instruments (range analysis for price movements, threshold detection for market signals, temporal analysis for trend identification, and comparative metrics for performance evaluation), Prisma's comparison operators provide you with powerful mathematical and temporal tools to filter, analyze, and discover patterns in your data. Whether you're working with financial calculations, performance metrics, time series analysis, or business intelligence, these operators help you navigate through numerical and temporal data like a seasoned data scientist.

Understanding numeric and date filtering is essential for building analytics systems, reporting tools, and data-driven applications that require precise mathematical and temporal operations.

## Basic Numeric Comparisons

### Greater Than and Less Than Operations
Fundamental range and boundary filtering:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Basic greater than filtering
async function getExpensiveProducts(minPrice: number) {
  const products = await prisma.product.findMany({
    where: {
      price: {
        gt: minPrice // Greater than
      }
    }
  })
  
  return products
}

// Basic less than filtering
async function getAffordableProducts(maxPrice: number) {
  const products = await prisma.product.findMany({
    where: {
      price: {
        lt: maxPrice // Less than
      }
    }
  })
  
  return products
}

// Greater than or equal (inclusive)
async function getQualifiedUsers(minAge: number) {
  const users = await prisma.user.findMany({
    where: {
      age: {
        gte: minAge // Greater than or equal
      }
    }
  })
  
  return users
}

// Less than or equal (inclusive)
async function getEligibleDiscounts(maxOrderValue: number) {
  const orders = await prisma.order.findMany({
    where: {
      total: {
        lte: maxOrderValue // Less than or equal
      }
    }
  })
  
  return orders
}

// Range filtering with both bounds
async function getProductsInPriceRange(minPrice: number, maxPrice: number) {
  const products = await prisma.product.findMany({
    where: {
      price: {
        gte: minPrice,
        lte: maxPrice
      }
    }
  })
  
  return products
}

// Multiple numeric conditions
async function getQualityProducts(
  minPrice: number,
  minRating: number,
  minReviews: number
) {
  const products = await prisma.product.findMany({
    where: {
      price: { gte: minPrice },
      rating: { gte: minRating },
      reviewCount: { gte: minReviews },
      stock: { gt: 0 } // In stock
    }
  })
  
  return products
}
```

### Advanced Numeric Filtering Patterns
Complex mathematical filtering for business logic:

```typescript
// Percentage-based filtering
async function getDiscountedProducts(minDiscountPercent: number) {
  const products = await prisma.product.findMany({
    where: {
      discountPercent: {
        gte: minDiscountPercent
      },
      salePrice: {
        lt: prisma.product.fields.originalPrice // Conceptual - would use raw SQL
      }
    }
  })
  
  return products
}

// Statistical filtering
async function getTopPerformingUsers(percentile: number = 90) {
  // First, get the percentile threshold
  const totalUsers = await prisma.user.count()
  const thresholdIndex = Math.floor((totalUsers * percentile) / 100)
  
  // Get users ordered by score to find threshold
  const usersByScore = await prisma.user.findMany({
    orderBy: { score: 'desc' },
    skip: thresholdIndex,
    take: 1,
    select: { score: true }
  })
  
  const thresholdScore = usersByScore[0]?.score || 0
  
  // Get users above threshold
  const topUsers = await prisma.user.findMany({
    where: {
      score: {
        gte: thresholdScore
      }
    },
    orderBy: { score: 'desc' }
  })
  
  return topUsers
}

// Financial calculations
async function getHighValueOrders(multiplier: number = 2) {
  // Get orders above average order value * multiplier
  const avgOrderValue = await prisma.order.aggregate({
    _avg: { total: true }
  })
  
  const threshold = (avgOrderValue._avg.total || 0) * multiplier
  
  const highValueOrders = await prisma.order.findMany({
    where: {
      total: {
        gte: threshold
      }
    }
  })
  
  return highValueOrders
}

// Growth rate filtering
async function getFastGrowingProducts(
  minGrowthRate: number,
  periodDays: number = 30
) {
  const cutoffDate = new Date(Date.now() - periodDays * 24 * 60 * 60 * 1000)
  
  // This would typically involve more complex calculations
  // Showing conceptual approach
  const products = await prisma.product.findMany({
    where: {
      sales: {
        some: {
          createdAt: { gte: cutoffDate },
          quantity: { gt: 0 }
        }
      }
    },
    include: {
      sales: {
        where: {
          createdAt: { gte: cutoffDate }
        }
      }
    }
  })
  
  // Calculate growth in application layer
  const fastGrowing = products.filter(product => {
    const recentSales = product.sales.reduce((sum, sale) => sum + sale.quantity, 0)
    const growthRate = (recentSales / periodDays) * 100 // Simplified calculation
    return growthRate >= minGrowthRate
  })
  
  return fastGrowing
}

// Inventory management
async function getInventoryAlerts(
  lowStockThreshold: number = 10,
  overStockMultiplier: number = 5
) {
  const [lowStock, overStock] = await Promise.all([
    // Low stock products
    prisma.product.findMany({
      where: {
        stock: {
          lte: lowStockThreshold,
          gt: 0 // Not completely out of stock
        }
      }
    }),
    
    // Overstock products (stock > average daily sales * multiplier)
    prisma.product.findMany({
      where: {
        stock: {
          gt: 100 // Simplified - would calculate based on sales data
        }
      }
    })
  ])
  
  return { lowStock, overStock }
}

// Performance metrics
async function getPerformanceMetrics(thresholds: {
  responseTime?: number
  errorRate?: number
  throughput?: number
}) {
  const conditions: any[] = []
  
  if (thresholds.responseTime) {
    conditions.push({
      averageResponseTime: { gt: thresholds.responseTime }
    })
  }
  
  if (thresholds.errorRate) {
    conditions.push({
      errorRate: { gt: thresholds.errorRate }
    })
  }
  
  if (thresholds.throughput) {
    conditions.push({
      requestsPerSecond: { lt: thresholds.throughput }
    })
  }
  
  const metrics = await prisma.performanceMetric.findMany({
    where: {
      OR: conditions
    }
  })
  
  return metrics
}
```

## Date and Time Filtering

### Basic Date Comparisons
Fundamental temporal filtering patterns:

```typescript
// Recent content filtering
async function getRecentPosts(days: number = 7) {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - days)
  
  const posts = await prisma.post.findMany({
    where: {
      createdAt: {
        gte: cutoffDate
      }
    }
  })
  
  return posts
}

// Future event filtering
async function getUpcomingEvents() {
  const now = new Date()
  
  const events = await prisma.event.findMany({
    where: {
      startDate: {
        gt: now
      }
    },
    orderBy: {
      startDate: 'asc'
    }
  })
  
  return events
}

// Date range filtering
async function getContentInDateRange(startDate: Date, endDate: Date) {
  const posts = await prisma.post.findMany({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate
      }
    }
  })
  
  return posts
}

// Age-based filtering
async function getUsersByAge(minAge: number, maxAge?: number) {
  const now = new Date()
  const maxBirthDate = new Date(now.getFullYear() - minAge, now.getMonth(), now.getDate())
  
  const where: any = {
    birthDate: {
      lte: maxBirthDate
    }
  }
  
  if (maxAge) {
    const minBirthDate = new Date(now.getFullYear() - maxAge, now.getMonth(), now.getDate())
    where.birthDate.gte = minBirthDate
  }
  
  const users = await prisma.user.findMany({
    where
  })
  
  return users
}

// Expiration filtering
async function getExpiringItems(daysUntilExpiry: number = 30) {
  const expiryThreshold = new Date()
  expiryThreshold.setDate(expiryThreshold.getDate() + daysUntilExpiry)
  
  const items = await prisma.product.findMany({
    where: {
      expiryDate: {
        lte: expiryThreshold,
        gt: new Date() // Not already expired
      }
    }
  })
  
  return items
}

// Historical data filtering
async function getHistoricalData(monthsBack: number = 12) {
  const cutoffDate = new Date()
  cutoffDate.setMonth(cutoffDate.getMonth() - monthsBack)
  
  const data = await prisma.analyticsData.findMany({
    where: {
      recordedAt: {
        gte: cutoffDate
      }
    },
    orderBy: {
      recordedAt: 'asc'
    }
  })
  
  return data
}
```

### Advanced Temporal Filtering
Sophisticated time-based queries for complex scenarios:

```typescript
// Business hours filtering
async function getBusinessHoursActivity(date: Date = new Date()) {
  const startOfDay = new Date(date)
  startOfDay.setHours(9, 0, 0, 0) // 9 AM
  
  const endOfDay = new Date(date)
  endOfDay.setHours(17, 0, 0, 0) // 5 PM
  
  const activities = await prisma.userActivity.findMany({
    where: {
      timestamp: {
        gte: startOfDay,
        lte: endOfDay
      }
    }
  })
  
  return activities
}

// Weekly patterns
async function getWeeklyPatterns(startDate: Date, weeks: number = 4) {
  const endDate = new Date(startDate)
  endDate.setDate(startDate.getDate() + (weeks * 7))
  
  const data = await prisma.userActivity.findMany({
    where: {
      timestamp: {
        gte: startDate,
        lt: endDate
      }
    }
  })
  
  // Group by day of week
  const weeklyPattern = data.reduce((acc, activity) => {
    const dayOfWeek = activity.timestamp.getDay()
    acc[dayOfWeek] = (acc[dayOfWeek] || 0) + 1
    return acc
  }, {} as Record<number, number>)
  
  return weeklyPattern
}

// Monthly trends
async function getMonthlyTrends(year: number) {
  const trends = []
  
  for (let month = 0; month < 12; month++) {
    const startDate = new Date(year, month, 1)
    const endDate = new Date(year, month + 1, 0, 23, 59, 59)
    
    const count = await prisma.order.count({
      where: {
        createdAt: {
          gte: startDate,
          lte: endDate
        }
      }
    })
    
    const total = await prisma.order.aggregate({
      where: {
        createdAt: {
          gte: startDate,
          lte: endDate
        }
      },
      _sum: {
        total: true
      }
    })
    
    trends.push({
      month: month + 1,
      monthName: startDate.toLocaleString('default', { month: 'long' }),
      orderCount: count,
      totalRevenue: total._sum.total || 0
    })
  }
  
  return trends
}

// Session-based filtering
async function getActiveSessions(timeoutMinutes: number = 30) {
  const cutoffTime = new Date(Date.now() - timeoutMinutes * 60 * 1000)
  
  const activeSessions = await prisma.userSession.findMany({
    where: {
      lastActivity: {
        gte: cutoffTime
      },
      isActive: true
    }
  })
  
  return activeSessions
}

// Subscription lifecycle
async function getSubscriptionsByStatus(
  status: 'active' | 'expiring' | 'expired' | 'trial',
  daysThreshold: number = 30
) {
  const now = new Date()
  const thresholdDate = new Date(now.getTime() + daysThreshold * 24 * 60 * 60 * 1000)
  
  let whereCondition: any
  
  switch (status) {
    case 'active':
      whereCondition = {
        expiresAt: { gt: now },
        status: 'ACTIVE'
      }
      break
      
    case 'expiring':
      whereCondition = {
        expiresAt: {
          gt: now,
          lte: thresholdDate
        },
        status: 'ACTIVE'
      }
      break
      
    case 'expired':
      whereCondition = {
        expiresAt: { lte: now }
      }
      break
      
    case 'trial':
      whereCondition = {
        trialEndsAt: {
          gt: now,
          lte: thresholdDate
        },
        status: 'TRIAL'
      }
      break
  }
  
  const subscriptions = await prisma.subscription.findMany({
    where: whereCondition
  })
  
  return subscriptions
}

// Time zone aware filtering
async function getEventsInTimezone(
  timezone: string,
  startDate: Date,
  endDate: Date
) {
  // Convert dates to UTC for database storage
  const utcStart = new Date(startDate.toLocaleString('en-US', { timeZone: 'UTC' }))
  const utcEnd = new Date(endDate.toLocaleString('en-US', { timeZone: 'UTC' }))
  
  const events = await prisma.event.findMany({
    where: {
      startDate: {
        gte: utcStart,
        lte: utcEnd
      },
      timezone: timezone
    }
  })
  
  return events
}
```

## Advanced Range and Boundary Operations

### Dynamic Range Building
Flexible range filtering based on runtime conditions:

```typescript
// Dynamic price range builder
interface PriceFilter {
  min?: number
  max?: number
  currency?: string
}

async function getProductsByDynamicPrice(filter: PriceFilter) {
  const where: any = {}
  
  if (filter.min !== undefined) {
    where.price = { ...where.price, gte: filter.min }
  }
  
  if (filter.max !== undefined) {
    where.price = { ...where.price, lte: filter.max }
  }
  
  if (filter.currency) {
    where.currency = filter.currency
  }
  
  const products = await prisma.product.findMany({
    where
  })
  
  return products
}

// Multi-dimensional range filtering
interface MetricFilters {
  performance?: { min?: number; max?: number }
  usage?: { min?: number; max?: number }
  cost?: { min?: number; max?: number }
  date?: { start?: Date; end?: Date }
}

async function getResourcesByMetrics(filters: MetricFilters) {
  const conditions: any[] = []
  
  // Performance range
  if (filters.performance) {
    const perfCondition: any = {}
    if (filters.performance.min !== undefined) {
      perfCondition.gte = filters.performance.min
    }
    if (filters.performance.max !== undefined) {
      perfCondition.lte = filters.performance.max
    }
    if (Object.keys(perfCondition).length > 0) {
      conditions.push({ performanceScore: perfCondition })
    }
  }
  
  // Usage range
  if (filters.usage) {
    const usageCondition: any = {}
    if (filters.usage.min !== undefined) {
      usageCondition.gte = filters.usage.min
    }
    if (filters.usage.max !== undefined) {
      usageCondition.lte = filters.usage.max
    }
    if (Object.keys(usageCondition).length > 0) {
      conditions.push({ usageMetric: usageCondition })
    }
  }
  
  // Cost range
  if (filters.cost) {
    const costCondition: any = {}
    if (filters.cost.min !== undefined) {
      costCondition.gte = filters.cost.min
    }
    if (filters.cost.max !== undefined) {
      costCondition.lte = filters.cost.max
    }
    if (Object.keys(costCondition).length > 0) {
      conditions.push({ monthlyCost: costCondition })
    }
  }
  
  // Date range
  if (filters.date) {
    const dateCondition: any = {}
    if (filters.date.start) {
      dateCondition.gte = filters.date.start
    }
    if (filters.date.end) {
      dateCondition.lte = filters.date.end
    }
    if (Object.keys(dateCondition).length > 0) {
      conditions.push({ lastUpdated: dateCondition })
    }
  }
  
  const resources = await prisma.resource.findMany({
    where: conditions.length > 0 ? { AND: conditions } : {}
  })
  
  return resources
}

// Percentile-based filtering
async function getPercentileBasedResults<T>(
  model: string,
  field: string,
  percentiles: { min?: number; max?: number }
) {
  // Get total count
  const total = await (prisma as any)[model].count()
  
  const conditions: any[] = []
  
  if (percentiles.min !== undefined) {
    const minIndex = Math.floor((total * percentiles.min) / 100)
    const minThreshold = await (prisma as any)[model].findMany({
      orderBy: { [field]: 'asc' },
      skip: minIndex,
      take: 1,
      select: { [field]: true }
    })
    
    if (minThreshold[0]) {
      conditions.push({ [field]: { gte: minThreshold[0][field] } })
    }
  }
  
  if (percentiles.max !== undefined) {
    const maxIndex = Math.floor((total * percentiles.max) / 100)
    const maxThreshold = await (prisma as any)[model].findMany({
      orderBy: { [field]: 'asc' },
      skip: maxIndex,
      take: 1,
      select: { [field]: true }
    })
    
    if (maxThreshold[0]) {
      conditions.push({ [field]: { lte: maxThreshold[0][field] } })
    }
  }
  
  const results = await (prisma as any)[model].findMany({
    where: conditions.length > 0 ? { AND: conditions } : {}
  })
  
  return results
}
```

### Statistical and Mathematical Filtering
Advanced mathematical operations for data analysis:

```typescript
// Standard deviation filtering
async function getOutlierDetection(field: string, standardDeviations: number = 2) {
  // Get basic statistics
  const stats = await prisma.product.aggregate({
    _avg: { [field]: true },
    _count: { [field]: true }
  })
  
  const mean = (stats._avg as any)[field] || 0
  
  // Calculate standard deviation (simplified approach)
  const products = await prisma.product.findMany({
    select: { id: true, [field]: true }
  })
  
  const squaredDiffs = products.map(p => Math.pow((p as any)[field] - mean, 2))
  const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / products.length
  const standardDeviation = Math.sqrt(variance)
  
  const lowerBound = mean - (standardDeviations * standardDeviation)
  const upperBound = mean + (standardDeviations * standardDeviation)
  
  // Get outliers
  const outliers = await prisma.product.findMany({
    where: {
      OR: [
        { [field]: { lt: lowerBound } },
        { [field]: { gt: upperBound } }
      ]
    }
  })
  
  return {
    outliers,
    statistics: {
      mean,
      standardDeviation,
      lowerBound,
      upperBound
    }
  }
}

// Moving average filtering
async function getMovingAverageAnalysis(
  days: number = 30,
  threshold: number = 0.1
) {
  const startDate = new Date()
  startDate.setDate(startDate.getDate() - days)
  
  // Get daily metrics
  const dailyMetrics = await prisma.dailyMetric.findMany({
    where: {
      date: { gte: startDate }
    },
    orderBy: { date: 'asc' }
  })
  
  // Calculate moving averages
  const movingAverages = dailyMetrics.map((metric, index) => {
    const windowSize = Math.min(7, index + 1) // 7-day moving average
    const windowStart = Math.max(0, index - windowSize + 1)
    const window = dailyMetrics.slice(windowStart, index + 1)
    
    const average = window.reduce((sum, m) => sum + m.value, 0) / window.length
    const deviation = Math.abs(metric.value - average) / average
    
    return {
      ...metric,
      movingAverage: average,
      deviation,
      isOutlier: deviation > threshold
    }
  })
  
  return movingAverages
}

// Correlation-based filtering
async function getCorrelatedMetrics(
  primaryMetric: string,
  correlationThreshold: number = 0.7
) {
  // Get all metrics data
  const metrics = await prisma.metric.findMany({
    include: {
      values: {
        orderBy: { timestamp: 'asc' }
      }
    }
  })
  
  const primaryData = metrics.find(m => m.name === primaryMetric)
  if (!primaryData) return []
  
  // Calculate correlations
  const correlations = metrics
    .filter(m => m.name !== primaryMetric)
    .map(metric => {
      const correlation = calculateCorrelation(
        primaryData.values.map(v => v.value),
        metric.values.map(v => v.value)
      )
      
      return {
        metric: metric.name,
        correlation,
        isCorrelated: Math.abs(correlation) >= correlationThreshold
      }
    })
    .filter(c => c.isCorrelated)
    .sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation))
  
  return correlations
}

function calculateCorrelation(x: number[], y: number[]): number {
  const n = Math.min(x.length, y.length)
  if (n === 0) return 0
  
  const meanX = x.reduce((sum, val) => sum + val, 0) / n
  const meanY = y.reduce((sum, val) => sum + val, 0) / n
  
  let numerator = 0
  let sumXSquared = 0
  let sumYSquared = 0
  
  for (let i = 0; i < n; i++) {
    const deltaX = x[i] - meanX
    const deltaY = y[i] - meanY
    
    numerator += deltaX * deltaY
    sumXSquared += deltaX * deltaX
    sumYSquared += deltaY * deltaY
  }
  
  const denominator = Math.sqrt(sumXSquared * sumYSquared)
  return denominator === 0 ? 0 : numerator / denominator
}
```

## Performance Optimization for Numeric and Date Queries

### Index-Optimized Filtering
Maximizing query performance for numerical operations:

```typescript
// Optimized range queries
async function getOptimizedRangeQuery(
  minValue: number,
  maxValue: number,
  page: number = 1,
  limit: number = 20
) {
  const skip = (page - 1) * limit
  
  // Use indexed fields for optimal performance
  const [items, total] = await Promise.all([
    prisma.product.findMany({
      where: {
        price: {
          gte: minValue,
          lte: maxValue
        },
        isActive: true // Additional indexed filter
      },
      skip,
      take: limit,
      orderBy: {
        price: 'asc' // Order by indexed field
      }
    }),
    
    prisma.product.count({
      where: {
        price: {
          gte: minValue,
          lte: maxValue
        },
        isActive: true
      }
    })
  ])
  
  return { items, total, page, limit }
}

// Batch numeric operations
async function getBatchNumericAnalysis(ranges: Array<{ min: number; max: number }>) {
  const results = await Promise.all(
    ranges.map(async (range, index) => {
      const [count, sum, avg] = await Promise.all([
        prisma.product.count({
          where: {
            price: { gte: range.min, lte: range.max }
          }
        }),
        
        prisma.product.aggregate({
          where: {
            price: { gte: range.min, lte: range.max }
          },
          _sum: { price: true }
        }),
        
        prisma.product.aggregate({
          where: {
            price: { gte: range.min, lte: range.max }
          },
          _avg: { price: true }
        })
      ])
      
      return {
        rangeIndex: index,
        min: range.min,
        max: range.max,
        count,
        sum: sum._sum.price || 0,
        average: avg._avg.price || 0
      }
    })
  )
  
  return results
}

// Cached temporal queries
const temporalCache = new Map<string, { data: any; expires: number }>()

async function getCachedTemporalData(
  cacheKey: string,
  queryFn: () => Promise<any>,
  ttlMs: number = 10 * 60 * 1000 // 10 minutes
) {
  const cached = temporalCache.get(cacheKey)
  
  if (cached && Date.now() < cached.expires) {
    return cached.data
  }
  
  const data = await queryFn()
  
  temporalCache.set(cacheKey, {
    data,
    expires: Date.now() + ttlMs
  })
  
  return data
}

// Optimized date range aggregations
async function getOptimizedDateRangeStats(
  startDate: Date,
  endDate: Date,
  groupBy: 'day' | 'week' | 'month' = 'day'
) {
  const cacheKey = `date_stats_${startDate.toISOString()}_${endDate.toISOString()}_${groupBy}`
  
  return getCachedTemporalData(cacheKey, async () => {
    // Use raw SQL for better performance on large datasets
    let dateFormat: string
    
    switch (groupBy) {
      case 'day':
        dateFormat = '%Y-%m-%d'
        break
      case 'week':
        dateFormat = '%Y-%u'
        break
      case 'month':
        dateFormat = '%Y-%m'
        break
    }
    
    const results = await prisma.$queryRaw`
      SELECT 
        DATE_FORMAT(created_at, ${dateFormat}) as period,
        COUNT(*) as count,
        SUM(total) as total_amount,
        AVG(total) as avg_amount
      FROM orders
      WHERE created_at >= ${startDate} AND created_at <= ${endDate}
      GROUP BY period
      ORDER BY period
    `
    
    return results
  })
}
```

## Exercise: Advanced Numeric and Date Analysis System

Build a comprehensive numerical and temporal analysis system:

```typescript
// Your task: Create a production-ready numeric and date filtering system

// Requirements:
// 1. Support all comparison operators with proper performance optimization
// 2. Implement statistical analysis and outlier detection
// 3. Add time series analysis and trend detection
// 4. Support dynamic range building and multi-dimensional filtering
// 5. Include timezone-aware date operations
// 6. Implement caching for expensive calculations
// 7. Add real-time monitoring for numeric thresholds
// 8. Support advanced mathematical operations and correlations

interface NumericDateAnalysisSystem {
  // Define the comprehensive analysis interface
}

class AdvancedNumericDateFilter {
  // Implement the advanced filtering and analysis system
  
  // Methods to implement:
  // - rangeFilter(field: string, min?: number, max?: number): this
  // - dateRangeFilter(field: string, start?: Date, end?: Date): this
  // - statisticalFilter(field: string, operation: StatOperation): this
  // - trendAnalysis(field: string, period: TimePeriod): Promise<TrendData>
  // - outlierDetection(field: string, threshold: number): Promise<OutlierData>
  // - correlationAnalysis(fields: string[]): Promise<CorrelationMatrix>
  // - movingAverage(field: string, window: number): Promise<MovingAverageData>
  // - percentileFilter(field: string, percentiles: number[]): this
}

// Bonus features:
// - Machine learning-based trend prediction
// - Real-time anomaly detection
// - Advanced time series forecasting
// - Multi-dimensional statistical analysis
// - Automated threshold optimization
// - Performance benchmarking and query optimization
```

## Key Takeaways

1. **Comparison Operators**: Use gt, gte, lt, lte for precise numeric and date boundaries
2. **Range Filtering**: Combine operators for sophisticated range-based queries
3. **Date Operations**: Handle temporal data with timezone awareness and proper formatting
4. **Statistical Analysis**: Implement mathematical operations for data analysis and insights
5. **Performance**: Optimize queries with proper indexing and caching strategies
6. **Dynamic Building**: Create flexible systems that adapt to runtime numeric requirements
7. **Business Logic**: Apply numeric and temporal constraints for complex business rules

## Next Steps

Outstanding work! You've mastered comprehensive numeric and date filtering techniques. In the next lesson, **4.3.5 Array & List Filtering**, we'll explore advanced filtering for collections, arrays, and list-based data with sophisticated containment and relationship operations.

---

**Estimated Time:** 27 minutes
**Difficulty:** Intermediate to Advanced
**Prerequisites:** Understanding of mathematical operations, statistical concepts, and temporal data handling
