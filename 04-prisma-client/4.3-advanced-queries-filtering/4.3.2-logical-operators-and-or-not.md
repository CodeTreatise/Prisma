# 4.3.2 Logical Operators (AND, OR, NOT)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master AND, OR, and NOT logical operators for complex query combinations
- Design sophisticated multi-condition filtering logic with nested boolean expressions
- Implement advanced conditional logic for business rule enforcement in queries
- Build flexible query systems that handle complex user requirements and edge cases
- Optimize logical operator performance through strategic query structuring
- Create reusable logical patterns for consistent application behavior
- Handle complex nested conditions with proper precedence and grouping
- Design maintainable query logic that scales with application complexity

## Introduction

Think of Prisma's logical operators as **the master architect's blueprint system** - like a sophisticated building designer who combines different structural elements (foundation requirements, safety regulations, aesthetic preferences, budget constraints) using logical connections (AND for mandatory requirements, OR for alternative solutions, NOT for exclusions) to create comprehensive construction plans. Just as an architect uses logical thinking to combine various building requirements ("this room MUST have natural light AND meet fire safety codes, OR use alternative ventilation, but NOT be in the basement"), Prisma's logical operators allow you to combine multiple filtering conditions into sophisticated query logic that perfectly matches your application's complex business rules and user requirements.

Understanding logical operators is essential for building queries that can handle real-world complexity where multiple conditions must work together to produce precise results.

## Basic Logical Operations

### AND Logic - All Conditions Must Be True
Combining multiple requirements that must all be satisfied:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Implicit AND with multiple fields
async function getQualifiedUsers() {
  const users = await prisma.user.findMany({
    where: {
      isActive: true,        // AND
      emailVerified: true,   // AND
      age: { gte: 18 },     // AND
      role: 'USER'          // AND (implied)
    }
  })
  
  return users
}

// Explicit AND for complex conditions
async function getAdvancedUsers() {
  const users = await prisma.user.findMany({
    where: {
      AND: [
        { isActive: true },
        { emailVerified: true },
        { 
          age: { 
            gte: 18,
            lte: 65 
          } 
        },
        {
          OR: [
            { role: 'USER' },
            { role: 'PREMIUM' }
          ]
        }
      ]
    }
  })
  
  return users
}

// Multiple field conditions
async function getEligibleProducts() {
  const products = await prisma.product.findMany({
    where: {
      AND: [
        { isActive: true },
        { stock: { gt: 0 } },
        { price: { gte: 10, lte: 1000 } },
        { category: { isNot: null } },
        { 
          OR: [
            { featured: true },
            { rating: { gte: 4.0 } }
          ]
        }
      ]
    }
  })
  
  return products
}

// Date-based AND conditions
async function getRecentActiveUsers(days: number = 30) {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - days)
  
  const users = await prisma.user.findMany({
    where: {
      AND: [
        { isActive: true },
        { createdAt: { lte: cutoffDate } }, // Not too new
        { lastLoginAt: { gte: cutoffDate } }, // Recently active
        { isDeleted: false }
      ]
    }
  })
  
  return users
}

// Complex business logic with AND
async function getOrdersForProcessing() {
  const orders = await prisma.order.findMany({
    where: {
      AND: [
        { status: 'PENDING' },
        { paymentStatus: 'COMPLETED' },
        { total: { gte: 5 } }, // Minimum order value
        { 
          customer: {
            isActive: true,
            emailVerified: true
          }
        },
        {
          items: {
            every: { // All items must be in stock
              product: {
                stock: { gt: 0 }
              }
            }
          }
        }
      ]
    }
  })
  
  return orders
}
```

### OR Logic - Any Condition Can Be True
Providing alternative conditions where any can satisfy the requirement:

```typescript
// Basic OR conditions
async function getUsersByMultipleCriteria() {
  const users = await prisma.user.findMany({
    where: {
      OR: [
        { role: 'ADMIN' },
        { role: 'MODERATOR' },
        { 
          AND: [
            { role: 'USER' },
            { isPremium: true }
          ]
        }
      ]
    }
  })
  
  return users
}

// Text search with OR
async function searchContent(searchTerm: string) {
  const posts = await prisma.post.findMany({
    where: {
      published: true,
      OR: [
        { 
          title: { 
            contains: searchTerm,
            mode: 'insensitive' 
          } 
        },
        { 
          content: { 
            contains: searchTerm,
            mode: 'insensitive' 
          } 
        },
        { 
          excerpt: { 
            contains: searchTerm,
            mode: 'insensitive' 
          } 
        },
        {
          tags: {
            some: {
              name: {
                contains: searchTerm,
                mode: 'insensitive'
              }
            }
          }
        }
      ]
    }
  })
  
  return posts
}

// Status-based OR filtering
async function getActionableItems() {
  const items = await prisma.task.findMany({
    where: {
      OR: [
        { status: 'URGENT' },
        { 
          AND: [
            { status: 'PENDING' },
            { dueDate: { lte: new Date() } }
          ]
        },
        {
          AND: [
            { priority: 'HIGH' },
            { assigneeId: { not: null } }
          ]
        }
      ]
    }
  })
  
  return items
}

// Complex OR with nested conditions
async function getFlexibleProductSearch(criteria: {
  category?: string
  minPrice?: number
  maxPrice?: number
  minRating?: number
  searchTerm?: string
}) {
  const orConditions: any[] = []
  
  // Category match
  if (criteria.category) {
    orConditions.push({
      category: {
        name: {
          contains: criteria.category,
          mode: 'insensitive'
        }
      }
    })
  }
  
  // Price range match
  if (criteria.minPrice || criteria.maxPrice) {
    const priceCondition: any = {}
    if (criteria.minPrice) priceCondition.gte = criteria.minPrice
    if (criteria.maxPrice) priceCondition.lte = criteria.maxPrice
    
    orConditions.push({ price: priceCondition })
  }
  
  // High rating match
  if (criteria.minRating) {
    orConditions.push({
      rating: { gte: criteria.minRating }
    })
  }
  
  // Text search match
  if (criteria.searchTerm) {
    orConditions.push({
      OR: [
        { 
          name: { 
            contains: criteria.searchTerm,
            mode: 'insensitive' 
          } 
        },
        { 
          description: { 
            contains: criteria.searchTerm,
            mode: 'insensitive' 
          } 
        }
      ]
    })
  }
  
  if (orConditions.length === 0) {
    // Return all active products if no criteria
    return prisma.product.findMany({
      where: { isActive: true }
    })
  }
  
  const products = await prisma.product.findMany({
    where: {
      isActive: true,
      OR: orConditions
    }
  })
  
  return products
}

// User access control with OR
async function getUsersWithAccess(resourceId: number) {
  const users = await prisma.user.findMany({
    where: {
      isActive: true,
      OR: [
        { role: 'ADMIN' }, // Admins have access to everything
        { 
          permissions: {
            some: {
              resource: 'ALL',
              action: 'READ'
            }
          }
        },
        {
          permissions: {
            some: {
              AND: [
                { resourceId: resourceId },
                { action: { in: ['READ', 'WRITE', 'ADMIN'] } }
              ]
            }
          }
        },
        {
          ownedResources: {
            some: {
              id: resourceId
            }
          }
        }
      ]
    }
  })
  
  return users
}
```

### NOT Logic - Exclusion and Negation
Filtering out unwanted data with sophisticated exclusion patterns:

```typescript
// Basic NOT operations
async function getUsersExceptSpecificRoles() {
  const users = await prisma.user.findMany({
    where: {
      NOT: {
        role: {
          in: ['BANNED', 'SUSPENDED', 'PENDING']
        }
      }
    }
  })
  
  return users
}

// Complex NOT conditions
async function getCleanUserBase() {
  const users = await prisma.user.findMany({
    where: {
      NOT: {
        OR: [
          { isDeleted: true },
          { isBanned: true },
          { emailVerified: false },
          { 
            AND: [
              { createdAt: { lt: new Date('2020-01-01') } },
              { lastLoginAt: null }
            ]
          }
        ]
      }
    }
  })
  
  return users
}

// NOT with nested relationships
async function getPostsWithoutSpecificContent() {
  const posts = await prisma.post.findMany({
    where: {
      published: true,
      NOT: {
        OR: [
          { 
            content: {
              contains: 'spam',
              mode: 'insensitive'
            }
          },
          {
            comments: {
              some: {
                flagged: true
              }
            }
          },
          {
            author: {
              isBanned: true
            }
          },
          {
            tags: {
              some: {
                name: {
                  in: ['inappropriate', 'adult', 'violence']
                }
              }
            }
          }
        ]
      }
    }
  })
  
  return posts
}

// Advanced exclusion patterns
async function getHighQualityContent(excludeCriteria: {
  minRating?: number
  excludeAuthors?: number[]
  excludeCategories?: number[]
  excludeKeywords?: string[]
}) {
  const notConditions: any[] = []
  
  // Exclude low-rated content
  if (excludeCriteria.minRating) {
    notConditions.push({
      rating: { lt: excludeCriteria.minRating }
    })
  }
  
  // Exclude specific authors
  if (excludeCriteria.excludeAuthors?.length) {
    notConditions.push({
      authorId: { in: excludeCriteria.excludeAuthors }
    })
  }
  
  // Exclude specific categories
  if (excludeCriteria.excludeCategories?.length) {
    notConditions.push({
      categoryId: { in: excludeCriteria.excludeCategories }
    })
  }
  
  // Exclude content with specific keywords
  if (excludeCriteria.excludeKeywords?.length) {
    notConditions.push({
      OR: excludeCriteria.excludeKeywords.map(keyword => ({
        content: {
          contains: keyword,
          mode: 'insensitive' as const
        }
      }))
    })
  }
  
  const posts = await prisma.post.findMany({
    where: {
      published: true,
      NOT: notConditions.length > 0 ? { OR: notConditions } : undefined
    }
  })
  
  return posts
}

// Sophisticated user filtering
async function getRecommendedUsers(currentUserId: number) {
  const users = await prisma.user.findMany({
    where: {
      isActive: true,
      NOT: {
        OR: [
          { id: currentUserId }, // Exclude self
          { 
            followers: {
              some: {
                followerId: currentUserId
              }
            }
          }, // Exclude already following
          { 
            blockedBy: {
              some: {
                blockerId: currentUserId
              }
            }
          }, // Exclude blocked users
          { 
            blocking: {
              some: {
                blockedId: currentUserId
              }
            }
          }, // Exclude users who blocked current user
          { isPrivate: true }, // Exclude private profiles
          { 
            AND: [
              { createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } },
              { posts: { none: {} } }
            ]
          } // Exclude new users with no posts
        ]
      }
    }
  })
  
  return users
}
```

## Complex Nested Logic

### Multi-Level Logical Combinations
Building sophisticated query logic with multiple levels:

```typescript
// Complex business rules implementation
async function getEligiblePromotions(userId: number) {
  const currentDate = new Date()
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
  
  const promotions = await prisma.promotion.findMany({
    where: {
      AND: [
        { isActive: true },
        { startDate: { lte: currentDate } },
        { endDate: { gte: currentDate } },
        {
          OR: [
            // Global promotions
            { targetType: 'ALL' },
            // User-specific promotions
            {
              AND: [
                { targetType: 'USER' },
                {
                  targetUsers: {
                    some: { userId: userId }
                  }
                }
              ]
            },
            // Conditional promotions
            {
              AND: [
                { targetType: 'CONDITIONAL' },
                {
                  OR: [
                    // First-time buyer
                    {
                      conditions: {
                        some: {
                          type: 'FIRST_TIME_BUYER',
                          user: {
                            orders: { none: {} }
                          }
                        }
                      }
                    },
                    // Recent activity
                    {
                      conditions: {
                        some: {
                          type: 'RECENT_ACTIVITY',
                          user: {
                            lastLoginAt: { gte: thirtyDaysAgo }
                          }
                        }
                      }
                    },
                    // High-value customer
                    {
                      conditions: {
                        some: {
                          type: 'HIGH_VALUE',
                          user: {
                            orders: {
                              some: {
                                total: { gte: 500 }
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        // Exclude if user already used this promotion
        {
          NOT: {
            usedBy: {
              some: { userId: userId }
            }
          }
        }
      ]
    }
  })
  
  return promotions
}

// Advanced content moderation
async function getContentForReview() {
  const posts = await prisma.post.findMany({
    where: {
      AND: [
        { published: true },
        {
          OR: [
            // Posts with multiple reports
            {
              reports: {
                some: {
                  AND: [
                    { status: 'PENDING' },
                    { createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } }
                  ]
                }
              }
            },
            // Posts from new users with suspicious activity
            {
              AND: [
                {
                  author: {
                    createdAt: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
                  }
                },
                {
                  OR: [
                    {
                      author: {
                        posts: {
                          some: {
                            createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
                          }
                        }
                      }
                    },
                    {
                      content: {
                        OR: [
                          { contains: 'buy now', mode: 'insensitive' },
                          { contains: 'click here', mode: 'insensitive' },
                          { contains: 'limited time', mode: 'insensitive' }
                        ]
                      }
                    }
                  ]
                }
              ]
            },
            // Posts with unusual engagement patterns
            {
              AND: [
                {
                  likes: {
                    some: {
                      createdAt: { gte: new Date(Date.now() - 60 * 60 * 1000) } // Last hour
                    }
                  }
                },
                {
                  comments: { none: {} } // No comments but many likes
                },
                {
                  NOT: {
                    author: {
                      role: { in: ['ADMIN', 'MODERATOR', 'VERIFIED'] }
                    }
                  }
                }
              ]
            }
          ]
        },
        // Exclude already reviewed content
        {
          NOT: {
            reviews: {
              some: {
                status: { in: ['APPROVED', 'REJECTED'] },
                createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
              }
            }
          }
        }
      ]
    }
  })
  
  return posts
}

// Sophisticated user access control
async function getUserAccessibleResources(userId: number) {
  const resources = await prisma.resource.findMany({
    where: {
      AND: [
        { isActive: true },
        {
          OR: [
            // Public resources
            { visibility: 'PUBLIC' },
            // Owned resources
            { ownerId: userId },
            // Shared with user directly
            {
              sharedWith: {
                some: {
                  userId: userId,
                  expiresAt: { gt: new Date() }
                }
              }
            },
            // Shared through team membership
            {
              AND: [
                { visibility: 'TEAM' },
                {
                  owner: {
                    teamMembers: {
                      some: {
                        userId: userId,
                        status: 'ACTIVE'
                      }
                    }
                  }
                }
              ]
            },
            // Conditional access based on user properties
            {
              AND: [
                { visibility: 'CONDITIONAL' },
                {
                  OR: [
                    {
                      accessConditions: {
                        some: {
                          type: 'USER_ROLE',
                          user: {
                            role: { in: ['PREMIUM', 'ADMIN'] }
                          }
                        }
                      }
                    },
                    {
                      accessConditions: {
                        some: {
                          type: 'USER_LEVEL',
                          user: {
                            level: { gte: 5 }
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        // Exclude blocked resources
        {
          NOT: {
            OR: [
              {
                blockedUsers: {
                  some: { userId: userId }
                }
              },
              {
                owner: {
                  blockedBy: {
                    some: { blockerId: userId }
                  }
                }
              }
            ]
          }
        }
      ]
    }
  })
  
  return resources
}
```

### Dynamic Logical Query Building
Creating flexible logical expressions based on runtime conditions:

```typescript
// Dynamic AND/OR builder
interface QueryCondition {
  field: string
  operator: 'equals' | 'contains' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'notIn'
  value: any
}

interface LogicalGroup {
  operator: 'AND' | 'OR' | 'NOT'
  conditions: (QueryCondition | LogicalGroup)[]
}

class LogicalQueryBuilder {
  private conditions: (QueryCondition | LogicalGroup)[] = []
  
  and(...conditions: (QueryCondition | LogicalGroup)[]): this {
    this.conditions.push({
      operator: 'AND',
      conditions
    })
    return this
  }
  
  or(...conditions: (QueryCondition | LogicalGroup)[]): this {
    this.conditions.push({
      operator: 'OR',
      conditions
    })
    return this
  }
  
  not(condition: QueryCondition | LogicalGroup): this {
    this.conditions.push({
      operator: 'NOT',
      conditions: [condition]
    })
    return this
  }
  
  addCondition(condition: QueryCondition): this {
    this.conditions.push(condition)
    return this
  }
  
  private buildCondition(condition: QueryCondition): any {
    const { field, operator, value } = condition
    
    switch (operator) {
      case 'equals':
        return { [field]: value }
      case 'contains':
        return { [field]: { contains: value, mode: 'insensitive' } }
      case 'gt':
        return { [field]: { gt: value } }
      case 'gte':
        return { [field]: { gte: value } }
      case 'lt':
        return { [field]: { lt: value } }
      case 'lte':
        return { [field]: { lte: value } }
      case 'in':
        return { [field]: { in: value } }
      case 'notIn':
        return { [field]: { notIn: value } }
      default:
        throw new Error(`Unsupported operator: ${operator}`)
    }
  }
  
  private buildGroup(group: LogicalGroup): any {
    const builtConditions = group.conditions.map(condition => {
      if ('operator' in condition) {
        return this.buildGroup(condition)
      } else {
        return this.buildCondition(condition)
      }
    })
    
    switch (group.operator) {
      case 'AND':
        return { AND: builtConditions }
      case 'OR':
        return { OR: builtConditions }
      case 'NOT':
        return { NOT: builtConditions[0] }
      default:
        throw new Error(`Unsupported logical operator: ${group.operator}`)
    }
  }
  
  build(): any {
    if (this.conditions.length === 0) {
      return {}
    }
    
    if (this.conditions.length === 1) {
      const condition = this.conditions[0]
      if ('operator' in condition) {
        return this.buildGroup(condition)
      } else {
        return this.buildCondition(condition)
      }
    }
    
    return {
      AND: this.conditions.map(condition => {
        if ('operator' in condition) {
          return this.buildGroup(condition)
        } else {
          return this.buildCondition(condition)
        }
      })
    }
  }
  
  reset(): this {
    this.conditions = []
    return this
  }
}

// Usage example
async function complexUserSearch(criteria: {
  name?: string
  email?: string
  ageRange?: [number, number]
  roles?: string[]
  excludeRoles?: string[]
  isActive?: boolean
  hasProfilePicture?: boolean
  registeredAfter?: Date
  lastLoginBefore?: Date
}) {
  const builder = new LogicalQueryBuilder()
  
  // Add basic conditions
  if (criteria.name) {
    builder.addCondition({
      field: 'name',
      operator: 'contains',
      value: criteria.name
    })
  }
  
  if (criteria.email) {
    builder.addCondition({
      field: 'email',
      operator: 'contains',
      value: criteria.email
    })
  }
  
  if (criteria.isActive !== undefined) {
    builder.addCondition({
      field: 'isActive',
      operator: 'equals',
      value: criteria.isActive
    })
  }
  
  // Add complex logical groups
  if (criteria.ageRange) {
    builder.and({
      field: 'age',
      operator: 'gte',
      value: criteria.ageRange[0]
    }, {
      field: 'age',
      operator: 'lte',
      value: criteria.ageRange[1]
    })
  }
  
  if (criteria.roles && criteria.roles.length > 0) {
    builder.addCondition({
      field: 'role',
      operator: 'in',
      value: criteria.roles
    })
  }
  
  if (criteria.excludeRoles && criteria.excludeRoles.length > 0) {
    builder.not({
      field: 'role',
      operator: 'in',
      value: criteria.excludeRoles
    })
  }
  
  // Complex date logic
  if (criteria.registeredAfter || criteria.lastLoginBefore) {
    const dateConditions: QueryCondition[] = []
    
    if (criteria.registeredAfter) {
      dateConditions.push({
        field: 'createdAt',
        operator: 'gte',
        value: criteria.registeredAfter
      })
    }
    
    if (criteria.lastLoginBefore) {
      dateConditions.push({
        field: 'lastLoginAt',
        operator: 'lt',
        value: criteria.lastLoginBefore
      })
    }
    
    builder.and(...dateConditions)
  }
  
  const where = builder.build()
  
  const users = await prisma.user.findMany({
    where
  })
  
  return users
}

// Advanced search with multiple logical patterns
async function advancedProductSearch(searchCriteria: {
  query?: string
  categories?: number[]
  priceRange?: [number, number]
  rating?: number
  inStock?: boolean
  featured?: boolean
  onSale?: boolean
  newArrival?: boolean
  brand?: string
  excludeBrands?: string[]
}) {
  const builder = new LogicalQueryBuilder()
  
  // Always include active products
  builder.addCondition({
    field: 'isActive',
    operator: 'equals',
    value: true
  })
  
  // Text search across multiple fields
  if (searchCriteria.query) {
    builder.or(
      {
        field: 'name',
        operator: 'contains',
        value: searchCriteria.query
      },
      {
        field: 'description',
        operator: 'contains',
        value: searchCriteria.query
      },
      {
        field: 'tags',
        operator: 'contains',
        value: searchCriteria.query
      }
    )
  }
  
  // Category filtering
  if (searchCriteria.categories && searchCriteria.categories.length > 0) {
    builder.addCondition({
      field: 'categoryId',
      operator: 'in',
      value: searchCriteria.categories
    })
  }
  
  // Price range
  if (searchCriteria.priceRange) {
    builder.and(
      {
        field: 'price',
        operator: 'gte',
        value: searchCriteria.priceRange[0]
      },
      {
        field: 'price',
        operator: 'lte',
        value: searchCriteria.priceRange[1]
      }
    )
  }
  
  // Quality indicators (OR logic for flexibility)
  const qualityConditions: QueryCondition[] = []
  
  if (searchCriteria.rating) {
    qualityConditions.push({
      field: 'rating',
      operator: 'gte',
      value: searchCriteria.rating
    })
  }
  
  if (searchCriteria.featured) {
    qualityConditions.push({
      field: 'featured',
      operator: 'equals',
      value: true
    })
  }
  
  if (qualityConditions.length > 0) {
    builder.or(...qualityConditions)
  }
  
  // Stock and availability
  if (searchCriteria.inStock) {
    builder.addCondition({
      field: 'stock',
      operator: 'gt',
      value: 0
    })
  }
  
  // Brand filtering
  if (searchCriteria.brand) {
    builder.addCondition({
      field: 'brand',
      operator: 'equals',
      value: searchCriteria.brand
    })
  }
  
  if (searchCriteria.excludeBrands && searchCriteria.excludeBrands.length > 0) {
    builder.not({
      field: 'brand',
      operator: 'in',
      value: searchCriteria.excludeBrands
    })
  }
  
  const where = builder.build()
  
  const products = await prisma.product.findMany({
    where
  })
  
  return products
}
```

## Performance Optimization for Logical Queries

### Efficient Logical Operations
Optimizing complex logical queries for better performance:

```typescript
// Optimize logical query structure
async function getOptimizedComplexQuery() {
  // Place most selective conditions first in AND
  const users = await prisma.user.findMany({
    where: {
      AND: [
        { email: { endsWith: '@premium.com' } }, // Most selective first
        { isActive: true },                       // Index-friendly
        { role: { in: ['PREMIUM', 'VIP'] } },    // Limited set
        {
          OR: [
            { lastLoginAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } },
            { posts: { some: { published: true } } }
          ]
        }
      ]
    }
  })
  
  return users
}

// Minimize OR conditions for better performance
async function getOptimizedOrQuery(userType: 'active' | 'premium' | 'recent') {
  let where: any
  
  switch (userType) {
    case 'active':
      where = {
        isActive: true,
        lastLoginAt: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
      }
      break
    case 'premium':
      where = {
        role: { in: ['PREMIUM', 'VIP'] },
        isActive: true
      }
      break
    case 'recent':
      where = {
        createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
        emailVerified: true
      }
      break
    default:
      where = { isActive: true }
  }
  
  const users = await prisma.user.findMany({
    where
  })
  
  return users
}

// Use separate queries for complex OR conditions when beneficial
async function getComplexDataEfficiently() {
  // Instead of one complex OR query, use parallel queries
  const [
    urgentTasks,
    overdueTasks,
    highPriorityTasks
  ] = await Promise.all([
    prisma.task.findMany({
      where: {
        status: 'URGENT',
        assigneeId: { not: null }
      }
    }),
    prisma.task.findMany({
      where: {
        dueDate: { lt: new Date() },
        status: { not: 'COMPLETED' }
      }
    }),
    prisma.task.findMany({
      where: {
        priority: 'HIGH',
        createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
      }
    })
  ])
  
  // Combine and deduplicate results
  const allTasks = new Map()
  
  ;[...urgentTasks, ...overdueTasks, ...highPriorityTasks].forEach(task => {
    allTasks.set(task.id, task)
  })
  
  return Array.from(allTasks.values())
}

// Cache complex logical queries
const queryCache = new Map<string, { data: any; expires: number }>()

async function getCachedComplexQuery<T>(
  cacheKey: string,
  queryFn: () => Promise<T>,
  ttlMs: number = 5 * 60 * 1000 // 5 minutes
): Promise<T> {
  const cached = queryCache.get(cacheKey)
  
  if (cached && Date.now() < cached.expires) {
    return cached.data
  }
  
  const data = await queryFn()
  
  queryCache.set(cacheKey, {
    data,
    expires: Date.now() + ttlMs
  })
  
  return data
}

// Usage with caching
async function getCachedUserAnalytics(filters: any) {
  const cacheKey = `user_analytics_${JSON.stringify(filters)}`
  
  return getCachedComplexQuery(
    cacheKey,
    async () => {
      return prisma.user.findMany({
        where: {
          AND: [
            { isActive: true },
            {
              OR: [
                { role: { in: ['PREMIUM', 'VIP'] } },
                { 
                  AND: [
                    { posts: { some: { published: true } } },
                    { followers: { some: {} } }
                  ]
                }
              ]
            },
            {
              NOT: {
                OR: [
                  { isBanned: true },
                  { isDeleted: true },
                  { lastLoginAt: { lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) } }
                ]
              }
            }
          ]
        }
      })
    }
  )
}
```

## Exercise: Advanced Logical Query System

Build a comprehensive logical query system:

```typescript
// Your task: Create a production-ready logical query system

// Requirements:
// 1. Support all logical operators with proper precedence
// 2. Implement query optimization for performance
// 3. Add validation and error handling for logical expressions
// 4. Support dynamic query building from user interfaces
// 5. Include query explanation and analysis tools
// 6. Implement caching for complex logical queries
// 7. Add query performance monitoring and optimization suggestions
// 8. Support custom logical operators and functions

interface LogicalQuerySystem {
  // Define the comprehensive logical query interface
}

class AdvancedLogicalBuilder<T> {
  // Implement the advanced logical query system
  
  // Methods to implement:
  // - and(...conditions: LogicalCondition<T>[]): this
  // - or(...conditions: LogicalCondition<T>[]): this
  // - not(condition: LogicalCondition<T>): this
  // - when(condition: boolean, builder: (b: AdvancedLogicalBuilder<T>) => void): this
  // - optimize(): this
  // - validate(): ValidationResult
  // - explain(): QueryExplanation
  // - execute(model: string): Promise<T[]>
  // - cache(key: string, ttl?: number): this
  // - toSQL(): string
}

// Bonus features:
// - Visual query builder integration
// - Query performance benchmarking
// - Intelligent query optimization suggestions
// - A/B testing for query performance
// - Machine learning-based query optimization
// - Real-time query monitoring and alerting
```

## Key Takeaways

1. **AND Logic**: Use for mandatory conditions that must all be satisfied
2. **OR Logic**: Use for alternative conditions where any can satisfy requirements
3. **NOT Logic**: Use for exclusions and sophisticated filtering patterns
4. **Nested Logic**: Combine operators for complex business rules and sophisticated filtering
5. **Performance**: Structure queries to leverage indexes and minimize expensive operations
6. **Dynamic Building**: Create flexible systems that adapt logical expressions to runtime conditions
7. **Optimization**: Use caching, parallel queries, and smart structuring for scalable performance

## Next Steps

Excellent work! You've mastered the art of combining conditions with sophisticated logical expressions. In the next lesson, **4.3.3 String & Text Filtering**, we'll dive deep into advanced text searching, pattern matching, and content filtering techniques.

---

**Estimated Time:** 26 minutes
**Difficulty:** Intermediate to Advanced
**Prerequisites:** Understanding of boolean logic, query optimization principles, and complex conditional expressions
