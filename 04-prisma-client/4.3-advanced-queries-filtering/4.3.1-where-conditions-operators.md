# 4.3.1 Where Conditions & Operators

## Learning Objectives
By the end of this lesson, you will be able to:
- Master fundamental where conditions for precise data filtering
- Implement comparison operators (equals, not equals, greater than, less than) with confidence
- Design complex filtering logic using field-specific operators and conditions
- Build efficient query patterns for different data types and use cases
- Handle null values and undefined states in where conditions safely
- Optimize query performance through strategic filtering and indexing considerations
- Create reusable filtering patterns for consistent application behavior
- Implement advanced filtering strategies for scalable data retrieval systems

## Introduction

Think of Prisma's where conditions and operators as **a master detective's investigative toolkit** - like Sherlock Holmes equipped with a comprehensive set of analytical instruments and logical reasoning methods. Just as a skilled detective uses different investigative techniques to examine evidence (magnifying glass for fine details, chemical tests for substance analysis, logical deduction for pattern recognition), Prisma's where operators provide you with specialized tools to examine and filter your data with surgical precision. Each operator serves a specific investigative purpose, allowing you to uncover exactly the data you need from the vast database of information, whether you're looking for exact matches, ranges, patterns, or complex relationships between different pieces of evidence.

Understanding where conditions is fundamental to building efficient, precise, and maintainable database queries that scale with your application's growth.

## Basic Where Conditions

### Exact Match Filtering
The foundation of precise data retrieval:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Basic equality filtering
async function getUserByEmail(email: string) {
  const user = await prisma.user.findFirst({
    where: {
      email: email
    }
  })
  
  return user
}

// Multiple field filtering
async function getActiveUserByEmailAndRole(email: string, role: string) {
  const user = await prisma.user.findFirst({
    where: {
      email: email,
      role: role,
      isActive: true
    }
  })
  
  return user
}

// Shorthand syntax for exact matches
async function getUsersInRole(role: string) {
  const users = await prisma.user.findMany({
    where: {
      role, // Shorthand for role: role
      isActive: true
    }
  })
  
  return users
}

// Boolean field filtering
async function getActiveUsers() {
  const users = await prisma.user.findMany({
    where: {
      isActive: true,
      emailVerified: true,
      isDeleted: false
    }
  })
  
  return users
}

// Enum field filtering
async function getPostsByStatus(status: 'DRAFT' | 'PUBLISHED' | 'ARCHIVED') {
  const posts = await prisma.post.findMany({
    where: {
      status: status
    }
  })
  
  return posts
}
```

### Negation and Exclusion
Filtering out unwanted data:

```typescript
// Not equals filtering
async function getUsersExceptRole(excludeRole: string) {
  const users = await prisma.user.findMany({
    where: {
      role: {
        not: excludeRole
      }
    }
  })
  
  return users
}

// Multiple exclusions
async function getActiveUsersExceptAdmins() {
  const users = await prisma.user.findMany({
    where: {
      isActive: true,
      role: {
        not: 'ADMIN'
      },
      isDeleted: {
        not: true // or simply: false
      }
    }
  })
  
  return users
}

// Complex negation patterns
async function getPublishedPostsExceptByUser(excludeUserId: number) {
  const posts = await prisma.post.findMany({
    where: {
      published: true,
      authorId: {
        not: excludeUserId
      },
      status: {
        not: 'ARCHIVED'
      }
    }
  })
  
  return posts
}

// Negating multiple values
async function getUsersExceptRoles(excludeRoles: string[]) {
  const users = await prisma.user.findMany({
    where: {
      role: {
        notIn: excludeRoles
      }
    }
  })
  
  return users
}

// Boolean negation patterns
async function getUnverifiedUsers() {
  const users = await prisma.user.findMany({
    where: {
      OR: [
        { emailVerified: false },
        { emailVerified: null },
        { 
          emailVerified: {
            not: true
          }
        }
      ]
    }
  })
  
  return users
}
```

## Comparison Operators

### Numeric Comparisons
Powerful range and boundary filtering:

```typescript
// Greater than and less than
async function getUsersByAgeRange(minAge: number, maxAge: number) {
  const users = await prisma.user.findMany({
    where: {
      age: {
        gte: minAge, // Greater than or equal
        lte: maxAge  // Less than or equal
      }
    }
  })
  
  return users
}

// Strict comparisons
async function getExpensiveProducts(minPrice: number) {
  const products = await prisma.product.findMany({
    where: {
      price: {
        gt: minPrice // Greater than (strict)
      },
      stock: {
        gt: 0 // In stock
      }
    }
  })
  
  return products
}

// Range filtering with boundaries
async function getProductsInPriceRange(minPrice: number, maxPrice: number) {
  const products = await prisma.product.findMany({
    where: {
      price: {
        gte: minPrice,
        lt: maxPrice // Less than (strict)
      }
    }
  })
  
  return products
}

// Multiple numeric conditions
async function getQualifiedUsers(minAge: number, minScore: number) {
  const users = await prisma.user.findMany({
    where: {
      age: {
        gte: minAge
      },
      score: {
        gte: minScore
      },
      rating: {
        gt: 3.0
      }
    }
  })
  
  return users
}

// Complex numeric filtering
async function getHighPerformingProducts() {
  const products = await prisma.product.findMany({
    where: {
      rating: {
        gte: 4.0
      },
      reviewCount: {
        gte: 10
      },
      price: {
        lte: 1000
      },
      stock: {
        gt: 0
      }
    },
    orderBy: {
      rating: 'desc'
    }
  })
  
  return products
}
```

### Date and DateTime Comparisons
Time-based filtering for temporal data:

```typescript
// Date range filtering
async function getRecentPosts(days: number = 7) {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - days)
  
  const posts = await prisma.post.findMany({
    where: {
      createdAt: {
        gte: cutoffDate
      },
      published: true
    }
  })
  
  return posts
}

// Date boundary filtering
async function getPostsInDateRange(startDate: Date, endDate: Date) {
  const posts = await prisma.post.findMany({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate
      }
    }
  })
  
  return posts
}

// Time-based user analysis
async function getNewUsersThisMonth() {
  const startOfMonth = new Date()
  startOfMonth.setDate(1)
  startOfMonth.setHours(0, 0, 0, 0)
  
  const users = await prisma.user.findMany({
    where: {
      createdAt: {
        gte: startOfMonth
      }
    }
  })
  
  return users
}

// Complex temporal filtering
async function getActiveUsersInPeriod(startDate: Date, endDate: Date) {
  const users = await prisma.user.findMany({
    where: {
      createdAt: {
        lt: endDate
      },
      lastLoginAt: {
        gte: startDate
      },
      isActive: true
    }
  })
  
  return users
}

// Updated content filtering
async function getRecentlyUpdatedPosts(hours: number = 24) {
  const cutoffDate = new Date(Date.now() - hours * 60 * 60 * 1000)
  
  const posts = await prisma.post.findMany({
    where: {
      updatedAt: {
        gte: cutoffDate
      },
      updatedAt: {
        not: {
          equals: undefined // Ensure updatedAt exists
        }
      }
    }
  })
  
  return posts
}

// Scheduled content
async function getScheduledPosts() {
  const now = new Date()
  
  const posts = await prisma.post.findMany({
    where: {
      publishAt: {
        gt: now
      },
      status: 'SCHEDULED'
    },
    orderBy: {
      publishAt: 'asc'
    }
  })
  
  return posts
}
```

## Field-Specific Operators

### String Operators
Advanced text matching and searching:

```typescript
// String pattern matching
async function searchUsersByName(query: string) {
  const users = await prisma.user.findMany({
    where: {
      name: {
        contains: query,
        mode: 'insensitive' // Case-insensitive search
      }
    }
  })
  
  return users
}

// String prefix and suffix matching
async function getUsersByEmailDomain(domain: string) {
  const users = await prisma.user.findMany({
    where: {
      email: {
        endsWith: `@${domain}`
      }
    }
  })
  
  return users
}

// String starts with filtering
async function getPostsByTitlePrefix(prefix: string) {
  const posts = await prisma.post.findMany({
    where: {
      title: {
        startsWith: prefix,
        mode: 'insensitive'
      }
    }
  })
  
  return posts
}

// Multiple string conditions
async function searchContent(searchTerm: string) {
  const posts = await prisma.post.findMany({
    where: {
      OR: [
        {
          title: {
            contains: searchTerm,
            mode: 'insensitive'
          }
        },
        {
          content: {
            contains: searchTerm,
            mode: 'insensitive'
          }
        },
        {
          excerpt: {
            contains: searchTerm,
            mode: 'insensitive'
          }
        }
      ]
    }
  })
  
  return posts
}

// String length and format filtering
async function getUsersWithShortNames(maxLength: number = 3) {
  // Note: This would require raw SQL for string length
  // Showing conceptual approach with available operators
  const users = await prisma.user.findMany({
    where: {
      name: {
        not: {
          equals: ''
        }
      }
    }
  })
  
  // Filter in application layer for string length
  return users.filter(user => user.name.length <= maxLength)
}

// Advanced string pattern matching
async function getProductsByCode(pattern: string) {
  const products = await prisma.product.findMany({
    where: {
      code: {
        startsWith: pattern.toUpperCase()
      },
      OR: [
        {
          category: {
            contains: 'electronics',
            mode: 'insensitive'
          }
        },
        {
          tags: {
            some: {
              name: {
                contains: pattern,
                mode: 'insensitive'
              }
            }
          }
        }
      ]
    }
  })
  
  return products
}
```

### Array and List Operators
Working with collections and multiple values:

```typescript
// In array filtering
async function getUsersByRoles(roles: string[]) {
  const users = await prisma.user.findMany({
    where: {
      role: {
        in: roles
      }
    }
  })
  
  return users
}

// Not in array filtering
async function getUsersExceptRoles(excludeRoles: string[]) {
  const users = await prisma.user.findMany({
    where: {
      role: {
        notIn: excludeRoles
      }
    }
  })
  
  return users
}

// ID-based filtering
async function getPostsByIds(postIds: number[]) {
  const posts = await prisma.post.findMany({
    where: {
      id: {
        in: postIds
      }
    }
  })
  
  return posts
}

// Status-based batch filtering
async function getOrdersByStatuses(statuses: string[]) {
  const orders = await prisma.order.findMany({
    where: {
      status: {
        in: statuses
      }
    }
  })
  
  return orders
}

// Complex array filtering with conditions
async function getProductsByCategories(categoryIds: number[], minPrice?: number) {
  const where: any = {
    categoryId: {
      in: categoryIds
    }
  }
  
  if (minPrice !== undefined) {
    where.price = {
      gte: minPrice
    }
  }
  
  const products = await prisma.product.findMany({
    where
  })
  
  return products
}

// Array field operations (for JSON arrays)
async function getUsersByTags(requiredTags: string[]) {
  const users = await prisma.user.findMany({
    where: {
      tags: {
        hasEvery: requiredTags // PostgreSQL array operator
      }
    }
  })
  
  return users
}

// Has some operation
async function getUsersWithAnyTag(tags: string[]) {
  const users = await prisma.user.findMany({
    where: {
      tags: {
        hasSome: tags
      }
    }
  })
  
  return users
}
```

## Null and Undefined Handling

### Safe Null Filtering
Robust handling of missing data:

```typescript
// Filtering for null values
async function getUsersWithoutProfilePicture() {
  const users = await prisma.user.findMany({
    where: {
      profilePictureUrl: null
    }
  })
  
  return users
}

// Filtering for non-null values
async function getUsersWithProfilePicture() {
  const users = await prisma.user.findMany({
    where: {
      profilePictureUrl: {
        not: null
      }
    }
  })
  
  return users
}

// Complex null handling
async function getIncompleteUserProfiles() {
  const users = await prisma.user.findMany({
    where: {
      OR: [
        { bio: null },
        { bio: '' },
        { profilePictureUrl: null },
        { birthDate: null }
      ]
    }
  })
  
  return users
}

// Conditional null filtering
async function getUsersWithOptionalData(includeIncomplete: boolean = false) {
  const baseWhere = {
    isActive: true
  }
  
  if (!includeIncomplete) {
    return prisma.user.findMany({
      where: {
        ...baseWhere,
        bio: {
          not: null
        },
        profilePictureUrl: {
          not: null
        }
      }
    })
  }
  
  return prisma.user.findMany({
    where: baseWhere
  })
}

// Safe optional field filtering
async function getPostsWithOptionalFields(
  categoryId?: number,
  authorId?: number,
  published?: boolean
) {
  const where: any = {}
  
  if (categoryId !== undefined) {
    where.categoryId = categoryId
  }
  
  if (authorId !== undefined) {
    where.authorId = authorId
  }
  
  if (published !== undefined) {
    where.published = published
  }
  
  const posts = await prisma.post.findMany({
    where
  })
  
  return posts
}

// Null-safe date filtering
async function getPostsWithPublishDate(
  startDate?: Date,
  endDate?: Date,
  includeUnpublished: boolean = false
) {
  const where: any = {}
  
  if (!includeUnpublished) {
    where.publishedAt = {
      not: null
    }
  }
  
  if (startDate || endDate) {
    where.publishedAt = {
      ...where.publishedAt,
      ...(startDate && { gte: startDate }),
      ...(endDate && { lte: endDate })
    }
  }
  
  const posts = await prisma.post.findMany({
    where
  })
  
  return posts
}
```

## Dynamic Query Building

### Flexible Query Construction
Building queries based on runtime conditions:

```typescript
// Dynamic filter builder
interface UserFilters {
  role?: string
  isActive?: boolean
  ageMin?: number
  ageMax?: number
  emailDomain?: string
  createdAfter?: Date
  createdBefore?: Date
}

async function getUsersWithFilters(filters: UserFilters) {
  const where: any = {}
  
  // Simple equality filters
  if (filters.role !== undefined) {
    where.role = filters.role
  }
  
  if (filters.isActive !== undefined) {
    where.isActive = filters.isActive
  }
  
  // Range filters
  if (filters.ageMin !== undefined || filters.ageMax !== undefined) {
    where.age = {}
    if (filters.ageMin !== undefined) {
      where.age.gte = filters.ageMin
    }
    if (filters.ageMax !== undefined) {
      where.age.lte = filters.ageMax
    }
  }
  
  // String pattern filters
  if (filters.emailDomain) {
    where.email = {
      endsWith: `@${filters.emailDomain}`
    }
  }
  
  // Date range filters
  if (filters.createdAfter || filters.createdBefore) {
    where.createdAt = {}
    if (filters.createdAfter) {
      where.createdAt.gte = filters.createdAfter
    }
    if (filters.createdBefore) {
      where.createdAt.lte = filters.createdBefore
    }
  }
  
  const users = await prisma.user.findMany({
    where
  })
  
  return users
}

// Advanced dynamic query builder
class QueryBuilder<T> {
  private whereConditions: any = {}
  
  equals(field: keyof T, value: any): this {
    this.whereConditions[field] = value
    return this
  }
  
  not(field: keyof T, value: any): this {
    this.whereConditions[field] = { not: value }
    return this
  }
  
  in(field: keyof T, values: any[]): this {
    this.whereConditions[field] = { in: values }
    return this
  }
  
  range(field: keyof T, min?: any, max?: any): this {
    const condition: any = {}
    if (min !== undefined) condition.gte = min
    if (max !== undefined) condition.lte = max
    
    if (Object.keys(condition).length > 0) {
      this.whereConditions[field] = condition
    }
    
    return this
  }
  
  contains(field: keyof T, value: string, caseInsensitive = true): this {
    this.whereConditions[field] = {
      contains: value,
      mode: caseInsensitive ? 'insensitive' : 'default'
    }
    return this
  }
  
  startsWith(field: keyof T, value: string, caseInsensitive = true): this {
    this.whereConditions[field] = {
      startsWith: value,
      mode: caseInsensitive ? 'insensitive' : 'default'
    }
    return this
  }
  
  endsWith(field: keyof T, value: string, caseInsensitive = true): this {
    this.whereConditions[field] = {
      endsWith: value,
      mode: caseInsensitive ? 'insensitive' : 'default'
    }
    return this
  }
  
  isNull(field: keyof T): this {
    this.whereConditions[field] = null
    return this
  }
  
  isNotNull(field: keyof T): this {
    this.whereConditions[field] = { not: null }
    return this
  }
  
  build() {
    return this.whereConditions
  }
  
  reset(): this {
    this.whereConditions = {}
    return this
  }
}

// Usage example
async function searchUsers(criteria: {
  name?: string
  roles?: string[]
  ageRange?: [number, number]
  active?: boolean
  emailDomain?: string
}) {
  const queryBuilder = new QueryBuilder<any>()
  
  if (criteria.name) {
    queryBuilder.contains('name', criteria.name)
  }
  
  if (criteria.roles && criteria.roles.length > 0) {
    queryBuilder.in('role', criteria.roles)
  }
  
  if (criteria.ageRange) {
    queryBuilder.range('age', criteria.ageRange[0], criteria.ageRange[1])
  }
  
  if (criteria.active !== undefined) {
    queryBuilder.equals('isActive', criteria.active)
  }
  
  if (criteria.emailDomain) {
    queryBuilder.endsWith('email', `@${criteria.emailDomain}`)
  }
  
  const where = queryBuilder.build()
  
  const users = await prisma.user.findMany({
    where
  })
  
  return users
}

// Conditional query building
async function getPostsWithConditionalFilters(
  authorId?: number,
  published?: boolean,
  searchTerm?: string,
  categoryIds?: number[],
  dateRange?: { start: Date; end: Date }
) {
  const conditions: any[] = []
  
  // Always include non-deleted posts
  conditions.push({ isDeleted: false })
  
  if (authorId !== undefined) {
    conditions.push({ authorId })
  }
  
  if (published !== undefined) {
    conditions.push({ published })
  }
  
  if (searchTerm) {
    conditions.push({
      OR: [
        { title: { contains: searchTerm, mode: 'insensitive' } },
        { content: { contains: searchTerm, mode: 'insensitive' } }
      ]
    })
  }
  
  if (categoryIds && categoryIds.length > 0) {
    conditions.push({ categoryId: { in: categoryIds } })
  }
  
  if (dateRange) {
    conditions.push({
      createdAt: {
        gte: dateRange.start,
        lte: dateRange.end
      }
    })
  }
  
  const posts = await prisma.post.findMany({
    where: {
      AND: conditions
    }
  })
  
  return posts
}
```

## Performance Optimization

### Efficient Where Conditions
Optimizing queries for speed and scalability:

```typescript
// Index-friendly filtering
async function getOptimizedUserQuery(email: string) {
  // Assumes email has a unique index
  const user = await prisma.user.findUnique({
    where: {
      email // Uses unique index for O(log n) lookup
    }
  })
  
  return user
}

// Compound index optimization
async function getPostsByAuthorAndStatus(authorId: number, status: string) {
  // Assumes compound index on (authorId, status)
  const posts = await prisma.post.findMany({
    where: {
      authorId, // First column in compound index
      status    // Second column in compound index
    }
  })
  
  return posts
}

// Selective filtering for large datasets
async function getLargeDatasetWithPagination(
  page: number = 1,
  limit: number = 20,
  filters: any = {}
) {
  const skip = (page - 1) * limit
  
  const [items, total] = await Promise.all([
    prisma.post.findMany({
      where: {
        published: true, // Index-friendly filter first
        ...filters
      },
      skip,
      take: limit,
      orderBy: {
        createdAt: 'desc' // Use indexed column for ordering
      }
    }),
    prisma.post.count({
      where: {
        published: true,
        ...filters
      }
    })
  ])
  
  return {
    items,
    pagination: {
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    }
  }
}

// Optimized date range queries
async function getOptimizedDateRangeQuery(startDate: Date, endDate: Date) {
  // Use indexed timestamp columns
  const posts = await prisma.post.findMany({
    where: {
      createdAt: {
        gte: startDate,
        lt: endDate  // Use 'lt' instead of 'lte' when possible
      },
      published: true // Additional indexed filter
    },
    orderBy: {
      createdAt: 'desc' // Order by indexed column
    }
  })
  
  return posts
}

// Avoiding expensive operations
async function getEfficientTextSearch(searchTerm: string) {
  // For full-text search, consider using database-specific features
  // This is a simplified approach
  const posts = await prisma.post.findMany({
    where: {
      published: true, // Index filter first
      title: {
        contains: searchTerm,
        mode: 'insensitive'
      }
    }
  })
  
  return posts
}
```

## Exercise: Advanced Filtering System

Build a comprehensive filtering system:

```typescript
// Your task: Create a production-ready advanced filtering system

// Requirements:
// 1. Support all comparison operators and field types
// 2. Implement dynamic query building with type safety
// 3. Add performance optimization and caching
// 4. Support complex nested filtering conditions
// 5. Include validation and error handling
// 6. Implement filter presets and saved filters
// 7. Add query execution time monitoring
// 8. Support custom operator extensions

interface FilterSystem {
  // Define the comprehensive filtering interface
}

class AdvancedFilterBuilder<T> {
  // Implement the advanced filtering system
  
  // Methods to implement:
  // - addCondition(field: keyof T, operator: Operator, value: any)
  // - addDateRange(field: keyof T, start?: Date, end?: Date)
  // - addTextSearch(fields: (keyof T)[], searchTerm: string)
  // - addCustomCondition(condition: any)
  // - combineWithAnd(...builders: AdvancedFilterBuilder<T>[])
  // - combineWithOr(...builders: AdvancedFilterBuilder<T>[])
  // - optimize()
  // - validate()
  // - execute(model: string)
  // - explain() // Query execution plan
}

// Bonus features:
// - Filter builder UI component integration
// - SQL query generation and analysis
// - Performance benchmarking and optimization suggestions
// - Filter result caching with intelligent invalidation
// - Advanced text search with stemming and fuzzy matching
```

## Key Takeaways

1. **Exact Matching**: Use simple equality for precise filtering with indexed fields
2. **Comparison Operators**: Leverage gt, gte, lt, lte for range and boundary filtering
3. **String Operations**: Use contains, startsWith, endsWith for flexible text searching
4. **Array Operations**: Use in, notIn for efficient multi-value filtering
5. **Null Handling**: Always consider null values and undefined states in filtering logic
6. **Dynamic Queries**: Build flexible query systems that adapt to runtime conditions
7. **Performance**: Structure queries to leverage database indexes and optimize execution

## Next Steps

Great work! You've mastered the fundamental building blocks of advanced querying. In the next lesson, **4.3.2 Logical Operators (AND, OR, NOT)**, we'll explore how to combine these conditions into sophisticated logical expressions for complex filtering scenarios.

---

**Estimated Time:** 24 minutes
**Difficulty:** Intermediate
**Prerequisites:** Understanding of basic CRUD operations, database indexes, and TypeScript type system
