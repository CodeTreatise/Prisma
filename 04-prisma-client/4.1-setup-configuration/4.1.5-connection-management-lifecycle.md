# 4.1.5 Connection Management & Lifecycle

## Learning Objectives
By the end of this lesson, you will be able to:
- Understand Prisma Client connection lifecycle and pooling mechanisms
- Implement proper connection management strategies for different environments
- Handle connection errors, timeouts, and recovery scenarios
- Configure connection pooling for optimal performance and resource usage
- Manage graceful shutdown and cleanup procedures
- Monitor connection health and performance metrics
- Implement connection retry and circuit breaker patterns
- Optimize connections for serverless and long-running applications

## Introduction

Think of Prisma Client connection management as **operating the electrical grid for a smart city** - like managing the power distribution network that must reliably deliver electricity to millions of devices while efficiently balancing load, preventing outages, and scaling capacity based on demand. Just as a smart grid automatically manages power distribution, reconnects after failures, and optimizes energy flow, your application needs sophisticated connection management to handle database access efficiently, recover from network issues, and scale seamlessly across different deployment scenarios.

Proper connection management ensures your application maintains reliable, performant database access under all conditions.

## Understanding Connection Lifecycle

### Connection States and Transitions
Understanding how Prisma Client manages connections:

```typescript
// Connection states visualization and management
import { PrismaClient } from '@prisma/client'

// Connection lifecycle events
interface ConnectionEvent {
  type: 'connect' | 'disconnect' | 'error' | 'reconnect'
  timestamp: Date
  metadata?: any
}

class ConnectionManager {
  private client: PrismaClient
  private connectionEvents: ConnectionEvent[] = []
  private isConnected = false
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5

  constructor() {
    this.client = new PrismaClient({
      log: [
        { emit: 'event', level: 'query' },
        { emit: 'event', level: 'info' },
        { emit: 'event', level: 'warn' },
        { emit: 'event', level: 'error' }
      ],
      datasources: {
        db: {
          url: process.env.DATABASE_URL
        }
      }
    })

    this.setupEventListeners()
  }

  private setupEventListeners(): void {
    // Listen to connection events
    this.client.$on('beforeExit', async () => {
      this.logEvent('disconnect', { reason: 'beforeExit' })
      await this.gracefulShutdown()
    })

    // Monitor query events for connection health
    this.client.$on('query', (event) => {
      this.isConnected = true
      this.reconnectAttempts = 0
    })

    // Handle errors
    this.client.$on('error', (event) => {
      this.logEvent('error', { error: event })
      this.handleConnectionError(event)
    })
  }

  private logEvent(type: ConnectionEvent['type'], metadata?: any): void {
    this.connectionEvents.push({
      type,
      timestamp: new Date(),
      metadata
    })

    // Keep only last 100 events
    if (this.connectionEvents.length > 100) {
      this.connectionEvents.shift()
    }
  }

  async connect(): Promise<void> {
    try {
      // Test connection
      await this.client.$queryRaw`SELECT 1`
      this.isConnected = true
      this.logEvent('connect')
      console.log('‚úÖ Database connection established')
    } catch (error) {
      this.isConnected = false
      this.logEvent('error', { error })
      throw new Error(`Failed to connect to database: ${error}`)
    }
  }

  async disconnect(): Promise<void> {
    try {
      await this.client.$disconnect()
      this.isConnected = false
      this.logEvent('disconnect')
      console.log('‚úÖ Database connection closed')
    } catch (error) {
      this.logEvent('error', { error })
      throw new Error(`Failed to disconnect from database: ${error}`)
    }
  }

  getConnectionStatus(): {
    isConnected: boolean
    events: ConnectionEvent[]
    reconnectAttempts: number
  } {
    return {
      isConnected: this.isConnected,
      events: [...this.connectionEvents],
      reconnectAttempts: this.reconnectAttempts
    }
  }
}
```

### Connection Pooling Configuration
Optimizing connection pools for different scenarios:

```typescript
// Advanced connection pool configuration
interface PoolConfig {
  minConnections: number
  maxConnections: number
  acquireTimeoutMillis: number
  idleTimeoutMillis: number
  createTimeoutMillis: number
  destroyTimeoutMillis: number
  reapIntervalMillis: number
}

class AdvancedConnectionManager {
  private static instance: AdvancedConnectionManager
  private client: PrismaClient | null = null
  private poolConfig: PoolConfig

  constructor(poolConfig: PoolConfig) {
    this.poolConfig = poolConfig
  }

  static getInstance(config?: PoolConfig): AdvancedConnectionManager {
    if (!this.instance) {
      const defaultConfig: PoolConfig = {
        minConnections: 2,
        maxConnections: 10,
        acquireTimeoutMillis: 30000,
        idleTimeoutMillis: 600000, // 10 minutes
        createTimeoutMillis: 30000,
        destroyTimeoutMillis: 5000,
        reapIntervalMillis: 1000
      }
      this.instance = new AdvancedConnectionManager(config || defaultConfig)
    }
    return this.instance
  }

  createClient(): PrismaClient {
    if (this.client) {
      return this.client
    }

    // Build connection URL with pool parameters
    const connectionUrl = this.buildPooledConnectionUrl()

    this.client = new PrismaClient({
      datasources: {
        db: { url: connectionUrl }
      },
      log: [
        { emit: 'event', level: 'warn' },
        { emit: 'event', level: 'error' }
      ],
      errorFormat: 'minimal'
    })

    // Setup connection monitoring
    this.setupConnectionMonitoring()

    return this.client
  }

  private buildPooledConnectionUrl(): string {
    const baseUrl = process.env.DATABASE_URL
    if (!baseUrl) throw new Error('DATABASE_URL is required')

    const url = new URL(baseUrl)
    const { 
      minConnections, 
      maxConnections, 
      acquireTimeoutMillis,
      idleTimeoutMillis 
    } = this.poolConfig

    // PostgreSQL-specific pool parameters
    if (url.protocol === 'postgresql:') {
      url.searchParams.set('connection_limit', maxConnections.toString())
      url.searchParams.set('connect_timeout', Math.floor(acquireTimeoutMillis / 1000).toString())
      url.searchParams.set('pool_timeout', Math.floor(acquireTimeoutMillis / 1000).toString())
      url.searchParams.set('statement_timeout', '30000')
    }

    // MySQL-specific pool parameters
    if (url.protocol === 'mysql:') {
      url.searchParams.set('connectionLimit', maxConnections.toString())
      url.searchParams.set('acquireTimeout', acquireTimeoutMillis.toString())
      url.searchParams.set('timeout', '60000')
      url.searchParams.set('reconnect', 'true')
    }

    return url.toString()
  }

  private setupConnectionMonitoring(): void {
    if (!this.client) return

    const client = this.client

    // Monitor connection pool metrics
    setInterval(async () => {
      try {
        const startTime = Date.now()
        await client.$queryRaw`SELECT 1`
        const responseTime = Date.now() - startTime

        if (responseTime > 1000) {
          console.warn(`üêå Slow database response: ${responseTime}ms`)
        }

        // Log pool metrics if available
        console.log(`üìä Connection health check: ${responseTime}ms`)
      } catch (error) {
        console.error('‚ùå Connection health check failed:', error)
        await this.handleConnectionFailure()
      }
    }, 30000) // Every 30 seconds
  }

  private async handleConnectionFailure(): Promise<void> {
    console.log('üîÑ Attempting to recover connection...')
    
    try {
      if (this.client) {
        await this.client.$disconnect()
      }
      
      // Wait before reconnecting
      await new Promise(resolve => setTimeout(resolve, 5000))
      
      // Recreate client
      this.client = null
      this.createClient()
      
      console.log('‚úÖ Connection recovered successfully')
    } catch (error) {
      console.error('‚ùå Connection recovery failed:', error)
    }
  }

  async gracefulShutdown(): Promise<void> {
    console.log('üõë Initiating graceful shutdown...')
    
    try {
      if (this.client) {
        await this.client.$disconnect()
        this.client = null
      }
      console.log('‚úÖ Graceful shutdown completed')
    } catch (error) {
      console.error('‚ùå Error during shutdown:', error)
    }
  }
}

// Environment-specific configurations
export const createConnectionManager = () => {
  const environment = process.env.NODE_ENV || 'development'
  
  const configs = {
    development: {
      minConnections: 1,
      maxConnections: 5,
      acquireTimeoutMillis: 60000,
      idleTimeoutMillis: 300000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      reapIntervalMillis: 1000
    },
    production: {
      minConnections: 5,
      maxConnections: 25,
      acquireTimeoutMillis: 30000,
      idleTimeoutMillis: 600000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      reapIntervalMillis: 1000
    },
    test: {
      minConnections: 1,
      maxConnections: 3,
      acquireTimeoutMillis: 10000,
      idleTimeoutMillis: 60000,
      createTimeoutMillis: 10000,
      destroyTimeoutMillis: 2000,
      reapIntervalMillis: 500
    }
  }

  return AdvancedConnectionManager.getInstance(configs[environment as keyof typeof configs])
}
```

## Error Handling and Recovery

### Connection Error Patterns
Robust error handling for connection issues:

```typescript
// Comprehensive error handling for connection management
enum ConnectionError {
  TIMEOUT = 'CONNECTION_TIMEOUT',
  REFUSED = 'CONNECTION_REFUSED',
  LOST = 'CONNECTION_LOST',
  AUTH_FAILED = 'AUTH_FAILED',
  POOL_EXHAUSTED = 'POOL_EXHAUSTED',
  NETWORK_ERROR = 'NETWORK_ERROR'
}

interface RetryConfig {
  maxAttempts: number
  baseDelayMs: number
  maxDelayMs: number
  backoffFactor: number
  jitterMs: number
}

class ResilientConnectionManager {
  private client: PrismaClient
  private retryConfig: RetryConfig
  private circuitBreaker: CircuitBreaker

  constructor(retryConfig: RetryConfig) {
    this.retryConfig = retryConfig
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: 5,
      recoveryTimeout: 30000,
      monitoringPeriod: 60000
    })
    
    this.client = this.createClient()
  }

  private createClient(): PrismaClient {
    return new PrismaClient({
      datasources: {
        db: { url: process.env.DATABASE_URL }
      },
      log: [
        { emit: 'event', level: 'error' },
        { emit: 'event', level: 'warn' }
      ],
      errorFormat: 'minimal'
    })
  }

  async executeWithRetry<T>(
    operation: (client: PrismaClient) => Promise<T>,
    context = 'database_operation'
  ): Promise<T> {
    return this.circuitBreaker.execute(async () => {
      let lastError: Error
      
      for (let attempt = 1; attempt <= this.retryConfig.maxAttempts; attempt++) {
        try {
          return await operation(this.client)
        } catch (error: any) {
          lastError = error
          
          const errorType = this.classifyError(error)
          const shouldRetry = this.shouldRetryError(errorType, attempt)
          
          console.warn(
            `Attempt ${attempt}/${this.retryConfig.maxAttempts} failed`,
            { error: error.message, type: errorType, context }
          )

          if (!shouldRetry) {
            throw error
          }

          if (this.isConnectionError(errorType)) {
            await this.handleConnectionRecovery()
          }

          await this.delay(this.calculateRetryDelay(attempt))
        }
      }

      throw lastError!
    })
  }

  private classifyError(error: any): ConnectionError {
    const message = error.message?.toLowerCase() || ''
    const code = error.code

    if (message.includes('timeout') || code === 'P1008') {
      return ConnectionError.TIMEOUT
    }
    
    if (message.includes('connection refused') || code === 'ECONNREFUSED') {
      return ConnectionError.REFUSED
    }
    
    if (message.includes('connection lost') || code === 'ECONNRESET') {
      return ConnectionError.LOST
    }
    
    if (message.includes('authentication') || code === 'P1001') {
      return ConnectionError.AUTH_FAILED
    }
    
    if (message.includes('pool') || code === 'P1017') {
      return ConnectionError.POOL_EXHAUSTED
    }

    return ConnectionError.NETWORK_ERROR
  }

  private shouldRetryError(errorType: ConnectionError, attempt: number): boolean {
    // Don't retry auth failures
    if (errorType === ConnectionError.AUTH_FAILED) {
      return false
    }

    // Don't exceed max attempts
    if (attempt >= this.retryConfig.maxAttempts) {
      return false
    }

    // Retry most connection errors
    return [
      ConnectionError.TIMEOUT,
      ConnectionError.REFUSED,
      ConnectionError.LOST,
      ConnectionError.POOL_EXHAUSTED,
      ConnectionError.NETWORK_ERROR
    ].includes(errorType)
  }

  private isConnectionError(errorType: ConnectionError): boolean {
    return [
      ConnectionError.REFUSED,
      ConnectionError.LOST,
      ConnectionError.NETWORK_ERROR
    ].includes(errorType)
  }

  private async handleConnectionRecovery(): Promise<void> {
    try {
      console.log('üîÑ Attempting connection recovery...')
      
      // Disconnect current client
      await this.client.$disconnect()
      
      // Wait before reconnecting
      await this.delay(2000)
      
      // Create new client instance
      this.client = this.createClient()
      
      // Test new connection
      await this.client.$queryRaw`SELECT 1`
      
      console.log('‚úÖ Connection recovery successful')
    } catch (error) {
      console.error('‚ùå Connection recovery failed:', error)
      throw error
    }
  }

  private calculateRetryDelay(attempt: number): number {
    const { baseDelayMs, maxDelayMs, backoffFactor, jitterMs } = this.retryConfig
    
    // Exponential backoff with jitter
    const exponentialDelay = baseDelayMs * Math.pow(backoffFactor, attempt - 1)
    const cappedDelay = Math.min(exponentialDelay, maxDelayMs)
    const jitter = Math.random() * jitterMs
    
    return cappedDelay + jitter
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  async healthCheck(): Promise<{
    isHealthy: boolean
    latency: number
    circuitState: string
  }> {
    const startTime = Date.now()
    
    try {
      await this.client.$queryRaw`SELECT 1`
      const latency = Date.now() - startTime
      
      return {
        isHealthy: true,
        latency,
        circuitState: this.circuitBreaker.getState()
      }
    } catch (error) {
      return {
        isHealthy: false,
        latency: Date.now() - startTime,
        circuitState: this.circuitBreaker.getState()
      }
    }
  }
}

// Circuit breaker implementation
class CircuitBreaker {
  private failureCount = 0
  private lastFailureTime = 0
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED'
  
  constructor(private config: {
    failureThreshold: number
    recoveryTimeout: number
    monitoringPeriod: number
  }) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.config.recoveryTimeout) {
        this.state = 'HALF_OPEN'
      } else {
        throw new Error('Circuit breaker is OPEN')
      }
    }

    try {
      const result = await operation()
      this.onSuccess()
      return result
    } catch (error) {
      this.onFailure()
      throw error
    }
  }

  private onSuccess(): void {
    this.failureCount = 0
    this.state = 'CLOSED'
  }

  private onFailure(): void {
    this.failureCount++
    this.lastFailureTime = Date.now()
    
    if (this.failureCount >= this.config.failureThreshold) {
      this.state = 'OPEN'
    }
  }

  getState(): string {
    return this.state
  }
}

// Usage example
const connectionManager = new ResilientConnectionManager({
  maxAttempts: 3,
  baseDelayMs: 1000,
  maxDelayMs: 30000,
  backoffFactor: 2,
  jitterMs: 1000
})

// Execute operations with automatic retry
const users = await connectionManager.executeWithRetry(
  async (prisma) => await prisma.user.findMany()
)
```

## Serverless Connection Optimization

### Serverless-Specific Patterns
Optimizing connections for serverless environments:

```typescript
// Serverless connection management optimizations
class ServerlessConnectionManager {
  private static client: PrismaClient | null = null
  private static connectionPromise: Promise<PrismaClient> | null = null
  private static lastActivity = Date.now()

  static async getClient(): Promise<PrismaClient> {
    // Return existing client if available and recent
    if (this.client && Date.now() - this.lastActivity < 300000) { // 5 minutes
      this.lastActivity = Date.now()
      return this.client
    }

    // Return existing connection promise if in progress
    if (this.connectionPromise) {
      return this.connectionPromise
    }

    // Create new connection
    this.connectionPromise = this.createConnection()
    
    try {
      this.client = await this.connectionPromise
      this.lastActivity = Date.now()
      return this.client
    } finally {
      this.connectionPromise = null
    }
  }

  private static async createConnection(): Promise<PrismaClient> {
    // Clean up old connection if exists
    if (this.client) {
      try {
        await this.client.$disconnect()
      } catch (error) {
        console.warn('Error disconnecting old client:', error)
      }
      this.client = null
    }

    const client = new PrismaClient({
      datasources: {
        db: {
          url: this.buildServerlessConnectionUrl()
        }
      },
      log: ['error'],
      errorFormat: 'minimal'
    })

    // Test connection
    await client.$queryRaw`SELECT 1`
    
    console.log('‚úÖ Serverless database connection established')
    return client
  }

  private static buildServerlessConnectionUrl(): string {
    const baseUrl = process.env.DATABASE_URL
    if (!baseUrl) throw new Error('DATABASE_URL is required')

    const url = new URL(baseUrl)
    
    // Optimize for serverless
    url.searchParams.set('connection_limit', '1')
    url.searchParams.set('connect_timeout', '10')
    url.searchParams.set('pool_timeout', '10')
    url.searchParams.set('statement_timeout', '30000')
    url.searchParams.set('sslmode', 'require')
    
    return url.toString()
  }

  // Serverless function wrapper
  static async withConnection<T>(
    operation: (prisma: PrismaClient) => Promise<T>
  ): Promise<T> {
    const client = await this.getClient()
    
    try {
      return await operation(client)
    } catch (error) {
      // Log error but don't disconnect (let connection pool handle it)
      console.error('Serverless operation failed:', error)
      throw error
    }
  }

  // Cleanup for testing or manual cleanup
  static async cleanup(): Promise<void> {
    if (this.client) {
      await this.client.$disconnect()
      this.client = null
    }
    this.connectionPromise = null
  }
}

// Lambda handler example
export const handler = async (event: any, context: any) => {
  // Enable connection reuse
  context.callbackWaitsForEmptyEventLoop = false

  return ServerlessConnectionManager.withConnection(async (prisma) => {
    const users = await prisma.user.findMany({
      take: 10
    })

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(users)
    }
  })
}

// Vercel Edge Function example
export default async function handler(request: Request) {
  return ServerlessConnectionManager.withConnection(async (prisma) => {
    const users = await prisma.user.findMany({
      take: 10
    })

    return new Response(JSON.stringify(users), {
      headers: { 'Content-Type': 'application/json' }
    })
  })
}

// CloudFlare Workers example
export default {
  async fetch(request: Request, env: any, ctx: any): Promise<Response> {
    return ServerlessConnectionManager.withConnection(async (prisma) => {
      const users = await prisma.user.findMany({
        take: 10
      })

      return new Response(JSON.stringify(users), {
        headers: { 'Content-Type': 'application/json' }
      })
    })
  }
}
```

## Connection Monitoring and Metrics

### Comprehensive Monitoring System
Tracking connection health and performance:

```typescript
// Advanced connection monitoring and metrics
interface ConnectionMetrics {
  activeConnections: number
  totalConnections: number
  failedConnections: number
  averageResponseTime: number
  slowQueries: number
  connectionPoolUtilization: number
  lastHealthCheck: Date
}

class ConnectionMonitor {
  private metrics: ConnectionMetrics = {
    activeConnections: 0,
    totalConnections: 0,
    failedConnections: 0,
    averageResponseTime: 0,
    slowQueries: 0,
    connectionPoolUtilization: 0,
    lastHealthCheck: new Date()
  }
  
  private responseTimes: number[] = []
  private client: PrismaClient
  private monitoringInterval: NodeJS.Timeout | null = null

  constructor(client: PrismaClient) {
    this.client = client
    this.setupEventListeners()
    this.startMonitoring()
  }

  private setupEventListeners(): void {
    this.client.$on('query', (event) => {
      const duration = event.duration
      this.recordQueryTime(duration)
      
      if (duration > 1000) { // Slow query threshold
        this.metrics.slowQueries++
        console.warn('üêå Slow query detected:', {
          query: event.query,
          duration: `${duration}ms`,
          params: event.params
        })
      }
    })

    this.client.$on('info', (event) => {
      console.log('‚ÑπÔ∏è Database info:', event)
    })

    this.client.$on('warn', (event) => {
      console.warn('‚ö†Ô∏è Database warning:', event)
    })

    this.client.$on('error', (event) => {
      this.metrics.failedConnections++
      console.error('‚ùå Database error:', event)
    })
  }

  private recordQueryTime(duration: number): void {
    this.responseTimes.push(duration)
    
    // Keep only last 100 response times
    if (this.responseTimes.length > 100) {
      this.responseTimes.shift()
    }
    
    // Recalculate average
    this.metrics.averageResponseTime = 
      this.responseTimes.reduce((sum, time) => sum + time, 0) / this.responseTimes.length
  }

  private startMonitoring(): void {
    this.monitoringInterval = setInterval(async () => {
      await this.performHealthCheck()
      this.logMetrics()
    }, 30000) // Every 30 seconds
  }

  private async performHealthCheck(): Promise<void> {
    try {
      const startTime = Date.now()
      await this.client.$queryRaw`SELECT 1`
      const responseTime = Date.now() - startTime
      
      this.metrics.lastHealthCheck = new Date()
      this.recordQueryTime(responseTime)
      
      console.log(`üíö Health check passed: ${responseTime}ms`)
    } catch (error) {
      console.error('‚ù§Ô∏è‚Äçü©π Health check failed:', error)
      this.metrics.failedConnections++
    }
  }

  private logMetrics(): void {
    console.log('üìä Connection Metrics:', {
      ...this.metrics,
      responseTimeP95: this.calculatePercentile(95),
      responseTimeP99: this.calculatePercentile(99)
    })
  }

  private calculatePercentile(percentile: number): number {
    if (this.responseTimes.length === 0) return 0
    
    const sorted = [...this.responseTimes].sort((a, b) => a - b)
    const index = Math.ceil((percentile / 100) * sorted.length) - 1
    return sorted[index] || 0
  }

  getMetrics(): ConnectionMetrics & {
    responseTimeP95: number
    responseTimeP99: number
  } {
    return {
      ...this.metrics,
      responseTimeP95: this.calculatePercentile(95),
      responseTimeP99: this.calculatePercentile(99)
    }
  }

  stop(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval)
      this.monitoringInterval = null
    }
  }
}

// Health check endpoint for monitoring services
export async function createHealthEndpoint(client: PrismaClient) {
  const monitor = new ConnectionMonitor(client)
  
  return async (req: any, res: any) => {
    try {
      const metrics = monitor.getMetrics()
      const isHealthy = metrics.averageResponseTime < 1000 && 
                       Date.now() - metrics.lastHealthCheck.getTime() < 60000

      res.status(isHealthy ? 200 : 503).json({
        status: isHealthy ? 'healthy' : 'unhealthy',
        metrics,
        timestamp: new Date().toISOString()
      })
    } catch (error) {
      res.status(503).json({
        status: 'error',
        error: error.message,
        timestamp: new Date().toISOString()
      })
    }
  }
}
```

## Graceful Shutdown Patterns

### Production-Ready Shutdown Handling
Ensuring clean application termination:

```typescript
// Comprehensive graceful shutdown system
interface ShutdownConfig {
  timeoutMs: number
  signals: string[]
  forceExitDelay: number
}

class GracefulShutdownManager {
  private clients: PrismaClient[] = []
  private isShuttingDown = false
  private shutdownCallbacks: (() => Promise<void>)[] = []
  private config: ShutdownConfig

  constructor(config: Partial<ShutdownConfig> = {}) {
    this.config = {
      timeoutMs: 30000,
      signals: ['SIGTERM', 'SIGINT'],
      forceExitDelay: 5000,
      ...config
    }
    
    this.setupSignalHandlers()
  }

  registerClient(client: PrismaClient): void {
    this.clients.push(client)
  }

  registerShutdownCallback(callback: () => Promise<void>): void {
    this.shutdownCallbacks.push(callback)
  }

  private setupSignalHandlers(): void {
    this.config.signals.forEach(signal => {
      process.on(signal, () => {
        console.log(`\nüõë Received ${signal}, initiating graceful shutdown...`)
        this.shutdown()
      })
    })

    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
      console.error('üí• Uncaught Exception:', error)
      this.shutdown(1)
    })

    process.on('unhandledRejection', (reason, promise) => {
      console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason)
      this.shutdown(1)
    })
  }

  async shutdown(exitCode = 0): Promise<void> {
    if (this.isShuttingDown) {
      console.log('‚è≥ Shutdown already in progress...')
      return
    }

    this.isShuttingDown = true
    console.log('üîÑ Starting graceful shutdown process...')

    // Set timeout for forced shutdown
    const forceShutdownTimer = setTimeout(() => {
      console.error('‚è∞ Graceful shutdown timeout, forcing exit...')
      process.exit(exitCode || 1)
    }, this.config.timeoutMs)

    try {
      // Run custom shutdown callbacks
      if (this.shutdownCallbacks.length > 0) {
        console.log('üîß Running shutdown callbacks...')
        await Promise.all(
          this.shutdownCallbacks.map(async (callback, index) => {
            try {
              await callback()
              console.log(`‚úÖ Shutdown callback ${index + 1} completed`)
            } catch (error) {
              console.error(`‚ùå Shutdown callback ${index + 1} failed:`, error)
            }
          })
        )
      }

      // Disconnect all Prisma clients
      if (this.clients.length > 0) {
        console.log(`üîå Disconnecting ${this.clients.length} database client(s)...`)
        await Promise.all(
          this.clients.map(async (client, index) => {
            try {
              await client.$disconnect()
              console.log(`‚úÖ Client ${index + 1} disconnected`)
            } catch (error) {
              console.error(`‚ùå Failed to disconnect client ${index + 1}:`, error)
            }
          })
        )
      }

      clearTimeout(forceShutdownTimer)
      console.log('‚úÖ Graceful shutdown completed successfully')
      
      // Small delay to allow logs to flush
      setTimeout(() => process.exit(exitCode), 100)
      
    } catch (error) {
      clearTimeout(forceShutdownTimer)
      console.error('‚ùå Error during graceful shutdown:', error)
      
      // Force exit after delay
      setTimeout(() => process.exit(exitCode || 1), this.config.forceExitDelay)
    }
  }
}

// Express.js integration example
import express from 'express'

const app = express()
const shutdownManager = new GracefulShutdownManager()

// Register Prisma client
const prisma = new PrismaClient()
shutdownManager.registerClient(prisma)

// Register custom cleanup
shutdownManager.registerShutdownCallback(async () => {
  console.log('üßπ Performing custom cleanup...')
  // Clear caches, close files, etc.
})

// Start server with shutdown handling
const server = app.listen(3000, () => {
  console.log('üöÄ Server started on port 3000')
})

// Register server shutdown
shutdownManager.registerShutdownCallback(async () => {
  return new Promise<void>((resolve) => {
    server.close((error) => {
      if (error) {
        console.error('‚ùå Error closing server:', error)
      } else {
        console.log('‚úÖ HTTP server closed')
      }
      resolve()
    })
  })
})

// Next.js integration example
export default function handler(req: any, res: any) {
  const shutdownManager = new GracefulShutdownManager({
    timeoutMs: 10000 // Shorter timeout for serverless
  })
  
  const prisma = new PrismaClient()
  shutdownManager.registerClient(prisma)
  
  // Your API logic here
  return res.json({ status: 'ok' })
}
```

## Exercise: Production Connection Management

Design a production-ready connection management system:

```typescript
// Your task: Create a comprehensive connection management solution

// Requirements:
// 1. Support multiple environments with different configurations
// 2. Implement retry logic with exponential backoff
// 3. Add circuit breaker pattern for resilience
// 4. Include comprehensive monitoring and metrics
// 5. Support both traditional and serverless deployments
// 6. Implement graceful shutdown procedures
// 7. Add health check endpoints
// 8. Support connection pooling optimization
// 9. Include error classification and handling
// 10. Provide debugging and logging capabilities

interface ProductionConnectionManagerConfig {
  // Define comprehensive configuration interface
}

class ProductionConnectionManager {
  // Implement enterprise-grade connection management
  
  // Methods to implement:
  // - configure(config: ProductionConnectionManagerConfig)
  // - getClient(options?: ConnectionOptions)
  // - executeWithRetry<T>(operation: Operation<T>)
  // - startMonitoring()
  // - getHealthStatus()
  // - getMetrics()
  // - gracefulShutdown()
  // - handleFailover()
}

// Bonus features:
// - Database failover support
// - Connection warming
// - Query performance analysis
// - Automatic connection scaling
// - Custom alerting integration
```

## Key Takeaways

1. **Connection Lifecycle**: Understand how Prisma Client manages connections and implement proper lifecycle management
2. **Pool Optimization**: Configure connection pools based on environment and usage patterns
3. **Error Recovery**: Implement robust error handling with retry logic and circuit breakers
4. **Serverless Optimization**: Adapt connection management for serverless constraints and benefits
5. **Monitoring**: Track connection health, performance metrics, and potential issues
6. **Graceful Shutdown**: Ensure clean termination with proper resource cleanup
7. **Environment Adaptation**: Configure connections differently for development, testing, and production

## Next Steps

With Section 4.1 now complete, you've mastered the foundational aspects of Prisma Client setup and configuration. In the next section, **4.2 Basic CRUD Operations**, we'll dive into the core database operations: creating, reading, updating, and deleting data with Prisma Client's powerful and type-safe API.

---

**Estimated Time:** 26 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of connection pooling, error handling patterns, and application lifecycle management
