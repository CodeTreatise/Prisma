# 4.1.4 Client Instantiation & Singleton Patterns

## Learning Objectives
By the end of this lesson, you will be able to:
- Implement proper Prisma Client instantiation patterns for different environments
- Design and implement singleton patterns for client management
- Handle client instantiation in serverless and traditional server environments
- Configure client instances with environment-specific settings
- Manage client lifecycle in development vs production scenarios
- Implement dependency injection patterns with Prisma Client
- Optimize client instantiation for performance and resource usage

## Introduction

Think of Prisma Client instantiation as **establishing the communication headquarters for your application's data operations** - like setting up a mission control center that coordinates all database communications. Just as NASA carefully establishes and maintains a single, reliable command center to avoid conflicting signals and ensure efficient coordination, your application needs a well-designed client instantiation strategy to prevent connection conflicts, optimize resource usage, and maintain consistent database access patterns.

Proper client instantiation ensures your application communicates with the database efficiently and reliably across all environments.

## Understanding Client Instantiation

### Basic Client Instantiation
The foundation of Prisma Client usage:

```typescript
// Basic instantiation - simple but not optimal for production
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Using the client
async function getUsers() {
  const users = await prisma.user.findMany()
  return users
}

// Important: Always disconnect when done
async function cleanup() {
  await prisma.$disconnect()
}
```

### Client Configuration Options
Comprehensive configuration for different scenarios:

```typescript
import { PrismaClient, Prisma } from '@prisma/client'

// Development configuration - verbose logging
const devPrisma = new PrismaClient({
  log: [
    { emit: 'stdout', level: 'query' },
    { emit: 'stdout', level: 'info' },
    { emit: 'stdout', level: 'warn' },
    { emit: 'stdout', level: 'error' }
  ],
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  }
})

// Production configuration - minimal logging, optimized
const prodPrisma = new PrismaClient({
  log: ['error'],
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  },
  // Error formatting for production
  errorFormat: 'minimal',
  // Reject on not found for stricter error handling
  rejectOnNotFound: {
    findUnique: true,
    findFirst: true
  }
})

// Testing configuration - isolated and predictable
const testPrisma = new PrismaClient({
  log: ['warn', 'error'],
  datasources: {
    db: {
      url: process.env.TEST_DATABASE_URL || process.env.DATABASE_URL
    }
  }
})
```

### Environment-Based Instantiation
Adapting client creation to different environments:

```typescript
// utils/prisma.ts
import { PrismaClient } from '@prisma/client'

function createPrismaClient() {
  const environment = process.env.NODE_ENV || 'development'
  
  const baseConfig = {
    datasources: {
      db: {
        url: process.env.DATABASE_URL
      }
    }
  }

  switch (environment) {
    case 'development':
      return new PrismaClient({
        ...baseConfig,
        log: [
          { emit: 'stdout', level: 'query' },
          { emit: 'stdout', level: 'info' },
          { emit: 'stdout', level: 'warn' },
          { emit: 'stdout', level: 'error' }
        ],
        errorFormat: 'pretty'
      })

    case 'production':
      return new PrismaClient({
        ...baseConfig,
        log: ['error'],
        errorFormat: 'minimal'
      })

    case 'test':
      return new PrismaClient({
        ...baseConfig,
        log: ['warn', 'error'],
        datasources: {
          db: {
            url: process.env.TEST_DATABASE_URL || process.env.DATABASE_URL
          }
        }
      })

    default:
      return new PrismaClient(baseConfig)
  }
}

export const prisma = createPrismaClient()
```

## Singleton Pattern Implementation

### Global Singleton Pattern
Ensuring single client instance across application:

```typescript
// lib/prisma.ts - Global singleton implementation
import { PrismaClient } from '@prisma/client'

// Declare global type for Node.js global object
declare global {
  var __prisma: PrismaClient | undefined
}

// Singleton implementation
class PrismaManager {
  private static instance: PrismaClient | null = null

  static getInstance(): PrismaClient {
    if (!PrismaManager.instance) {
      PrismaManager.instance = new PrismaClient({
        log: process.env.NODE_ENV === 'development' 
          ? ['query', 'info', 'warn', 'error'] 
          : ['error'],
        datasources: {
          db: {
            url: process.env.DATABASE_URL
          }
        }
      })

      // Handle process termination
      process.on('beforeExit', async () => {
        await PrismaManager.disconnect()
      })
    }

    return PrismaManager.instance
  }

  static async disconnect(): Promise<void> {
    if (PrismaManager.instance) {
      await PrismaManager.instance.$disconnect()
      PrismaManager.instance = null
    }
  }
}

// Export singleton instance
export const prisma = PrismaManager.getInstance()

// Export manager for advanced control
export { PrismaManager }
```

### Hot Reload-Safe Singleton
Preventing multiple instances during development:

```typescript
// lib/prisma-singleton.ts - Development-friendly singleton
import { PrismaClient } from '@prisma/client'

// Prevent multiple instances during hot reload in development
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

// Create or reuse existing instance
export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' 
    ? ['query', 'info', 'warn', 'error'] 
    : ['error'],
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  }
})

// Store in global during development to survive hot reloads
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}

// Graceful shutdown handling
process.on('SIGINT', async () => {
  console.log('Gracefully shutting down Prisma Client...')
  await prisma.$disconnect()
  process.exit(0)
})

process.on('SIGTERM', async () => {
  console.log('Gracefully shutting down Prisma Client...')
  await prisma.$disconnect()
  process.exit(0)
})
```

### Factory Pattern Implementation
Flexible client creation with dependency injection:

```typescript
// services/PrismaFactory.ts
import { PrismaClient, Prisma } from '@prisma/client'

export interface PrismaConfig {
  databaseUrl?: string
  logLevel?: ('query' | 'info' | 'warn' | 'error')[]
  errorFormat?: 'pretty' | 'colorless' | 'minimal'
  rejectOnNotFound?: boolean
}

export class PrismaFactory {
  private static clients = new Map<string, PrismaClient>()

  static create(config: PrismaConfig = {}, instanceKey = 'default'): PrismaClient {
    // Return existing instance if already created
    if (this.clients.has(instanceKey)) {
      return this.clients.get(instanceKey)!
    }

    const client = new PrismaClient({
      log: config.logLevel || ['error'],
      datasources: {
        db: {
          url: config.databaseUrl || process.env.DATABASE_URL
        }
      },
      errorFormat: config.errorFormat || 'minimal',
      rejectOnNotFound: config.rejectOnNotFound || false
    })

    this.clients.set(instanceKey, client)
    return client
  }

  static async disconnect(instanceKey?: string): Promise<void> {
    if (instanceKey) {
      const client = this.clients.get(instanceKey)
      if (client) {
        await client.$disconnect()
        this.clients.delete(instanceKey)
      }
    } else {
      // Disconnect all clients
      await Promise.all(
        Array.from(this.clients.values()).map(client => client.$disconnect())
      )
      this.clients.clear()
    }
  }

  static getClient(instanceKey = 'default'): PrismaClient | undefined {
    return this.clients.get(instanceKey)
  }

  static hasClient(instanceKey = 'default'): boolean {
    return this.clients.has(instanceKey)
  }
}

// Usage examples
export const mainDb = PrismaFactory.create({
  logLevel: ['query', 'error'],
  errorFormat: 'pretty'
}, 'main')

export const analyticsDb = PrismaFactory.create({
  databaseUrl: process.env.ANALYTICS_DATABASE_URL,
  logLevel: ['error']
}, 'analytics')
```

## Framework-Specific Patterns

### Next.js App Router Pattern
Optimized for Next.js 13+ App Router:

```typescript
// lib/db.ts - Next.js App Router optimized
import { PrismaClient } from '@prisma/client'

const createPrismaClient = () =>
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' 
      ? ['query', 'error', 'warn'] 
      : ['error'],
    datasources: {
      db: {
        url: process.env.DATABASE_URL
      }
    }
  })

const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined
}

// Use existing client or create new one
export const db = globalForPrisma.prisma ?? createPrismaClient()

// Store in global during development to prevent hot reload issues
if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = db
}

// Server action helper
export async function withDb<T>(
  action: (db: PrismaClient) => Promise<T>
): Promise<T> {
  try {
    return await action(db)
  } catch (error) {
    console.error('Database operation failed:', error)
    throw error
  }
}
```

### Express.js Middleware Pattern
Integration with Express.js applications:

```typescript
// middleware/prisma.ts
import { Request, Response, NextFunction } from 'express'
import { PrismaClient } from '@prisma/client'

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      db: PrismaClient
    }
  }
}

class PrismaMiddleware {
  private static client: PrismaClient | null = null

  static getClient(): PrismaClient {
    if (!this.client) {
      this.client = new PrismaClient({
        log: process.env.NODE_ENV === 'development' 
          ? ['query', 'info', 'warn', 'error'] 
          : ['error']
      })
    }
    return this.client
  }

  static middleware() {
    return (req: Request, res: Response, next: NextFunction) => {
      req.db = this.getClient()
      next()
    }
  }

  static async cleanup(): Promise<void> {
    if (this.client) {
      await this.client.$disconnect()
      this.client = null
    }
  }
}

export default PrismaMiddleware

// Usage in Express app
// app.use(PrismaMiddleware.middleware())
```

### Serverless Function Pattern
Optimized for serverless environments:

```typescript
// utils/prisma-serverless.ts
import { PrismaClient } from '@prisma/client'

// Serverless-optimized singleton
let prisma: PrismaClient | undefined

export function getPrismaClient(): PrismaClient {
  if (!prisma) {
    prisma = new PrismaClient({
      // Minimize connections for serverless
      datasources: {
        db: {
          url: process.env.DATABASE_URL
        }
      },
      log: ['error'],
      errorFormat: 'minimal'
    })
  }
  return prisma
}

// Serverless function wrapper
export async function withPrisma<T>(
  handler: (prisma: PrismaClient) => Promise<T>
): Promise<T> {
  const client = getPrismaClient()
  
  try {
    return await handler(client)
  } finally {
    // Don't disconnect in serverless - reuse connections
    // Connection pooling handles this automatically
  }
}

// AWS Lambda example
export const lambdaHandler = async (event: any, context: any) => {
  return withPrisma(async (prisma) => {
    const users = await prisma.user.findMany()
    return {
      statusCode: 200,
      body: JSON.stringify(users)
    }
  })
}

// Vercel Edge Function example
export default async function handler(req: Request) {
  return withPrisma(async (prisma) => {
    const users = await prisma.user.findMany()
    return new Response(JSON.stringify(users), {
      headers: { 'Content-Type': 'application/json' }
    })
  })
}
```

## Testing Patterns

### Test-Specific Client Management
Isolated client instances for testing:

```typescript
// tests/setup/prisma.ts
import { PrismaClient } from '@prisma/client'

export class TestPrismaManager {
  private static testClients = new Map<string, PrismaClient>()

  static createTestClient(testName: string): PrismaClient {
    const client = new PrismaClient({
      datasources: {
        db: {
          url: process.env.TEST_DATABASE_URL || process.env.DATABASE_URL
        }
      },
      log: ['warn', 'error']
    })

    this.testClients.set(testName, client)
    return client
  }

  static async cleanupTest(testName: string): Promise<void> {
    const client = this.testClients.get(testName)
    if (client) {
      await client.$disconnect()
      this.testClients.delete(testName)
    }
  }

  static async cleanupAll(): Promise<void> {
    await Promise.all(
      Array.from(this.testClients.values()).map(client => client.$disconnect())
    )
    this.testClients.clear()
  }
}

// Jest setup
beforeEach(async () => {
  // Create isolated client for each test
  global.testPrisma = TestPrismaManager.createTestClient(expect.getState().currentTestName)
})

afterEach(async () => {
  // Cleanup after each test
  await TestPrismaManager.cleanupTest(expect.getState().currentTestName)
})

afterAll(async () => {
  // Final cleanup
  await TestPrismaManager.cleanupAll()
})
```

### Mock Client Patterns
Creating mock clients for unit testing:

```typescript
// tests/mocks/prisma.ts
import { PrismaClient } from '@prisma/client'
import { DeepMockProxy, mockDeep, mockReset } from 'jest-mock-extended'

// Create mock client type
export type MockPrismaClient = DeepMockProxy<PrismaClient>

// Create mock instance
export const mockPrisma = mockDeep<PrismaClient>()

// Reset mock between tests
beforeEach(() => {
  mockReset(mockPrisma)
})

// Mock factory for dependency injection
export function createMockPrismaClient(): MockPrismaClient {
  return mockDeep<PrismaClient>()
}

// Usage in tests
import { mockPrisma } from '../mocks/prisma'

describe('UserService', () => {
  it('should create user', async () => {
    const userData = { email: 'test@example.com', name: 'Test User' }
    const expectedUser = { id: 1, ...userData }

    mockPrisma.user.create.mockResolvedValue(expectedUser)

    const userService = new UserService(mockPrisma)
    const result = await userService.createUser(userData)

    expect(result).toEqual(expectedUser)
    expect(mockPrisma.user.create).toHaveBeenCalledWith({
      data: userData
    })
  })
})
```

## Performance Optimization

### Connection Pool Management
Optimizing client instances for performance:

```typescript
// utils/optimized-prisma.ts
import { PrismaClient } from '@prisma/client'

interface OptimizedPrismaConfig {
  maxConnections?: number
  connectionTimeout?: number
  environment?: 'development' | 'production' | 'test'
}

export class OptimizedPrismaClient {
  private static instance: PrismaClient | null = null
  private static config: OptimizedPrismaConfig = {}

  static configure(config: OptimizedPrismaConfig): void {
    this.config = { ...this.config, ...config }
  }

  static getInstance(): PrismaClient {
    if (!this.instance) {
      const { environment = 'development' } = this.config

      // Build connection URL with pool settings
      const baseUrl = process.env.DATABASE_URL
      const connectionUrl = this.buildConnectionUrl(baseUrl)

      this.instance = new PrismaClient({
        datasources: {
          db: { url: connectionUrl }
        },
        log: environment === 'development' 
          ? ['query', 'info', 'warn', 'error'] 
          : ['error'],
        errorFormat: environment === 'production' ? 'minimal' : 'pretty'
      })

      // Setup connection monitoring
      this.setupMonitoring()
    }

    return this.instance
  }

  private static buildConnectionUrl(baseUrl?: string): string {
    if (!baseUrl) throw new Error('DATABASE_URL is required')

    const url = new URL(baseUrl)
    const { maxConnections = 10, connectionTimeout = 30 } = this.config

    // Add connection pool parameters
    url.searchParams.set('connection_limit', maxConnections.toString())
    url.searchParams.set('connect_timeout', connectionTimeout.toString())
    url.searchParams.set('pool_timeout', '30')

    return url.toString()
  }

  private static setupMonitoring(): void {
    const client = this.instance!

    // Monitor connection metrics
    setInterval(async () => {
      try {
        const metrics = await client.$metrics.prometheus()
        console.log('Connection metrics:', metrics)
      } catch (error) {
        console.warn('Failed to collect metrics:', error)
      }
    }, 60000) // Every minute

    // Setup graceful shutdown
    const shutdown = async () => {
      console.log('Shutting down Prisma Client...')
      await this.disconnect()
      process.exit(0)
    }

    process.on('SIGINT', shutdown)
    process.on('SIGTERM', shutdown)
  }

  static async disconnect(): Promise<void> {
    if (this.instance) {
      await this.instance.$disconnect()
      this.instance = null
    }
  }

  static async healthCheck(): Promise<boolean> {
    try {
      const client = this.getInstance()
      await client.$queryRaw`SELECT 1`
      return true
    } catch (error) {
      console.error('Health check failed:', error)
      return false
    }
  }
}

// Usage
OptimizedPrismaClient.configure({
  maxConnections: process.env.NODE_ENV === 'production' ? 20 : 5,
  connectionTimeout: 30,
  environment: process.env.NODE_ENV as any
})

export const prisma = OptimizedPrismaClient.getInstance()
```

## Advanced Patterns

### Dependency Injection with IoC Container
Enterprise-grade client management:

```typescript
// services/container.ts
import { Container } from 'inversify'
import { PrismaClient } from '@prisma/client'

// Define service identifiers
export const TYPES = {
  PrismaClient: Symbol.for('PrismaClient'),
  UserService: Symbol.for('UserService'),
  OrderService: Symbol.for('OrderService')
}

// Container setup
export const container = new Container()

// Bind PrismaClient as singleton
container.bind<PrismaClient>(TYPES.PrismaClient).toDynamicValue(() => {
  return new PrismaClient({
    log: process.env.NODE_ENV === 'development' 
      ? ['query', 'error'] 
      : ['error'],
    datasources: {
      db: {
        url: process.env.DATABASE_URL
      }
    }
  })
}).inSingletonScope()

// Service that depends on PrismaClient
import { injectable, inject } from 'inversify'

@injectable()
export class UserService {
  constructor(
    @inject(TYPES.PrismaClient) private prisma: PrismaClient
  ) {}

  async createUser(data: { email: string; name?: string }) {
    return await this.prisma.user.create({ data })
  }
}

// Bind services
container.bind<UserService>(TYPES.UserService).to(UserService)

// Usage
const userService = container.get<UserService>(TYPES.UserService)
```

### Multi-Tenant Client Management
Dynamic client creation for multi-tenant applications:

```typescript
// services/TenantPrismaManager.ts
import { PrismaClient } from '@prisma/client'

interface TenantConfig {
  tenantId: string
  databaseUrl: string
  schema?: string
}

export class TenantPrismaManager {
  private static clients = new Map<string, PrismaClient>()
  private static readonly maxClients = 50 // Prevent memory leaks

  static async getClient(config: TenantConfig): Promise<PrismaClient> {
    const { tenantId, databaseUrl, schema } = config

    if (this.clients.has(tenantId)) {
      return this.clients.get(tenantId)!
    }

    // Enforce client limit
    if (this.clients.size >= this.maxClients) {
      await this.evictOldestClient()
    }

    const client = new PrismaClient({
      datasources: {
        db: { url: databaseUrl }
      },
      log: ['error'],
      errorFormat: 'minimal'
    })

    // Set schema if provided (for PostgreSQL)
    if (schema) {
      await client.$executeRaw`SET search_path TO ${schema}`
    }

    this.clients.set(tenantId, client)
    return client
  }

  private static async evictOldestClient(): Promise<void> {
    const [oldestTenantId] = this.clients.keys()
    const oldestClient = this.clients.get(oldestTenantId)
    
    if (oldestClient) {
      await oldestClient.$disconnect()
      this.clients.delete(oldestTenantId)
    }
  }

  static async disconnectTenant(tenantId: string): Promise<void> {
    const client = this.clients.get(tenantId)
    if (client) {
      await client.$disconnect()
      this.clients.delete(tenantId)
    }
  }

  static async disconnectAll(): Promise<void> {
    await Promise.all(
      Array.from(this.clients.values()).map(client => client.$disconnect())
    )
    this.clients.clear()
  }
}

// Middleware for tenant resolution
export function tenantMiddleware() {
  return async (req: any, res: any, next: any) => {
    const tenantId = req.headers['x-tenant-id'] || req.subdomain
    
    if (!tenantId) {
      return res.status(400).json({ error: 'Tenant ID required' })
    }

    const tenantConfig = await getTenantConfig(tenantId)
    req.prisma = await TenantPrismaManager.getClient(tenantConfig)
    
    next()
  }
}
```

## Exercise: Enterprise Client Architecture

Design a comprehensive client management system:

```typescript
// Your task: Implement an enterprise-grade Prisma Client management system

// Requirements:
// 1. Support multiple environments (dev, staging, prod)
// 2. Handle multiple databases (main, analytics, audit)
// 3. Implement health checking and monitoring
// 4. Support graceful shutdown
// 5. Provide dependency injection compatibility
// 6. Include comprehensive error handling
// 7. Support multi-tenant architecture
// 8. Implement connection pooling optimization

interface ClientManagerConfig {
  // Define configuration interface
}

class EnterpriseClientManager {
  // Implement comprehensive client management
  
  // Methods to implement:
  // - configure(config: ClientManagerConfig)
  // - getClient(database: string, tenant?: string)
  // - healthCheck(database?: string)
  // - getMetrics()
  // - gracefulShutdown()
  // - setupMonitoring()
  // - handleTenantIsolation()
}

// Bonus: Implement patterns for:
// - Circuit breaker for database failures
// - Automatic reconnection handling
// - Connection metrics and alerting
// - Database failover support
```

## Key Takeaways

1. **Singleton Patterns**: Prevent multiple client instances to avoid connection exhaustion and ensure consistent configuration
2. **Environment Awareness**: Configure clients differently for development, testing, and production environments
3. **Framework Integration**: Adapt instantiation patterns to your framework's lifecycle and patterns
4. **Resource Management**: Properly manage client lifecycle with graceful shutdown and cleanup
5. **Performance Optimization**: Configure connection pooling and monitoring for optimal performance
6. **Testing Isolation**: Use separate client instances and mocking strategies for reliable testing
7. **Scalability Planning**: Design client management that supports growth and multi-tenant architectures

## Next Steps

In the next lesson, we'll explore **Connection Management & Lifecycle** and learn how to properly manage database connections, handle reconnections, and optimize connection usage throughout your application's lifecycle.

---

**Estimated Time:** 24 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of singleton patterns, dependency injection, and application lifecycle management
