# 4.4.4 Filtering Relations & Nested Where

## Learning Objectives
By the end of this lesson, you will be able to:
- Master nested where conditions to filter related data at every relationship level
- Implement sophisticated relationship filtering that combines multiple criteria across models
- Design complex filtering strategies that span multiple levels of database relationships
- Build performance-optimized nested filtering systems for large-scale applications
- Handle conditional relationship filtering based on dynamic requirements
- Create flexible nested filtering patterns that adapt to complex business logic
- Optimize database queries through strategic relationship filtering and indexing
- Build comprehensive filtering frameworks that support advanced use cases and edge cases

## Introduction

Think of Prisma's nested where filtering as **a master detective's comprehensive investigation system** - like an expert investigator who can simultaneously examine suspects (main records) while also investigating their associates, family members, business partners, and historical connections using interconnected criteria across multiple evidence levels. Just as a skilled detective understands how to trace connections (looking for suspects who have associates with specific backgrounds, who were present at certain locations, and whose financial records show particular patterns), Prisma's nested where system allows you to filter data based on relationships and nested conditions across your entire database schema. Whether you're building user management systems that filter based on team memberships and project roles, e-commerce platforms that filter products by category hierarchies and vendor relationships, or content systems that filter based on author permissions and content hierarchies, nested where conditions help you build precise, multi-dimensional filtering logic.

Understanding nested where filtering is essential for building sophisticated applications that handle complex business rules and data relationships.

## Basic Nested Where Patterns

### Filtering by Related Model Properties
Using relationship data to filter main records:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Filter users by their posts
async function getUsersWithPublishedPosts() {
  const users = await prisma.user.findMany({
    where: {
      posts: {
        some: {
          published: true
        }
      }
    },
    include: {
      posts: {
        where: {
          published: true
        }
      }
    }
  })
  
  return users
}

// Filter posts by author properties
async function getPostsByActiveAuthors() {
  const posts = await prisma.post.findMany({
    where: {
      author: {
        isActive: true,
        emailVerified: true
      }
    },
    include: {
      author: {
        select: {
          id: true,
          name: true,
          email: true
        }
      }
    }
  })
  
  return posts
}

// Filter by nested relationship properties
async function getPostsFromVerifiedAuthorsInCategory(categoryName: string) {
  const posts = await prisma.post.findMany({
    where: {
      AND: [
        {
          author: {
            profile: {
              verified: true
            }
          }
        },
        {
          postCategories: {
            some: {
              category: {
                name: categoryName
              }
            }
          }
        }
      ]
    },
    include: {
      author: {
        include: {
          profile: true
        }
      },
      postCategories: {
        include: {
          category: true
        }
      }
    }
  })
  
  return posts
}

// Complex nested filtering with multiple conditions
async function getActiveUsersWithRecentActivity() {
  const users = await prisma.user.findMany({
    where: {
      AND: [
        { isActive: true },
        {
          OR: [
            // Users with recent posts
            {
              posts: {
                some: {
                  createdAt: {
                    gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
                  }
                }
              }
            },
            // Users with recent comments
            {
              comments: {
                some: {
                  createdAt: {
                    gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
                  }
                }
              }
            }
          ]
        }
      ]
    },
    include: {
      posts: {
        where: {
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 5
      },
      _count: {
        select: {
          posts: true,
          comments: true
        }
      }
    }
  })
  
  return users
}

// Filtering with relationship counts
async function getPopularUsers(minPosts: number = 10, minFollowers: number = 100) {
  const users = await prisma.user.findMany({
    where: {
      AND: [
        {
          posts: {
            _count: {
              gte: minPosts
            }
          }
        },
        {
          followers: {
            _count: {
              gte: minFollowers
            }
          }
        }
      ]
    },
    include: {
      _count: {
        select: {
          posts: true,
          followers: true,
          following: true
        }
      }
    }
  })
  
  return users
}
```

### Many-to-Many Relationship Filtering
Advanced filtering through junction tables:

```typescript
// Filter products by multiple categories
async function getProductsInCategories(categoryNames: string[]) {
  const products = await prisma.product.findMany({
    where: {
      productCategories: {
        some: {
          category: {
            name: {
              in: categoryNames
            }
          }
        }
      }
    },
    include: {
      productCategories: {
        include: {
          category: true
        }
      }
    }
  })
  
  return products
}

// Filter users by project roles
async function getUsersByProjectRole(projectId: string, roleNames: string[]) {
  const users = await prisma.user.findMany({
    where: {
      projectMembers: {
        some: {
          AND: [
            { projectId },
            {
              role: {
                name: {
                  in: roleNames
                }
              }
            }
          ]
        }
      }
    },
    include: {
      projectMembers: {
        where: {
          projectId
        },
        include: {
          role: true,
          project: true
        }
      }
    }
  })
  
  return users
}

// Complex many-to-many filtering
async function getProjectsWithSpecificTeamComposition(
  requiredRoles: string[],
  minTeamSize: number = 3
) {
  const projects = await prisma.project.findMany({
    where: {
      AND: [
        // Must have all required roles
        ...requiredRoles.map(roleName => ({
          projectMembers: {
            some: {
              role: {
                name: roleName
              }
            }
          }
        })),
        // Must have minimum team size
        {
          projectMembers: {
            _count: {
              gte: minTeamSize
            }
          }
        }
      ]
    },
    include: {
      projectMembers: {
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          role: true
        }
      }
    }
  })
  
  return projects
}

// Filter by relationship existence and properties
async function getPostsWithEngagement(minComments: number = 5, minLikes: number = 10) {
  const posts = await prisma.post.findMany({
    where: {
      AND: [
        {
          comments: {
            _count: {
              gte: minComments
            }
          }
        },
        {
          likes: {
            _count: {
              gte: minLikes
            }
          }
        },
        // Only published posts
        { published: true }
      ]
    },
    include: {
      author: {
        select: {
          id: true,
          name: true
        }
      },
      _count: {
        select: {
          comments: true,
          likes: true
        }
      }
    },
    orderBy: [
      {
        likes: {
          _count: 'desc'
        }
      },
      {
        comments: {
          _count: 'desc'
        }
      }
    ]
  })
  
  return posts
}
```

## Advanced Nested Filtering Strategies

### Multi-Level Relationship Filtering
Complex filtering across multiple relationship levels:

```typescript
// Deep organizational filtering
async function getEmployeesByDepartmentAndSkills(
  departmentName: string,
  requiredSkills: string[]
) {
  const employees = await prisma.user.findMany({
    where: {
      AND: [
        // Must be in specific department
        {
          employeeProfile: {
            department: {
              name: departmentName
            }
          }
        },
        // Must have all required skills
        ...requiredSkills.map(skill => ({
          employeeProfile: {
            skills: {
              some: {
                skill: {
                  name: skill
                }
              }
            }
          }
        })),
        // Must be active employee
        {
          employeeProfile: {
            status: 'ACTIVE'
          }
        }
      ]
    },
    include: {
      employeeProfile: {
        include: {
          department: true,
          skills: {
            include: {
              skill: true
            }
          },
          projects: {
            where: {
              status: 'ACTIVE'
            },
            include: {
              project: true
            }
          }
        }
      }
    }
  })
  
  return employees
}

// E-commerce filtering with deep relationships
async function getProductsWithAdvancedFiltering(filters: {
  categoryPath?: string[]
  priceRange?: { min: number; max: number }
  inStock?: boolean
  rating?: number
  brand?: string
  features?: string[]
}) {
  const conditions: any[] = []
  
  // Filter by category hierarchy
  if (filters.categoryPath) {
    let categoryCondition = {
      categories: {
        some: {
          category: {
            name: filters.categoryPath[filters.categoryPath.length - 1]
          }
        }
      }
    }
    
    // Add parent category conditions
    for (let i = filters.categoryPath.length - 2; i >= 0; i--) {
      categoryCondition = {
        categories: {
          some: {
            category: {
              AND: [
                { name: filters.categoryPath[filters.categoryPath.length - 1] },
                {
                  parent: categoryCondition.categories.some.category
                }
              ]
            }
          }
        }
      }
    }
    
    conditions.push(categoryCondition)
  }
  
  // Price range filtering
  if (filters.priceRange) {
    conditions.push({
      price: {
        gte: filters.priceRange.min,
        lte: filters.priceRange.max
      }
    })
  }
  
  // Stock filtering
  if (filters.inStock) {
    conditions.push({
      inventory: {
        quantity: {
          gt: 0
        }
      }
    })
  }
  
  // Rating filtering
  if (filters.rating) {
    conditions.push({
      reviews: {
        some: {
          rating: {
            gte: filters.rating
          }
        }
      }
    })
  }
  
  // Brand filtering
  if (filters.brand) {
    conditions.push({
      brand: {
        name: filters.brand
      }
    })
  }
  
  // Features filtering
  if (filters.features && filters.features.length > 0) {
    conditions.push({
      AND: filters.features.map(feature => ({
        features: {
          some: {
            feature: {
              name: feature
            }
          }
        }
      }))
    })
  }
  
  const products = await prisma.product.findMany({
    where: {
      AND: conditions
    },
    include: {
      categories: {
        include: {
          category: {
            include: {
              parent: true
            }
          }
        }
      },
      brand: true,
      inventory: true,
      features: {
        include: {
          feature: true
        }
      },
      reviews: {
        select: {
          rating: true
        }
      },
      _count: {
        select: {
          reviews: true
        }
      }
    }
  })
  
  return products
}

// Social media content filtering
async function getContentByComplexCriteria(criteria: {
  authorFollowerCount?: number
  contentAge?: number // days
  engagementThreshold?: number
  topics?: string[]
  authorVerified?: boolean
}) {
  const conditions: any[] = []
  
  // Author follower count
  if (criteria.authorFollowerCount) {
    conditions.push({
      author: {
        followers: {
          _count: {
            gte: criteria.authorFollowerCount
          }
        }
      }
    })
  }
  
  // Content age
  if (criteria.contentAge) {
    const cutoffDate = new Date(Date.now() - criteria.contentAge * 24 * 60 * 60 * 1000)
    conditions.push({
      createdAt: {
        gte: cutoffDate
      }
    })
  }
  
  // Engagement threshold
  if (criteria.engagementThreshold) {
    conditions.push({
      OR: [
        {
          likes: {
            _count: {
              gte: criteria.engagementThreshold
            }
          }
        },
        {
          comments: {
            _count: {
              gte: Math.floor(criteria.engagementThreshold / 2)
            }
          }
        }
      ]
    })
  }
  
  // Topics/tags
  if (criteria.topics && criteria.topics.length > 0) {
    conditions.push({
      tags: {
        some: {
          tag: {
            name: {
              in: criteria.topics
            }
          }
        }
      }
    })
  }
  
  // Author verification
  if (criteria.authorVerified) {
    conditions.push({
      author: {
        profile: {
          verified: true
        }
      }
    })
  }
  
  const posts = await prisma.post.findMany({
    where: {
      AND: conditions
    },
    include: {
      author: {
        select: {
          id: true,
          name: true,
          profile: {
            select: {
              avatar: true,
              verified: true
            }
          },
          _count: {
            select: {
              followers: true
            }
          }
        }
      },
      tags: {
        include: {
          tag: true
        }
      },
      _count: {
        select: {
          likes: true,
          comments: true,
          shares: true
        }
      }
    },
    orderBy: [
      {
        likes: {
          _count: 'desc'
        }
      },
      {
        createdAt: 'desc'
      }
    ]
  })
  
  return posts
}
```

### Dynamic Nested Filtering Systems
Building flexible filtering frameworks:

```typescript
// Dynamic filter builder for complex nested conditions
interface FilterCondition {
  field: string
  operator: 'equals' | 'contains' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'notIn'
  value: any
  relation?: string
  nestedConditions?: FilterCondition[]
}

class NestedFilterBuilder {
  private conditions: any[] = []
  
  addCondition(condition: FilterCondition): this {
    const prismaCondition = this.buildPrismaCondition(condition)
    this.conditions.push(prismaCondition)
    return this
  }
  
  addRelationFilter(
    relationName: string,
    operator: 'some' | 'every' | 'none',
    nestedConditions: FilterCondition[]
  ): this {
    const nestedWhere = this.buildNestedWhere(nestedConditions)
    
    this.conditions.push({
      [relationName]: {
        [operator]: nestedWhere
      }
    })
    
    return this
  }
  
  addCountFilter(
    relationName: string,
    operator: 'gte' | 'gt' | 'lte' | 'lt' | 'equals',
    count: number
  ): this {
    this.conditions.push({
      [relationName]: {
        _count: {
          [operator]: count
        }
      }
    })
    
    return this
  }
  
  addOrGroup(conditions: FilterCondition[]): this {
    const orConditions = conditions.map(condition => 
      this.buildPrismaCondition(condition)
    )
    
    this.conditions.push({
      OR: orConditions
    })
    
    return this
  }
  
  private buildPrismaCondition(condition: FilterCondition): any {
    if (condition.relation) {
      return {
        [condition.relation]: {
          [condition.field]: {
            [condition.operator]: condition.value
          }
        }
      }
    }
    
    return {
      [condition.field]: {
        [condition.operator]: condition.value
      }
    }
  }
  
  private buildNestedWhere(conditions: FilterCondition[]): any {
    if (conditions.length === 1) {
      return this.buildPrismaCondition(conditions[0])
    }
    
    return {
      AND: conditions.map(condition => this.buildPrismaCondition(condition))
    }
  }
  
  build(): any {
    if (this.conditions.length === 0) {
      return {}
    }
    
    if (this.conditions.length === 1) {
      return this.conditions[0]
    }
    
    return {
      AND: this.conditions
    }
  }
  
  reset(): this {
    this.conditions = []
    return this
  }
}

// Usage example
async function getFilteredUsers(filters: any) {
  const builder = new NestedFilterBuilder()
    .addCondition({
      field: 'isActive',
      operator: 'equals',
      value: true
    })
    .addRelationFilter('posts', 'some', [
      {
        field: 'published',
        operator: 'equals',
        value: true
      },
      {
        field: 'createdAt',
        operator: 'gte',
        value: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
      }
    ])
    .addCountFilter('followers', 'gte', 10)
  
  const whereCondition = builder.build()
  
  const users = await prisma.user.findMany({
    where: whereCondition,
    include: {
      posts: {
        where: {
          published: true
        },
        take: 5
      },
      _count: {
        select: {
          posts: true,
          followers: true
        }
      }
    }
  })
  
  return users
}

// Advanced permission-based filtering
interface UserPermissions {
  canViewPrivateContent: boolean
  canViewAllUsers: boolean
  canViewAnalytics: boolean
  departmentAccess?: string[]
  roleLevel: number
}

async function getFilteredContentByPermissions(
  userId: string,
  permissions: UserPermissions,
  filters: any = {}
) {
  const baseConditions: any[] = []
  
  // Basic visibility rules
  if (!permissions.canViewPrivateContent) {
    baseConditions.push({
      OR: [
        { published: true },
        { authorId: userId } // User can see their own content
      ]
    })
  }
  
  // Department-based filtering
  if (permissions.departmentAccess && permissions.departmentAccess.length > 0) {
    baseConditions.push({
      author: {
        employeeProfile: {
          department: {
            name: {
              in: permissions.departmentAccess
            }
          }
        }
      }
    })
  }
  
  // Role level filtering
  if (permissions.roleLevel < 5) { // Assuming 5 is admin level
    baseConditions.push({
      author: {
        employeeProfile: {
          roleLevel: {
            lte: permissions.roleLevel + 1 // Can see content from same or lower level
          }
        }
      }
    })
  }
  
  // Apply additional filters
  if (filters.category) {
    baseConditions.push({
      categories: {
        some: {
          category: {
            name: filters.category
          }
        }
      }
    })
  }
  
  if (filters.dateRange) {
    baseConditions.push({
      createdAt: {
        gte: filters.dateRange.start,
        lte: filters.dateRange.end
      }
    })
  }
  
  const content = await prisma.post.findMany({
    where: {
      AND: baseConditions
    },
    include: {
      author: {
        select: {
          id: true,
          name: true,
          employeeProfile: permissions.canViewAnalytics ? {
            select: {
              department: true,
              roleLevel: true
            }
          } : false
        }
      },
      categories: {
        include: {
          category: true
        }
      },
      _count: permissions.canViewAnalytics ? {
        select: {
          likes: true,
          comments: true,
          views: true
        }
      } : false
    },
    orderBy: {
      createdAt: 'desc'
    }
  })
  
  return content
}

// Performance-optimized complex filtering
async function getOptimizedComplexQuery(filters: {
  userFilters?: any
  postFilters?: any
  relationshipFilters?: any
  limit?: number
  offset?: number
}) {
  // Use cursor-based pagination for better performance
  const cursorCondition = filters.offset ? {
    cursor: { id: filters.offset },
    skip: 1
  } : {}
  
  // Build optimized where conditions
  const whereConditions: any = {
    AND: []
  }
  
  if (filters.userFilters) {
    whereConditions.AND.push(filters.userFilters)
  }
  
  if (filters.relationshipFilters) {
    whereConditions.AND.push(filters.relationshipFilters)
  }
  
  const users = await prisma.user.findMany({
    where: whereConditions,
    include: {
      posts: {
        where: filters.postFilters || {},
        select: {
          id: true,
          title: true,
          createdAt: true,
          _count: {
            select: {
              comments: true,
              likes: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 5
      },
      _count: {
        select: {
          posts: true,
          followers: true
        }
      }
    },
    ...cursorCondition,
    take: filters.limit || 20,
    orderBy: {
      createdAt: 'desc'
    }
  })
  
  return users
}
```

## Exercise: Advanced Nested Filtering System

Build a comprehensive nested filtering management system:

```typescript
// Your task: Create a sophisticated nested filtering system

// Requirements:
// 1. Support unlimited depth relationship filtering
// 2. Implement dynamic filter building with type safety
// 3. Add performance optimization for complex nested filters
// 4. Support permission-based filtering and access control
// 5. Include query optimization and caching
// 6. Add filter validation and sanitization
// 7. Support GraphQL-style filtering syntax
// 8. Implement advanced aggregation filtering (counts, sums, averages)

interface AdvancedNestedFilterSystem {
  // Define the comprehensive nested filtering interface
}

class MasterNestedFilterEngine {
  // Implement the advanced nested filtering system
  
  // Methods to implement:
  // - buildNestedFilter(config: FilterConfig): FilterResult
  // - optimizeFilter(filter: any): OptimizedFilter
  // - validateFilter(filter: any): ValidationResult
  // - cacheFilterResult(key: string, filter: any): CacheResult
  // - applyPermissions(filter: any, permissions: any): SecureFilter
  // - analyzePerformance(queryResult: any): FilterMetrics
  // - sanitizeInput(filter: any): SanitizedFilter
  // - convertFromGraphQL(graphqlFilter: any): PrismaFilter
}

// Bonus features:
// - Machine learning-based filter optimization
// - Real-time filter performance monitoring
// - Automatic index suggestion based on filter patterns
// - Integration with database query planning
// - Advanced security scanning for filter injection
// - Filter result caching with intelligent invalidation
```

## Key Takeaways

1. **Relationship Filtering**: Use nested where conditions to filter based on related model properties
2. **Multi-Level Logic**: Build complex filtering logic across multiple relationship levels
3. **Dynamic Building**: Create flexible filtering systems that adapt to different requirements
4. **Performance Optimization**: Use strategic filtering to minimize database load and improve query performance
5. **Permission Integration**: Implement security-aware filtering based on user permissions and roles
6. **Complex Conditions**: Combine multiple filtering strategies for sophisticated business logic
7. **Validation & Safety**: Ensure filter inputs are validated and protected against injection attacks

Mastering nested where filtering is essential for building sophisticated applications that handle complex business rules and relationship-based queries efficiently.

---

**Estimated Time:** 29 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of complex database relationships, query optimization, security principles, and advanced filtering patterns
