# 4.4.3 Nested Selections & Deep Includes

## Learning Objectives
By the end of this lesson, you will be able to:
- Master complex nested selections that combine `select` and `include` for optimal data retrieval
- Build deep relationship chains that span multiple levels of database relationships
- Implement performance-optimized nested queries that balance completeness with efficiency
- Design sophisticated data loading patterns for complex application architectures
- Handle circular references and infinite recursion in deep nested structures safely
- Create flexible nested selection systems that adapt to different depth requirements
- Optimize database queries through strategic nested loading and intelligent caching
- Build comprehensive data aggregation strategies that combine multiple relationship levels

## Introduction

Think of Prisma's nested selections and deep includes as **a master architect's comprehensive blueprint system** - like an expert city planner who can simultaneously design detailed building specifications (precise field selections) while also mapping out complete neighborhood infrastructures (full relationship includes) across multiple city levels. Just as a skilled architect understands how to balance detailed precision (selecting specific room dimensions and materials) with comprehensive scope (including entire districts with their interconnected utilities, transportation, and social systems), Prisma's nested selection system allows you to precisely control data retrieval at every level while efficiently loading complex relationship hierarchies. Whether you're building user dashboards with nested team structures, e-commerce catalogs with multi-level categories and reviews, or content management systems with deep taxonomies and permissions, nested selections help you craft the perfect balance of detail and scope.

Understanding nested selections is essential for building sophisticated applications that handle complex data relationships efficiently.

## Basic Nested Selection Patterns

### Combining Select and Include
Mixing precise field selection with relationship includes:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Select specific fields while including full relationships
async function getUserWithSelectiveData(userId: string) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      name: true,
      email: true,
      // Include full posts relationship
      posts: {
        include: {
          comments: true,
          categories: true
        }
      },
      // Select specific profile fields
      profile: {
        select: {
          bio: true,
          avatar: true,
          website: true
        }
      }
    }
  })
  
  return user
}

// Nested select within includes
async function getPostWithNestedSelections(postId: string) {
  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: {
      // Include author but select specific fields
      author: {
        select: {
          id: true,
          name: true,
          profile: {
            select: {
              avatar: true
            }
          }
        }
      },
      // Include comments with nested selections
      comments: {
        include: {
          author: {
            select: {
              id: true,
              name: true
            }
          },
          // Select specific fields from replies
          replies: {
            select: {
              id: true,
              content: true,
              createdAt: true,
              author: {
                select: {
                  name: true
                }
              }
            }
          }
        }
      }
    }
  })
  
  return post
}

// Multi-level nested selections
async function getOrganizationStructure(orgId: string) {
  const organization = await prisma.organization.findUnique({
    where: { id: orgId },
    select: {
      id: true,
      name: true,
      departments: {
        select: {
          id: true,
          name: true,
          teams: {
            select: {
              id: true,
              name: true,
              members: {
                select: {
                  user: {
                    select: {
                      id: true,
                      name: true,
                      email: true,
                      profile: {
                        select: {
                          title: true,
                          avatar: true
                        }
                      }
                    }
                  },
                  role: {
                    select: {
                      name: true,
                      permissions: true
                    }
                  },
                  joinedAt: true
                }
              }
            }
          }
        }
      }
    }
  })
  
  return organization
}

// Conditional nested selections
async function getFlexibleUserData(
  userId: string,
  options: {
    includeFullPosts?: boolean
    includeComments?: boolean
    includeFollowers?: boolean
    maxDepth?: number
  } = {}
) {
  const selectConfig: any = {
    id: true,
    name: true,
    email: true
  }
  
  if (options.includeFullPosts) {
    selectConfig.posts = {
      include: {
        comments: options.includeComments ? {
          select: {
            id: true,
            content: true,
            author: {
              select: {
                name: true
              }
            }
          }
        } : false,
        categories: {
          select: {
            category: {
              select: {
                name: true,
                slug: true
              }
            }
          }
        }
      }
    }
  } else {
    selectConfig.posts = {
      select: {
        id: true,
        title: true,
        createdAt: true
      }
    }
  }
  
  if (options.includeFollowers) {
    selectConfig.followers = {
      select: {
        follower: {
          select: {
            id: true,
            name: true,
            profile: {
              select: {
                avatar: true
              }
            }
          }
        },
        createdAt: true
      }
    }
  }
  
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: selectConfig
  })
  
  return user
}
```

### Deep Relationship Chains
Building complex multi-level relationship queries:

```typescript
// Deep content hierarchy
async function getContentHierarchy(categoryId: string) {
  const category = await prisma.category.findUnique({
    where: { id: categoryId },
    select: {
      id: true,
      name: true,
      slug: true,
      // Deep nested categories
      children: {
        select: {
          id: true,
          name: true,
          slug: true,
          children: {
            select: {
              id: true,
              name: true,
              slug: true,
              posts: {
                select: {
                  id: true,
                  title: true,
                  slug: true,
                  author: {
                    select: {
                      name: true,
                      profile: {
                        select: {
                          avatar: true
                        }
                      }
                    }
                  },
                  comments: {
                    select: {
                      id: true,
                      author: {
                        select: {
                          name: true
                        }
                      }
                    },
                    take: 3
                  }
                },
                orderBy: {
                  createdAt: 'desc'
                },
                take: 5
              }
            }
          }
        }
      },
      // Parent hierarchy
      parent: {
        select: {
          id: true,
          name: true,
          parent: {
            select: {
              id: true,
              name: true,
              parent: {
                select: {
                  id: true,
                  name: true
                }
              }
            }
          }
        }
      }
    }
  })
  
  return category
}

// E-commerce product with deep relationships
async function getProductWithFullDetails(productId: string) {
  const product = await prisma.product.findUnique({
    where: { id: productId },
    select: {
      id: true,
      name: true,
      description: true,
      price: true,
      images: {
        select: {
          url: true,
          alt: true,
          order: true
        },
        orderBy: {
          order: 'asc'
        }
      },
      // Category hierarchy
      category: {
        select: {
          id: true,
          name: true,
          slug: true,
          parent: {
            select: {
              id: true,
              name: true,
              slug: true
            }
          }
        }
      },
      // Reviews with nested author data
      reviews: {
        select: {
          id: true,
          rating: true,
          comment: true,
          createdAt: true,
          author: {
            select: {
              id: true,
              name: true,
              profile: {
                select: {
                  avatar: true
                }
              },
              // Author's review statistics
              _count: {
                select: {
                  reviews: true
                }
              }
            }
          },
          // Review helpfulness votes
          votes: {
            select: {
              helpful: true,
              user: {
                select: {
                  id: true
                }
              }
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 10
      },
      // Related products
      relatedProducts: {
        select: {
          relatedProduct: {
            select: {
              id: true,
              name: true,
              price: true,
              images: {
                select: {
                  url: true
                },
                take: 1
              }
            }
          }
        },
        take: 4
      },
      // Inventory and variants
      variants: {
        select: {
          id: true,
          name: true,
          price: true,
          inventory: {
            select: {
              quantity: true,
              reserved: true
            }
          }
        }
      }
    }
  })
  
  return product
}

// Social media feed with complex nesting
async function getSocialFeed(userId: string, limit: number = 20) {
  const posts = await prisma.post.findMany({
    where: {
      OR: [
        // User's own posts
        { authorId: userId },
        // Posts from followed users
        {
          author: {
            followers: {
              some: {
                followerId: userId
              }
            }
          }
        }
      ]
    },
    select: {
      id: true,
      content: true,
      createdAt: true,
      // Author details
      author: {
        select: {
          id: true,
          name: true,
          profile: {
            select: {
              avatar: true,
              verified: true
            }
          }
        }
      },
      // Media attachments
      media: {
        select: {
          id: true,
          type: true,
          url: true,
          thumbnail: true
        }
      },
      // Engagement data
      likes: {
        select: {
          user: {
            select: {
              id: true,
              name: true
            }
          }
        },
        take: 3
      },
      comments: {
        select: {
          id: true,
          content: true,
          createdAt: true,
          author: {
            select: {
              id: true,
              name: true,
              profile: {
                select: {
                  avatar: true
                }
              }
            }
          },
          // Nested replies
          replies: {
            select: {
              id: true,
              content: true,
              author: {
                select: {
                  name: true
                }
              }
            },
            take: 2
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 5
      },
      // Aggregated counts
      _count: {
        select: {
          likes: true,
          comments: true,
          shares: true
        }
      }
    },
    orderBy: [
      { createdAt: 'desc' }
    ],
    take: limit
  })
  
  return posts
}
```

## Advanced Deep Selection Strategies

### Performance-Optimized Deep Queries
Building efficient deep selections for production use:

```typescript
// Depth-controlled nested selection
function buildNestedSelect(maxDepth: number, currentDepth: number = 0): any {
  if (currentDepth >= maxDepth) {
    return false
  }
  
  return {
    select: {
      id: true,
      name: true,
      children: buildNestedSelect(maxDepth, currentDepth + 1),
      posts: currentDepth === 0 ? {
        select: {
          id: true,
          title: true,
          author: {
            select: {
              name: true
            }
          }
        },
        take: 5
      } : false
    }
  }
}

async function getCategoryTreeWithLimit(rootId: string, maxDepth: number = 3) {
  const category = await prisma.category.findUnique({
    where: { id: rootId },
    select: {
      id: true,
      name: true,
      children: buildNestedSelect(maxDepth)
    }
  })
  
  return category
}

// Paginated deep selections
async function getPaginatedNestedData(
  userId: string,
  page: number = 1,
  limit: number = 10
) {
  const skip = (page - 1) * limit
  
  const [user, totalPosts] = await Promise.all([
    prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        name: true,
        profile: {
          select: {
            bio: true,
            avatar: true
          }
        },
        posts: {
          select: {
            id: true,
            title: true,
            content: true,
            createdAt: true,
            comments: {
              select: {
                id: true,
                content: true,
                author: {
                  select: {
                    name: true
                  }
                }
              },
              orderBy: {
                createdAt: 'desc'
              },
              take: 3
            },
            _count: {
              select: {
                comments: true,
                likes: true
              }
            }
          },
          skip,
          take: limit,
          orderBy: {
            createdAt: 'desc'
          }
        }
      }
    }),
    prisma.post.count({
      where: { authorId: userId }
    })
  ])
  
  return {
    user,
    pagination: {
      page,
      limit,
      total: totalPosts,
      totalPages: Math.ceil(totalPosts / limit),
      hasNext: page * limit < totalPosts,
      hasPrev: page > 1
    }
  }
}

// Batch deep selections with optimization
async function getBatchUsersWithNestedData(userIds: string[]) {
  // Split into chunks to avoid overwhelming the database
  const chunkSize = 25
  const chunks = []
  
  for (let i = 0; i < userIds.length; i += chunkSize) {
    chunks.push(userIds.slice(i, i + chunkSize))
  }
  
  const results = await Promise.all(
    chunks.map(chunk =>
      prisma.user.findMany({
        where: {
          id: { in: chunk }
        },
        select: {
          id: true,
          name: true,
          email: true,
          profile: {
            select: {
              avatar: true,
              bio: true
            }
          },
          posts: {
            select: {
              id: true,
              title: true,
              createdAt: true
            },
            orderBy: {
              createdAt: 'desc'
            },
            take: 3
          },
          _count: {
            select: {
              posts: true,
              comments: true,
              followers: true
            }
          }
        }
      })
    )
  )
  
  return results.flat()
}

// Smart caching for deep nested queries
class DeepSelectionCache {
  private cache = new Map<string, {
    data: any
    timestamp: number
    depth: number
  }>()
  private ttl = 10 * 60 * 1000 // 10 minutes
  
  private generateCacheKey(
    model: string,
    id: string,
    selectConfig: any
  ): string {
    return `${model}:${id}:${JSON.stringify(selectConfig)}`
  }
  
  private calculateDepth(obj: any, currentDepth: number = 0): number {
    let maxDepth = currentDepth
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'object' && value !== null) {
        if (key === 'select' || key === 'include') {
          const nestedDepth = this.calculateDepth(value, currentDepth + 1)
          maxDepth = Math.max(maxDepth, nestedDepth)
        }
      }
    }
    
    return maxDepth
  }
  
  async getWithCache<T>(
    model: string,
    id: string,
    selectConfig: any,
    queryFn: () => Promise<T>
  ): Promise<T> {
    const cacheKey = this.generateCacheKey(model, id, selectConfig)
    const cached = this.cache.get(cacheKey)
    const depth = this.calculateDepth(selectConfig)
    
    // Use longer TTL for deeper queries (they're more expensive)
    const adjustedTTL = this.ttl + (depth * 2 * 60 * 1000)
    
    if (cached && Date.now() - cached.timestamp < adjustedTTL) {
      return cached.data
    }
    
    const result = await queryFn()
    
    if (result) {
      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now(),
        depth
      })
    }
    
    return result
  }
  
  invalidateByModel(model: string): void {
    for (const [key] of this.cache) {
      if (key.startsWith(`${model}:`)) {
        this.cache.delete(key)
      }
    }
  }
  
  getStats(): {
    totalEntries: number
    averageDepth: number
    cacheHitRatio: number
  } {
    const entries = Array.from(this.cache.values())
    const totalDepth = entries.reduce((sum, entry) => sum + entry.depth, 0)
    
    return {
      totalEntries: entries.length,
      averageDepth: entries.length > 0 ? totalDepth / entries.length : 0,
      cacheHitRatio: 0 // Would track this in a real implementation
    }
  }
}

const deepSelectionCache = new DeepSelectionCache()

// Usage with caching
async function getCachedUserWithDeepData(userId: string) {
  const selectConfig = {
    id: true,
    name: true,
    posts: {
      select: {
        id: true,
        title: true,
        comments: {
          select: {
            author: {
              select: {
                name: true
              }
            }
          }
        }
      }
    }
  }
  
  return deepSelectionCache.getWithCache(
    'user',
    userId,
    selectConfig,
    () => prisma.user.findUnique({
      where: { id: userId },
      select: selectConfig
    })
  )
}
```

### Dynamic Nested Selection Builder
Building flexible nested selection systems:

```typescript
// Advanced nested selection builder
class NestedSelectionBuilder {
  private selection: any = {}
  private currentPath: string[] = []
  
  // Start building selection for a model
  select(fields: string[]): this {
    fields.forEach(field => {
      this.setFieldValue(field, true)
    })
    return this
  }
  
  // Navigate into a relationship
  into(relationName: string): this {
    this.currentPath.push(relationName)
    this.ensurePathExists()
    return this
  }
  
  // Go back up one level
  back(): this {
    this.currentPath.pop()
    return this
  }
  
  // Go back to root level
  root(): this {
    this.currentPath = []
    return this
  }
  
  // Add fields at current path level
  fields(fields: string[]): this {
    fields.forEach(field => {
      this.setFieldValue(field, true)
    })
    return this
  }
  
  // Add conditional field
  conditionalField(field: string, condition: boolean): this {
    if (condition) {
      this.setFieldValue(field, true)
    }
    return this
  }
  
  // Add aggregation counts
  count(relations: string[]): this {
    const countObject = relations.reduce((acc, relation) => {
      acc[relation] = true
      return acc
    }, {} as any)
    
    this.setFieldValue('_count', { select: countObject })
    return this
  }
  
  // Add ordering and pagination
  orderAndLimit(orderBy: any, take?: number, skip?: number): this {
    const currentObj = this.getCurrentObject()
    if (orderBy) currentObj.orderBy = orderBy
    if (take) currentObj.take = take
    if (skip) currentObj.skip = skip
    return this
  }
  
  // Add where conditions
  where(conditions: any): this {
    const currentObj = this.getCurrentObject()
    currentObj.where = conditions
    return this
  }
  
  private ensurePathExists(): void {
    let current = this.selection
    
    for (const pathSegment of this.currentPath) {
      if (!current[pathSegment]) {
        current[pathSegment] = { select: {} }
      }
      if (!current[pathSegment].select) {
        current[pathSegment].select = {}
      }
      current = current[pathSegment].select
    }
  }
  
  private setFieldValue(field: string, value: any): void {
    this.ensurePathExists()
    const current = this.getCurrentSelectObject()
    current[field] = value
  }
  
  private getCurrentSelectObject(): any {
    let current = this.selection
    
    for (const pathSegment of this.currentPath) {
      current = current[pathSegment].select
    }
    
    return current
  }
  
  private getCurrentObject(): any {
    let current = this.selection
    
    for (const pathSegment of this.currentPath) {
      current = current[pathSegment]
    }
    
    return current
  }
  
  build(): any {
    return { ...this.selection }
  }
  
  reset(): this {
    this.selection = {}
    this.currentPath = []
    return this
  }
}

// Usage examples
async function buildComplexUserQuery(userId: string) {
  const builder = new NestedSelectionBuilder()
    .select(['id', 'name', 'email'])
    .into('profile')
      .fields(['bio', 'avatar', 'website'])
    .back()
    .into('posts')
      .fields(['id', 'title', 'content', 'createdAt'])
      .orderAndLimit({ createdAt: 'desc' }, 10)
      .into('comments')
        .fields(['id', 'content', 'createdAt'])
        .orderAndLimit({ createdAt: 'asc' }, 5)
        .into('author')
          .fields(['id', 'name'])
        .back()
      .back()
      .count(['comments', 'likes'])
    .back()
    .count(['posts', 'followers'])
  
  const selectConfig = builder.build()
  
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: selectConfig
  })
  
  return user
}

// Template-based nested selection
interface NestedTemplate {
  name: string
  description: string
  config: any
}

class NestedSelectionTemplates {
  private static templates = new Map<string, NestedTemplate>()
  
  static register(template: NestedTemplate): void {
    this.templates.set(template.name, template)
  }
  
  static get(name: string): NestedTemplate | undefined {
    return this.templates.get(name)
  }
  
  static apply(templateName: string, variables: Record<string, any> = {}): any {
    const template = this.get(templateName)
    if (!template) {
      throw new Error(`Template not found: ${templateName}`)
    }
    
    return this.interpolateTemplate(template.config, variables)
  }
  
  private static interpolateTemplate(obj: any, variables: Record<string, any>): any {
    if (typeof obj === 'string') {
      return obj.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
        return variables[varName] !== undefined ? variables[varName] : match
      })
    }
    
    if (typeof obj === 'number' || typeof obj === 'boolean') {
      return obj
    }
    
    if (Array.isArray(obj)) {
      return obj.map(item => this.interpolateTemplate(item, variables))
    }
    
    if (typeof obj === 'object' && obj !== null) {
      const result: any = {}
      for (const [key, value] of Object.entries(obj)) {
        result[key] = this.interpolateTemplate(value, variables)
      }
      return result
    }
    
    return obj
  }
}

// Register templates
NestedSelectionTemplates.register({
  name: 'user-profile',
  description: 'Basic user profile with configurable post limit',
  config: {
    id: true,
    name: true,
    email: true,
    profile: {
      select: {
        bio: true,
        avatar: true
      }
    },
    posts: {
      select: {
        id: true,
        title: true,
        createdAt: true
      },
      take: '{{postLimit}}',
      orderBy: {
        createdAt: 'desc'
      }
    }
  }
})

NestedSelectionTemplates.register({
  name: 'post-detail',
  description: 'Detailed post view with comments and author',
  config: {
    id: true,
    title: true,
    content: true,
    createdAt: true,
    author: {
      select: {
        id: true,
        name: true,
        profile: {
          select: {
            avatar: true
          }
        }
      }
    },
    comments: {
      select: {
        id: true,
        content: true,
        createdAt: true,
        author: {
          select: {
            name: true
          }
        }
      },
      take: '{{commentLimit}}',
      orderBy: {
        createdAt: 'asc'
      }
    }
  }
})

// Usage
async function getTemplatedUserData(userId: string, postLimit: number = 5) {
  const selectConfig = NestedSelectionTemplates.apply('user-profile', {
    postLimit
  })
  
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: selectConfig
  })
  
  return user
}
```

## Exercise: Advanced Nested Selection System

Build a comprehensive nested selection management system:

```typescript
// Your task: Create a sophisticated nested selection system

// Requirements:
// 1. Support unlimited depth with performance safeguards
// 2. Implement intelligent caching based on selection complexity
// 3. Add template system for reusable selection patterns
// 4. Support dynamic selection building with fluent API
// 5. Include performance monitoring and optimization
// 6. Add circular reference detection and prevention
// 7. Support GraphQL-style selection parsing
// 8. Implement automatic query optimization based on usage patterns

interface AdvancedNestedSelectionSystem {
  // Define the comprehensive nested selection interface
}

class MasterNestedSelectionEngine {
  // Implement the advanced nested selection system
  
  // Methods to implement:
  // - buildNestedSelection(config: NestedConfig): SelectionResult
  // - optimizeSelection(selection: any): OptimizedSelection
  // - validateDepth(selection: any, maxDepth: number): ValidationResult
  // - cacheNestedQuery(key: string, selection: any): CacheResult
  // - detectCircularRefs(selection: any): CircularReference[]
  // - analyzePerformance(queryResult: any): PerformanceMetrics
  // - createTemplate(name: string, config: TemplateConfig): void
  // - applyTemplate(name: string, variables: any): SelectionConfig
}

// Bonus features:
// - Machine learning-based selection optimization
// - Real-time performance monitoring and alerting
// - Automatic depth limiting based on query complexity
// - Integration with database query planning
// - Advanced caching strategies with intelligent invalidation
// - GraphQL schema integration and validation
```

## Key Takeaways

1. **Mixed Strategies**: Combine `select` and `include` for optimal data retrieval patterns
2. **Depth Control**: Implement safeguards to prevent overly deep or expensive queries
3. **Performance Optimization**: Use caching, pagination, and batching for deep selections
4. **Dynamic Building**: Create flexible systems that adapt to different nesting requirements
5. **Template Systems**: Build reusable selection patterns for common use cases
6. **Monitoring**: Track performance and complexity of nested queries in production
7. **Safety Measures**: Implement circular reference detection and depth limiting

Mastering nested selections is crucial for building sophisticated applications that efficiently handle complex relationship hierarchies.

---

**Estimated Time:** 27 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of complex database relationships, query optimization, and caching strategies
