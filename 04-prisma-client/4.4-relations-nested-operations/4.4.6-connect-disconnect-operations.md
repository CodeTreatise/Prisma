# 4.4.6 Connect & Disconnect Operations

## Learning Objectives
By the end of this lesson, you will be able to:
- Master connect and disconnect operations to manage existing relationships efficiently
- Implement sophisticated relationship management strategies for complex business workflows
- Design flexible connection patterns that handle dynamic relationship requirements
- Build performance-optimized relationship operations for large-scale applications
- Handle conditional relationship operations based on business rules and permissions
- Create robust relationship validation and integrity checking systems
- Optimize database operations through strategic relationship management and batching
- Build comprehensive relationship audit trails and change tracking systems

## Introduction

Think of Prisma's connect and disconnect operations as **a master network administrator's sophisticated connection management system** - like an expert systems administrator who can dynamically establish, modify, and terminate network connections between servers, applications, and services without disrupting existing operations or data integrity. Just as a skilled network administrator understands how to safely connect new servers to existing clusters, move applications between environments, and disconnect outdated systems while maintaining service continuity, Prisma's connect/disconnect operations allow you to manage existing data relationships without recreating records or losing important connections. Whether you're building user management systems that assign users to teams and projects, e-commerce platforms that manage product categories and vendor relationships, or content systems that handle author assignments and content hierarchies, connect/disconnect operations help you maintain clean, efficient relationship management.

Understanding connect and disconnect operations is essential for building maintainable applications that handle relationship changes efficiently and safely.

## Basic Connect Operations

### Connecting Existing Records
Establishing relationships between existing records:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Connect user to existing posts
async function assignPostsToUser(userId: string, postIds: string[]) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      posts: {
        connect: postIds.map(id => ({ id }))
      }
    },
    include: {
      posts: {
        select: {
          id: true,
          title: true,
          createdAt: true
        }
      }
    }
  })
  
  return user
}

// Connect user to team and role
async function addUserToTeam(
  userId: string,
  teamId: string,
  roleId: string
) {
  const teamMember = await prisma.teamMember.create({
    data: {
      user: {
        connect: { id: userId }
      },
      team: {
        connect: { id: teamId }
      },
      role: {
        connect: { id: roleId }
      },
      joinedAt: new Date()
    },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          email: true
        }
      },
      team: {
        select: {
          id: true,
          name: true
        }
      },
      role: {
        select: {
          id: true,
          name: true,
          permissions: true
        }
      }
    }
  })
  
  return teamMember
}

// Connect product to categories
async function assignProductToCategories(
  productId: string,
  categoryIds: string[]
) {
  const product = await prisma.product.update({
    where: { id: productId },
    data: {
      productCategories: {
        create: categoryIds.map(categoryId => ({
          category: {
            connect: { id: categoryId }
          }
        }))
      }
    },
    include: {
      productCategories: {
        include: {
          category: {
            select: {
              id: true,
              name: true,
              slug: true
            }
          }
        }
      }
    }
  })
  
  return product
}

// Connect post to tags with metadata
async function assignTagsToPost(
  postId: string,
  tagAssignments: Array<{
    tagId: string
    weight?: number
    primary?: boolean
  }>
) {
  const post = await prisma.post.update({
    where: { id: postId },
    data: {
      postTags: {
        create: tagAssignments.map(assignment => ({
          tag: {
            connect: { id: assignment.tagId }
          },
          weight: assignment.weight || 1,
          primary: assignment.primary || false
        }))
      }
    },
    include: {
      postTags: {
        include: {
          tag: {
            select: {
              id: true,
              name: true,
              slug: true
            }
          }
        }
      }
    }
  })
  
  return post
}

// Conditional connect based on existing relationships
async function connectUserToProjectIfEligible(
  userId: string,
  projectId: string,
  roleId: string
) {
  // Check if user is already in the project
  const existingMembership = await prisma.projectMember.findFirst({
    where: {
      userId,
      projectId
    }
  })
  
  if (existingMembership) {
    throw new Error('User is already a member of this project')
  }
  
  // Check project capacity
  const project = await prisma.project.findUnique({
    where: { id: projectId },
    include: {
      _count: {
        select: {
          projectMembers: true
        }
      }
    }
  })
  
  if (project?.maxMembers && project._count.projectMembers >= project.maxMembers) {
    throw new Error('Project has reached maximum capacity')
  }
  
  // Connect user to project
  const membership = await prisma.projectMember.create({
    data: {
      user: {
        connect: { id: userId }
      },
      project: {
        connect: { id: projectId }
      },
      role: {
        connect: { id: roleId }
      },
      joinedAt: new Date()
    },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          email: true
        }
      },
      project: {
        select: {
          id: true,
          name: true
        }
      },
      role: true
    }
  })
  
  return membership
}
```

### ConnectOrCreate Operations
Connecting to existing records or creating new ones if they don't exist:

```typescript
// Connect or create categories for post
async function assignCategoriesToPost(
  postId: string,
  categoryData: Array<{
    name: string
    description?: string
  }>
) {
  const post = await prisma.post.update({
    where: { id: postId },
    data: {
      postCategories: {
        create: categoryData.map(cat => ({
          category: {
            connectOrCreate: {
              where: {
                name: cat.name
              },
              create: {
                name: cat.name,
                slug: cat.name.toLowerCase().replace(/\s+/g, '-'),
                description: cat.description
              }
            }
          }
        }))
      }
    },
    include: {
      postCategories: {
        include: {
          category: true
        }
      }
    }
  })
  
  return post
}

// Connect or create user skills
async function assignSkillsToUser(
  userId: string,
  skillsData: Array<{
    name: string
    level: 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED' | 'EXPERT'
    yearsExperience?: number
  }>
) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      userSkills: {
        create: skillsData.map(skillData => ({
          level: skillData.level,
          yearsExperience: skillData.yearsExperience || 0,
          skill: {
            connectOrCreate: {
              where: {
                name: skillData.name
              },
              create: {
                name: skillData.name,
                category: 'GENERAL' // Default category
              }
            }
          }
        }))
      }
    },
    include: {
      userSkills: {
        include: {
          skill: true
        }
      }
    }
  })
  
  return user
}

// Connect or create vendor relationships
async function establishVendorRelationships(
  productId: string,
  vendorData: Array<{
    name: string
    email: string
    type: 'SUPPLIER' | 'MANUFACTURER' | 'DISTRIBUTOR'
    contractTerms?: string
  }>
) {
  const product = await prisma.product.update({
    where: { id: productId },
    data: {
      productVendors: {
        create: vendorData.map(vendorInfo => ({
          type: vendorInfo.type,
          contractTerms: vendorInfo.contractTerms,
          vendor: {
            connectOrCreate: {
              where: {
                email: vendorInfo.email
              },
              create: {
                name: vendorInfo.name,
                email: vendorInfo.email,
                status: 'ACTIVE'
              }
            }
          }
        }))
      }
    },
    include: {
      productVendors: {
        include: {
          vendor: true
        }
      }
    }
  })
  
  return product
}

// Smart connect with duplicate prevention
async function smartConnectUserToGroups(
  userId: string,
  groupIdentifiers: Array<{
    id?: string
    name?: string
    createIfMissing?: boolean
  }>
) {
  const connections = []
  
  for (const groupInfo of groupIdentifiers) {
    if (groupInfo.id) {
      // Direct connect by ID
      connections.push({
        group: {
          connect: { id: groupInfo.id }
        }
      })
    } else if (groupInfo.name) {
      if (groupInfo.createIfMissing) {
        // Connect or create by name
        connections.push({
          group: {
            connectOrCreate: {
              where: { name: groupInfo.name },
              create: {
                name: groupInfo.name,
                description: `Auto-created group: ${groupInfo.name}`
              }
            }
          }
        })
      } else {
        // Try to find existing group
        const existingGroup = await prisma.group.findUnique({
          where: { name: groupInfo.name }
        })
        
        if (existingGroup) {
          connections.push({
            group: {
              connect: { id: existingGroup.id }
            }
          })
        }
      }
    }
  }
  
  if (connections.length === 0) {
    return null
  }
  
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      userGroups: {
        create: connections
      }
    },
    include: {
      userGroups: {
        include: {
          group: true
        }
      }
    }
  })
  
  return user
}
```

## Advanced Disconnect Operations

### Removing Relationships Safely
Disconnecting records while maintaining data integrity:

```typescript
// Disconnect user from posts (reassign to default author)
async function transferPostsFromUser(
  fromUserId: string,
  toUserId: string,
  postIds?: string[]
) {
  const whereCondition = postIds ? {
    id: { in: postIds },
    authorId: fromUserId
  } : {
    authorId: fromUserId
  }
  
  const updatedPosts = await prisma.post.updateMany({
    where: whereCondition,
    data: {
      authorId: toUserId
    }
  })
  
  return {
    transferredCount: updatedPosts.count,
    fromUserId,
    toUserId
  }
}

// Remove user from team with cleanup
async function removeUserFromTeam(
  userId: string,
  teamId: string,
  options: {
    reassignTasks?: boolean
    newAssigneeId?: string
    removeDate?: Date
  } = {}
) {
  return await prisma.$transaction(async (tx) => {
    // Find the team membership
    const membership = await tx.teamMember.findFirst({
      where: {
        userId,
        teamId
      },
      include: {
        user: true,
        team: true
      }
    })
    
    if (!membership) {
      throw new Error('User is not a member of this team')
    }
    
    // Handle task reassignment if requested
    if (options.reassignTasks && options.newAssigneeId) {
      await tx.task.updateMany({
        where: {
          assigneeId: userId,
          teamId
        },
        data: {
          assigneeId: options.newAssigneeId
        }
      })
    } else if (options.reassignTasks) {
      // Unassign tasks if no new assignee specified
      await tx.task.updateMany({
        where: {
          assigneeId: userId,
          teamId
        },
        data: {
          assigneeId: null
        }
      })
    }
    
    // Remove team membership
    await tx.teamMember.delete({
      where: {
        id: membership.id
      }
    })
    
    // Log the removal
    await tx.auditLog.create({
      data: {
        action: 'TEAM_MEMBER_REMOVED',
        entityType: 'TeamMember',
        entityId: membership.id,
        userId: userId,
        details: {
          teamId,
          removedAt: options.removeDate || new Date(),
          tasksReassigned: options.reassignTasks
        }
      }
    })
    
    return {
      success: true,
      membership,
      tasksAffected: options.reassignTasks
    }
  })
}

// Disconnect product from categories with validation
async function removeProductFromCategories(
  productId: string,
  categoryIds: string[],
  options: {
    requireMinimumCategories?: number
    validateRemoval?: boolean
  } = {}
) {
  return await prisma.$transaction(async (tx) => {
    // Get current category count
    const currentCategories = await tx.productCategory.count({
      where: { productId }
    })
    
    // Validate minimum categories requirement
    if (options.requireMinimumCategories) {
      const remainingCount = currentCategories - categoryIds.length
      if (remainingCount < options.requireMinimumCategories) {
        throw new Error(
          `Cannot remove categories. Product must remain in at least ${options.requireMinimumCategories} categories`
        )
      }
    }
    
    // Validate removal permissions if requested
    if (options.validateRemoval) {
      const categoriesToRemove = await tx.category.findMany({
        where: {
          id: { in: categoryIds }
        }
      })
      
      const protectedCategories = categoriesToRemove.filter(cat => cat.protected)
      if (protectedCategories.length > 0) {
        throw new Error(
          `Cannot remove product from protected categories: ${protectedCategories.map(c => c.name).join(', ')}`
        )
      }
    }
    
    // Remove the category associations
    const removed = await tx.productCategory.deleteMany({
      where: {
        productId,
        categoryId: { in: categoryIds }
      }
    })
    
    return {
      removedCount: removed.count,
      remainingCategories: currentCategories - removed.count
    }
  })
}

// Bulk disconnect operations with error handling
async function bulkDisconnectUsersFromProject(
  projectId: string,
  userIds: string[],
  options: {
    reassignTasks?: boolean
    notifyUsers?: boolean
  } = {}
) {
  const results = []
  
  for (const userId of userIds) {
    try {
      const result = await prisma.$transaction(async (tx) => {
        // Check if user is in project
        const membership = await tx.projectMember.findFirst({
          where: { userId, projectId }
        })
        
        if (!membership) {
          return { success: false, reason: 'User not in project' }
        }
        
        // Handle task reassignment
        if (options.reassignTasks) {
          await tx.task.updateMany({
            where: {
              assigneeId: userId,
              projectId
            },
            data: {
              assigneeId: null,
              status: 'UNASSIGNED'
            }
          })
        }
        
        // Remove membership
        await tx.projectMember.delete({
          where: { id: membership.id }
        })
        
        // Create notification if requested
        if (options.notifyUsers) {
          await tx.notification.create({
            data: {
              userId,
              type: 'PROJECT_REMOVAL',
              title: 'Removed from Project',
              message: `You have been removed from the project.`,
              data: { projectId }
            }
          })
        }
        
        return { success: true, membership }
      })
      
      results.push({ userId, ...result })
    } catch (error) {
      results.push({
        userId,
        success: false,
        error: error.message
      })
    }
  }
  
  return results
}
```

### Complex Relationship Management
Advanced patterns for sophisticated relationship operations:

```typescript
// Multi-level relationship management
async function reorganizeUserHierarchy(
  changes: Array<{
    userId: string
    action: 'PROMOTE' | 'DEMOTE' | 'TRANSFER' | 'REMOVE'
    newManagerId?: string
    newDepartmentId?: string
    newRoleId?: string
  }>
) {
  return await prisma.$transaction(async (tx) => {
    const results = []
    
    for (const change of changes) {
      try {
        const user = await tx.user.findUnique({
          where: { id: change.userId },
          include: {
            employeeProfile: {
              include: {
                manager: true,
                department: true,
                role: true
              }
            }
          }
        })
        
        if (!user?.employeeProfile) {
          results.push({
            userId: change.userId,
            success: false,
            error: 'User has no employee profile'
          })
          continue
        }
        
        const updateData: any = {}
        
        switch (change.action) {
          case 'PROMOTE':
          case 'DEMOTE':
            if (change.newRoleId) {
              updateData.role = { connect: { id: change.newRoleId } }
            }
            if (change.newManagerId) {
              updateData.manager = { connect: { id: change.newManagerId } }
            }
            break
            
          case 'TRANSFER':
            if (change.newDepartmentId) {
              updateData.department = { connect: { id: change.newDepartmentId } }
            }
            if (change.newManagerId) {
              updateData.manager = { connect: { id: change.newManagerId } }
            }
            break
            
          case 'REMOVE':
            updateData.status = 'INACTIVE'
            updateData.endDate = new Date()
            // Disconnect from active relationships
            updateData.manager = { disconnect: true }
            break
        }
        
        const updatedProfile = await tx.employeeProfile.update({
          where: { userId: change.userId },
          data: updateData,
          include: {
            manager: true,
            department: true,
            role: true
          }
        })
        
        // Log the change
        await tx.auditLog.create({
          data: {
            action: `EMPLOYEE_${change.action}`,
            entityType: 'EmployeeProfile',
            entityId: updatedProfile.id,
            userId: change.userId,
            details: {
              previousData: user.employeeProfile,
              newData: change,
              timestamp: new Date()
            }
          }
        })
        
        results.push({
          userId: change.userId,
          success: true,
          action: change.action,
          profile: updatedProfile
        })
      } catch (error) {
        results.push({
          userId: change.userId,
          success: false,
          error: error.message
        })
      }
    }
    
    return results
  })
}

// Dynamic relationship builder
class RelationshipManager {
  constructor(private prisma: PrismaClient) {}
  
  async connect(
    sourceModel: string,
    sourceId: string,
    relationName: string,
    targetIds: string[],
    metadata?: any
  ) {
    const connectData = targetIds.map(id => ({ id }))
    
    return await (this.prisma as any)[sourceModel].update({
      where: { id: sourceId },
      data: {
        [relationName]: {
          connect: connectData
        }
      }
    })
  }
  
  async disconnect(
    sourceModel: string,
    sourceId: string,
    relationName: string,
    targetIds: string[]
  ) {
    const disconnectData = targetIds.map(id => ({ id }))
    
    return await (this.prisma as any)[sourceModel].update({
      where: { id: sourceId },
      data: {
        [relationName]: {
          disconnect: disconnectData
        }
      }
    })
  }
  
  async reconnect(
    sourceModel: string,
    sourceId: string,
    relationName: string,
    currentTargetIds: string[],
    newTargetIds: string[]
  ) {
    return await (this.prisma as any)[sourceModel].update({
      where: { id: sourceId },
      data: {
        [relationName]: {
          disconnect: currentTargetIds.map(id => ({ id })),
          connect: newTargetIds.map(id => ({ id }))
        }
      }
    })
  }
  
  async replaceRelationships(
    sourceModel: string,
    sourceId: string,
    relationName: string,
    newTargetIds: string[]
  ) {
    // First, get current relationships
    const current = await (this.prisma as any)[sourceModel].findUnique({
      where: { id: sourceId },
      include: {
        [relationName]: {
          select: { id: true }
        }
      }
    })
    
    const currentIds = current?.[relationName]?.map((item: any) => item.id) || []
    const toDisconnect = currentIds.filter((id: string) => !newTargetIds.includes(id))
    const toConnect = newTargetIds.filter(id => !currentIds.includes(id))
    
    if (toDisconnect.length === 0 && toConnect.length === 0) {
      return current // No changes needed
    }
    
    const updateData: any = {}
    
    if (toDisconnect.length > 0) {
      updateData.disconnect = toDisconnect.map(id => ({ id }))
    }
    
    if (toConnect.length > 0) {
      updateData.connect = toConnect.map(id => ({ id }))
    }
    
    return await (this.prisma as any)[sourceModel].update({
      where: { id: sourceId },
      data: {
        [relationName]: updateData
      }
    })
  }
}

// Usage example
const relationshipManager = new RelationshipManager(prisma)

async function updateUserProjectAssignments(
  userId: string,
  newProjectIds: string[]
) {
  return await relationshipManager.replaceRelationships(
    'user',
    userId,
    'projectMembers',
    newProjectIds
  )
}

// Relationship validation and constraints
async function validateAndConnectUserToRole(
  userId: string,
  roleId: string,
  departmentId: string
) {
  return await prisma.$transaction(async (tx) => {
    // Validate user exists and is active
    const user = await tx.user.findUnique({
      where: { id: userId },
      include: {
        employeeProfile: true
      }
    })
    
    if (!user) {
      throw new Error('User not found')
    }
    
    if (!user.isActive) {
      throw new Error('Cannot assign role to inactive user')
    }
    
    // Validate role exists and is available
    const role = await tx.role.findUnique({
      where: { id: roleId },
      include: {
        _count: {
          select: {
            employees: true
          }
        }
      }
    })
    
    if (!role) {
      throw new Error('Role not found')
    }
    
    if (role.maxOccupants && role._count.employees >= role.maxOccupants) {
      throw new Error('Role has reached maximum capacity')
    }
    
    // Validate department compatibility
    const department = await tx.department.findUnique({
      where: { id: departmentId },
      include: {
        allowedRoles: {
          where: { id: roleId }
        }
      }
    })
    
    if (!department) {
      throw new Error('Department not found')
    }
    
    if (department.allowedRoles.length === 0) {
      throw new Error('Role is not allowed in this department')
    }
    
    // Perform the connection
    const updatedProfile = await tx.employeeProfile.upsert({
      where: { userId },
      create: {
        user: { connect: { id: userId } },
        role: { connect: { id: roleId } },
        department: { connect: { id: departmentId } },
        startDate: new Date(),
        status: 'ACTIVE'
      },
      update: {
        role: { connect: { id: roleId } },
        department: { connect: { id: departmentId } }
      },
      include: {
        role: true,
        department: true
      }
    })
    
    return updatedProfile
  })
}
```

## Exercise: Advanced Connect/Disconnect System

Build a comprehensive relationship management system:

```typescript
// Your task: Create a sophisticated connect/disconnect system

// Requirements:
// 1. Support complex multi-model relationship management
// 2. Implement validation and constraint checking for connections
// 3. Add audit logging and change tracking for all relationship operations
// 4. Support bulk operations with error handling and rollback
// 5. Include performance optimization for large-scale relationship operations
// 6. Add dynamic relationship discovery and management
// 7. Support conditional connections based on business rules
// 8. Implement relationship analytics and reporting

interface AdvancedRelationshipSystem {
  // Define the comprehensive relationship management interface
}

class MasterRelationshipEngine {
  // Implement the advanced relationship system
  
  // Methods to implement:
  // - validateConnection(config: ConnectionConfig): ValidationResult
  // - executeConnection(operation: ConnectionOperation): ConnectionResult
  // - disconnectWithCleanup(config: DisconnectionConfig): DisconnectionResult
  // - bulkRelationshipOperations(operations: Operation[]): BulkResult
  // - auditRelationshipChanges(changes: Change[]): AuditReport
  // - optimizeRelationshipQueries(operations: any[]): OptimizedOperations
  // - analyzeRelationshipPatterns(timeframe: TimeFrame): AnalysisReport
  // - enforceRelationshipConstraints(constraints: Constraint[]): EnforcementResult
}

// Bonus features:
// - Machine learning-based relationship recommendation
// - Real-time relationship monitoring and alerting
// - Automatic relationship cleanup and maintenance
// - Integration with graph database for complex relationship analysis
// - Advanced permission-based relationship management
// - Intelligent relationship caching and optimization
```

## Key Takeaways

1. **Efficient Relationship Management**: Use connect/disconnect for managing existing relationships without data duplication
2. **Validation and Constraints**: Implement proper validation before establishing or removing relationships
3. **Transaction Safety**: Use transactions for complex relationship operations to maintain data integrity
4. **Audit Trails**: Track relationship changes for compliance and debugging purposes
5. **Performance Optimization**: Design efficient relationship operations that minimize database load
6. **Error Handling**: Build robust error handling for relationship operations
7. **Flexibility**: Create dynamic systems that can handle various relationship management scenarios

Mastering connect and disconnect operations is essential for building maintainable applications that efficiently manage complex data relationships.

---

**Estimated Time:** 28 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of database relationships, data integrity principles, transaction management, and audit logging concepts

## Section 4.4 Complete! ðŸŽ‰

Congratulations! You've now mastered **all aspects of Relations & Nested Operations** with comprehensive coverage of:

- âœ… **4.4.1** Including Related Data (`include`) (26 min)
- âœ… **4.4.2** Selecting Specific Fields (`select`) (28 min)  
- âœ… **4.4.3** Nested Selections & Deep Includes (27 min)
- âœ… **4.4.4** Filtering Relations & Nested Where (29 min)
- âœ… **4.4.5** Nested Creates & Updates (31 min)
- âœ… **4.4.6** Connect & Disconnect Operations (28 min)

**Section 4.4 Total: 169 minutes (2.82 hours) - Complete relationship mastery achieved!**

You now have comprehensive expertise in sophisticated relationship handling, from basic includes to complex nested operations and relationship management. Ready to tackle **Section 4.5 Raw SQL & Custom Queries**? ðŸš€
