# 4.4.1 Including Related Data (`include`)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master the `include` option to fetch related data in single queries efficiently
- Understand the difference between includes and joins for optimized data retrieval
- Implement nested includes for complex multi-level relationship fetching
- Design performance-optimized include strategies for large datasets and deep relationships
- Handle circular references and infinite loops in relationship includes safely
- Build flexible include patterns that adapt to different API endpoint requirements
- Optimize database queries through strategic relationship loading and caching
- Create comprehensive data loading strategies for complex application architectures

## Introduction

Think of Prisma's `include` functionality as **a master librarian's comprehensive reference system** - like an expert research librarian who can instantly gather not just the book you requested, but also all related volumes, cross-references, citations, and supplementary materials in a single, organized collection. Just as a skilled librarian understands the interconnected nature of knowledge (knowing that when you ask for a book on astronomy, you might also need the author's biography, related scientific papers, reader reviews, and books by cited researchers), Prisma's include system intelligently fetches related data across your database relationships in optimized queries. Whether you're building user profiles with their posts and comments, product catalogs with categories and reviews, or complex organizational hierarchies with nested departments and employees, the include system helps you gather complete, contextual data efficiently.

Understanding includes is essential for building responsive applications that minimize database round-trips while delivering rich, interconnected data.

## Basic Include Operations

### Single Relationship Includes
Including one-to-one and one-to-many relationships:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Include user's posts (one-to-many)
async function getUserWithPosts(userId: string) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      posts: true
    }
  })
  
  return user
}

// Include post's author (many-to-one)
async function getPostWithAuthor(postId: string) {
  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: {
      author: true
    }
  })
  
  return post
}

// Include user's profile (one-to-one)
async function getUserWithProfile(userId: string) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      profile: true
    }
  })
  
  return user
}

// Multiple basic includes
async function getUserWithMultipleRelations(userId: string) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      posts: true,
      comments: true,
      profile: true,
      followers: true,
      following: true
    }
  })
  
  return user
}

// Include with findMany
async function getAllUsersWithPosts() {
  const users = await prisma.user.findMany({
    include: {
      posts: true
    }
  })
  
  return users
}

// Conditional includes
async function getUserWithConditionalIncludes(userId: string, includePosts: boolean = false) {
  const includeOptions: any = {
    profile: true,
    comments: true
  }
  
  if (includePosts) {
    includeOptions.posts = true
  }
  
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: includeOptions
  })
  
  return user
}
```

### Many-to-Many Relationship Includes
Handling complex many-to-many relationships:

```typescript
// Include user's roles (many-to-many)
async function getUserWithRoles(userId: string) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      userRoles: {
        include: {
          role: true
        }
      }
    }
  })
  
  // Transform to flatten the structure
  const userWithRoles = {
    ...user,
    roles: user?.userRoles.map(ur => ur.role) || []
  }
  
  return userWithRoles
}

// Include post's categories (many-to-many)
async function getPostWithCategories(postId: string) {
  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: {
      postCategories: {
        include: {
          category: true
        }
      }
    }
  })
  
  return post
}

// Include project members with their roles
async function getProjectWithMembers(projectId: string) {
  const project = await prisma.project.findUnique({
    where: { id: projectId },
    include: {
      projectMembers: {
        include: {
          user: {
            include: {
              profile: true
            }
          },
          role: true
        }
      }
    }
  })
  
  return project
}

// Complex many-to-many with filtering
async function getUsersWithActiveProjects() {
  const users = await prisma.user.findMany({
    where: { isActive: true },
    include: {
      projectMembers: {
        where: {
          project: {
            status: 'ACTIVE'
          }
        },
        include: {
          project: true,
          role: true
        }
      }
    }
  })
  
  return users
}

// Include with junction table data
async function getProjectMembershipsWithMetadata(projectId: string) {
  const memberships = await prisma.projectMember.findMany({
    where: { projectId },
    include: {
      user: {
        include: {
          profile: true
        }
      },
      role: true,
      project: true
    }
  })
  
  return memberships
}
```

## Advanced Include Patterns

### Nested and Deep Includes
Building complex nested data structures:

```typescript
// Deep nested includes
async function getUserWithDeepRelations(userId: string) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      posts: {
        include: {
          comments: {
            include: {
              author: {
                include: {
                  profile: true
                }
              },
              replies: {
                include: {
                  author: true
                }
              }
            }
          },
          categories: {
            include: {
              category: true
            }
          },
          likes: {
            include: {
              user: true
            }
          }
        }
      },
      profile: true,
      followers: {
        include: {
          follower: {
            include: {
              profile: true
            }
          }
        }
      }
    }
  })
  
  return user
}

// Selective deep includes
async function getPostWithSelectiveDeepData(postId: string) {
  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: {
      author: {
        include: {
          profile: true,
          _count: {
            select: {
              posts: true,
              followers: true
            }
          }
        }
      },
      comments: {
        include: {
          author: {
            select: {
              id: true,
              name: true,
              profile: {
                select: {
                  avatar: true
                }
              }
            }
          }
        },
        orderBy: {
          createdAt: 'asc'
        },
        take: 10
      },
      _count: {
        select: {
          comments: true,
          likes: true
        }
      }
    }
  })
  
  return post
}

// Conditional deep includes
interface IncludeOptions {
  includeComments?: boolean
  includeAuthor?: boolean
  includeLikes?: boolean
  commentsLimit?: number
  includeReplies?: boolean
}

async function getFlexiblePostData(postId: string, options: IncludeOptions = {}) {
  const includeConfig: any = {}
  
  if (options.includeAuthor) {
    includeConfig.author = {
      include: {
        profile: true
      }
    }
  }
  
  if (options.includeComments) {
    includeConfig.comments = {
      include: {
        author: {
          select: {
            id: true,
            name: true,
            profile: {
              select: { avatar: true }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: options.commentsLimit || 5
    }
    
    if (options.includeReplies) {
      includeConfig.comments.include.replies = {
        include: {
          author: {
            select: {
              id: true,
              name: true
            }
          }
        }
      }
    }
  }
  
  if (options.includeLikes) {
    includeConfig.likes = {
      include: {
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    }
  }
  
  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: includeConfig
  })
  
  return post
}

// Hierarchical data includes
async function getCategoryHierarchy(categoryId: string) {
  const category = await prisma.category.findUnique({
    where: { id: categoryId },
    include: {
      children: {
        include: {
          children: {
            include: {
              children: true,
              posts: {
                select: {
                  id: true,
                  title: true,
                  author: {
                    select: {
                      name: true
                    }
                  }
                }
              }
            }
          },
          posts: true
        }
      },
      parent: {
        include: {
          parent: true
        }
      },
      posts: {
        include: {
          author: true
        }
      }
    }
  })
  
  return category
}
```

### Performance-Optimized Include Strategies
Building efficient include patterns for production applications:

```typescript
// Pagination with includes
async function getPaginatedPostsWithRelations(
  page: number = 1,
  limit: number = 10
) {
  const skip = (page - 1) * limit
  
  const [posts, total] = await Promise.all([
    prisma.post.findMany({
      skip,
      take: limit,
      include: {
        author: {
          select: {
            id: true,
            name: true,
            profile: {
              select: {
                avatar: true
              }
            }
          }
        },
        _count: {
          select: {
            comments: true,
            likes: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    }),
    prisma.post.count()
  ])
  
  return {
    posts,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      hasNext: page * limit < total,
      hasPrev: page > 1
    }
  }
}

// Batch loading with includes
async function getBatchUsersWithData(userIds: string[]) {
  // Split into chunks to avoid overwhelming the database
  const chunkSize = 50
  const chunks = []
  
  for (let i = 0; i < userIds.length; i += chunkSize) {
    chunks.push(userIds.slice(i, i + chunkSize))
  }
  
  const results = await Promise.all(
    chunks.map(chunk =>
      prisma.user.findMany({
        where: {
          id: { in: chunk }
        },
        include: {
          profile: true,
          posts: {
            select: {
              id: true,
              title: true,
              createdAt: true
            },
            orderBy: {
              createdAt: 'desc'
            },
            take: 5
          },
          _count: {
            select: {
              posts: true,
              comments: true,
              followers: true
            }
          }
        }
      })
    )
  )
  
  return results.flat()
}

// Smart caching with includes
class IncludeCache {
  private cache = new Map<string, { data: any; timestamp: number }>()
  private ttl = 5 * 60 * 1000 // 5 minutes
  
  async getUserWithCache(userId: string, includeOptions: any = {}) {
    const cacheKey = `user:${userId}:${JSON.stringify(includeOptions)}`
    const cached = this.cache.get(cacheKey)
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data
    }
    
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: includeOptions
    })
    
    if (user) {
      this.cache.set(cacheKey, {
        data: user,
        timestamp: Date.now()
      })
    }
    
    return user
  }
  
  invalidateUser(userId: string) {
    // Remove all cached entries for this user
    for (const [key] of this.cache) {
      if (key.startsWith(`user:${userId}:`)) {
        this.cache.delete(key)
      }
    }
  }
  
  clearExpired() {
    const now = Date.now()
    for (const [key, value] of this.cache) {
      if (now - value.timestamp >= this.ttl) {
        this.cache.delete(key)
      }
    }
  }
}

const includeCache = new IncludeCache()

// Performance monitoring for includes
async function getPostWithPerformanceTracking(postId: string) {
  const startTime = Date.now()
  
  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: {
      author: {
        include: {
          profile: true
        }
      },
      comments: {
        include: {
          author: true
        }
      },
      categories: {
        include: {
          category: true
        }
      }
    }
  })
  
  const endTime = Date.now()
  const queryTime = endTime - startTime
  
  // Log slow queries
  if (queryTime > 1000) {
    console.warn(`Slow include query detected: ${queryTime}ms for post ${postId}`)
  }
  
  return {
    post,
    metadata: {
      queryTime,
      includedRelations: ['author', 'comments', 'categories']
    }
  }
}
```

## Production-Ready Include Systems

### Dynamic Include Builder
Building flexible include systems for different use cases:

```typescript
// Dynamic include builder
class IncludeBuilder {
  private includes: any = {}
  
  // Basic relationship includes
  includeAuthor(deep: boolean = false): this {
    this.includes.author = deep ? {
      include: {
        profile: true,
        _count: {
          select: {
            posts: true,
            followers: true
          }
        }
      }
    } : true
    
    return this
  }
  
  includeComments(options: {
    limit?: number
    includeAuthor?: boolean
    includeReplies?: boolean
  } = {}): this {
    const commentsInclude: any = {
      orderBy: { createdAt: 'desc' }
    }
    
    if (options.limit) {
      commentsInclude.take = options.limit
    }
    
    if (options.includeAuthor) {
      commentsInclude.include = {
        author: {
          select: {
            id: true,
            name: true,
            profile: {
              select: { avatar: true }
            }
          }
        }
      }
      
      if (options.includeReplies) {
        commentsInclude.include.replies = {
          include: {
            author: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    }
    
    this.includes.comments = commentsInclude
    return this
  }
  
  includeCategories(): this {
    this.includes.categories = {
      include: {
        category: true
      }
    }
    return this
  }
  
  includeLikes(includeUsers: boolean = false): this {
    if (includeUsers) {
      this.includes.likes = {
        include: {
          user: {
            select: {
              id: true,
              name: true
            }
          }
        }
      }
    } else {
      this.includes.likes = true
    }
    return this
  }
  
  includeCounts(counts: string[] = ['comments', 'likes']): this {
    const countSelect: any = {}
    counts.forEach(count => {
      countSelect[count] = true
    })
    
    this.includes._count = {
      select: countSelect
    }
    
    return this
  }
  
  build(): any {
    return { ...this.includes }
  }
  
  reset(): this {
    this.includes = {}
    return this
  }
}

// Usage examples
async function getPostForAPI(postId: string, includeLevel: 'basic' | 'detailed' | 'full' = 'basic') {
  const builder = new IncludeBuilder()
  
  switch (includeLevel) {
    case 'basic':
      builder.includeAuthor().includeCounts()
      break
    case 'detailed':
      builder
        .includeAuthor(true)
        .includeComments({ limit: 5, includeAuthor: true })
        .includeCounts()
      break
    case 'full':
      builder
        .includeAuthor(true)
        .includeComments({ limit: 10, includeAuthor: true, includeReplies: true })
        .includeCategories()
        .includeLikes(true)
        .includeCounts()
      break
  }
  
  const includeOptions = builder.build()
  
  const post = await prisma.post.findUnique({
    where: { id: postId },
    include: includeOptions
  })
  
  return post
}

// Role-based include system
interface UserRole {
  canViewPrivateData: boolean
  canViewAnalytics: boolean
  canViewFullProfiles: boolean
}

async function getUserDataByRole(userId: string, userRole: UserRole) {
  const includeOptions: any = {
    profile: userRole.canViewFullProfiles ? true : {
      select: {
        avatar: true,
        bio: true
      }
    }
  }
  
  if (userRole.canViewPrivateData) {
    includeOptions.posts = {
      include: {
        comments: true
      }
    }
    includeOptions.comments = true
  } else {
    includeOptions.posts = {
      where: {
        published: true
      },
      select: {
        id: true,
        title: true,
        createdAt: true
      }
    }
  }
  
  if (userRole.canViewAnalytics) {
    includeOptions._count = {
      select: {
        posts: true,
        comments: true,
        followers: true,
        following: true
      }
    }
  }
  
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: includeOptions
  })
  
  return user
}

// API endpoint optimization
class APIIncludeOptimizer {
  private static presets = {
    'user-profile': {
      profile: true,
      _count: {
        select: {
          posts: true,
          followers: true
        }
      }
    },
    'user-with-posts': {
      profile: true,
      posts: {
        select: {
          id: true,
          title: true,
          createdAt: true,
          _count: {
            select: {
              comments: true,
              likes: true
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: 10
      }
    },
    'post-detail': {
      author: {
        include: {
          profile: true
        }
      },
      comments: {
        include: {
          author: {
            select: {
              id: true,
              name: true,
              profile: {
                select: { avatar: true }
              }
            }
          }
        },
        orderBy: { createdAt: 'asc' }
      },
      _count: {
        select: {
          likes: true
        }
      }
    }
  }
  
  static getPreset(name: keyof typeof APIIncludeOptimizer.presets) {
    return this.presets[name]
  }
  
  static combinePresets(...names: Array<keyof typeof APIIncludeOptimizer.presets>) {
    return names.reduce((combined, name) => {
      return { ...combined, ...this.presets[name] }
    }, {})
  }
}

// Usage in API routes
async function handleUserProfileRequest(userId: string, preset: string = 'user-profile') {
  const includeOptions = APIIncludeOptimizer.getPreset(preset as any)
  
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: includeOptions
  })
  
  return user
}
```

## Exercise: Advanced Include System

Build a comprehensive include management system:

```typescript
// Your task: Create a sophisticated include system

// Requirements:
// 1. Support dynamic include building with type safety
// 2. Implement performance monitoring and optimization
// 3. Add caching layer for frequently accessed includes
// 4. Support role-based include filtering
// 5. Include pagination and batching capabilities
// 6. Add query optimization and analysis
// 7. Support circular reference detection and prevention
// 8. Implement include preset management for different use cases

interface AdvancedIncludeSystem {
  // Define the comprehensive include interface
}

class MasterIncludeEngine {
  // Implement the advanced include system
  
  // Methods to implement:
  // - buildInclude(config: IncludeConfig): IncludeOptions
  // - optimizeQuery(model: string, include: any): OptimizedInclude
  // - cacheInclude(key: string, data: any, ttl?: number): void
  // - getCachedInclude(key: string): any | null
  // - validateIncludes(includes: any): ValidationResult
  // - analyzePerformance(queryResult: any): PerformanceMetrics
  // - detectCircularReferences(includes: any): CircularReference[]
  // - createPreset(name: string, config: IncludeConfig): void
  // - loadPreset(name: string): IncludeConfig
}

// Bonus features:
// - GraphQL-style include syntax support
// - Automatic include optimization based on usage patterns
// - Real-time include performance monitoring
// - Include dependency graph visualization
// - Automated include testing and validation
// - Integration with application metrics and monitoring
```

## Key Takeaways

1. **Basic Includes**: Use `include` to fetch related data in single queries efficiently
2. **Nested Relationships**: Build complex data structures with deep nested includes
3. **Performance Optimization**: Balance data completeness with query performance
4. **Dynamic Building**: Create flexible include systems that adapt to different needs
5. **Caching Strategies**: Implement intelligent caching for frequently accessed data
6. **Role-Based Access**: Filter includes based on user permissions and roles
7. **Production Patterns**: Build scalable include systems for enterprise applications

Understanding includes is fundamental to building efficient Prisma applications that deliver rich, interconnected data while maintaining optimal performance.

---

**Estimated Time:** 26 minutes
**Difficulty:** Intermediate to Advanced
**Prerequisites:** Understanding of database relationships, JOIN operations, and performance optimization concepts
