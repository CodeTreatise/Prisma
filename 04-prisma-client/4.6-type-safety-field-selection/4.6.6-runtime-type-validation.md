# 4.6.6 Runtime Type Validation

*Think like a master security guard who checks every entry against multiple credentials - runtime type validation ensures that data flowing through your application matches your TypeScript types at runtime, providing bulletproof safety in production environments.*

## Learning Objectives
- Master runtime type validation with Prisma and TypeScript
- Build comprehensive validation pipelines for data integrity
- Learn to create type-safe parsing and transformation systems
- Develop robust error handling and validation reporting

## The Master Security Guard's Checkpoint Analogy

Just as a master security guard maintains multiple checkpoints with different validation levels—from basic ID checks to comprehensive security screening—runtime type validation creates layered verification systems that ensure your data maintains type safety from compile time through runtime execution.

## 1. Schema Validation with Zod

### Basic Validation Patterns

```typescript
// Comprehensive validation using Zod with Prisma types
import { z } from 'zod';
import { User, Post, Profile, Comment } from '@prisma/client';

namespace ValidationSchemas {
  // Core entity validation schemas
  export const UserSchema = z.object({
    id: z.string().uuid(),
    email: z.string().email(),
    firstName: z.string().min(1).max(50).nullable(),
    lastName: z.string().min(1).max(50).nullable(),
    isActive: z.boolean(),
    createdAt: z.date(),
    updatedAt: z.date(),
    lastLogin: z.date().nullable()
  });

  export const ProfileSchema = z.object({
    id: z.string().uuid(),
    userId: z.string().uuid(),
    bio: z.string().max(500).nullable(),
    avatar: z.string().url().nullable(),
    website: z.string().url().nullable(),
    location: z.string().max(100).nullable(),
    socialLinks: z.record(z.string().url()).optional(),
    createdAt: z.date(),
    updatedAt: z.date()
  });

  export const PostSchema = z.object({
    id: z.string().uuid(),
    title: z.string().min(3).max(200),
    content: z.string().min(10),
    published: z.boolean(),
    publishedAt: z.date().nullable(),
    authorId: z.string().uuid(),
    categoryId: z.string().uuid().nullable(),
    featured: z.boolean().optional(),
    viewCount: z.number().min(0).optional(),
    metaTitle: z.string().max(60).nullable(),
    metaDescription: z.string().max(160).nullable(),
    createdAt: z.date(),
    updatedAt: z.date()
  });

  // Input validation schemas for API endpoints
  export const CreateUserSchema = z.object({
    email: z.string().email(),
    firstName: z.string().min(1).max(50).optional(),
    lastName: z.string().min(1).max(50).optional(),
    password: z.string().min(8).max(128),
    isActive: z.boolean().default(true)
  });

  export const UpdateUserSchema = z.object({
    firstName: z.string().min(1).max(50).optional(),
    lastName: z.string().min(1).max(50).optional(),
    email: z.string().email().optional(),
    isActive: z.boolean().optional()
  }).refine(
    (data) => Object.keys(data).length > 0,
    { message: "At least one field must be provided for update" }
  );

  export const CreatePostSchema = z.object({
    title: z.string().min(3).max(200),
    content: z.string().min(10),
    categoryId: z.string().uuid().optional(),
    published: z.boolean().default(false),
    publishNow: z.boolean().optional(),
    scheduledFor: z.string().datetime().optional(),
    tags: z.array(z.string().min(1).max(50)).max(10).optional(),
    metaTitle: z.string().max(60).optional(),
    metaDescription: z.string().max(160).optional()
  }).refine(
    (data) => {
      if (data.publishNow && data.scheduledFor) {
        return false; // Can't have both
      }
      return true;
    },
    { message: "Cannot set both publishNow and scheduledFor" }
  );

  export const CreateProfileSchema = z.object({
    bio: z.string().max(500).optional(),
    avatar: z.string().url().optional(),
    website: z.string().url().optional(),
    location: z.string().max(100).optional(),
    socialLinks: z.object({
      twitter: z.string().url().optional(),
      linkedin: z.string().url().optional(),
      github: z.string().url().optional(),
      instagram: z.string().url().optional()
    }).optional()
  });

  // Query parameter validation
  export const PaginationSchema = z.object({
    page: z.coerce.number().min(1).default(1),
    limit: z.coerce.number().min(1).max(100).default(10),
    sort: z.enum(['asc', 'desc']).default('desc'),
    sortBy: z.string().optional()
  });

  export const PostFilterSchema = z.object({
    published: z.coerce.boolean().optional(),
    categoryId: z.string().uuid().optional(),
    authorId: z.string().uuid().optional(),
    search: z.string().min(2).optional(),
    featured: z.coerce.boolean().optional(),
    dateFrom: z.string().datetime().optional(),
    dateTo: z.string().datetime().optional()
  });

  export const UserFilterSchema = z.object({
    isActive: z.coerce.boolean().optional(),
    hasProfile: z.coerce.boolean().optional(),
    registeredAfter: z.string().datetime().optional(),
    registeredBefore: z.string().datetime().optional(),
    search: z.string().min(2).optional()
  });

  // Combined schemas for complex operations
  export const PostWithRelationsSchema = PostSchema.extend({
    author: UserSchema.pick({ id: true, firstName: true, lastName: true, email: true }),
    category: z.object({
      id: z.string().uuid(),
      name: z.string(),
      slug: z.string()
    }).optional(),
    tags: z.array(z.object({
      tag: z.object({
        id: z.string().uuid(),
        name: z.string(),
        slug: z.string()
      })
    })).optional(),
    _count: z.object({
      comments: z.number(),
      likes: z.number()
    }).optional()
  });
}

class ValidationService {
  // Validate and parse input data
  async validateCreateUser(data: unknown): Promise<z.infer<typeof ValidationSchemas.CreateUserSchema>> {
    try {
      const parsed = ValidationSchemas.CreateUserSchema.parse(data);
      
      // Additional business logic validation
      await this.validateUniqueEmail(parsed.email);
      await this.validatePasswordStrength(parsed.password);
      
      return parsed;
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid user data', error.errors);
      }
      throw error;
    }
  }

  async validateUpdateUser(data: unknown): Promise<z.infer<typeof ValidationSchemas.UpdateUserSchema>> {
    try {
      const parsed = ValidationSchemas.UpdateUserSchema.parse(data);
      
      // Additional validation if email is being updated
      if (parsed.email) {
        await this.validateUniqueEmail(parsed.email);
      }
      
      return parsed;
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid update data', error.errors);
      }
      throw error;
    }
  }

  async validateCreatePost(data: unknown, authorId: string): Promise<z.infer<typeof ValidationSchemas.CreatePostSchema>> {
    try {
      const parsed = ValidationSchemas.CreatePostSchema.parse(data);
      
      // Additional validation
      await this.validatePostTitle(parsed.title);
      
      if (parsed.categoryId) {
        await this.validateCategoryExists(parsed.categoryId);
      }
      
      if (parsed.scheduledFor) {
        this.validateFutureDate(new Date(parsed.scheduledFor));
      }
      
      return parsed;
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid post data', error.errors);
      }
      throw error;
    }
  }

  // Validate query parameters
  validatePagination(data: unknown): z.infer<typeof ValidationSchemas.PaginationSchema> {
    return ValidationSchemas.PaginationSchema.parse(data);
  }

  validatePostFilters(data: unknown): z.infer<typeof ValidationSchemas.PostFilterSchema> {
    return ValidationSchemas.PostFilterSchema.parse(data);
  }

  // Validate database results
  async validateDatabaseResult<T>(
    data: unknown,
    schema: z.ZodSchema<T>,
    context: string
  ): Promise<T> {
    try {
      return schema.parse(data);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error(`Database validation failed for ${context}:`, error.errors);
        throw new DatabaseValidationError(`Invalid data from database: ${context}`, error.errors);
      }
      throw error;
    }
  }

  // Batch validation
  async validateMany<T>(
    items: unknown[],
    schema: z.ZodSchema<T>
  ): Promise<{ valid: T[]; invalid: Array<{ item: unknown; errors: z.ZodError }> }> {
    const valid: T[] = [];
    const invalid: Array<{ item: unknown; errors: z.ZodError }> = [];

    for (const item of items) {
      try {
        const parsed = schema.parse(item);
        valid.push(parsed);
      } catch (error) {
        if (error instanceof z.ZodError) {
          invalid.push({ item, errors: error });
        } else {
          throw error;
        }
      }
    }

    return { valid, invalid };
  }

  // Custom validation methods
  private async validateUniqueEmail(email: string): Promise<void> {
    const existingUser = await prisma.user.findUnique({
      where: { email },
      select: { id: true }
    });

    if (existingUser) {
      throw new BusinessValidationError('Email already exists');
    }
  }

  private async validatePasswordStrength(password: string): Promise<void> {
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);

    if (!hasUpperCase || !hasLowerCase || !hasNumbers || !hasSpecialChar) {
      throw new BusinessValidationError(
        'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'
      );
    }
  }

  private async validatePostTitle(title: string): Promise<void> {
    // Check for duplicate titles
    const existingPost = await prisma.post.findFirst({
      where: {
        title: {
          equals: title,
          mode: 'insensitive'
        }
      },
      select: { id: true }
    });

    if (existingPost) {
      throw new BusinessValidationError('Post title already exists');
    }
  }

  private async validateCategoryExists(categoryId: string): Promise<void> {
    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      select: { id: true }
    });

    if (!category) {
      throw new BusinessValidationError('Category does not exist');
    }
  }

  private validateFutureDate(date: Date): void {
    if (date <= new Date()) {
      throw new BusinessValidationError('Scheduled date must be in the future');
    }
  }
}
```

### Advanced Validation Patterns

```typescript
// Advanced validation with custom logic and transformations
namespace AdvancedValidation {
  // Custom validation functions
  export const validateSlug = (slug: string) => {
    const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
    return slugRegex.test(slug);
  };

  export const validateColor = (color: string) => {
    const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    return hexRegex.test(color);
  };

  export const validateImageUrl = async (url: string): Promise<boolean> => {
    try {
      const response = await fetch(url, { method: 'HEAD' });
      const contentType = response.headers.get('content-type');
      return contentType?.startsWith('image/') ?? false;
    } catch {
      return false;
    }
  };

  // Custom Zod refinements
  export const slugRefinement = z.string().refine(validateSlug, {
    message: 'Slug must contain only lowercase letters, numbers, and hyphens'
  });

  export const colorRefinement = z.string().refine(validateColor, {
    message: 'Must be a valid hex color'
  });

  export const imageUrlRefinement = z.string().url().refine(validateImageUrl, {
    message: 'Must be a valid image URL'
  });

  // Complex validation schemas
  export const CategorySchema = z.object({
    name: z.string().min(2).max(50),
    slug: slugRefinement,
    description: z.string().max(200).optional(),
    color: colorRefinement.optional(),
    parentId: z.string().uuid().optional(),
    image: imageUrlRefinement.optional(),
    isActive: z.boolean().default(true),
    sortOrder: z.number().min(0).default(0)
  }).refine(
    async (data) => {
      // Validate parent category exists
      if (data.parentId) {
        const parent = await prisma.category.findUnique({
          where: { id: data.parentId },
          select: { id: true }
        });
        return !!parent;
      }
      return true;
    },
    { message: 'Parent category does not exist' }
  );

  export const TagSchema = z.object({
    name: z.string().min(1).max(30),
    slug: slugRefinement,
    color: colorRefinement.optional(),
    description: z.string().max(100).optional()
  });

  // File upload validation
  export const ImageUploadSchema = z.object({
    file: z.object({
      name: z.string(),
      size: z.number().max(5 * 1024 * 1024), // 5MB max
      type: z.string().regex(/^image\/(jpeg|png|gif|webp)$/),
      buffer: z.instanceof(Buffer)
    }),
    altText: z.string().min(1).max(100).optional(),
    caption: z.string().max(200).optional()
  });

  // Bulk operation validation
  export const BulkUpdateSchema = z.object({
    ids: z.array(z.string().uuid()).min(1).max(100),
    operation: z.enum(['publish', 'unpublish', 'delete', 'archive']),
    data: z.record(z.any()).optional()
  });

  // API response validation
  export const ApiResponseSchema = <T>(dataSchema: z.ZodSchema<T>) => z.object({
    success: z.boolean(),
    data: dataSchema.optional(),
    error: z.object({
      message: z.string(),
      code: z.string(),
      details: z.any().optional()
    }).optional(),
    meta: z.object({
      timestamp: z.string().datetime(),
      requestId: z.string().uuid(),
      duration: z.number()
    })
  });

  // Form validation with dependent fields
  export const PostFormSchema = z.object({
    title: z.string().min(3).max(200),
    content: z.string().min(10),
    categoryId: z.string().uuid().optional(),
    tags: z.array(z.string()).max(10).optional(),
    published: z.boolean(),
    publishedAt: z.string().datetime().optional(),
    metaTitle: z.string().max(60).optional(),
    metaDescription: z.string().max(160).optional(),
    featuredImage: z.string().url().optional(),
    allowComments: z.boolean().default(true),
    seoSettings: z.object({
      noIndex: z.boolean().default(false),
      noFollow: z.boolean().default(false),
      canonicalUrl: z.string().url().optional()
    }).optional()
  }).superRefine((data, ctx) => {
    // If published, require publishedAt
    if (data.published && !data.publishedAt) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Published date is required when publishing',
        path: ['publishedAt']
      });
    }

    // If published, require meta description
    if (data.published && !data.metaDescription) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Meta description is required for published posts',
        path: ['metaDescription']
      });
    }

    // Validate title and meta title aren't identical
    if (data.metaTitle && data.metaTitle === data.title) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Meta title should be different from post title',
        path: ['metaTitle']
      });
    }
  });
}

class AdvancedValidationService {
  // Validate with transformation
  async validateAndTransformPost(data: unknown): Promise<{
    valid: z.infer<typeof AdvancedValidation.PostFormSchema>;
    transformed: any;
  }> {
    const valid = AdvancedValidation.PostFormSchema.parse(data);
    
    // Transform the data
    const transformed = {
      ...valid,
      slug: this.generateSlug(valid.title),
      excerpt: this.generateExcerpt(valid.content),
      readingTime: this.calculateReadingTime(valid.content),
      wordCount: this.countWords(valid.content),
      publishedAt: valid.published ? 
        (valid.publishedAt ? new Date(valid.publishedAt) : new Date()) :
        null,
      tags: valid.tags ? await this.processTags(valid.tags) : []
    };

    return { valid, transformed };
  }

  // Validate file uploads
  async validateImageUpload(data: unknown): Promise<{
    isValid: boolean;
    file?: z.infer<typeof AdvancedValidation.ImageUploadSchema>;
    errors?: z.ZodError;
  }> {
    try {
      const file = AdvancedValidation.ImageUploadSchema.parse(data);
      
      // Additional validation
      const isValidImage = await this.validateImageContent(file.file.buffer);
      if (!isValidImage) {
        throw new ValidationError('Invalid image content');
      }

      return { isValid: true, file };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return { isValid: false, errors: error };
      }
      throw error;
    }
  }

  // Validate bulk operations
  async validateBulkOperation(data: unknown): Promise<{
    operation: z.infer<typeof AdvancedValidation.BulkUpdateSchema>;
    validIds: string[];
    invalidIds: string[];
  }> {
    const operation = AdvancedValidation.BulkUpdateSchema.parse(data);
    
    // Validate that all IDs exist
    const validIds: string[] = [];
    const invalidIds: string[] = [];

    for (const id of operation.ids) {
      const exists = await this.checkEntityExists(id);
      if (exists) {
        validIds.push(id);
      } else {
        invalidIds.push(id);
      }
    }

    return { operation, validIds, invalidIds };
  }

  // Pipeline validation
  async validatePipeline<T>(
    data: unknown,
    pipeline: Array<{
      name: string;
      validator: (data: any) => Promise<any> | any;
      required: boolean;
    }>
  ): Promise<{
    isValid: boolean;
    result?: T;
    errors: Array<{ stage: string; error: string }>;
  }> {
    const errors: Array<{ stage: string; error: string }> = [];
    let currentData = data;

    for (const stage of pipeline) {
      try {
        currentData = await stage.validator(currentData);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        errors.push({ stage: stage.name, error: errorMessage });
        
        if (stage.required) {
          return { isValid: false, errors };
        }
      }
    }

    return {
      isValid: errors.length === 0,
      result: currentData as T,
      errors
    };
  }

  // Helper methods
  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  private generateExcerpt(content: string, maxLength: number = 150): string {
    const stripped = content.replace(/<[^>]*>/g, '');
    return stripped.length > maxLength 
      ? stripped.substring(0, maxLength) + '...'
      : stripped;
  }

  private calculateReadingTime(content: string): number {
    const words = this.countWords(content);
    return Math.ceil(words / 200); // 200 WPM average
  }

  private countWords(content: string): number {
    return content.trim().split(/\s+/).length;
  }

  private async processTags(tagNames: string[]): Promise<string[]> {
    const processedTags: string[] = [];
    
    for (const tagName of tagNames) {
      const tag = await prisma.tag.upsert({
        where: { name: tagName },
        update: {},
        create: {
          name: tagName,
          slug: this.generateSlug(tagName)
        }
      });
      processedTags.push(tag.id);
    }

    return processedTags;
  }

  private async validateImageContent(buffer: Buffer): Promise<boolean> {
    // Check if buffer contains valid image data
    // This is a simplified check - in production, use a proper image validation library
    const signatures = {
      jpeg: [0xFF, 0xD8, 0xFF],
      png: [0x89, 0x50, 0x4E, 0x47],
      gif: [0x47, 0x49, 0x46],
      webp: [0x52, 0x49, 0x46, 0x46]
    };

    for (const [format, signature] of Object.entries(signatures)) {
      if (buffer.subarray(0, signature.length).every((byte, i) => byte === signature[i])) {
        return true;
      }
    }

    return false;
  }

  private async checkEntityExists(id: string): Promise<boolean> {
    // Check if entity exists in database
    const entity = await prisma.post.findUnique({
      where: { id },
      select: { id: true }
    });
    return !!entity;
  }
}
```

## 2. Custom Error Classes and Handling

### Comprehensive Error System

```typescript
// Custom error classes for different validation scenarios
export class ValidationError extends Error {
  public readonly type = 'ValidationError';
  public readonly errors: z.ZodIssue[];

  constructor(message: string, errors: z.ZodIssue[]) {
    super(message);
    this.name = 'ValidationError';
    this.errors = errors;
  }

  getFormattedErrors(): Record<string, string[]> {
    const formatted: Record<string, string[]> = {};
    
    for (const error of this.errors) {
      const path = error.path.join('.');
      if (!formatted[path]) {
        formatted[path] = [];
      }
      formatted[path].push(error.message);
    }

    return formatted;
  }

  getFirstError(): string {
    return this.errors[0]?.message || this.message;
  }
}

export class BusinessValidationError extends Error {
  public readonly type = 'BusinessValidationError';
  public readonly field?: string;
  public readonly code?: string;

  constructor(message: string, field?: string, code?: string) {
    super(message);
    this.name = 'BusinessValidationError';
    this.field = field;
    this.code = code;
  }
}

export class DatabaseValidationError extends Error {
  public readonly type = 'DatabaseValidationError';
  public readonly errors: z.ZodIssue[];

  constructor(message: string, errors: z.ZodIssue[]) {
    super(message);
    this.name = 'DatabaseValidationError';
    this.errors = errors;
  }
}

export class AuthorizationError extends Error {
  public readonly type = 'AuthorizationError';
  public readonly action: string;
  public readonly resource: string;

  constructor(message: string, action: string, resource: string) {
    super(message);
    this.name = 'AuthorizationError';
    this.action = action;
    this.resource = resource;
  }
}

// Error handler service
class ErrorHandlingService {
  handleValidationError(error: unknown): {
    status: number;
    message: string;
    errors?: any;
    code?: string;
  } {
    if (error instanceof ValidationError) {
      return {
        status: 400,
        message: 'Validation failed',
        errors: error.getFormattedErrors(),
        code: 'VALIDATION_ERROR'
      };
    }

    if (error instanceof BusinessValidationError) {
      return {
        status: 422,
        message: error.message,
        errors: error.field ? { [error.field]: [error.message] } : undefined,
        code: error.code || 'BUSINESS_RULE_VIOLATION'
      };
    }

    if (error instanceof DatabaseValidationError) {
      return {
        status: 500,
        message: 'Database validation failed',
        code: 'DATABASE_VALIDATION_ERROR'
      };
    }

    if (error instanceof AuthorizationError) {
      return {
        status: 403,
        message: error.message,
        code: 'AUTHORIZATION_ERROR'
      };
    }

    // Generic error handling
    console.error('Unhandled error:', error);
    return {
      status: 500,
      message: 'Internal server error',
      code: 'INTERNAL_ERROR'
    };
  }

  logValidationError(error: ValidationError, context: any): void {
    console.error('Validation Error:', {
      message: error.message,
      errors: error.getFormattedErrors(),
      context,
      timestamp: new Date().toISOString()
    });
  }

  createErrorResponse(error: unknown, requestId?: string) {
    const errorInfo = this.handleValidationError(error);
    
    return {
      success: false,
      error: {
        message: errorInfo.message,
        code: errorInfo.code,
        ...(errorInfo.errors && { details: errorInfo.errors })
      },
      meta: {
        timestamp: new Date().toISOString(),
        requestId: requestId || 'unknown'
      }
    };
  }
}
```

## 3. Production-Ready Validation Patterns

### Middleware and Integration

```typescript
// Express middleware for validation
import { Request, Response, NextFunction } from 'express';

interface ValidatedRequest<TBody = any, TQuery = any, TParams = any> extends Request {
  validatedBody: TBody;
  validatedQuery: TQuery;
  validatedParams: TParams;
}

function validateBody<T>(schema: z.ZodSchema<T>) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.body);
      (req as ValidatedRequest<T>).validatedBody = validated;
      next();
    } catch (error) {
      const errorHandler = new ErrorHandlingService();
      const errorResponse = errorHandler.createErrorResponse(error, req.headers['x-request-id'] as string);
      
      const errorInfo = errorHandler.handleValidationError(error);
      return res.status(errorInfo.status).json(errorResponse);
    }
  };
}

function validateQuery<T>(schema: z.ZodSchema<T>) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.query);
      (req as ValidatedRequest<any, T>).validatedQuery = validated;
      next();
    } catch (error) {
      const errorHandler = new ErrorHandlingService();
      const errorResponse = errorHandler.createErrorResponse(error, req.headers['x-request-id'] as string);
      
      const errorInfo = errorHandler.handleValidationError(error);
      return res.status(errorInfo.status).json(errorResponse);
    }
  };
}

function validateParams<T>(schema: z.ZodSchema<T>) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.params);
      (req as ValidatedRequest<any, any, T>).validatedParams = validated;
      next();
    } catch (error) {
      const errorHandler = new ErrorHandlingService();
      const errorResponse = errorHandler.createErrorResponse(error, req.headers['x-request-id'] as string);
      
      const errorInfo = errorHandler.handleValidationError(error);
      return res.status(errorInfo.status).json(errorResponse);
    }
  };
}

// Usage examples with Express routes
const router = express.Router();

// Create user endpoint
router.post('/users',
  validateBody(ValidationSchemas.CreateUserSchema),
  async (req: ValidatedRequest<z.infer<typeof ValidationSchemas.CreateUserSchema>>, res: Response) => {
    try {
      const validationService = new ValidationService();
      const userData = await validationService.validateCreateUser(req.validatedBody);
      
      const user = await prisma.user.create({
        data: userData,
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          isActive: true,
          createdAt: true
        }
      });

      res.status(201).json({
        success: true,
        data: user,
        meta: {
          timestamp: new Date().toISOString(),
          requestId: req.headers['x-request-id']
        }
      });
    } catch (error) {
      const errorHandler = new ErrorHandlingService();
      const errorResponse = errorHandler.createErrorResponse(error, req.headers['x-request-id'] as string);
      
      const errorInfo = errorHandler.handleValidationError(error);
      res.status(errorInfo.status).json(errorResponse);
    }
  }
);

// Get posts endpoint with filters
router.get('/posts',
  validateQuery(ValidationSchemas.PostFilterSchema.merge(ValidationSchemas.PaginationSchema)),
  async (req: ValidatedRequest<any, z.infer<typeof ValidationSchemas.PostFilterSchema> & z.infer<typeof ValidationSchemas.PaginationSchema>>, res: Response) => {
    try {
      const { page, limit, sort, sortBy, ...filters } = req.validatedQuery;
      
      const posts = await prisma.post.findMany({
        where: {
          ...(filters.published !== undefined && { published: filters.published }),
          ...(filters.categoryId && { categoryId: filters.categoryId }),
          ...(filters.authorId && { authorId: filters.authorId }),
          ...(filters.featured !== undefined && { featured: filters.featured }),
          ...(filters.search && {
            OR: [
              { title: { contains: filters.search, mode: 'insensitive' } },
              { content: { contains: filters.search, mode: 'insensitive' } }
            ]
          }),
          ...(filters.dateFrom && filters.dateTo && {
            createdAt: {
              gte: new Date(filters.dateFrom),
              lte: new Date(filters.dateTo)
            }
          })
        },
        include: {
          author: {
            select: { id: true, firstName: true, lastName: true }
          },
          category: true,
          _count: {
            select: { comments: true, likes: true }
          }
        },
        orderBy: {
          [sortBy || 'createdAt']: sort
        },
        skip: (page - 1) * limit,
        take: limit
      });

      const total = await prisma.post.count({
        where: {
          ...(filters.published !== undefined && { published: filters.published }),
          ...(filters.categoryId && { categoryId: filters.categoryId }),
          ...(filters.authorId && { authorId: filters.authorId })
        }
      });

      res.json({
        success: true,
        data: posts,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
          hasNext: page * limit < total,
          hasPrev: page > 1
        },
        meta: {
          timestamp: new Date().toISOString(),
          requestId: req.headers['x-request-id']
        }
      });
    } catch (error) {
      const errorHandler = new ErrorHandlingService();
      const errorResponse = errorHandler.createErrorResponse(error, req.headers['x-request-id'] as string);
      
      const errorInfo = errorHandler.handleValidationError(error);
      res.status(errorInfo.status).json(errorResponse);
    }
  }
);

// Type-safe service layer
class TypeSafePostService {
  private validationService = new ValidationService();
  private errorHandler = new ErrorHandlingService();

  async createPost(
    data: unknown,
    authorId: string
  ): Promise<{ success: true; data: Post } | { success: false; error: any }> {
    try {
      const validatedData = await this.validationService.validateCreatePost(data, authorId);
      
      const post = await prisma.post.create({
        data: {
          title: validatedData.title,
          content: validatedData.content,
          published: validatedData.published,
          publishedAt: validatedData.publishNow ? new Date() :
                       validatedData.scheduledFor ? new Date(validatedData.scheduledFor) : null,
          authorId,
          categoryId: validatedData.categoryId,
          metaTitle: validatedData.metaTitle,
          metaDescription: validatedData.metaDescription
        }
      });

      return { success: true, data: post };
    } catch (error) {
      return { 
        success: false, 
        error: this.errorHandler.createErrorResponse(error)
      };
    }
  }

  async updatePost(
    postId: string,
    data: unknown,
    userId: string
  ): Promise<{ success: true; data: Post } | { success: false; error: any }> {
    try {
      const validatedData = ValidationSchemas.UpdateUserSchema.parse(data);
      
      // Check authorization
      const existingPost = await prisma.post.findUnique({
        where: { id: postId },
        select: { authorId: true }
      });

      if (!existingPost) {
        throw new BusinessValidationError('Post not found');
      }

      if (existingPost.authorId !== userId) {
        throw new AuthorizationError('Not authorized to update this post', 'update', 'post');
      }

      const post = await prisma.post.update({
        where: { id: postId },
        data: validatedData
      });

      return { success: true, data: post };
    } catch (error) {
      return { 
        success: false, 
        error: this.errorHandler.createErrorResponse(error)
      };
    }
  }
}
```

## Key Takeaways

1. **Use Zod for comprehensive runtime validation** of all input data
2. **Create custom error classes** for different validation scenarios
3. **Build validation pipelines** for complex data processing
4. **Validate database results** to ensure data integrity
5. **Implement proper error handling** with detailed error messages
6. **Use middleware patterns** for consistent validation across routes

## Exercises

1. **Schema Creation**: Build comprehensive Zod schemas for your models
2. **Error Handling**: Implement custom error classes and handlers
3. **Middleware**: Create validation middleware for your API routes
4. **Pipeline Validation**: Build complex validation pipelines for data processing

---

**Duration**: 30 minutes
**Previous**: [4.6.5 Custom Type Definitions](./4.6.5-custom-type-definitions.md)
**Section Complete**: [Back to Module 4 Overview](../04-prisma-client.md)
