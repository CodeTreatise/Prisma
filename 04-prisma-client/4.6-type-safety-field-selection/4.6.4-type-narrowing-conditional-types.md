# 4.6.4 Type Narrowing & Conditional Types

*Think like a master detective who narrows down clues to solve complex cases - type narrowing allows you to progressively refine types based on runtime conditions, creating safer and more intelligent applications.*

## Learning Objectives
- Master type narrowing and type guards in Prisma
- Build conditional types based on runtime data
- Learn discriminated unions and type predicates
- Create intelligent type-safe conditional logic

## The Master Detective's Investigation Analogy

Just as a master detective uses evidence to narrow down suspects and build a precise case, type narrowing allows you to use runtime information to progressively refine your types, ensuring your code handles every possibility safely and intelligently.

## 1. Type Guards and Runtime Type Safety

### Basic Type Guards

```typescript
// Type guards for safe data access
import { User, Post, Profile, Category } from '@prisma/client'

class TypeGuardService {
  // Basic type guards for nullable fields
  hasProfile(user: User & { profile?: Profile | null }): user is User & { profile: Profile } {
    return user.profile !== null && user.profile !== undefined;
  }

  hasFullName(user: User): user is User & { firstName: string; lastName: string } {
    return user.firstName !== null && 
           user.lastName !== null && 
           user.firstName.length > 0 && 
           user.lastName.length > 0;
  }

  isPublished(post: Post): post is Post & { publishedAt: Date } {
    return post.published && post.publishedAt !== null;
  }

  hasCategory(post: Post & { category?: Category | null }): 
    post is Post & { category: Category } {
    return post.category !== null && post.category !== undefined;
  }

  // Advanced type guards with custom logic
  isActiveUser(user: User): user is User & { isActive: true; lastLogin: Date } {
    return user.isActive && 
           user.lastLogin !== null && 
           user.lastLogin > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days
  }

  isFeaturedPost(post: Post): post is Post & { featured: true; publishedAt: Date } {
    return post.featured === true && 
           post.published && 
           post.publishedAt !== null;
  }

  // Using type guards in practice
  async processUser(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        posts: {
          where: { published: true },
          include: { category: true }
        }
      }
    });

    if (!user) {
      throw new Error('User not found');
    }

    // Type narrowing with guards
    if (this.hasProfile(user)) {
      // TypeScript knows user.profile is not null
      console.log(`Bio: ${user.profile.bio || 'No bio'}`);
      console.log(`Website: ${user.profile.website || 'No website'}`);
    }

    if (this.hasFullName(user)) {
      // TypeScript knows both names are strings
      const fullName = `${user.firstName} ${user.lastName}`;
      console.log(`Full name: ${fullName}`);
    }

    if (this.isActiveUser(user)) {
      // TypeScript knows user is active with recent login
      console.log(`Last active: ${user.lastLogin.toLocaleDateString()}`);
    }

    // Process posts with type guards
    const featuredPosts = user.posts.filter(this.isFeaturedPost);
    const postsWithCategories = user.posts.filter(this.hasCategory);

    return {
      user,
      hasProfile: this.hasProfile(user),
      hasFullName: this.hasFullName(user),
      isActive: this.isActiveUser(user),
      featuredPostsCount: featuredPosts.length,
      categorizedPostsCount: postsWithCategories.length
    };
  }

  // Generic type guard factory
  createNotNullGuard<T>() {
    return function isNotNull(value: T | null | undefined): value is T {
      return value !== null && value !== undefined;
    };
  }

  createMinLengthGuard(minLength: number) {
    return function hasMinLength(value: string | null): value is string {
      return value !== null && value.length >= minLength;
    };
  }

  // Advanced filtering with type guards
  async getQualityContent() {
    const posts = await prisma.post.findMany({
      include: {
        author: {
          include: { profile: true }
        },
        category: true,
        tags: { include: { tag: true } },
        _count: {
          select: {
            comments: true,
            likes: true
          }
        }
      }
    });

    const isNotNull = this.createNotNullGuard<any>();
    const hasMinTitle = this.createMinLengthGuard(10);

    // Filter and narrow types
    const qualityPosts = posts
      .filter(this.isPublished)                    // Published posts only
      .filter(post => hasMinTitle(post.title))     // Minimum title length
      .filter(this.hasCategory)                    // Has category
      .filter(post => post._count.comments > 5)    // Minimum engagement
      .filter(post => this.hasFullName(post.author)) // Author has full name
      .map(post => ({
        ...post,
        // TypeScript knows these fields are safe
        authorName: `${post.author.firstName} ${post.author.lastName}`,
        categoryName: post.category.name,
        publishDate: post.publishedAt.toLocaleDateString()
      }));

    return qualityPosts;
  }
}
```

### Discriminated Unions and Type Narrowing

```typescript
// Advanced type narrowing with discriminated unions
namespace ContentTypes {
  // Base content interface
  interface BaseContent {
    id: string;
    title: string;
    createdAt: Date;
    authorId: string;
  }

  // Discriminated union for different content types
  export type Content = 
    | (BaseContent & { type: 'post'; content: string; published: boolean; publishedAt?: Date })
    | (BaseContent & { type: 'page'; content: string; slug: string; isLive: boolean })
    | (BaseContent & { type: 'draft'; content?: string; lastSaved: Date })
    | (BaseContent & { type: 'template'; templateData: object; category: string });

  // Status-based discriminated union
  export type UserStatus = 
    | { status: 'active'; lastLogin: Date; sessionCount: number }
    | { status: 'inactive'; lastLogin: Date | null; reason?: string }
    | { status: 'suspended'; suspendedAt: Date; reason: string; appealable: boolean }
    | { status: 'pending'; invitedAt: Date; invitationToken: string };

  // Permission-based types
  export type UserWithPermissions = User & {
    role: 'admin' | 'editor' | 'author' | 'viewer';
    permissions: string[];
  };

  export type AdminUser = UserWithPermissions & { role: 'admin' };
  export type EditorUser = UserWithPermissions & { role: 'editor' };
  export type AuthorUser = UserWithPermissions & { role: 'author' };
  export type ViewerUser = UserWithPermissions & { role: 'viewer' };
}

class ConditionalTypeService {
  // Type narrowing with discriminated unions
  processContent(content: ContentTypes.Content) {
    switch (content.type) {
      case 'post':
        // TypeScript knows this is a post
        if (content.published && content.publishedAt) {
          console.log(`Published post: ${content.title} on ${content.publishedAt}`);
          return this.handlePublishedPost(content);
        } else {
          console.log(`Draft post: ${content.title}`);
          return this.handleDraftPost(content);
        }

      case 'page':
        // TypeScript knows this is a page
        if (content.isLive) {
          console.log(`Live page: ${content.title} at /${content.slug}`);
          return this.handleLivePage(content);
        } else {
          console.log(`Draft page: ${content.title}`);
          return this.handleDraftPage(content);
        }

      case 'draft':
        // TypeScript knows this is a draft
        console.log(`Draft: ${content.title}, last saved: ${content.lastSaved}`);
        return this.handleGenericDraft(content);

      case 'template':
        // TypeScript knows this is a template
        console.log(`Template: ${content.title} in ${content.category}`);
        return this.handleTemplate(content);

      default:
        // TypeScript ensures exhaustive checking
        const _exhaustive: never = content;
        throw new Error(`Unknown content type`);
    }
  }

  // User status handling with type narrowing
  handleUserByStatus(user: User, status: ContentTypes.UserStatus) {
    switch (status.status) {
      case 'active':
        // TypeScript knows user is active
        console.log(`Active user, ${status.sessionCount} sessions, last login: ${status.lastLogin}`);
        return this.handleActiveUser(user, status);

      case 'inactive':
        // TypeScript knows user is inactive
        const lastLoginText = status.lastLogin ? 
          `last login: ${status.lastLogin}` : 'never logged in';
        console.log(`Inactive user, ${lastLoginText}`);
        return this.handleInactiveUser(user, status);

      case 'suspended':
        // TypeScript knows user is suspended
        console.log(`Suspended user since ${status.suspendedAt}, reason: ${status.reason}`);
        return this.handleSuspendedUser(user, status);

      case 'pending':
        // TypeScript knows user is pending
        console.log(`Pending user, invited at: ${status.invitedAt}`);
        return this.handlePendingUser(user, status);

      default:
        const _exhaustive: never = status;
        throw new Error(`Unknown status`);
    }
  }

  // Role-based type narrowing
  performRoleBasedAction(user: ContentTypes.UserWithPermissions, action: string) {
    switch (user.role) {
      case 'admin':
        return this.handleAdminAction(user, action);
      
      case 'editor':
        return this.handleEditorAction(user, action);
      
      case 'author':
        return this.handleAuthorAction(user, action);
      
      case 'viewer':
        return this.handleViewerAction(user, action);
      
      default:
        const _exhaustive: never = user.role;
        throw new Error(`Unknown role: ${_exhaustive}`);
    }
  }

  // Permission-based conditional logic
  private handleAdminAction(user: ContentTypes.AdminUser, action: string) {
    // TypeScript knows this is an admin
    console.log(`Admin ${user.firstName} performing: ${action}`);
    // Admins can do anything
    return { allowed: true, message: 'Admin access granted' };
  }

  private handleEditorAction(user: ContentTypes.EditorUser, action: string) {
    // TypeScript knows this is an editor
    const allowedActions = ['create', 'edit', 'publish', 'delete'];
    const allowed = allowedActions.includes(action) || 
                   user.permissions.includes(action);
    
    return { 
      allowed, 
      message: allowed ? 'Editor access granted' : 'Editor access denied' 
    };
  }

  private handleAuthorAction(user: ContentTypes.AuthorUser, action: string) {
    // TypeScript knows this is an author
    const allowedActions = ['create', 'edit'];
    const allowed = allowedActions.includes(action) || 
                   user.permissions.includes(action);
    
    return { 
      allowed, 
      message: allowed ? 'Author access granted' : 'Author access denied' 
    };
  }

  private handleViewerAction(user: ContentTypes.ViewerUser, action: string) {
    // TypeScript knows this is a viewer
    const allowedActions = ['read'];
    const allowed = allowedActions.includes(action);
    
    return { 
      allowed, 
      message: allowed ? 'Viewer access granted' : 'Viewer access denied' 
    };
  }

  // Helper methods for content processing
  private handlePublishedPost(post: Extract<ContentTypes.Content, { type: 'post'; published: true }>) {
    return { type: 'published_post', id: post.id, title: post.title };
  }

  private handleDraftPost(post: Extract<ContentTypes.Content, { type: 'post'; published: false }>) {
    return { type: 'draft_post', id: post.id, title: post.title };
  }

  private handleLivePage(page: Extract<ContentTypes.Content, { type: 'page'; isLive: true }>) {
    return { type: 'live_page', id: page.id, slug: page.slug };
  }

  private handleDraftPage(page: Extract<ContentTypes.Content, { type: 'page'; isLive: false }>) {
    return { type: 'draft_page', id: page.id, title: page.title };
  }

  private handleGenericDraft(draft: Extract<ContentTypes.Content, { type: 'draft' }>) {
    return { type: 'generic_draft', id: draft.id, lastSaved: draft.lastSaved };
  }

  private handleTemplate(template: Extract<ContentTypes.Content, { type: 'template' }>) {
    return { type: 'template', id: template.id, category: template.category };
  }

  private handleActiveUser(user: User, status: Extract<ContentTypes.UserStatus, { status: 'active' }>) {
    return { type: 'active_user', userId: user.id, sessionCount: status.sessionCount };
  }

  private handleInactiveUser(user: User, status: Extract<ContentTypes.UserStatus, { status: 'inactive' }>) {
    return { type: 'inactive_user', userId: user.id, reason: status.reason };
  }

  private handleSuspendedUser(user: User, status: Extract<ContentTypes.UserStatus, { status: 'suspended' }>) {
    return { type: 'suspended_user', userId: user.id, appealable: status.appealable };
  }

  private handlePendingUser(user: User, status: Extract<ContentTypes.UserStatus, { status: 'pending' }>) {
    return { type: 'pending_user', userId: user.id, token: status.invitationToken };
  }
}
```

## 2. Conditional Types and Advanced Patterns

### Building Intelligent Type Systems

```typescript
// Advanced conditional types for dynamic behavior
namespace ConditionalTypes {
  // Conditional type based on field presence
  export type WithOptionalProfile<T> = T extends { profile: any } 
    ? T & { profile: Profile }
    : T & { profile?: Profile | null };

  // Conditional type based on published status
  export type PublishedPost<T> = T extends { published: true }
    ? T & { publishedAt: Date }
    : T & { publishedAt?: Date | null };

  // Dynamic field selection based on role
  export type UserFieldsByRole<Role extends string> = 
    Role extends 'admin' 
      ? User & { email: string; isActive: boolean; createdAt: Date }
    : Role extends 'editor'
      ? Pick<User, 'id' | 'firstName' | 'lastName' | 'email'>
    : Role extends 'public'
      ? Pick<User, 'id' | 'firstName' | 'lastName'>
    : never;

  // Conditional include based on permissions
  export type PostWithConditionalData<IncludeAuthor extends boolean, IncludeComments extends boolean> = Post & {
    author: IncludeAuthor extends true ? User : never;
    comments: IncludeComments extends true ? Comment[] : never;
  };

  // Smart defaults based on context
  export type SmartUserDefaults<Context extends 'creation' | 'update' | 'profile'> =
    Context extends 'creation'
      ? Required<Pick<User, 'email'>> & Partial<Pick<User, 'firstName' | 'lastName' | 'isActive'>>
    : Context extends 'update'
      ? Partial<Pick<User, 'firstName' | 'lastName' | 'email' | 'isActive'>>
    : Context extends 'profile'
      ? Pick<User, 'firstName' | 'lastName'> & { profile?: Partial<Profile> }
    : never;

  // Response type based on operation
  export type ApiResponse<T, Success extends boolean> = Success extends true
    ? { success: true; data: T; message?: string }
    : { success: false; error: string; details?: any };
}

class ConditionalTypeProcessor {
  // Smart user data processing based on context
  async processUserData<TContext extends 'creation' | 'update' | 'profile'>(
    context: TContext,
    data: ConditionalTypes.SmartUserDefaults<TContext>
  ): Promise<ConditionalTypes.ApiResponse<User, true> | ConditionalTypes.ApiResponse<never, false>> {
    try {
      switch (context) {
        case 'creation':
          const creationData = data as ConditionalTypes.SmartUserDefaults<'creation'>;
          const newUser = await prisma.user.create({
            data: {
              email: creationData.email,
              firstName: creationData.firstName || null,
              lastName: creationData.lastName || null,
              isActive: creationData.isActive ?? true
            }
          });
          return { success: true, data: newUser, message: 'User created successfully' };

        case 'update':
          const updateData = data as ConditionalTypes.SmartUserDefaults<'update'>;
          // Assuming we have a user ID from somewhere
          const updatedUser = await prisma.user.update({
            where: { id: 'user-id' }, // Would come from context
            data: updateData
          });
          return { success: true, data: updatedUser, message: 'User updated successfully' };

        case 'profile':
          const profileData = data as ConditionalTypes.SmartUserDefaults<'profile'>;
          const userWithProfile = await prisma.user.update({
            where: { id: 'user-id' }, // Would come from context
            data: {
              firstName: profileData.firstName,
              lastName: profileData.lastName,
              profile: profileData.profile ? {
                upsert: {
                  create: profileData.profile,
                  update: profileData.profile
                }
              } : undefined
            },
            include: { profile: true }
          });
          return { success: true, data: userWithProfile, message: 'Profile updated successfully' };

        default:
          const _exhaustive: never = context;
          throw new Error(`Unknown context: ${_exhaustive}`);
      }
    } catch (error) {
      return { 
        success: false, 
        error: 'Operation failed', 
        details: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  // Dynamic field selection based on user role
  async getUserByRole<TRole extends 'admin' | 'editor' | 'public'>(
    userId: string,
    role: TRole
  ): Promise<ConditionalTypes.UserFieldsByRole<TRole> | null> {
    const baseUser = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!baseUser) return null;

    switch (role) {
      case 'admin':
        // Admin gets full user data
        return baseUser as ConditionalTypes.UserFieldsByRole<TRole>;

      case 'editor':
        // Editor gets limited fields
        const editorUser = {
          id: baseUser.id,
          firstName: baseUser.firstName,
          lastName: baseUser.lastName,
          email: baseUser.email
        };
        return editorUser as ConditionalTypes.UserFieldsByRole<TRole>;

      case 'public':
        // Public gets minimal fields
        const publicUser = {
          id: baseUser.id,
          firstName: baseUser.firstName,
          lastName: baseUser.lastName
        };
        return publicUser as ConditionalTypes.UserFieldsByRole<TRole>;

      default:
        const _exhaustive: never = role;
        throw new Error(`Unknown role: ${_exhaustive}`);
    }
  }

  // Conditional data loading based on permissions
  async getPostWithConditionalData<
    TIncludeAuthor extends boolean,
    TIncludeComments extends boolean
  >(
    postId: string,
    includeAuthor: TIncludeAuthor,
    includeComments: TIncludeComments
  ): Promise<ConditionalTypes.PostWithConditionalData<TIncludeAuthor, TIncludeComments> | null> {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        author: includeAuthor,
        comments: includeComments
      }
    });

    return post as ConditionalTypes.PostWithConditionalData<TIncludeAuthor, TIncludeComments> | null;
  }

  // Smart validation based on operation type
  validateDataByOperation<TOperation extends 'create' | 'update' | 'delete'>(
    operation: TOperation,
    data: any
  ): ConditionalTypes.ApiResponse<any, boolean> {
    switch (operation) {
      case 'create':
        if (!data.email) {
          return { success: false, error: 'Email is required for creation' };
        }
        if (!data.firstName && !data.lastName) {
          return { success: false, error: 'At least one name field is required' };
        }
        return { success: true, data, message: 'Create validation passed' };

      case 'update':
        if (Object.keys(data).length === 0) {
          return { success: false, error: 'At least one field must be provided for update' };
        }
        if (data.email === '') {
          return { success: false, error: 'Email cannot be empty' };
        }
        return { success: true, data, message: 'Update validation passed' };

      case 'delete':
        if (!data.id) {
          return { success: false, error: 'ID is required for deletion' };
        }
        return { success: true, data, message: 'Delete validation passed' };

      default:
        const _exhaustive: never = operation;
        return { success: false, error: `Unknown operation: ${_exhaustive}` };
    }
  }
}
```

## 3. Runtime Type Narrowing with Prisma Queries

### Dynamic Query Building with Type Safety

```typescript
// Dynamic query building with full type safety
class DynamicQueryService {
  // Build queries based on runtime conditions
  async getContentBasedOnUserRole(
    userId: string,
    userRole: 'admin' | 'editor' | 'author' | 'viewer'
  ) {
    const baseQuery = {
      where: {},
      include: {},
      select: {}
    };

    // Type-safe query building based on role
    switch (userRole) {
      case 'admin':
        return await prisma.post.findMany({
          include: {
            author: true,
            category: true,
            tags: { include: { tag: true } },
            comments: {
              include: { author: true }
            },
            _count: {
              select: {
                comments: true,
                likes: true,
                views: true
              }
            }
          },
          orderBy: { createdAt: 'desc' }
        });

      case 'editor':
        return await prisma.post.findMany({
          where: {
            OR: [
              { authorId: userId },
              { published: true }
            ]
          },
          include: {
            author: {
              select: {
                id: true,
                firstName: true,
                lastName: true
              }
            },
            category: true,
            _count: {
              select: { comments: true }
            }
          },
          orderBy: { updatedAt: 'desc' }
        });

      case 'author':
        return await prisma.post.findMany({
          where: { authorId: userId },
          include: {
            category: true,
            tags: { include: { tag: true } },
            _count: {
              select: { comments: true }
            }
          },
          orderBy: { createdAt: 'desc' }
        });

      case 'viewer':
        return await prisma.post.findMany({
          where: { 
            published: true,
            publishedAt: { lte: new Date() }
          },
          select: {
            id: true,
            title: true,
            content: true,
            publishedAt: true,
            author: {
              select: {
                firstName: true,
                lastName: true
              }
            },
            category: {
              select: {
                name: true,
                slug: true
              }
            }
          },
          orderBy: { publishedAt: 'desc' }
        });

      default:
        const _exhaustive: never = userRole;
        throw new Error(`Unknown role: ${_exhaustive}`);
    }
  }

  // Conditional filtering with type narrowing
  async searchContent(params: {
    query?: string;
    category?: string;
    author?: string;
    publishedOnly?: boolean;
    dateRange?: {
      from: Date;
      to: Date;
    };
    sortBy?: 'newest' | 'oldest' | 'popular' | 'relevant';
  }) {
    // Build where clause conditionally
    const whereClause: any = {};

    if (params.query) {
      whereClause.OR = [
        { title: { contains: params.query, mode: 'insensitive' } },
        { content: { contains: params.query, mode: 'insensitive' } }
      ];
    }

    if (params.category) {
      whereClause.category = {
        slug: params.category
      };
    }

    if (params.author) {
      whereClause.author = {
        OR: [
          { firstName: { contains: params.author, mode: 'insensitive' } },
          { lastName: { contains: params.author, mode: 'insensitive' } }
        ]
      };
    }

    if (params.publishedOnly) {
      whereClause.published = true;
      whereClause.publishedAt = { lte: new Date() };
    }

    if (params.dateRange) {
      whereClause.createdAt = {
        gte: params.dateRange.from,
        lte: params.dateRange.to
      };
    }

    // Build order clause conditionally
    let orderBy: any;
    switch (params.sortBy) {
      case 'newest':
        orderBy = { createdAt: 'desc' };
        break;
      case 'oldest':
        orderBy = { createdAt: 'asc' };
        break;
      case 'popular':
        orderBy = [
          { likes: { _count: 'desc' } },
          { comments: { _count: 'desc' } }
        ];
        break;
      case 'relevant':
        // Would require full-text search capabilities
        orderBy = { createdAt: 'desc' };
        break;
      default:
        orderBy = { createdAt: 'desc' };
    }

    const posts = await prisma.post.findMany({
      where: whereClause,
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profile: {
              select: { avatar: true }
            }
          }
        },
        category: true,
        tags: {
          include: { tag: true }
        },
        _count: {
          select: {
            comments: true,
            likes: true
          }
        }
      },
      orderBy,
      take: 50 // Limit results
    });

    return posts;
  }

  // Type-safe aggregation based on conditions
  async getAnalytics(timeFrame: 'day' | 'week' | 'month' | 'year') {
    const now = new Date();
    let startDate: Date;

    switch (timeFrame) {
      case 'day':
        startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case 'week':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'month':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case 'year':
        startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
        break;
      default:
        const _exhaustive: never = timeFrame;
        throw new Error(`Unknown timeframe: ${_exhaustive}`);
    }

    const [userStats, postStats, engagementStats] = await Promise.all([
      // User statistics
      prisma.user.aggregate({
        where: {
          createdAt: { gte: startDate }
        },
        _count: { id: true },
        _min: { createdAt: true },
        _max: { lastLogin: true }
      }),

      // Post statistics
      prisma.post.aggregate({
        where: {
          createdAt: { gte: startDate }
        },
        _count: { 
          id: true,
          published: true 
        },
        _avg: { viewCount: true }
      }),

      // Engagement statistics
      prisma.comment.aggregate({
        where: {
          createdAt: { gte: startDate }
        },
        _count: { id: true }
      })
    ]);

    return {
      timeFrame,
      period: {
        start: startDate,
        end: now
      },
      users: {
        new: userStats._count.id,
        firstRegistration: userStats._min.createdAt,
        lastActivity: userStats._max.lastLogin
      },
      posts: {
        total: postStats._count.id,
        published: postStats._count.published,
        averageViews: postStats._avg.viewCount
      },
      engagement: {
        comments: engagementStats._count.id
      }
    };
  }
}
```

## Key Takeaways

1. **Use type guards** for safe runtime type checking
2. **Leverage discriminated unions** for complex type scenarios
3. **Build conditional types** for dynamic behavior
4. **Ensure exhaustive checking** with never types
5. **Combine runtime logic with compile-time safety**
6. **Create intelligent query building** based on conditions

## Exercises

1. **Type Guards**: Create comprehensive type guards for your models
2. **Discriminated Unions**: Design union types for different content states
3. **Conditional Types**: Build dynamic types based on user roles
4. **Query Building**: Create type-safe dynamic query builders

---

**Duration**: 28 minutes
**Next**: [4.6.5 Custom Type Definitions](./4.6.5-custom-type-definitions.md)
**Previous**: [4.6.3 Partial Types & Optional Fields](./4.6.3-partial-types-optional-fields.md)
