# 4.6.5 Custom Type Definitions

*Think like a master architect who designs custom blueprints for unique structures - custom type definitions allow you to extend Prisma's generated types with your own domain-specific types, creating a perfectly tailored type system for your application.*

## Learning Objectives
- Master custom type definition patterns with Prisma
- Build domain-specific type extensions and compositions
- Learn to create reusable type utilities and helpers
- Develop advanced type transformation patterns

## The Master Architect's Blueprint Analogy

Just as a master architect creates custom blueprints that extend standard building components with unique designs for specific needs, custom type definitions allow you to build upon Prisma's generated types to create perfectly fitted type systems that match your application's exact requirements.

## 1. Extending Generated Types

### Basic Type Extensions

```typescript
// Extending Prisma's generated types with custom properties
import { User, Post, Profile, Comment } from '@prisma/client'

namespace CustomTypes {
  // Extend User with computed properties
  export interface UserWithComputed extends User {
    fullName: string;
    displayName: string;
    isOnline: boolean;
    membershipDuration: string;
    avatarUrl: string;
  }

  // Extend Post with metadata
  export interface PostWithMetadata extends Post {
    readingTime: number;
    wordCount: number;
    excerpt: string;
    slug: string;
    socialImageUrl: string;
    authorName: string;
    categoryName: string;
    tagNames: string[];
  }

  // Extend Profile with social features
  export interface EnhancedProfile extends Profile {
    socialLinks: {
      twitter?: string;
      linkedin?: string;
      github?: string;
      website?: string;
      instagram?: string;
    };
    stats: {
      followers: number;
      following: number;
      posts: number;
      likes: number;
    };
    badges: string[];
    isVerified: boolean;
  }

  // API Response wrappers
  export interface ApiResponse<T> {
    data: T;
    meta: {
      timestamp: Date;
      requestId: string;
      version: string;
    };
    pagination?: {
      page: number;
      limit: number;
      total: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
  }

  export interface PaginatedResponse<T> extends ApiResponse<T[]> {
    pagination: {
      page: number;
      limit: number;
      total: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
  }

  // Error types
  export interface ApiError {
    code: string;
    message: string;
    details?: any;
    timestamp: Date;
    path?: string;
  }

  export interface ValidationError extends ApiError {
    code: 'VALIDATION_ERROR';
    field: string;
    value: any;
    constraints: string[];
  }
}

class TypeExtensionService {
  // Transform User to UserWithComputed
  transformUser(user: User, additionalData?: {
    isOnline?: boolean;
    avatar?: string;
  }): CustomTypes.UserWithComputed {
    const fullName = [user.firstName, user.lastName]
      .filter(Boolean)
      .join(' ') || 'Anonymous User';

    const displayName = user.firstName || 
                       user.email.split('@')[0] || 
                       'User';

    const membershipDuration = this.calculateMembershipDuration(user.createdAt);
    
    return {
      ...user,
      fullName,
      displayName,
      isOnline: additionalData?.isOnline ?? false,
      membershipDuration,
      avatarUrl: additionalData?.avatar || this.generateAvatarUrl(user.email)
    };
  }

  // Transform Post to PostWithMetadata
  transformPost(
    post: Post & { 
      author: Pick<User, 'firstName' | 'lastName'>;
      category?: { name: string } | null;
      tags?: Array<{ tag: { name: string } }>;
    }
  ): CustomTypes.PostWithMetadata {
    const wordCount = this.countWords(post.content);
    const readingTime = Math.ceil(wordCount / 200); // Assuming 200 WPM
    const excerpt = this.generateExcerpt(post.content, 150);
    const slug = this.generateSlug(post.title);
    
    return {
      ...post,
      readingTime,
      wordCount,
      excerpt,
      slug,
      socialImageUrl: this.generateSocialImage(post.title, post.id),
      authorName: [post.author.firstName, post.author.lastName]
        .filter(Boolean)
        .join(' ') || 'Anonymous',
      categoryName: post.category?.name || 'Uncategorized',
      tagNames: post.tags?.map(pt => pt.tag.name) || []
    };
  }

  // Transform Profile to EnhancedProfile
  async transformProfile(
    userId: string,
    profile: Profile | null
  ): Promise<CustomTypes.EnhancedProfile | null> {
    if (!profile) return null;

    // Get additional stats (in real app, these would come from queries)
    const stats = await this.getUserStats(userId);
    const badges = await this.getUserBadges(userId);
    const socialLinks = this.parseSocialLinks(profile.website);

    return {
      ...profile,
      socialLinks,
      stats,
      badges,
      isVerified: stats.followers > 1000 // Simple verification logic
    };
  }

  // Helper methods
  private calculateMembershipDuration(createdAt: Date): string {
    const now = new Date();
    const diffMs = now.getTime() - createdAt.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffDays < 30) {
      return `${diffDays} days`;
    } else if (diffDays < 365) {
      return `${Math.floor(diffDays / 30)} months`;
    } else {
      return `${Math.floor(diffDays / 365)} years`;
    }
  }

  private countWords(text: string): number {
    return text.trim().split(/\s+/).length;
  }

  private generateExcerpt(content: string, maxLength: number): string {
    const stripped = content.replace(/<[^>]*>/g, ''); // Remove HTML
    return stripped.length > maxLength 
      ? stripped.substring(0, maxLength) + '...'
      : stripped;
  }

  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  private generateAvatarUrl(email: string): string {
    // Generate gravatar URL or use a service like DiceBear
    const hash = this.simpleHash(email.toLowerCase());
    return `https://www.gravatar.com/avatar/${hash}?d=identicon&s=200`;
  }

  private generateSocialImage(title: string, postId: string): string {
    // Generate dynamic social media image URL
    return `/api/og-image/${postId}?title=${encodeURIComponent(title)}`;
  }

  private simpleHash(str: string): string {
    // Simple hash function for demo purposes
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(16);
  }

  private async getUserStats(userId: string) {
    // In real app, these would be actual database queries
    return {
      followers: Math.floor(Math.random() * 1000),
      following: Math.floor(Math.random() * 500),
      posts: Math.floor(Math.random() * 100),
      likes: Math.floor(Math.random() * 5000)
    };
  }

  private async getUserBadges(userId: string): Promise<string[]> {
    // Logic to determine user badges
    return ['Early Adopter', 'Active Contributor'];
  }

  private parseSocialLinks(website: string | null): CustomTypes.EnhancedProfile['socialLinks'] {
    // Parse social links from bio or other sources
    return {
      website: website || undefined
    };
  }
}
```

### Complex Type Compositions

```typescript
// Advanced type composition patterns
namespace AdvancedTypes {
  // Union types for different states
  export type PostState = 
    | { status: 'draft'; lastSaved: Date; autoSaveEnabled: boolean }
    | { status: 'scheduled'; publishAt: Date; timezone: string }
    | { status: 'published'; publishedAt: Date; views: number }
    | { status: 'archived'; archivedAt: Date; reason: string };

  // Intersection types for complex entities
  export type UserProfile = User & Profile & {
    preferences: UserPreferences;
    subscription: SubscriptionDetails;
    activity: ActivitySummary;
  };

  export interface UserPreferences {
    theme: 'light' | 'dark' | 'auto';
    language: string;
    timezone: string;
    notifications: {
      email: boolean;
      push: boolean;
      sms: boolean;
      marketing: boolean;
    };
    privacy: {
      profileVisible: boolean;
      showEmail: boolean;
      showLastSeen: boolean;
    };
  }

  export interface SubscriptionDetails {
    plan: 'free' | 'pro' | 'enterprise';
    status: 'active' | 'cancelled' | 'expired' | 'trial';
    startDate: Date;
    endDate?: Date;
    features: string[];
    billing: {
      amount: number;
      currency: string;
      interval: 'monthly' | 'yearly';
      nextBillingDate?: Date;
    };
  }

  export interface ActivitySummary {
    lastLogin: Date;
    loginCount: number;
    postsCreated: number;
    commentsLeft: number;
    likesGiven: number;
    likesReceived: number;
    streak: {
      current: number;
      longest: number;
      lastActivity: Date;
    };
  }

  // Generic repository patterns
  export interface Repository<T, TCreate, TUpdate> {
    findById(id: string): Promise<T | null>;
    findMany(filters?: any): Promise<T[]>;
    create(data: TCreate): Promise<T>;
    update(id: string, data: TUpdate): Promise<T>;
    delete(id: string): Promise<void>;
    count(filters?: any): Promise<number>;
  }

  export interface SearchableRepository<T> extends Repository<T, any, any> {
    search(query: string, options?: SearchOptions): Promise<SearchResult<T>>;
    suggest(query: string, limit?: number): Promise<string[]>;
  }

  export interface SearchOptions {
    fields?: string[];
    filters?: Record<string, any>;
    sort?: { field: string; direction: 'asc' | 'desc' }[];
    pagination?: { page: number; limit: number };
    highlight?: boolean;
  }

  export interface SearchResult<T> {
    items: T[];
    total: number;
    facets?: Record<string, Array<{ value: string; count: number }>>;
    suggestions?: string[];
    took: number;
  }

  // Event sourcing types
  export interface DomainEvent {
    id: string;
    aggregateId: string;
    aggregateType: string;
    eventType: string;
    eventData: any;
    eventVersion: number;
    occurredAt: Date;
    userId?: string;
  }

  export interface EventStore {
    saveEvent(event: DomainEvent): Promise<void>;
    getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]>;
    getEventsByType(eventType: string, limit?: number): Promise<DomainEvent[]>;
  }

  // CQRS patterns
  export interface Command {
    type: string;
    aggregateId: string;
    data: any;
    userId?: string;
    timestamp: Date;
  }

  export interface Query {
    type: string;
    filters?: any;
    pagination?: { page: number; limit: number };
    sort?: any;
  }

  export interface CommandHandler<TCommand extends Command> {
    handle(command: TCommand): Promise<void>;
  }

  export interface QueryHandler<TQuery extends Query, TResult> {
    handle(query: TQuery): Promise<TResult>;
  }
}

class AdvancedTypeService {
  // Work with complex composed types
  async buildUserProfile(userId: string): Promise<AdvancedTypes.UserProfile> {
    // Fetch all related data
    const [user, profile, preferences, subscription, activity] = await Promise.all([
      prisma.user.findUnique({ where: { id: userId } }),
      prisma.profile.findUnique({ where: { userId } }),
      this.getUserPreferences(userId),
      this.getSubscriptionDetails(userId),
      this.getActivitySummary(userId)
    ]);

    if (!user) {
      throw new Error('User not found');
    }

    // Compose the complex type
    return {
      ...user,
      ...profile,
      preferences,
      subscription,
      activity
    } as AdvancedTypes.UserProfile;
  }

  // Handle different post states
  async getPostWithState(postId: string): Promise<Post & { state: AdvancedTypes.PostState }> {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        _count: { select: { views: true } }
      }
    });

    if (!post) {
      throw new Error('Post not found');
    }

    let state: AdvancedTypes.PostState;

    if (!post.published) {
      if (post.publishedAt && post.publishedAt > new Date()) {
        // Scheduled post
        state = {
          status: 'scheduled',
          publishAt: post.publishedAt,
          timezone: 'UTC' // Would come from user preferences
        };
      } else {
        // Draft post
        state = {
          status: 'draft',
          lastSaved: post.updatedAt,
          autoSaveEnabled: true
        };
      }
    } else if (post.published && post.publishedAt) {
      // Published post
      state = {
        status: 'published',
        publishedAt: post.publishedAt,
        views: post._count?.views || 0
      };
    } else {
      // Archived post (custom logic)
      state = {
        status: 'archived',
        archivedAt: post.updatedAt,
        reason: 'Manual archive'
      };
    }

    return { ...post, state };
  }

  // Generic repository implementation
  createRepository<T, TCreate, TUpdate>(
    model: any
  ): AdvancedTypes.Repository<T, TCreate, TUpdate> {
    return {
      async findById(id: string): Promise<T | null> {
        return await model.findUnique({ where: { id } });
      },

      async findMany(filters?: any): Promise<T[]> {
        return await model.findMany(filters ? { where: filters } : {});
      },

      async create(data: TCreate): Promise<T> {
        return await model.create({ data });
      },

      async update(id: string, data: TUpdate): Promise<T> {
        return await model.update({ where: { id }, data });
      },

      async delete(id: string): Promise<void> {
        await model.delete({ where: { id } });
      },

      async count(filters?: any): Promise<number> {
        return await model.count(filters ? { where: filters } : {});
      }
    };
  }

  // Event handling with custom types
  async handleDomainEvent(event: AdvancedTypes.DomainEvent): Promise<void> {
    switch (event.eventType) {
      case 'UserCreated':
        await this.handleUserCreated(event);
        break;
      case 'PostPublished':
        await this.handlePostPublished(event);
        break;
      case 'CommentAdded':
        await this.handleCommentAdded(event);
        break;
      default:
        console.warn(`Unknown event type: ${event.eventType}`);
    }
  }

  private async handleUserCreated(event: AdvancedTypes.DomainEvent): Promise<void> {
    // Handle user creation event
    console.log(`User created: ${event.aggregateId}`);
  }

  private async handlePostPublished(event: AdvancedTypes.DomainEvent): Promise<void> {
    // Handle post published event
    console.log(`Post published: ${event.aggregateId}`);
  }

  private async handleCommentAdded(event: AdvancedTypes.DomainEvent): Promise<void> {
    // Handle comment added event
    console.log(`Comment added: ${event.aggregateId}`);
  }

  // Helper methods for building complex types
  private async getUserPreferences(userId: string): Promise<AdvancedTypes.UserPreferences> {
    // In real app, fetch from preferences table
    return {
      theme: 'light',
      language: 'en',
      timezone: 'UTC',
      notifications: {
        email: true,
        push: true,
        sms: false,
        marketing: false
      },
      privacy: {
        profileVisible: true,
        showEmail: false,
        showLastSeen: true
      }
    };
  }

  private async getSubscriptionDetails(userId: string): Promise<AdvancedTypes.SubscriptionDetails> {
    // In real app, fetch from subscription table
    return {
      plan: 'free',
      status: 'active',
      startDate: new Date(),
      features: ['basic_features'],
      billing: {
        amount: 0,
        currency: 'USD',
        interval: 'monthly'
      }
    };
  }

  private async getActivitySummary(userId: string): Promise<AdvancedTypes.ActivitySummary> {
    // In real app, calculate from various tables
    return {
      lastLogin: new Date(),
      loginCount: 100,
      postsCreated: 10,
      commentsLeft: 50,
      likesGiven: 200,
      likesReceived: 150,
      streak: {
        current: 5,
        longest: 30,
        lastActivity: new Date()
      }
    };
  }
}
```

## 2. Domain-Specific Type Libraries

### Building Reusable Type Utilities

```typescript
// Comprehensive type utility library
namespace TypeUtilities {
  // Utility types for common patterns
  export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
  };

  export type DeepRequired<T> = {
    [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
  };

  export type Prettify<T> = {
    [K in keyof T]: T[K];
  } & {};

  export type NonNullable<T> = T extends null | undefined ? never : T;

  export type KeysOfType<T, U> = {
    [K in keyof T]: T[K] extends U ? K : never;
  }[keyof T];

  export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> =
    Pick<T, Exclude<keyof T, Keys>> 
    & {
        [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>
    }[Keys];

  export type RequireOnlyOne<T, Keys extends keyof T = keyof T> =
    Pick<T, Exclude<keyof T, Keys>>
    & {
        [K in Keys]-?:
            Required<Pick<T, K>>
            & Partial<Record<Exclude<Keys, K>, undefined>>
    }[Keys];

  // API-specific utilities
  export type ApiEndpoint<TRequest, TResponse> = {
    request: TRequest;
    response: TResponse;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    path: string;
  };

  export type PaginatedApiResponse<T> = {
    data: T[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
    meta: {
      requestId: string;
      timestamp: string;
      duration: number;
    };
  };

  // Form utilities
  export type FormState<T> = {
    values: T;
    errors: Partial<Record<keyof T, string[]>>;
    touched: Partial<Record<keyof T, boolean>>;
    isValid: boolean;
    isSubmitting: boolean;
    isDirty: boolean;
  };

  export type FormField<T> = {
    value: T;
    error?: string;
    touched: boolean;
    validate: (value: T) => string | undefined;
    onChange: (value: T) => void;
    onBlur: () => void;
  };

  // Database utilities
  export type WithTimestamps<T> = T & {
    createdAt: Date;
    updatedAt: Date;
  };

  export type WithSoftDelete<T> = T & {
    deletedAt: Date | null;
    isDeleted: boolean;
  };

  export type WithAudit<T> = T & {
    createdBy: string;
    updatedBy: string;
    version: number;
  };

  // Business logic utilities
  export type BusinessRule<T> = {
    name: string;
    description: string;
    validate: (data: T) => Promise<BusinessRuleResult>;
  };

  export type BusinessRuleResult = {
    isValid: boolean;
    errors: string[];
    warnings: string[];
  };

  export type Workflow<TState, TEvent> = {
    currentState: TState;
    allowedTransitions: Record<TState, TEvent[]>;
    transition: (event: TEvent) => Promise<TState>;
    canTransition: (event: TEvent) => boolean;
  };
}

// Domain-specific type definitions
namespace DomainTypes {
  // Content Management types
  export namespace CMS {
    export type ContentType = 'article' | 'page' | 'blog_post' | 'landing_page' | 'email_template';
    
    export interface ContentBlock {
      id: string;
      type: 'text' | 'image' | 'video' | 'code' | 'quote' | 'list' | 'table';
      content: any;
      metadata: Record<string, any>;
      order: number;
    }

    export interface ContentTemplate {
      id: string;
      name: string;
      contentType: ContentType;
      blocks: ContentBlock[];
      variables: Array<{
        name: string;
        type: 'string' | 'number' | 'boolean' | 'date' | 'rich_text';
        required: boolean;
        defaultValue?: any;
      }>;
    }

    export interface ContentRevision {
      id: string;
      contentId: string;
      version: number;
      title: string;
      content: ContentBlock[];
      changes: Array<{
        field: string;
        oldValue: any;
        newValue: any;
        timestamp: Date;
      }>;
      createdBy: string;
      createdAt: Date;
      isPublished: boolean;
    }
  }

  // E-commerce types
  export namespace ECommerce {
    export interface Product {
      id: string;
      sku: string;
      name: string;
      description: string;
      price: Money;
      comparePrice?: Money;
      costPrice?: Money;
      weight?: number;
      dimensions?: Dimensions;
      images: ProductImage[];
      variants: ProductVariant[];
      categories: Category[];
      tags: string[];
      inventory: InventoryInfo;
      seo: SEOMetadata;
      status: 'draft' | 'active' | 'archived';
    }

    export interface Money {
      amount: number;
      currency: string;
    }

    export interface Dimensions {
      length: number;
      width: number;
      height: number;
      unit: 'cm' | 'in' | 'm' | 'ft';
    }

    export interface ProductImage {
      id: string;
      url: string;
      altText: string;
      order: number;
      isFeatured: boolean;
    }

    export interface ProductVariant {
      id: string;
      productId: string;
      sku: string;
      price: Money;
      comparePrice?: Money;
      options: Array<{ name: string; value: string }>;
      inventory: InventoryInfo;
      image?: ProductImage;
    }

    export interface InventoryInfo {
      quantity: number;
      reserved: number;
      available: number;
      trackQuantity: boolean;
      allowBackorder: boolean;
      lowStockThreshold?: number;
    }

    export interface SEOMetadata {
      title?: string;
      description?: string;
      keywords?: string[];
      slug: string;
      canonicalUrl?: string;
      robots?: string;
    }

    export interface Category {
      id: string;
      name: string;
      slug: string;
      description?: string;
      parentId?: string;
      children?: Category[];
      image?: string;
      seo: SEOMetadata;
    }
  }

  // Analytics types
  export namespace Analytics {
    export interface Event {
      id: string;
      name: string;
      userId?: string;
      sessionId: string;
      timestamp: Date;
      properties: Record<string, any>;
      context: {
        ip: string;
        userAgent: string;
        referrer?: string;
        utm?: UTMParameters;
        page: PageContext;
        device: DeviceInfo;
      };
    }

    export interface UTMParameters {
      source?: string;
      medium?: string;
      campaign?: string;
      term?: string;
      content?: string;
    }

    export interface PageContext {
      url: string;
      path: string;
      title: string;
      referrer?: string;
    }

    export interface DeviceInfo {
      type: 'desktop' | 'mobile' | 'tablet';
      os: string;
      browser: string;
      screenResolution?: string;
    }

    export interface Metric {
      name: string;
      value: number;
      unit?: string;
      timestamp: Date;
      dimensions: Record<string, string>;
    }

    export interface Report {
      id: string;
      name: string;
      description: string;
      metrics: string[];
      dimensions: string[];
      filters: Array<{
        field: string;
        operator: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte' | 'in' | 'contains';
        value: any;
      }>;
      dateRange: {
        start: Date;
        end: Date;
      };
      schedule?: {
        frequency: 'daily' | 'weekly' | 'monthly';
        recipients: string[];
      };
    }
  }
}

class DomainTypeService {
  // CMS operations with domain types
  async createContentFromTemplate(
    templateId: string,
    variables: Record<string, any>
  ): Promise<DomainTypes.CMS.ContentRevision> {
    const template = await this.getContentTemplate(templateId);
    
    // Process template with variables
    const processedBlocks = template.blocks.map(block => ({
      ...block,
      content: this.processBlockContent(block.content, variables)
    }));

    const revision: DomainTypes.CMS.ContentRevision = {
      id: this.generateId(),
      contentId: this.generateId(),
      version: 1,
      title: this.processTemplate(template.name, variables),
      content: processedBlocks,
      changes: [],
      createdBy: 'system',
      createdAt: new Date(),
      isPublished: false
    };

    return revision;
  }

  // E-commerce operations
  async calculateProductPrice(
    product: DomainTypes.ECommerce.Product,
    context: {
      userId?: string;
      location?: string;
      currency?: string;
      discountCodes?: string[];
    }
  ): Promise<DomainTypes.ECommerce.Money> {
    let finalPrice = product.price;

    // Apply location-based pricing
    if (context.location && context.currency) {
      finalPrice = await this.convertCurrency(finalPrice, context.currency);
    }

    // Apply user-specific discounts
    if (context.userId) {
      const userDiscounts = await this.getUserDiscounts(context.userId);
      finalPrice = this.applyDiscounts(finalPrice, userDiscounts);
    }

    // Apply discount codes
    if (context.discountCodes) {
      for (const code of context.discountCodes) {
        const discount = await this.getDiscountByCode(code);
        if (discount) {
          finalPrice = this.applyDiscount(finalPrice, discount);
        }
      }
    }

    return finalPrice;
  }

  // Analytics operations
  async trackEvent(event: Omit<DomainTypes.Analytics.Event, 'id' | 'timestamp'>): Promise<void> {
    const fullEvent: DomainTypes.Analytics.Event = {
      ...event,
      id: this.generateId(),
      timestamp: new Date()
    };

    // Store event (would use actual storage)
    console.log('Event tracked:', fullEvent);

    // Process real-time metrics
    await this.updateRealTimeMetrics(fullEvent);
  }

  // Helper methods
  private async getContentTemplate(templateId: string): Promise<DomainTypes.CMS.ContentTemplate> {
    // Fetch template from database
    return {} as DomainTypes.CMS.ContentTemplate;
  }

  private processBlockContent(content: any, variables: Record<string, any>): any {
    // Process template variables in content
    return content;
  }

  private processTemplate(template: string, variables: Record<string, any>): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return variables[key] || match;
    });
  }

  private async convertCurrency(money: DomainTypes.ECommerce.Money, targetCurrency: string): Promise<DomainTypes.ECommerce.Money> {
    // Currency conversion logic
    return money;
  }

  private async getUserDiscounts(userId: string): Promise<any[]> {
    // Fetch user-specific discounts
    return [];
  }

  private applyDiscounts(price: DomainTypes.ECommerce.Money, discounts: any[]): DomainTypes.ECommerce.Money {
    // Apply multiple discounts
    return price;
  }

  private async getDiscountByCode(code: string): Promise<any> {
    // Fetch discount by code
    return null;
  }

  private applyDiscount(price: DomainTypes.ECommerce.Money, discount: any): DomainTypes.ECommerce.Money {
    // Apply single discount
    return price;
  }

  private async updateRealTimeMetrics(event: DomainTypes.Analytics.Event): Promise<void> {
    // Update real-time analytics
  }

  private generateId(): string {
    return `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

## Key Takeaways

1. **Extend generated types** with computed properties and metadata
2. **Build complex type compositions** using unions and intersections
3. **Create reusable utility types** for common patterns
4. **Design domain-specific type libraries** for business logic
5. **Use type-safe patterns** for repositories and services
6. **Leverage TypeScript's type system** for business rules

## Exercises

1. **Type Extensions**: Create extended types for your Prisma models
2. **Domain Types**: Build domain-specific type libraries
3. **Utility Types**: Create reusable type utilities for common patterns
4. **Repository Pattern**: Implement type-safe repository interfaces

---

**Duration**: 26 minutes
**Next**: [4.6.6 Runtime Type Validation](./4.6.6-runtime-type-validation.md)
**Previous**: [4.6.4 Type Narrowing & Conditional Types](./4.6.4-type-narrowing-conditional-types.md)
