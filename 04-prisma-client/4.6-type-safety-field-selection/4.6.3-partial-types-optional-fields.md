# 4.6.3 Partial Types & Optional Fields

*Think like a master tailor who creates custom-fitted garments - partial types allow you to craft precise type definitions that fit exactly what your application needs, handling optional fields with elegance and safety.*

## Learning Objectives
- Master partial types and optional field handling in Prisma
- Understand nullable vs optional field differences
- Learn to build flexible type patterns for forms and APIs
- Build expertise in type-safe partial data operations

## The Master Tailor's Custom Fit Analogy

Just as a master tailor creates custom-fitted garments that adapt to different occasions and requirements, partial types allow you to create flexible, well-fitted type definitions that handle optional data gracefully while maintaining type safety.

## 1. Understanding Optional vs Nullable Fields

### Core Concepts

```typescript
// Understanding the difference between optional and nullable
import { User, Post, Profile } from '@prisma/client'

class OptionalFieldsService {
  // Demonstrate different field types
  async demonstrateFieldTypes() {
    // Schema field types:
    // firstName String?     -> string | null (nullable)
    // lastName String?      -> string | null (nullable)  
    // email String          -> string (required)
    // isActive Boolean @default(true) -> boolean (required with default)
    
    const user: User = {
      id: 'user-1',
      email: 'user@example.com',
      firstName: null,          // ✅ Nullable field can be null
      lastName: 'Doe',          // ✅ Nullable field can have value
      isActive: true,           // ✅ Required field must have value
      createdAt: new Date(),
      updatedAt: new Date(),
      lastLogin: null           // ✅ Nullable field
    };

    // TypeScript understands nullable fields
    if (user.firstName) {
      console.log(user.firstName.toUpperCase()); // ✅ Type-safe after null check
    }

    // Using optional chaining
    console.log(user.firstName?.length); // ✅ Safe access

    return user;
  }

  // Working with partial data for updates
  async demonstratePartialUpdates() {
    // Partial<User> makes all fields optional
    const partialUser: Partial<User> = {
      firstName: 'John',
      lastLogin: new Date()
      // Other fields are optional
    };

    // Update with partial data
    const updatedUser = await prisma.user.update({
      where: { id: 'user-1' },
      data: {
        firstName: partialUser.firstName,
        lastLogin: partialUser.lastLogin
        // Only update provided fields
      }
    });

    return updatedUser;
  }

  // Handling optional fields in forms
  async demonstrateFormHandling() {
    // Form data with optional fields
    interface UserFormData {
      email: string;              // Required
      firstName?: string;         // Optional in form
      lastName?: string;          // Optional in form
      bio?: string;              // Optional profile field
      website?: string;          // Optional profile field
    }

    const formData: UserFormData = {
      email: 'new@example.com',
      firstName: 'Jane'
      // lastName, bio, website are optional
    };

    // Create user with conditional profile creation
    const newUser = await prisma.user.create({
      data: {
        email: formData.email,
        firstName: formData.firstName || null,
        lastName: formData.lastName || null,
        profile: (formData.bio || formData.website) ? {
          create: {
            bio: formData.bio || null,
            website: formData.website || null
          }
        } : undefined
      },
      include: {
        profile: true
      }
    });

    return newUser;
  }
}
```

### Working with Prisma's Input Types

```typescript
// Leveraging Prisma's built-in partial types
import type { 
  UserCreateInput, 
  UserUpdateInput,
  Prisma 
} from '@prisma/client'

class PartialInputTypesService {
  // Creating flexible input handlers
  async createUserFlexibly(data: Partial<UserCreateInput>) {
    // Build complete input with defaults
    const completeData: UserCreateInput = {
      email: data.email || 'default@example.com',
      firstName: data.firstName || null,
      lastName: data.lastName || null,
      isActive: data.isActive ?? true,
      ...data // Spread additional provided data
    };

    const user = await prisma.user.create({
      data: completeData,
      include: {
        profile: true
      }
    });

    return user;
  }

  // Update with optional fields
  async updateUserFlexibly(
    userId: string, 
    updates: Partial<UserUpdateInput>
  ) {
    // Filter out undefined values
    const cleanUpdates = Object.fromEntries(
      Object.entries(updates).filter(([_, value]) => value !== undefined)
    ) as UserUpdateInput;

    if (Object.keys(cleanUpdates).length === 0) {
      throw new Error('No valid updates provided');
    }

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        ...cleanUpdates,
        updatedAt: new Date() // Always update timestamp
      }
    });

    return updatedUser;
  }

  // Conditional nested updates
  async updateUserWithProfile(
    userId: string,
    userData?: Partial<Pick<User, 'firstName' | 'lastName' | 'email'>>,
    profileData?: Partial<Pick<Profile, 'bio' | 'avatar' | 'website'>>
  ) {
    const updateData: UserUpdateInput = {
      ...(userData && userData),
      ...(profileData && {
        profile: {
          upsert: {
            create: profileData,
            update: profileData
          }
        }
      })
    };

    const user = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      include: {
        profile: true
      }
    });

    return user;
  }

  // Handling complex optional relationships
  async createPostWithOptionalData(data: {
    title: string;
    content: string;
    authorId: string;
    categoryId?: string;
    tags?: string[];
    publishNow?: boolean;
    scheduledFor?: Date;
  }) {
    const postData: Prisma.PostCreateInput = {
      title: data.title,
      content: data.content,
      author: {
        connect: { id: data.authorId }
      },
      published: data.publishNow ?? false,
      publishedAt: data.publishNow ? new Date() : 
                   data.scheduledFor || null,
      
      // Conditional category connection
      ...(data.categoryId && {
        category: {
          connect: { id: data.categoryId }
        }
      }),
      
      // Conditional tags creation
      ...(data.tags && data.tags.length > 0 && {
        tags: {
          create: data.tags.map(tagName => ({
            tag: {
              connectOrCreate: {
                where: { name: tagName },
                create: { 
                  name: tagName,
                  slug: tagName.toLowerCase().replace(/\s+/g, '-')
                }
              }
            }
          }))
        }
      })
    };

    const post = await prisma.post.create({
      data: postData,
      include: {
        author: {
          select: {
            firstName: true,
            lastName: true
          }
        },
        category: true,
        tags: {
          include: {
            tag: true
          }
        }
      }
    });

    return post;
  }
}
```

## 2. Advanced Partial Type Patterns

### Building Flexible API Types

```typescript
// Advanced partial type patterns for APIs
namespace PartialTypePatterns {
  // Utility types for different scenarios
  export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
  };

  export type PartialExcept<T, K extends keyof T> = Partial<T> & Pick<T, K>;

  export type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

  export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

  // User-specific partial types
  export type UserCreationData = PartialExcept<
    Pick<User, 'email' | 'firstName' | 'lastName' | 'isActive'>,
    'email'
  >;

  export type UserUpdateData = Partial<
    Pick<User, 'firstName' | 'lastName' | 'email' | 'isActive'>
  >;

  export type UserProfileData = OptionalFields<
    Pick<Profile, 'bio' | 'avatar' | 'website' | 'socialLinks'>,
    'bio' | 'website'
  >;

  // Post-specific partial types
  export type PostDraftData = PartialExcept<
    Pick<Post, 'title' | 'content' | 'authorId' | 'categoryId' | 'published'>,
    'title' | 'authorId'
  >;

  export type PostPublishData = RequiredFields<
    Partial<Pick<Post, 'title' | 'content' | 'categoryId' | 'metaTitle' | 'metaDescription'>>,
    'title' | 'content'
  >;

  // API request/response types
  export interface UserRegistrationRequest {
    email: string;
    firstName?: string;
    lastName?: string;
    password: string;
    profile?: {
      bio?: string;
      website?: string;
    };
    preferences?: {
      newsletter?: boolean;
      notifications?: boolean;
    };
  }

  export interface UserUpdateRequest {
    firstName?: string;
    lastName?: string;
    email?: string;
    profile?: {
      bio?: string;
      avatar?: string;
      website?: string;
      socialLinks?: Record<string, string>;
    };
    preferences?: {
      newsletter?: boolean;
      notifications?: boolean;
      language?: string;
    };
  }

  export interface PostCreateRequest {
    title: string;
    content: string;
    categoryId?: string;
    tags?: string[];
    meta?: {
      title?: string;
      description?: string;
      keywords?: string[];
    };
    scheduling?: {
      publishNow?: boolean;
      scheduledFor?: string;
    };
  }
}

class AdvancedPartialTypeService {
  // User registration with optional profile
  async registerUser(data: PartialTypePatterns.UserRegistrationRequest) {
    const userData: UserCreateInput = {
      email: data.email,
      firstName: data.firstName || null,
      lastName: data.lastName || null,
      // password would be hashed in real implementation
      
      // Conditional profile creation
      ...(data.profile && Object.keys(data.profile).length > 0 && {
        profile: {
          create: {
            bio: data.profile.bio || null,
            website: data.profile.website || null
          }
        }
      }),
      
      // Conditional preferences creation
      ...(data.preferences && {
        preferences: {
          create: {
            newsletter: data.preferences.newsletter ?? true,
            notifications: data.preferences.notifications ?? true
          }
        }
      })
    };

    const user = await prisma.user.create({
      data: userData,
      include: {
        profile: true,
        preferences: true
      }
    });

    return user;
  }

  // Flexible user update
  async updateUserProfile(
    userId: string, 
    data: PartialTypePatterns.UserUpdateRequest
  ) {
    const updateData: UserUpdateInput = {
      // User fields
      ...(data.firstName !== undefined && { firstName: data.firstName }),
      ...(data.lastName !== undefined && { lastName: data.lastName }),
      ...(data.email !== undefined && { email: data.email }),
      
      // Profile updates
      ...(data.profile && {
        profile: {
          upsert: {
            create: {
              bio: data.profile.bio || null,
              avatar: data.profile.avatar || null,
              website: data.profile.website || null,
              socialLinks: data.profile.socialLinks || {}
            },
            update: {
              ...(data.profile.bio !== undefined && { bio: data.profile.bio }),
              ...(data.profile.avatar !== undefined && { avatar: data.profile.avatar }),
              ...(data.profile.website !== undefined && { website: data.profile.website }),
              ...(data.profile.socialLinks !== undefined && { socialLinks: data.profile.socialLinks })
            }
          }
        }
      }),
      
      // Preferences updates
      ...(data.preferences && {
        preferences: {
          upsert: {
            create: data.preferences,
            update: data.preferences
          }
        }
      })
    };

    const user = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      include: {
        profile: true,
        preferences: true
      }
    });

    return user;
  }

  // Create post with optional metadata
  async createPost(data: PartialTypePatterns.PostCreateRequest, authorId: string) {
    const postData: Prisma.PostCreateInput = {
      title: data.title,
      content: data.content,
      author: {
        connect: { id: authorId }
      },
      
      // Optional category
      ...(data.categoryId && {
        category: {
          connect: { id: data.categoryId }
        }
      }),
      
      // Optional tags
      ...(data.tags && data.tags.length > 0 && {
        tags: {
          create: data.tags.map(tagName => ({
            tag: {
              connectOrCreate: {
                where: { name: tagName },
                create: { 
                  name: tagName,
                  slug: this.slugify(tagName)
                }
              }
            }
          }))
        }
      }),
      
      // Optional meta data
      ...(data.meta && {
        metaTitle: data.meta.title || null,
        metaDescription: data.meta.description || null,
        metaKeywords: data.meta.keywords?.join(', ') || null
      }),
      
      // Publishing logic
      published: data.scheduling?.publishNow ?? false,
      publishedAt: data.scheduling?.publishNow ? new Date() :
                   data.scheduling?.scheduledFor ? new Date(data.scheduling.scheduledFor) :
                   null
    };

    const post = await prisma.post.create({
      data: postData,
      include: {
        author: {
          select: {
            firstName: true,
            lastName: true
          }
        },
        category: true,
        tags: {
          include: {
            tag: true
          }
        }
      }
    });

    return post;
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
}
```

## 3. Form Handling with Partial Types

### Type-Safe Form Processing

```typescript
// Form handling with comprehensive validation
namespace FormTypes {
  // Base form interfaces
  export interface BaseForm {
    isValid: boolean;
    errors: Record<string, string[]>;
    touched: Record<string, boolean>;
  }

  export interface UserForm extends BaseForm {
    data: {
      firstName?: string;
      lastName?: string;
      email?: string;
      bio?: string;
      website?: string;
      avatar?: File | string;
    };
  }

  export interface PostForm extends BaseForm {
    data: {
      title?: string;
      content?: string;
      categoryId?: string;
      tags?: string[];
      publishNow?: boolean;
      scheduledFor?: Date;
      metaTitle?: string;
      metaDescription?: string;
    };
  }

  // Validation results
  export interface ValidationResult<T> {
    isValid: boolean;
    data: T;
    errors: Partial<Record<keyof T, string[]>>;
  }
}

class FormHandlingService {
  // Validate user form data
  validateUserForm(formData: Partial<FormTypes.UserForm['data']>): 
    FormTypes.ValidationResult<FormTypes.UserForm['data']> {
    
    const errors: Partial<Record<keyof FormTypes.UserForm['data'], string[]>> = {};
    
    // Email validation
    if (formData.email !== undefined) {
      if (!formData.email) {
        errors.email = ['Email is required'];
      } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
        errors.email = ['Invalid email format'];
      }
    }
    
    // Name validation
    if (formData.firstName !== undefined && formData.firstName.length > 50) {
      errors.firstName = ['First name too long'];
    }
    
    if (formData.lastName !== undefined && formData.lastName.length > 50) {
      errors.lastName = ['Last name too long'];
    }
    
    // Website validation
    if (formData.website !== undefined && formData.website) {
      try {
        new URL(formData.website);
      } catch {
        errors.website = ['Invalid website URL'];
      }
    }
    
    // Bio length validation
    if (formData.bio !== undefined && formData.bio.length > 500) {
      errors.bio = ['Bio too long (max 500 characters)'];
    }

    return {
      isValid: Object.keys(errors).length === 0,
      data: formData,
      errors
    };
  }

  // Process user form submission
  async processUserForm(
    userId: string,
    formData: Partial<FormTypes.UserForm['data']>
  ) {
    // Validate form
    const validation = this.validateUserForm(formData);
    
    if (!validation.isValid) {
      return {
        success: false,
        errors: validation.errors
      };
    }

    try {
      // Prepare update data
      const updateData: UserUpdateInput = {};
      
      // Only include changed fields
      if (formData.firstName !== undefined) {
        updateData.firstName = formData.firstName || null;
      }
      
      if (formData.lastName !== undefined) {
        updateData.lastName = formData.lastName || null;
      }
      
      if (formData.email !== undefined) {
        updateData.email = formData.email;
      }

      // Handle profile data
      const profileData: any = {};
      let hasProfileUpdates = false;

      if (formData.bio !== undefined) {
        profileData.bio = formData.bio || null;
        hasProfileUpdates = true;
      }
      
      if (formData.website !== undefined) {
        profileData.website = formData.website || null;
        hasProfileUpdates = true;
      }
      
      if (formData.avatar !== undefined) {
        // Handle file upload logic here
        profileData.avatar = typeof formData.avatar === 'string' ? 
          formData.avatar : null;
        hasProfileUpdates = true;
      }

      if (hasProfileUpdates) {
        updateData.profile = {
          upsert: {
            create: profileData,
            update: profileData
          }
        };
      }

      // Update user
      const updatedUser = await prisma.user.update({
        where: { id: userId },
        data: updateData,
        include: {
          profile: true
        }
      });

      return {
        success: true,
        user: updatedUser
      };

    } catch (error) {
      return {
        success: false,
        errors: { general: ['Failed to update user'] }
      };
    }
  }

  // Process post form with draft/publish logic
  async processPostForm(
    authorId: string,
    formData: Partial<FormTypes.PostForm['data']>,
    existingPostId?: string
  ) {
    // Validate required fields based on action
    const errors: Record<string, string[]> = {};
    
    if (!formData.title?.trim()) {
      errors.title = ['Title is required'];
    }
    
    if (!formData.content?.trim()) {
      errors.content = ['Content is required'];
    }

    if (Object.keys(errors).length > 0) {
      return { success: false, errors };
    }

    try {
      const postData: Prisma.PostCreateInput | Prisma.PostUpdateInput = {
        title: formData.title!,
        content: formData.content!,
        published: formData.publishNow ?? false,
        publishedAt: formData.publishNow ? new Date() :
                     formData.scheduledFor || null,
        metaTitle: formData.metaTitle || null,
        metaDescription: formData.metaDescription || null,
        
        ...(formData.categoryId && {
          category: {
            connect: { id: formData.categoryId }
          }
        }),
        
        ...(!existingPostId && {
          author: {
            connect: { id: authorId }
          }
        })
      };

      let post;
      if (existingPostId) {
        // Update existing post
        post = await prisma.post.update({
          where: { id: existingPostId },
          data: postData as Prisma.PostUpdateInput,
          include: {
            author: true,
            category: true,
            tags: { include: { tag: true } }
          }
        });
      } else {
        // Create new post
        post = await prisma.post.create({
          data: postData as Prisma.PostCreateInput,
          include: {
            author: true,
            category: true,
            tags: { include: { tag: true } }
          }
        });
      }

      // Handle tags separately for updates
      if (formData.tags && existingPostId) {
        // Remove existing tags and add new ones
        await prisma.postTag.deleteMany({
          where: { postId: existingPostId }
        });

        if (formData.tags.length > 0) {
          await prisma.postTag.createMany({
            data: formData.tags.map(tagName => ({
              postId: existingPostId,
              tagId: tagName // Assuming tag IDs are provided
            }))
          });
        }
      }

      return {
        success: true,
        post
      };

    } catch (error) {
      return {
        success: false,
        errors: { general: ['Failed to save post'] }
      };
    }
  }
}
```

## Key Takeaways

1. **Distinguish between nullable and optional** field types
2. **Use Partial<T> for flexible updates** and form handling
3. **Build custom utility types** for specific use cases
4. **Handle conditional data creation** gracefully
5. **Validate partial data** before database operations
6. **Leverage TypeScript's type system** for safe partial operations

## Exercises

1. **Form Types**: Create type-safe form interfaces for your models
2. **Partial Updates**: Implement flexible update methods using partial types
3. **Validation**: Build validation logic for partial data
4. **API Design**: Create APIs that handle optional fields gracefully

---

**Duration**: 25 minutes
**Next**: [4.6.4 Type Narrowing & Conditional Types](./4.6.4-type-narrowing-conditional-types.md)
**Previous**: [4.6.2 Field Selection with Select](./4.6.2-field-selection-select.md)
