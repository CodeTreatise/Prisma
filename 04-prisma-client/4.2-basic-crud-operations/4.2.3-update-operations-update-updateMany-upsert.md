# 4.2.3 Update Operations (`update`, `updateMany`, `upsert`)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master single record updates with `update()` method and advanced modification patterns
- Implement efficient bulk updates using `updateMany()` for optimal performance
- Utilize `upsert()` operations for create-or-update scenarios with atomic guarantees
- Handle update operations with nested data and relationship modifications
- Implement optimistic locking and conflict resolution strategies
- Design update operations with proper validation and error handling
- Optimize update operations for different data volumes and concurrency scenarios
- Build robust update systems with audit trails and change tracking

## Introduction

Think of Prisma's update operations as **the master renovator of a dynamic smart building** - like an expert architect who can precisely modify a single room's layout (update), efficiently upgrade entire floors with consistent improvements (updateMany), or intelligently decide whether to renovate an existing space or construct a new one from scratch (upsert). Just as a master renovator understands when to make surgical changes versus wholesale improvements, and can seamlessly handle situations where plans might change mid-project, Prisma Client provides sophisticated update operations that can handle everything from precise single-record modifications to large-scale bulk updates with atomic guarantees.

Understanding update operations is crucial for building applications that can efficiently modify data while maintaining consistency and performance.

## Single Record Updates with `update()`

### Basic Update Operations
The foundation of data modification:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Basic user update
async function updateUser(id: number, data: { name?: string; email?: string; age?: number }) {
  const user = await prisma.user.update({
    where: {
      id: id
    },
    data: data
  })
  
  console.log('Updated user:', user)
  return user
}

// Update with specific field modifications
async function updateUserProfile(userId: number) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      name: 'Updated Name',
      age: 35,
      bio: 'Updated biography content',
      lastActiveAt: new Date(),
      // Increment a counter
      loginCount: {
        increment: 1
      }
    }
  })
  
  return user
}

// Update with JSON field modifications
async function updateUserSettings(userId: number, newSettings: any) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      settings: {
        // Merge with existing settings
        ...newSettings
      },
      metadata: {
        preferences: {
          theme: 'dark',
          notifications: {
            email: true,
            push: false
          }
        },
        lastModified: new Date().toISOString()
      }
    }
  })
  
  return user
}

// Update with selective field return
async function updateUserSelectFields(userId: number, data: any) {
  const user = await prisma.user.update({
    where: { id: userId },
    data,
    select: {
      id: true,
      name: true,
      email: true,
      updatedAt: true
      // Only return specific fields
    }
  })
  
  return user // TypeScript knows exact shape
}
```

### Advanced Update with Relationships
Modifying records with related data:

```typescript
// Update user with nested profile update
async function updateUserWithProfile(userId: number) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      name: 'Updated User Name',
      profile: {
        update: {
          bio: 'Updated bio content',
          website: 'https://updated-website.com',
          social: {
            twitter: '@updated_handle',
            linkedin: 'updated-profile'
          }
        }
      }
    },
    include: {
      profile: true,
      posts: {
        where: {
          published: true
        },
        take: 5
      }
    }
  })
  
  return user
}

// Update with nested create or connect
async function updatePostWithTags(postId: number, tagNames: string[]) {
  const post = await prisma.post.update({
    where: { id: postId },
    data: {
      title: 'Updated Post Title',
      content: 'Updated post content...',
      updatedAt: new Date(),
      tags: {
        // Disconnect existing tags
        set: [],
        // Connect or create new tags
        connectOrCreate: tagNames.map(name => ({
          where: { name },
          create: { 
            name, 
            color: `#${Math.floor(Math.random()*16777215).toString(16)}` 
          }
        }))
      }
    },
    include: {
      tags: true,
      author: {
        select: {
          id: true,
          name: true,
          email: true
        }
      }
    }
  })
  
  return post
}

// Complex relationship updates
async function updateUserPostsAndProfile(userId: number) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      // Update user fields
      lastActiveAt: new Date(),
      // Update profile
      profile: {
        upsert: {
          create: {
            bio: 'New user profile',
            website: 'https://newuser.com'
          },
          update: {
            bio: 'Updated user profile',
            lastModified: new Date()
          }
        }
      },
      // Update posts
      posts: {
        updateMany: {
          where: {
            published: false
          },
          data: {
            published: true,
            publishedAt: new Date()
          }
        }
      }
    },
    include: {
      profile: true,
      posts: {
        where: {
          published: true
        }
      }
    }
  })
  
  return user
}
```

### Atomic Updates and Data Transformations
Ensuring data consistency during updates:

```typescript
// Atomic numeric operations
async function updateUserStats(userId: number, actions: {
  incrementPosts?: number
  incrementFollowers?: number
  incrementFollowing?: number
  setLastLogin?: Date
}) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      // Atomic increment operations
      postCount: actions.incrementPosts ? {
        increment: actions.incrementPosts
      } : undefined,
      followerCount: actions.incrementFollowers ? {
        increment: actions.incrementFollowers
      } : undefined,
      followingCount: actions.incrementFollowing ? {
        increment: actions.incrementFollowing
      } : undefined,
      // Direct value updates
      lastLoginAt: actions.setLastLogin,
      updatedAt: new Date()
    },
    select: {
      id: true,
      postCount: true,
      followerCount: true,
      followingCount: true,
      lastLoginAt: true,
      updatedAt: true
    }
  })
  
  return user
}

// Array field updates
async function updateUserTags(userId: number, operation: 'add' | 'remove' | 'set', tags: string[]) {
  let data: any = {}
  
  switch (operation) {
    case 'add':
      // Add tags to existing array
      const currentUser = await prisma.user.findUnique({
        where: { id: userId },
        select: { tags: true }
      })
      data.tags = [...(currentUser?.tags || []), ...tags.filter(tag => !currentUser?.tags?.includes(tag))]
      break
      
    case 'remove':
      // Remove specific tags
      const userToUpdate = await prisma.user.findUnique({
        where: { id: userId },
        select: { tags: true }
      })
      data.tags = userToUpdate?.tags?.filter(tag => !tags.includes(tag)) || []
      break
      
    case 'set':
      // Replace entire array
      data.tags = tags
      break
  }
  
  const user = await prisma.user.update({
    where: { id: userId },
    data,
    select: {
      id: true,
      name: true,
      tags: true,
      updatedAt: true
    }
  })
  
  return user
}

// Conditional updates with version checking (optimistic locking)
async function updateWithOptimisticLock(
  userId: number, 
  expectedVersion: number, 
  updates: any
) {
  try {
    const user = await prisma.user.update({
      where: {
        id: userId,
        version: expectedVersion // Ensure version hasn't changed
      },
      data: {
        ...updates,
        version: {
          increment: 1 // Increment version
        },
        updatedAt: new Date()
      }
    })
    
    return { success: true, user, conflict: false }
  } catch (error: any) {
    if (error.code === 'P2025') {
      // Record not found (version mismatch)
      return { 
        success: false, 
        conflict: true, 
        error: 'Version conflict detected' 
      }
    }
    throw error
  }
}
```

## Bulk Updates with `updateMany()`

### Basic Bulk Update Operations
Efficient modification of multiple records:

```typescript
// Basic updateMany usage
async function activateUsers(userIds: number[]) {
  const result = await prisma.user.updateMany({
    where: {
      id: {
        in: userIds
      }
    },
    data: {
      isActive: true,
      activatedAt: new Date()
    }
  })
  
  console.log(`Activated ${result.count} users`)
  return result
}

// Bulk update with conditions
async function updateInactiveUsers() {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - 30) // 30 days ago
  
  const result = await prisma.user.updateMany({
    where: {
      AND: [
        { isActive: true },
        { lastLoginAt: { lt: cutoffDate } },
        { 
          posts: {
            none: {
              createdAt: { gte: cutoffDate }
            }
          }
        }
      ]
    },
    data: {
      isActive: false,
      deactivatedAt: new Date(),
      deactivationReason: 'INACTIVITY'
    }
  })
  
  console.log(`Deactivated ${result.count} inactive users`)
  return result
}

// Bulk updates with calculated values
async function updatePostStats() {
  // Update all published posts to recalculate engagement scores
  const result = await prisma.post.updateMany({
    where: {
      published: true
    },
    data: {
      lastCalculatedAt: new Date(),
      // Note: Complex calculations would typically be done in application logic
      // or using raw SQL for performance
    }
  })
  
  return result
}

// Conditional bulk updates based on relationships
async function promoteActiveUsers() {
  const result = await prisma.user.updateMany({
    where: {
      AND: [
        { isActive: true },
        { 
          posts: {
            some: {
              published: true,
              createdAt: {
                gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // Last 90 days
              }
            }
          }
        },
        { role: 'USER' }
      ]
    },
    data: {
      role: 'CONTRIBUTOR',
      promotedAt: new Date()
    }
  })
  
  console.log(`Promoted ${result.count} users to CONTRIBUTOR`)
  return result
}
```

### Chunked Bulk Updates
Handling large datasets efficiently:

```typescript
// Chunked bulk updates for performance
async function updateManyUsersChunked(
  userUpdates: { id: number; data: any }[],
  chunkSize = 1000
) {
  const results = []
  
  for (let i = 0; i < userUpdates.length; i += chunkSize) {
    const chunk = userUpdates.slice(i, i + chunkSize)
    
    console.log(`Processing chunk ${Math.floor(i / chunkSize) + 1}/${Math.ceil(userUpdates.length / chunkSize)}`)
    
    // Update chunk using updateMany
    const userIds = chunk.map(u => u.id)
    const commonData = chunk[0].data // Assuming same data for all in chunk
    
    const result = await prisma.user.updateMany({
      where: {
        id: { in: userIds }
      },
      data: commonData
    })
    
    results.push(result)
    
    // Small delay to prevent overwhelming the database
    if (i + chunkSize < userUpdates.length) {
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }
  
  const totalUpdated = results.reduce((sum, result) => sum + result.count, 0)
  console.log(`Total updated: ${totalUpdated} records`)
  
  return { totalUpdated, chunks: results.length }
}

// Progressive bulk updates with monitoring
async function updateManyWithProgress(
  whereCondition: any,
  updateData: any,
  batchSize = 1000
) {
  let totalUpdated = 0
  let hasMore = true
  
  while (hasMore) {
    const result = await prisma.user.updateMany({
      where: whereCondition,
      data: updateData
    })
    
    totalUpdated += result.count
    hasMore = result.count === batchSize
    
    console.log(`Updated ${result.count} records, total: ${totalUpdated}`)
    
    if (hasMore) {
      // Small delay between batches
      await new Promise(resolve => setTimeout(resolve, 200))
    }
  }
  
  return { totalUpdated }
}

// Bulk updates with transaction for atomicity
async function updateManyWithTransaction() {
  const result = await prisma.$transaction(async (tx) => {
    // Update users
    const userResult = await tx.user.updateMany({
      where: { isActive: false },
      data: { 
        isActive: true,
        reactivatedAt: new Date()
      }
    })
    
    // Update related posts
    const postResult = await tx.post.updateMany({
      where: {
        author: {
          isActive: true
        },
        published: false
      },
      data: {
        published: true,
        publishedAt: new Date()
      }
    })
    
    return {
      usersUpdated: userResult.count,
      postsUpdated: postResult.count
    }
  })
  
  console.log(`Transaction completed: ${result.usersUpdated} users, ${result.postsUpdated} posts`)
  return result
}
```

## Upsert Operations

### Basic Upsert Patterns
Create-or-update operations with atomic guarantees:

```typescript
// Basic upsert - create or update user
async function upsertUser(email: string, userData: any) {
  const user = await prisma.user.upsert({
    where: {
      email: email
    },
    update: {
      name: userData.name,
      age: userData.age,
      bio: userData.bio,
      lastLoginAt: new Date()
    },
    create: {
      email: email,
      name: userData.name,
      age: userData.age,
      bio: userData.bio,
      isActive: true,
      createdAt: new Date(),
      lastLoginAt: new Date()
    }
  })
  
  return user
}

// Upsert with different create/update logic
async function upsertUserProfile(userId: number, profileData: any) {
  const profile = await prisma.profile.upsert({
    where: {
      userId: userId
    },
    update: {
      bio: profileData.bio,
      website: profileData.website,
      social: profileData.social,
      updatedAt: new Date()
    },
    create: {
      userId: userId,
      bio: profileData.bio,
      website: profileData.website,
      social: profileData.social,
      createdAt: new Date()
    },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          email: true
        }
      }
    }
  })
  
  return profile
}

// Upsert with conditional logic
async function upsertUserSettings(userId: number, settings: any) {
  // Get current settings to merge
  const existingUser = await prisma.user.findUnique({
    where: { id: userId },
    select: { settings: true }
  })
  
  const user = await prisma.user.upsert({
    where: { id: userId },
    update: {
      settings: {
        // Merge with existing settings
        ...(existingUser?.settings as any || {}),
        ...settings,
        lastModified: new Date().toISOString()
      },
      updatedAt: new Date()
    },
    create: {
      // This shouldn't happen if userId exists, but required for upsert
      email: `user${userId}@placeholder.com`,
      name: 'Unknown User',
      settings: {
        ...settings,
        created: new Date().toISOString()
      }
    }
  })
  
  return user
}
```

### Advanced Upsert with Relationships
Complex upsert operations involving related data:

```typescript
// Upsert post with author and tags
async function upsertPostWithRelations(
  title: string,
  authorEmail: string,
  postData: any,
  tagNames: string[]
) {
  const post = await prisma.post.upsert({
    where: {
      // Assuming we have a unique constraint on title + authorId
      title_authorEmail: {
        title: title,
        authorEmail: authorEmail
      }
    },
    update: {
      content: postData.content,
      published: postData.published,
      updatedAt: new Date(),
      tags: {
        set: [], // Clear existing tags
        connectOrCreate: tagNames.map(name => ({
          where: { name },
          create: { 
            name, 
            color: postData.tagColors?.[name] || '#6B7280'
          }
        }))
      }
    },
    create: {
      title: title,
      content: postData.content,
      published: postData.published || false,
      author: {
        connectOrCreate: {
          where: { email: authorEmail },
          create: {
            email: authorEmail,
            name: postData.authorName || 'Unknown Author'
          }
        }
      },
      tags: {
        connectOrCreate: tagNames.map(name => ({
          where: { name },
          create: { 
            name, 
            color: postData.tagColors?.[name] || '#6B7280'
          }
        }))
      }
    },
    include: {
      author: {
        select: {
          id: true,
          name: true,
          email: true
        }
      },
      tags: true
    }
  })
  
  return post
}

// Batch upsert operations
async function batchUpsertUsers(usersData: any[]) {
  const results = []
  
  for (const userData of usersData) {
    const result = await prisma.user.upsert({
      where: { email: userData.email },
      update: {
        name: userData.name,
        age: userData.age,
        bio: userData.bio,
        lastSyncAt: new Date()
      },
      create: {
        email: userData.email,
        name: userData.name,
        age: userData.age,
        bio: userData.bio,
        isActive: true,
        importedAt: new Date()
      },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
        updatedAt: true
      }
    })
    
    results.push(result)
  }
  
  return results
}

// Upsert with complex nested operations
async function upsertUserWithCompleteProfile(userData: any) {
  const user = await prisma.user.upsert({
    where: { email: userData.email },
    update: {
      name: userData.name,
      age: userData.age,
      updatedAt: new Date(),
      profile: {
        upsert: {
          update: {
            bio: userData.profile.bio,
            website: userData.profile.website,
            social: userData.profile.social,
            updatedAt: new Date()
          },
          create: {
            bio: userData.profile.bio,
            website: userData.profile.website,
            social: userData.profile.social
          }
        }
      }
    },
    create: {
      email: userData.email,
      name: userData.name,
      age: userData.age,
      isActive: true,
      profile: {
        create: {
          bio: userData.profile.bio,
          website: userData.profile.website,
          social: userData.profile.social
        }
      }
    },
    include: {
      profile: true
    }
  })
  
  return user
}
```

## Error Handling and Validation

### Comprehensive Error Handling for Updates
Robust error management for update operations:

```typescript
// Custom error types for update operations
class UpdateOperationError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message)
    this.name = 'UpdateOperationError'
  }
}

// Comprehensive error handling for updates
async function updateUserWithErrorHandling(userId: number, updateData: any) {
  try {
    // Pre-validation
    if (!userId || userId <= 0) {
      throw new UpdateOperationError(
        'Invalid user ID',
        'INVALID_USER_ID',
        { userId }
      )
    }
    
    // Check if user exists and is active
    const existingUser = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, isActive: true, version: true }
    })
    
    if (!existingUser) {
      throw new UpdateOperationError(
        'User not found',
        'USER_NOT_FOUND',
        { userId }
      )
    }
    
    if (!existingUser.isActive) {
      throw new UpdateOperationError(
        'Cannot update inactive user',
        'USER_INACTIVE',
        { userId }
      )
    }
    
    // Perform update with optimistic locking
    const user = await prisma.user.update({
      where: { 
        id: userId,
        version: existingUser.version
      },
      data: {
        ...updateData,
        version: {
          increment: 1
        },
        updatedAt: new Date()
      },
      select: {
        id: true,
        name: true,
        email: true,
        version: true,
        updatedAt: true
      }
    })
    
    return { success: true, user }
    
  } catch (error: any) {
    // Handle Prisma-specific errors
    if (error.code === 'P2025') {
      return {
        success: false,
        error: 'VERSION_CONFLICT',
        message: 'Record was modified by another process'
      }
    }
    
    if (error.code === 'P2002') {
      return {
        success: false,
        error: 'UNIQUE_CONSTRAINT',
        message: 'Value already exists',
        field: error.meta?.target?.[0]
      }
    }
    
    if (error.code === 'P2000') {
      return {
        success: false,
        error: 'VALUE_TOO_LONG',
        message: 'One or more values exceed maximum length'
      }
    }
    
    // Handle custom validation errors
    if (error instanceof UpdateOperationError) {
      return {
        success: false,
        error: error.code,
        message: error.message,
        details: error.details
      }
    }
    
    // Generic error fallback
    console.error('Unexpected update error:', error)
    return {
      success: false,
      error: 'UNKNOWN_ERROR',
      message: 'An unexpected error occurred during update'
    }
  }
}

// Batch update with individual error handling
async function updateManyWithIndividualErrorHandling(updates: { id: number; data: any }[]) {
  const results = {
    successful: [],
    failed: [],
    total: updates.length
  }
  
  for (const update of updates) {
    const result = await updateUserWithErrorHandling(update.id, update.data)
    
    if (result.success) {
      results.successful.push(result.user)
    } else {
      results.failed.push({
        id: update.id,
        data: update.data,
        error: result.error,
        message: result.message
      })
    }
  }
  
  console.log(`Batch update completed: ${results.successful.length} successful, ${results.failed.length} failed`)
  return results
}
```

### Data Validation and Audit Trails
Ensuring data quality and tracking changes:

```typescript
// Update with change tracking
async function updateWithAuditTrail(
  userId: number, 
  updateData: any, 
  performedBy: number
) {
  return await prisma.$transaction(async (tx) => {
    // Get current state for audit
    const currentUser = await tx.user.findUnique({
      where: { id: userId }
    })
    
    if (!currentUser) {
      throw new Error('User not found')
    }
    
    // Perform update
    const updatedUser = await tx.user.update({
      where: { id: userId },
      data: {
        ...updateData,
        updatedAt: new Date()
      }
    })
    
    // Create audit log
    const changes = Object.keys(updateData).reduce((acc, key) => {
      if (currentUser[key] !== updateData[key]) {
        acc[key] = {
          from: currentUser[key],
          to: updateData[key]
        }
      }
      return acc
    }, {})
    
    if (Object.keys(changes).length > 0) {
      await tx.auditLog.create({
        data: {
          entityType: 'User',
          entityId: userId,
          action: 'UPDATE',
          changes: changes,
          performedBy: performedBy,
          timestamp: new Date()
        }
      })
    }
    
    return updatedUser
  })
}

// Validation-enhanced update
interface UserUpdateValidation {
  isValid: boolean
  sanitizedData?: any
  errors: string[]
}

function validateUserUpdateData(updateData: any): UserUpdateValidation {
  const errors: string[] = []
  const sanitized: any = {}
  
  // Name validation
  if (updateData.name !== undefined) {
    if (typeof updateData.name !== 'string') {
      errors.push('Name must be a string')
    } else {
      const name = updateData.name.trim()
      if (name.length === 0) {
        errors.push('Name cannot be empty')
      } else if (name.length > 100) {
        errors.push('Name is too long (max 100 characters)')
      } else {
        sanitized.name = name
      }
    }
  }
  
  // Email validation
  if (updateData.email !== undefined) {
    if (typeof updateData.email !== 'string') {
      errors.push('Email must be a string')
    } else {
      const email = updateData.email.toLowerCase().trim()
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      
      if (!emailRegex.test(email)) {
        errors.push('Email format is invalid')
      } else {
        sanitized.email = email
      }
    }
  }
  
  // Age validation
  if (updateData.age !== undefined) {
    if (typeof updateData.age !== 'number') {
      errors.push('Age must be a number')
    } else if (updateData.age < 0 || updateData.age > 150) {
      errors.push('Age must be between 0 and 150')
    } else {
      sanitized.age = Math.floor(updateData.age)
    }
  }
  
  return {
    isValid: errors.length === 0,
    sanitizedData: errors.length === 0 ? sanitized : undefined,
    errors
  }
}

// Update with validation
async function updateValidatedUser(userId: number, updateData: any) {
  const validation = validateUserUpdateData(updateData)
  
  if (!validation.isValid) {
    return {
      success: false,
      errors: validation.errors
    }
  }
  
  return updateUserWithErrorHandling(userId, validation.sanitizedData!)
}
```

## Exercise: Advanced Update System

Design a comprehensive update operation system:

```typescript
// Your task: Build a production-ready update system

// Requirements:
// 1. Support all types of update operations with optimization
// 2. Implement comprehensive validation and conflict resolution
// 3. Add audit trails and change tracking for all updates
// 4. Include performance monitoring and bulk operation support
// 5. Support optimistic locking and version control
// 6. Implement rollback capabilities for failed operations
// 7. Add real-time notification system for updates
// 8. Support conditional updates based on complex business rules

interface UpdateSystemConfig {
  // Define configuration options
}

class AdvancedUpdateSystem {
  // Implement comprehensive update system
  
  // Methods to implement:
  // - updateSingle<T>(model: string, id: any, data: any, options?: UpdateOptions)
  // - updateMany<T>(model: string, criteria: any, data: any, options?: BulkUpdateOptions)
  // - upsert<T>(model: string, where: any, create: any, update: any, options?: UpsertOptions)
  // - updateWithLocking<T>(model: string, id: any, version: number, data: any)
  // - batchUpdate<T>(operations: UpdateOperation[], options?: BatchOptions)
  // - rollbackUpdate(updateId: string)
  // - trackChanges(entityType: string, entityId: any, changes: any, performedBy: any)
  // - validateUpdateData(data: any, schema: ValidationSchema)
}

// Bonus features:
// - Automatic conflict resolution strategies
// - Update queuing for high-concurrency scenarios
// - Integration with event sourcing patterns
// - Performance analytics for update operations
// - Custom business rule engine for conditional updates
// - Real-time collaboration and conflict notifications
```

## Key Takeaways

1. **Operation Selection**: Use `update()` for single records, `updateMany()` for bulk operations, `upsert()` for create-or-update scenarios
2. **Atomicity**: Leverage atomic operations like increment/decrement for consistent data modifications
3. **Optimistic Locking**: Implement version control to handle concurrent updates safely
4. **Error Handling**: Always handle update conflicts, validation errors, and constraint violations
5. **Performance**: Use bulk operations for large datasets and monitor update performance
6. **Audit Trails**: Track changes for compliance and debugging purposes
7. **Validation**: Sanitize and validate data before updates to maintain data integrity

## Next Steps

In the next lesson, we'll explore **Delete Operations** (`delete`, `deleteMany`) and learn how to safely remove data with cascade handling, soft deletion patterns, and recovery mechanisms.

---

**Estimated Time:** 25 minutes
**Difficulty:** Intermediate to Advanced
**Prerequisites:** Understanding of database concepts, concurrency, and data consistency patterns
