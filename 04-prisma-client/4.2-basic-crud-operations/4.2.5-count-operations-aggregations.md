# 4.2.5 Count Operations & Aggregations

## Learning Objectives
By the end of this lesson, you will be able to:
- Master count operations for efficient record counting with complex filtering
- Implement comprehensive aggregation functions (sum, avg, min, max) for data analysis
- Design groupBy operations for sophisticated data categorization and reporting
- Build performance-optimized counting and aggregation queries
- Handle nested counts and relationship-based aggregations
- Create real-time analytics and dashboard systems with aggregated data
- Implement caching strategies for expensive aggregation operations
- Design scalable aggregation patterns for large datasets and reporting systems

## Introduction

Think of Prisma's count and aggregation operations as **the master data scientist of a sophisticated observatory** - like an expert astronomer who can precisely count celestial objects in specific regions (count), calculate statistical properties of star clusters (aggregations), and organize cosmic data into meaningful categories for deep analysis (groupBy). Just as an observatory's advanced instruments can process vast amounts of cosmic data to reveal patterns, trends, and insights about the universe, Prisma Client provides powerful analytical operations that can efficiently process your database to extract meaningful metrics, statistics, and business intelligence from complex data relationships.

Understanding count and aggregation operations is essential for building applications that provide insights, analytics, and data-driven decision making.

## Basic Count Operations

### Simple Count Queries
The foundation of data analysis:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Basic count of all records
async function getTotalUsers() {
  const count = await prisma.user.count()
  console.log(`Total users: ${count}`)
  return count
}

// Count with basic filtering
async function getActiveUserCount() {
  const count = await prisma.user.count({
    where: {
      isActive: true
    }
  })
  
  return count
}

// Count with complex conditions
async function getRecentActiveUsers(days: number = 30) {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - days)
  
  const count = await prisma.user.count({
    where: {
      AND: [
        { isActive: true },
        { lastLoginAt: { gte: cutoffDate } },
        { 
          posts: {
            some: {
              published: true,
              createdAt: { gte: cutoffDate }
            }
          }
        }
      ]
    }
  })
  
  return count
}

// Multiple count queries for dashboard
async function getDashboardCounts() {
  const [
    totalUsers,
    activeUsers,
    totalPosts,
    publishedPosts,
    totalComments,
    pendingComments
  ] = await Promise.all([
    prisma.user.count(),
    prisma.user.count({ where: { isActive: true } }),
    prisma.post.count(),
    prisma.post.count({ where: { published: true } }),
    prisma.comment.count(),
    prisma.comment.count({ where: { status: 'PENDING' } })
  ])
  
  return {
    users: { total: totalUsers, active: activeUsers },
    posts: { total: totalPosts, published: publishedPosts },
    comments: { total: totalComments, pending: pendingComments }
  }
}
```

### Nested Count Operations
Counting related records efficiently:

```typescript
// Count with nested relationships
async function getUsersWithPostCounts() {
  const users = await prisma.user.findMany({
    where: {
      isActive: true
    },
    select: {
      id: true,
      name: true,
      email: true,
      _count: {
        select: {
          posts: true,
          comments: true,
          followers: true,
          following: true
        }
      }
    },
    orderBy: {
      posts: {
        _count: 'desc' // Order by post count
      }
    }
  })
  
  return users
}

// Conditional nested counts
async function getUsersWithConditionalCounts() {
  const users = await prisma.user.findMany({
    select: {
      id: true,
      name: true,
      email: true,
      _count: {
        select: {
          posts: {
            where: {
              published: true,
              createdAt: {
                gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
              }
            }
          },
          comments: {
            where: {
              createdAt: {
                gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
              }
            }
          },
          likes: true,
          followers: {
            where: {
              isActive: true
            }
          }
        }
      }
    }
  })
  
  return users
}

// Posts with engagement counts
async function getPostsWithEngagementCounts() {
  const posts = await prisma.post.findMany({
    where: {
      published: true
    },
    select: {
      id: true,
      title: true,
      createdAt: true,
      author: {
        select: {
          id: true,
          name: true
        }
      },
      _count: {
        select: {
          comments: true,
          likes: true,
          shares: true,
          bookmarks: true
        }
      }
    },
    orderBy: [
      { comments: { _count: 'desc' } },
      { likes: { _count: 'desc' } }
    ]
  })
  
  return posts
}

// Complex nested counts with filtering
async function getDetailedUserAnalytics(userId: number) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      name: true,
      email: true,
      createdAt: true,
      _count: {
        select: {
          posts: true,
          comments: true,
          likes: true,
          followers: true,
          following: true,
          // Conditional counts
          publishedPosts: {
            where: { published: true }
          },
          draftPosts: {
            where: { published: false }
          },
          recentPosts: {
            where: {
              createdAt: {
                gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
              }
            }
          },
          popularPosts: {
            where: {
              likes: {
                some: {}
              },
              comments: {
                some: {}
              }
            }
          }
        }
      }
    }
  })
  
  return user
}
```

## Aggregation Functions

### Basic Aggregations (sum, avg, min, max)
Statistical analysis of numeric data:

```typescript
// User age statistics
async function getUserAgeStatistics() {
  const stats = await prisma.user.aggregate({
    _avg: {
      age: true
    },
    _min: {
      age: true
    },
    _max: {
      age: true
    },
    _sum: {
      age: true
    },
    _count: {
      age: true
    }
  })
  
  return {
    averageAge: Math.round(stats._avg.age || 0),
    minAge: stats._min.age,
    maxAge: stats._max.age,
    totalAge: stats._sum.age,
    usersWithAge: stats._count.age
  }
}

// Post engagement statistics
async function getPostEngagementStats() {
  const stats = await prisma.post.aggregate({
    where: {
      published: true,
      createdAt: {
        gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
      }
    },
    _avg: {
      viewCount: true,
      readTime: true
    },
    _sum: {
      viewCount: true,
      shareCount: true
    },
    _min: {
      createdAt: true
    },
    _max: {
      createdAt: true
    },
    _count: {
      id: true
    }
  })
  
  return {
    averageViews: Math.round(stats._avg.viewCount || 0),
    averageReadTime: Math.round(stats._avg.readTime || 0),
    totalViews: stats._sum.viewCount || 0,
    totalShares: stats._sum.shareCount || 0,
    postCount: stats._count.id,
    dateRange: {
      earliest: stats._min.createdAt,
      latest: stats._max.createdAt
    }
  }
}

// Financial aggregations
async function getOrderStatistics(startDate: Date, endDate: Date) {
  const stats = await prisma.order.aggregate({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate
      },
      status: {
        in: ['COMPLETED', 'SHIPPED', 'DELIVERED']
      }
    },
    _sum: {
      total: true,
      tax: true,
      shipping: true
    },
    _avg: {
      total: true
    },
    _min: {
      total: true
    },
    _max: {
      total: true
    },
    _count: {
      id: true
    }
  })
  
  return {
    totalRevenue: stats._sum.total || 0,
    totalTax: stats._sum.tax || 0,
    totalShipping: stats._sum.shipping || 0,
    averageOrderValue: stats._avg.total || 0,
    minOrderValue: stats._min.total || 0,
    maxOrderValue: stats._max.total || 0,
    orderCount: stats._count.id
  }
}

// Conditional aggregations
async function getConditionalUserStats() {
  const [activeUsersStats, inactiveUsersStats] = await Promise.all([
    prisma.user.aggregate({
      where: { isActive: true },
      _avg: { age: true },
      _count: { id: true }
    }),
    prisma.user.aggregate({
      where: { isActive: false },
      _avg: { age: true },
      _count: { id: true }
    })
  ])
  
  return {
    active: {
      count: activeUsersStats._count.id,
      averageAge: activeUsersStats._avg.age
    },
    inactive: {
      count: inactiveUsersStats._count.id,
      averageAge: inactiveUsersStats._avg.age
    }
  }
}
```

### Advanced Aggregations with Filtering
Complex analytical queries:

```typescript
// Time-based aggregations
async function getTimeBasedAnalytics(period: 'day' | 'week' | 'month' | 'year') {
  let dateFilter: Date
  
  switch (period) {
    case 'day':
      dateFilter = new Date(Date.now() - 24 * 60 * 60 * 1000)
      break
    case 'week':
      dateFilter = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      break
    case 'month':
      dateFilter = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
      break
    case 'year':
      dateFilter = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000)
      break
  }
  
  const [userStats, postStats, commentStats] = await Promise.all([
    prisma.user.aggregate({
      where: {
        createdAt: { gte: dateFilter }
      },
      _count: { id: true },
      _avg: { age: true }
    }),
    prisma.post.aggregate({
      where: {
        createdAt: { gte: dateFilter },
        published: true
      },
      _count: { id: true },
      _avg: { viewCount: true },
      _sum: { viewCount: true }
    }),
    prisma.comment.aggregate({
      where: {
        createdAt: { gte: dateFilter }
      },
      _count: { id: true }
    })
  ])
  
  return {
    period,
    newUsers: userStats._count.id,
    averageUserAge: userStats._avg.age,
    newPosts: postStats._count.id,
    averagePostViews: postStats._avg.viewCount,
    totalViews: postStats._sum.viewCount,
    newComments: commentStats._count.id
  }
}

// Category-based aggregations
async function getCategoryAnalytics() {
  const categories = await prisma.category.findMany({
    select: {
      id: true,
      name: true,
      _count: {
        select: {
          posts: true
        }
      }
    }
  })
  
  const categoryStats = await Promise.all(
    categories.map(async (category) => {
      const stats = await prisma.post.aggregate({
        where: {
          categoryId: category.id,
          published: true
        },
        _avg: {
          viewCount: true,
          readTime: true
        },
        _sum: {
          viewCount: true
        },
        _count: {
          id: true
        }
      })
      
      return {
        categoryId: category.id,
        categoryName: category.name,
        postCount: stats._count.id,
        totalViews: stats._sum.viewCount || 0,
        averageViews: stats._avg.viewCount || 0,
        averageReadTime: stats._avg.readTime || 0
      }
    })
  )
  
  return categoryStats.sort((a, b) => b.totalViews - a.totalViews)
}

// User engagement aggregations
async function getUserEngagementMetrics() {
  const engagementStats = await prisma.user.findMany({
    where: {
      isActive: true
    },
    select: {
      id: true,
      name: true,
      email: true,
      createdAt: true,
      _count: {
        select: {
          posts: true,
          comments: true,
          likes: true
        }
      }
    }
  })
  
  // Calculate engagement scores
  const usersWithScores = engagementStats.map(user => {
    const daysSinceJoined = Math.floor(
      (Date.now() - user.createdAt.getTime()) / (1000 * 60 * 60 * 24)
    )
    
    const engagementScore = (
      user._count.posts * 10 +
      user._count.comments * 5 +
      user._count.likes * 1
    ) / Math.max(daysSinceJoined, 1) // Normalize by days
    
    return {
      ...user,
      daysSinceJoined,
      engagementScore: Math.round(engagementScore * 100) / 100
    }
  })
  
  return usersWithScores.sort((a, b) => b.engagementScore - a.engagementScore)
}
```

## GroupBy Operations

### Basic Grouping and Analysis
Categorizing data for deeper insights:

```typescript
// Group users by age ranges
async function getUsersByAgeGroup() {
  const users = await prisma.user.findMany({
    where: {
      age: { not: null }
    },
    select: {
      age: true,
      isActive: true
    }
  })
  
  // Group by age ranges in application logic
  const ageGroups = {
    '18-25': { total: 0, active: 0 },
    '26-35': { total: 0, active: 0 },
    '36-45': { total: 0, active: 0 },
    '46-55': { total: 0, active: 0 },
    '56+': { total: 0, active: 0 }
  }
  
  users.forEach(user => {
    const age = user.age!
    let group: keyof typeof ageGroups
    
    if (age <= 25) group = '18-25'
    else if (age <= 35) group = '26-35'
    else if (age <= 45) group = '36-45'
    else if (age <= 55) group = '46-55'
    else group = '56+'
    
    ageGroups[group].total++
    if (user.isActive) {
      ageGroups[group].active++
    }
  })
  
  return ageGroups
}

// Group posts by publication date
async function getPostsByMonth(year: number) {
  const posts = await prisma.post.findMany({
    where: {
      published: true,
      createdAt: {
        gte: new Date(year, 0, 1),
        lt: new Date(year + 1, 0, 1)
      }
    },
    select: {
      createdAt: true,
      viewCount: true
    }
  })
  
  // Group by month
  const monthlyStats = Array.from({ length: 12 }, (_, i) => ({
    month: i + 1,
    monthName: new Date(year, i, 1).toLocaleString('default', { month: 'long' }),
    postCount: 0,
    totalViews: 0,
    averageViews: 0
  }))
  
  posts.forEach(post => {
    const month = post.createdAt.getMonth()
    monthlyStats[month].postCount++
    monthlyStats[month].totalViews += post.viewCount || 0
  })
  
  // Calculate averages
  monthlyStats.forEach(stat => {
    stat.averageViews = stat.postCount > 0 
      ? Math.round(stat.totalViews / stat.postCount) 
      : 0
  })
  
  return monthlyStats
}

// Group comments by status and calculate metrics
async function getCommentStatusAnalytics() {
  const comments = await prisma.comment.findMany({
    select: {
      status: true,
      createdAt: true,
      post: {
        select: {
          categoryId: true
        }
      }
    }
  })
  
  // Group by status
  const statusGroups = comments.reduce((acc, comment) => {
    const status = comment.status
    if (!acc[status]) {
      acc[status] = {
        count: 0,
        categories: new Set()
      }
    }
    
    acc[status].count++
    if (comment.post.categoryId) {
      acc[status].categories.add(comment.post.categoryId)
    }
    
    return acc
  }, {} as Record<string, { count: number; categories: Set<number> }>)
  
  // Convert to final format
  return Object.entries(statusGroups).map(([status, data]) => ({
    status,
    count: data.count,
    categoriesCount: data.categories.size
  }))
}
```

### Advanced GroupBy with Prisma
Using Prisma's native groupBy functionality:

```typescript
// Native groupBy for user statistics
async function getUserStatsByRole() {
  const usersByRole = await prisma.user.groupBy({
    by: ['role'],
    _count: {
      id: true
    },
    _avg: {
      age: true
    },
    where: {
      isActive: true
    },
    orderBy: {
      _count: {
        id: 'desc'
      }
    }
  })
  
  return usersByRole.map(group => ({
    role: group.role,
    userCount: group._count.id,
    averageAge: Math.round(group._avg.age || 0)
  }))
}

// Group posts by category and author
async function getPostAnalyticsByCategory() {
  const postsByCategory = await prisma.post.groupBy({
    by: ['categoryId'],
    _count: {
      id: true
    },
    _avg: {
      viewCount: true,
      readTime: true
    },
    _sum: {
      viewCount: true
    },
    where: {
      published: true
    },
    having: {
      id: {
        _count: {
          gte: 5 // Only categories with 5+ posts
        }
      }
    },
    orderBy: {
      _sum: {
        viewCount: 'desc'
      }
    }
  })
  
  // Enrich with category names
  const categoryIds = postsByCategory.map(group => group.categoryId).filter(Boolean)
  const categories = await prisma.category.findMany({
    where: {
      id: { in: categoryIds }
    },
    select: {
      id: true,
      name: true
    }
  })
  
  const categoryMap = new Map(categories.map(cat => [cat.id, cat.name]))
  
  return postsByCategory.map(group => ({
    categoryId: group.categoryId,
    categoryName: categoryMap.get(group.categoryId!) || 'Unknown',
    postCount: group._count.id,
    totalViews: group._sum.viewCount || 0,
    averageViews: Math.round(group._avg.viewCount || 0),
    averageReadTime: Math.round(group._avg.readTime || 0)
  }))
}

// Group orders by date and status
async function getOrderAnalyticsByDateAndStatus(startDate: Date, endDate: Date) {
  const ordersByDateAndStatus = await prisma.order.groupBy({
    by: ['status', 'createdAt'],
    _count: {
      id: true
    },
    _sum: {
      total: true
    },
    _avg: {
      total: true
    },
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate
      }
    },
    orderBy: [
      { createdAt: 'asc' },
      { status: 'asc' }
    ]
  })
  
  // Group by day and aggregate statuses
  const dailyStats = new Map<string, {
    date: string
    statuses: Record<string, { count: number; total: number; average: number }>
  }>()
  
  ordersByDateAndStatus.forEach(group => {
    const dateKey = group.createdAt.toISOString().split('T')[0]
    
    if (!dailyStats.has(dateKey)) {
      dailyStats.set(dateKey, {
        date: dateKey,
        statuses: {}
      })
    }
    
    const dayStats = dailyStats.get(dateKey)!
    dayStats.statuses[group.status] = {
      count: group._count.id,
      total: group._sum.total || 0,
      average: group._avg.total || 0
    }
  })
  
  return Array.from(dailyStats.values()).sort((a, b) => a.date.localeCompare(b.date))
}
```

## Performance Optimization for Aggregations

### Caching and Optimization Strategies
Maximizing performance for analytical queries:

```typescript
// Aggregation cache system
class AggregationCache {
  private cache = new Map<string, { data: any; expires: number; lastCalculated: Date }>()
  private readonly defaultTTL = 15 * 60 * 1000 // 15 minutes
  
  generateKey(operation: string, params: any): string {
    return `agg_${operation}_${JSON.stringify(params)}`
  }
  
  async get<T>(key: string): Promise<T | null> {
    const cached = this.cache.get(key)
    
    if (!cached) return null
    
    if (Date.now() > cached.expires) {
      this.cache.delete(key)
      return null
    }
    
    return cached.data
  }
  
  set<T>(key: string, data: T, ttlMs?: number): void {
    const expires = Date.now() + (ttlMs || this.defaultTTL)
    this.cache.set(key, { 
      data, 
      expires, 
      lastCalculated: new Date() 
    })
  }
  
  invalidatePattern(pattern: string): void {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key)
      }
    }
  }
}

const aggCache = new AggregationCache()

// Cached aggregation wrapper
async function cachedAggregation<T>(
  operationName: string,
  params: any,
  aggregationFn: () => Promise<T>,
  ttlMs?: number
): Promise<T> {
  const cacheKey = aggCache.generateKey(operationName, params)
  
  // Try cache first
  const cached = await aggCache.get<T>(cacheKey)
  if (cached) {
    console.log(`Cache hit for aggregation: ${operationName}`)
    return cached
  }
  
  // Execute aggregation and cache result
  console.log(`Cache miss for aggregation: ${operationName}, executing query`)
  const startTime = Date.now()
  
  const result = await aggregationFn()
  
  const duration = Date.now() - startTime
  console.log(`Aggregation ${operationName} completed in ${duration}ms`)
  
  aggCache.set(cacheKey, result, ttlMs)
  
  return result
}

// Optimized dashboard aggregations
async function getOptimizedDashboardStats(userId?: number) {
  return cachedAggregation(
    'dashboard-stats',
    { userId },
    async () => {
      const [
        userStats,
        postStats,
        engagementStats,
        recentActivity
      ] = await Promise.all([
        // User statistics
        prisma.user.aggregate({
          _count: { id: true },
          _avg: { age: true }
        }),
        
        // Post statistics
        prisma.post.aggregate({
          where: { published: true },
          _count: { id: true },
          _sum: { viewCount: true },
          _avg: { viewCount: true }
        }),
        
        // Engagement statistics
        prisma.comment.aggregate({
          where: {
            createdAt: {
              gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
            }
          },
          _count: { id: true }
        }),
        
        // Recent activity count
        prisma.user.count({
          where: {
            lastLoginAt: {
              gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
            }
          }
        })
      ])
      
      return {
        users: {
          total: userStats._count.id,
          averageAge: Math.round(userStats._avg.age || 0),
          activeIn24h: recentActivity
        },
        posts: {
          total: postStats._count.id,
          totalViews: postStats._sum.viewCount || 0,
          averageViews: Math.round(postStats._avg.viewCount || 0)
        },
        engagement: {
          commentsLast7Days: engagementStats._count.id
        }
      }
    },
    5 * 60 * 1000 // 5-minute cache
  )
}

// Batch aggregations for efficiency
async function getBatchedAnalytics(dateRange: { start: Date; end: Date }) {
  return cachedAggregation(
    'batched-analytics',
    dateRange,
    async () => {
      // Use raw SQL for complex aggregations when needed
      const complexStats = await prisma.$queryRaw`
        SELECT 
          DATE(created_at) as date,
          COUNT(*) as post_count,
          AVG(view_count) as avg_views,
          SUM(view_count) as total_views
        FROM posts 
        WHERE created_at BETWEEN ${dateRange.start} AND ${dateRange.end}
          AND published = true
        GROUP BY DATE(created_at)
        ORDER BY date
      `
      
      // Combine with Prisma aggregations
      const [userGrowth, categoryDistribution] = await Promise.all([
        prisma.user.groupBy({
          by: ['createdAt'],
          _count: { id: true },
          where: {
            createdAt: {
              gte: dateRange.start,
              lte: dateRange.end
            }
          }
        }),
        
        prisma.post.groupBy({
          by: ['categoryId'],
          _count: { id: true },
          _sum: { viewCount: true },
          where: {
            published: true,
            createdAt: {
              gte: dateRange.start,
              lte: dateRange.end
            }
          }
        })
      ])
      
      return {
        dailyPostStats: complexStats,
        userGrowth,
        categoryDistribution
      }
    },
    10 * 60 * 1000 // 10-minute cache
  )
}
```

### Real-time Analytics System
Building live analytics dashboards:

```typescript
// Real-time analytics with WebSocket updates
class RealTimeAnalytics {
  private subscribers = new Map<string, ((data: any) => void)[]>()
  private updateInterval: NodeJS.Timeout | null = null
  
  constructor() {
    this.startPeriodicUpdates()
  }
  
  subscribe(channel: string, callback: (data: any) => void) {
    if (!this.subscribers.has(channel)) {
      this.subscribers.set(channel, [])
    }
    this.subscribers.get(channel)!.push(callback)
  }
  
  unsubscribe(channel: string, callback: (data: any) => void) {
    const callbacks = this.subscribers.get(channel)
    if (callbacks) {
      const index = callbacks.indexOf(callback)
      if (index > -1) {
        callbacks.splice(index, 1)
      }
    }
  }
  
  private async startPeriodicUpdates() {
    this.updateInterval = setInterval(async () => {
      await this.updateLiveStats()
    }, 30000) // Update every 30 seconds
  }
  
  private async updateLiveStats() {
    try {
      // Get live counts
      const liveStats = await this.getLiveStatistics()
      
      // Notify subscribers
      this.notifySubscribers('live-stats', liveStats)
      
      // Check for significant changes and trigger alerts
      await this.checkForAlerts(liveStats)
      
    } catch (error) {
      console.error('Error updating live stats:', error)
    }
  }
  
  private async getLiveStatistics() {
    const now = new Date()
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000)
    
    const [
      activeUsers,
      newPosts,
      newComments,
      systemLoad
    ] = await Promise.all([
      prisma.user.count({
        where: {
          lastActivityAt: {
            gte: oneHourAgo
          }
        }
      }),
      
      prisma.post.count({
        where: {
          createdAt: {
            gte: oneHourAgo
          }
        }
      }),
      
      prisma.comment.count({
        where: {
          createdAt: {
            gte: oneHourAgo
          }
        }
      }),
      
      // System load metrics
      this.getSystemLoadMetrics()
    ])
    
    return {
      timestamp: now,
      activeUsers,
      newPosts,
      newComments,
      systemLoad
    }
  }
  
  private async getSystemLoadMetrics() {
    // Example system metrics
    return {
      dbConnections: 15, // Would come from actual monitoring
      queryLatency: 45,  // milliseconds
      errorRate: 0.02    // percentage
    }
  }
  
  private notifySubscribers(channel: string, data: any) {
    const callbacks = this.subscribers.get(channel)
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(data)
        } catch (error) {
          console.error('Error in subscriber callback:', error)
        }
      })
    }
  }
  
  private async checkForAlerts(stats: any) {
    // Alert thresholds
    const THRESHOLDS = {
      HIGH_ACTIVITY: 1000,
      LOW_ACTIVITY: 10,
      HIGH_ERROR_RATE: 0.05
    }
    
    if (stats.activeUsers > THRESHOLDS.HIGH_ACTIVITY) {
      this.notifySubscribers('alerts', {
        type: 'HIGH_ACTIVITY',
        message: `High activity detected: ${stats.activeUsers} active users`,
        severity: 'warning'
      })
    }
    
    if (stats.systemLoad.errorRate > THRESHOLDS.HIGH_ERROR_RATE) {
      this.notifySubscribers('alerts', {
        type: 'HIGH_ERROR_RATE',
        message: `High error rate: ${(stats.systemLoad.errorRate * 100).toFixed(2)}%`,
        severity: 'critical'
      })
    }
  }
  
  stop() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval)
      this.updateInterval = null
    }
  }
}

// Usage example
const analytics = new RealTimeAnalytics()

// Subscribe to live updates
analytics.subscribe('live-stats', (data) => {
  console.log('Live stats update:', data)
  // Send to WebSocket clients, update dashboard, etc.
})

analytics.subscribe('alerts', (alert) => {
  console.log('Alert triggered:', alert)
  // Send notifications, update monitoring systems, etc.
})
```

## Exercise: Advanced Analytics System

Design a comprehensive analytics and reporting system:

```typescript
// Your task: Build a production-ready analytics system

// Requirements:
// 1. Support real-time and historical analytics
// 2. Implement efficient caching and optimization strategies
// 3. Add flexible grouping and filtering capabilities
// 4. Include performance monitoring and query optimization
// 5. Support custom metrics and KPI calculations
// 6. Implement data export and reporting features
// 7. Add alerting and threshold monitoring
// 8. Support multi-tenant analytics with data isolation

interface AnalyticsSystemConfig {
  // Define configuration options
}

class AdvancedAnalyticsSystem {
  // Implement comprehensive analytics system
  
  // Methods to implement:
  // - count<T>(model: string, criteria: any, options?: CountOptions)
  // - aggregate<T>(model: string, aggregation: AggregationOptions)
  // - groupBy<T>(model: string, grouping: GroupByOptions)
  // - timeSeriesAnalysis(model: string, dateField: string, interval: string)
  // - customMetrics(metricDefinitions: MetricDefinition[])
  // - generateReport(reportConfig: ReportConfig)
  // - subscribeToLiveUpdates(channel: string, callback: UpdateCallback)
  // - exportData(format: 'csv' | 'json' | 'excel', criteria: ExportCriteria)
}

// Bonus features:
// - Machine learning integration for predictive analytics
// - Advanced data visualization support
// - Custom dashboard builder
// - A/B testing analytics
// - User behavior analytics
// - Performance benchmarking and optimization suggestions
```

## Key Takeaways

1. **Count Operations**: Use simple counts for basic metrics, nested counts for relationship analysis
2. **Aggregations**: Leverage sum, avg, min, max for statistical analysis and reporting
3. **GroupBy**: Organize data into meaningful categories for deeper insights
4. **Performance**: Implement caching strategies for expensive aggregation operations
5. **Real-time Analytics**: Build live monitoring systems for immediate insights
6. **Optimization**: Use batch operations and raw SQL for complex analytical queries
7. **Scalability**: Design aggregation patterns that scale with data growth

## Next Steps

Congratulations! You've completed **Section 4.2: Basic CRUD Operations**. You now have comprehensive mastery of all fundamental database operations with Prisma Client. In the next section, **4.3 Advanced Queries & Filtering**, we'll explore sophisticated querying techniques, complex filtering patterns, and advanced data retrieval strategies.

---

**Estimated Time:** 23 minutes
**Difficulty:** Intermediate to Advanced
**Prerequisites:** Understanding of statistical concepts, data analysis principles, and performance optimization strategies
