# 4.2.1 Create Operations (`create`, `createMany`)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master single record creation with `create()` method and advanced options
- Implement bulk record creation using `createMany()` for optimal performance
- Handle create operations with nested data and relationships
- Configure creation behavior with skipDuplicates and data validation
- Implement error handling patterns for create operations
- Optimize create operations for different data volumes and scenarios
- Design create operations with proper type safety and validation
- Handle create conflicts and duplicate prevention strategies

## Introduction

Think of Prisma's create operations as **the master chef in a world-class restaurant kitchen** - like a culinary expert who can prepare both individual artisanal dishes with perfect attention to detail and coordinate large banquet preparations with efficiency and precision. Just as a master chef knows when to craft a single perfect plate and when to efficiently prepare hundreds of servings, Prisma Client provides both `create()` for detailed single record creation and `createMany()` for efficient bulk operations, each optimized for their specific use cases.

Understanding create operations is fundamental to building applications that can efficiently insert data while maintaining data integrity and performance.

## Single Record Creation with `create()`

### Basic Create Operations
The foundation of data insertion:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Basic user creation
async function createUser() {
  const user = await prisma.user.create({
    data: {
      email: 'john.doe@example.com',
      name: 'John Doe',
      age: 30
    }
  })
  
  console.log('Created user:', user)
  return user
}

// Create with optional fields
async function createUserWithOptionals() {
  const user = await prisma.user.create({
    data: {
      email: 'jane.smith@example.com',
      name: 'Jane Smith',
      // age is optional in schema
      bio: 'Software developer passionate about TypeScript',
      isActive: true
    }
  })
  
  return user
}

// Create with computed/derived fields
async function createUserWithDefaults() {
  const user = await prisma.user.create({
    data: {
      email: 'admin@example.com',
      name: 'Admin User',
      // Prisma will use schema defaults
      // createdAt: auto-generated
      // updatedAt: auto-generated
      // id: auto-increment
    }
  })
  
  return user
}
```

### Advanced Create with Select and Include
Controlling returned data and including relations:

```typescript
// Create and return specific fields only
async function createUserSelectFields() {
  const user = await prisma.user.create({
    data: {
      email: 'selective@example.com',
      name: 'Selective User',
      age: 25
    },
    select: {
      id: true,
      email: true,
      name: true,
      createdAt: true
      // Excludes age, bio, updatedAt, etc.
    }
  })
  
  return user // TypeScript knows exact shape
}

// Create with related data included
async function createUserWithProfile() {
  const user = await prisma.user.create({
    data: {
      email: 'profile@example.com',
      name: 'Profile User',
      age: 28,
      profile: {
        create: {
          bio: 'Experienced developer',
          website: 'https://profileuser.com',
          social: {
            twitter: '@profileuser',
            github: 'profileuser'
          }
        }
      }
    },
    include: {
      profile: true,
      posts: true // Include all related posts (empty initially)
    }
  })
  
  return user
}

// Create with nested selects for performance
async function createUserWithNestedSelect() {
  const user = await prisma.user.create({
    data: {
      email: 'nested@example.com',
      name: 'Nested User',
      profile: {
        create: {
          bio: 'Developer with nested selections',
          website: 'https://nested.dev'
        }
      }
    },
    select: {
      id: true,
      email: true,
      name: true,
      profile: {
        select: {
          id: true,
          bio: true,
          website: true
          // Excludes social, createdAt, etc.
        }
      }
    }
  })
  
  return user
}
```

### Create with Nested Relationships
Creating records with related data:

```typescript
// Create user with nested post creation
async function createUserWithPosts() {
  const user = await prisma.user.create({
    data: {
      email: 'blogger@example.com',
      name: 'Blog Writer',
      age: 32,
      posts: {
        create: [
          {
            title: 'Getting Started with Prisma',
            content: 'Prisma makes database access easy...',
            published: true,
            tags: {
              connectOrCreate: [
                {
                  where: { name: 'prisma' },
                  create: { name: 'prisma', color: '#2D3748' }
                },
                {
                  where: { name: 'typescript' },
                  create: { name: 'typescript', color: '#3178C6' }
                }
              ]
            }
          },
          {
            title: 'Advanced Database Patterns',
            content: 'Learn advanced patterns for...',
            published: false,
            tags: {
              connect: [
                { name: 'prisma' } // Assuming this tag exists
              ]
            }
          }
        ]
      },
      profile: {
        create: {
          bio: 'Technical writer and developer',
          website: 'https://techblog.example.com',
          social: {
            twitter: '@techwriter',
            linkedin: 'tech-writer'
          }
        }
      }
    },
    include: {
      posts: {
        include: {
          tags: true
        }
      },
      profile: true
    }
  })
  
  return user
}

// Create with existing relationship connections
async function createPostForExistingUser() {
  const post = await prisma.post.create({
    data: {
      title: 'New Post for Existing User',
      content: 'This post is connected to an existing user...',
      published: true,
      author: {
        connect: { 
          email: 'blogger@example.com' // Connect to existing user
        }
      },
      categories: {
        connect: [
          { id: 1 }, // Connect to existing categories
          { id: 3 }
        ]
      },
      tags: {
        connectOrCreate: [
          {
            where: { name: 'database' },
            create: { name: 'database', color: '#FF6B6B' }
          }
        ]
      }
    },
    include: {
      author: {
        select: {
          id: true,
          name: true,
          email: true
        }
      },
      categories: true,
      tags: true
    }
  })
  
  return post
}
```

### Create with JSON and Complex Data Types
Handling complex data structures:

```typescript
// Create with JSON data
async function createUserWithMetadata() {
  const user = await prisma.user.create({
    data: {
      email: 'metadata@example.com',
      name: 'Metadata User',
      age: 29,
      metadata: {
        preferences: {
          theme: 'dark',
          language: 'en',
          notifications: {
            email: true,
            push: false,
            sms: true
          }
        },
        analytics: {
          lastLogin: new Date().toISOString(),
          loginCount: 1,
          ipAddresses: ['192.168.1.1'],
          userAgent: 'Mozilla/5.0...'
        },
        customFields: {
          department: 'Engineering',
          jobTitle: 'Senior Developer',
          skills: ['TypeScript', 'React', 'Node.js', 'Prisma']
        }
      }
    }
  })
  
  return user
}

// Create with arrays and enums
async function createUserWithArraysAndEnums() {
  const user = await prisma.user.create({
    data: {
      email: 'arrays@example.com',
      name: 'Arrays User',
      age: 26,
      roles: ['USER', 'MODERATOR'], // Enum array
      tags: ['developer', 'typescript', 'react'], // String array
      settings: {
        theme: 'DARK', // Enum value
        timezone: 'UTC',
        features: ['BETA_FEATURES', 'ADVANCED_SEARCH'] // Enum array
      }
    }
  })
  
  return user
}

// Create with date/time handling
async function createEventWithDates() {
  const event = await prisma.event.create({
    data: {
      title: 'Annual Conference 2024',
      description: 'Our biggest conference yet!',
      startDate: new Date('2024-09-15T09:00:00Z'),
      endDate: new Date('2024-09-17T17:00:00Z'),
      registrationDeadline: new Date('2024-09-01T23:59:59Z'),
      location: {
        venue: 'Convention Center',
        address: '123 Main St, City, State',
        coordinates: {
          lat: 40.7128,
          lng: -74.0060
        }
      },
      organizer: {
        connect: { email: 'events@company.com' }
      }
    }
  })
  
  return event
}
```

## Bulk Operations with `createMany()`

### Basic Bulk Creation
Efficient insertion of multiple records:

```typescript
// Basic createMany usage
async function createManyUsers() {
  const users = await prisma.user.createMany({
    data: [
      {
        email: 'user1@example.com',
        name: 'User One',
        age: 25
      },
      {
        email: 'user2@example.com',
        name: 'User Two',
        age: 30
      },
      {
        email: 'user3@example.com',
        name: 'User Three',
        age: 28
      }
    ]
  })
  
  console.log(`Created ${users.count} users`)
  return users
}

// Bulk creation with skipDuplicates
async function createManyUsersSkipDuplicates() {
  const users = await prisma.user.createMany({
    data: [
      {
        email: 'unique1@example.com',
        name: 'Unique User 1',
        age: 25
      },
      {
        email: 'unique2@example.com',
        name: 'Unique User 2',
        age: 30
      },
      {
        email: 'user1@example.com', // This might already exist
        name: 'Duplicate Email User',
        age: 35
      }
    ],
    skipDuplicates: true // Skip records that would cause unique constraint violations
  })
  
  console.log(`Created ${users.count} new users (duplicates skipped)`)
  return users
}

// Generate bulk data programmatically
async function createManyUsersGenerated() {
  const userData = Array.from({ length: 1000 }, (_, index) => ({
    email: `user${index + 1}@example.com`,
    name: `Generated User ${index + 1}`,
    age: Math.floor(Math.random() * 50) + 18, // Random age 18-67
    isActive: Math.random() > 0.1, // 90% active
    metadata: {
      generatedAt: new Date().toISOString(),
      batchId: `batch_${Math.floor(index / 100)}`,
      source: 'bulk_generation'
    }
  }))
  
  const result = await prisma.user.createMany({
    data: userData,
    skipDuplicates: true
  })
  
  console.log(`Generated and created ${result.count} users`)
  return result
}
```

### Optimized Bulk Operations
Handling large datasets efficiently:

```typescript
// Chunked bulk operations for very large datasets
async function createManyUsersChunked(users: any[], chunkSize = 1000) {
  const results = []
  
  for (let i = 0; i < users.length; i += chunkSize) {
    const chunk = users.slice(i, i + chunkSize)
    
    console.log(`Processing chunk ${Math.floor(i / chunkSize) + 1}/${Math.ceil(users.length / chunkSize)}`)
    
    const result = await prisma.user.createMany({
      data: chunk,
      skipDuplicates: true
    })
    
    results.push(result)
    
    // Small delay to prevent overwhelming the database
    if (i + chunkSize < users.length) {
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }
  
  const totalCreated = results.reduce((sum, result) => sum + result.count, 0)
  console.log(`Total created: ${totalCreated} users`)
  
  return { totalCreated, chunks: results.length }
}

// Bulk creation with transaction for atomicity
async function createManyWithTransaction() {
  const result = await prisma.$transaction(async (tx) => {
    // Create users
    const users = await tx.user.createMany({
      data: [
        { email: 'tx1@example.com', name: 'Transaction User 1', age: 25 },
        { email: 'tx2@example.com', name: 'Transaction User 2', age: 30 },
        { email: 'tx3@example.com', name: 'Transaction User 3', age: 28 }
      ]
    })
    
    // Create related posts (separate createMany call)
    const posts = await tx.post.createMany({
      data: [
        { 
          title: 'First Transaction Post', 
          content: 'Content 1',
          authorEmail: 'tx1@example.com' // Assuming author relation by email
        },
        { 
          title: 'Second Transaction Post', 
          content: 'Content 2',
          authorEmail: 'tx2@example.com'
        }
      ]
    })
    
    return { users: users.count, posts: posts.count }
  })
  
  console.log(`Transaction completed: ${result.users} users, ${result.posts} posts`)
  return result
}

// Bulk operations with validation and error handling
async function createManyWithValidation(userData: any[]) {
  // Validate data before insertion
  const validUsers = userData.filter(user => {
    return user.email && 
           user.name && 
           user.email.includes('@') &&
           user.name.length > 0 &&
           (!user.age || (user.age >= 0 && user.age <= 120))
  })
  
  if (validUsers.length !== userData.length) {
    console.warn(`Filtered out ${userData.length - validUsers.length} invalid records`)
  }
  
  try {
    const result = await prisma.user.createMany({
      data: validUsers,
      skipDuplicates: true
    })
    
    return {
      success: true,
      created: result.count,
      skipped: validUsers.length - result.count,
      invalid: userData.length - validUsers.length
    }
  } catch (error) {
    console.error('Bulk creation failed:', error)
    return {
      success: false,
      error: error.message,
      attempted: validUsers.length
    }
  }
}
```

## Error Handling and Validation

### Comprehensive Error Handling Patterns
Robust error management for create operations:

```typescript
// Custom error types for better error handling
class CreateOperationError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message)
    this.name = 'CreateOperationError'
  }
}

// Detailed error handling for create operations
async function createUserWithErrorHandling(userData: any) {
  try {
    // Pre-validation
    if (!userData.email || !userData.email.includes('@')) {
      throw new CreateOperationError(
        'Invalid email format',
        'INVALID_EMAIL',
        { email: userData.email }
      )
    }
    
    if (!userData.name || userData.name.trim().length === 0) {
      throw new CreateOperationError(
        'Name is required',
        'MISSING_NAME',
        { providedName: userData.name }
      )
    }
    
    const user = await prisma.user.create({
      data: {
        email: userData.email.toLowerCase().trim(),
        name: userData.name.trim(),
        age: userData.age,
        bio: userData.bio?.trim() || null
      },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true
      }
    })
    
    return { success: true, user }
    
  } catch (error: any) {
    // Handle Prisma-specific errors
    if (error.code === 'P2002') {
      // Unique constraint violation
      const failedField = error.meta?.target?.[0] || 'unknown'
      return {
        success: false,
        error: 'DUPLICATE_ENTRY',
        message: `${failedField} already exists`,
        field: failedField
      }
    }
    
    if (error.code === 'P2000') {
      // Value too long for column
      return {
        success: false,
        error: 'VALUE_TOO_LONG',
        message: 'One or more values exceed maximum length',
        details: error.meta
      }
    }
    
    if (error.code === 'P2011') {
      // Null constraint violation
      return {
        success: false,
        error: 'MISSING_REQUIRED_FIELD',
        message: 'Required field is missing',
        field: error.meta?.column_name
      }
    }
    
    // Handle custom validation errors
    if (error instanceof CreateOperationError) {
      return {
        success: false,
        error: error.code,
        message: error.message,
        details: error.details
      }
    }
    
    // Generic error fallback
    console.error('Unexpected create error:', error)
    return {
      success: false,
      error: 'UNKNOWN_ERROR',
      message: 'An unexpected error occurred during user creation'
    }
  }
}

// Batch creation with individual error handling
async function createManyWithIndividualErrorHandling(usersData: any[]) {
  const results = {
    successful: [],
    failed: [],
    total: usersData.length
  }
  
  for (const userData of usersData) {
    const result = await createUserWithErrorHandling(userData)
    
    if (result.success) {
      results.successful.push(result.user)
    } else {
      results.failed.push({
        data: userData,
        error: result.error,
        message: result.message
      })
    }
  }
  
  console.log(`Batch creation completed: ${results.successful.length} successful, ${results.failed.length} failed`)
  return results
}
```

### Data Validation and Sanitization
Ensuring data quality before creation:

```typescript
// Comprehensive data validation utility
interface UserValidationResult {
  isValid: boolean
  sanitizedData?: any
  errors: string[]
}

function validateAndSanitizeUserData(userData: any): UserValidationResult {
  const errors: string[] = []
  const sanitized: any = {}
  
  // Email validation and sanitization
  if (!userData.email) {
    errors.push('Email is required')
  } else if (typeof userData.email !== 'string') {
    errors.push('Email must be a string')
  } else {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    const email = userData.email.toLowerCase().trim()
    
    if (!emailRegex.test(email)) {
      errors.push('Email format is invalid')
    } else if (email.length > 255) {
      errors.push('Email is too long (max 255 characters)')
    } else {
      sanitized.email = email
    }
  }
  
  // Name validation and sanitization
  if (!userData.name) {
    errors.push('Name is required')
  } else if (typeof userData.name !== 'string') {
    errors.push('Name must be a string')
  } else {
    const name = userData.name.trim()
    
    if (name.length === 0) {
      errors.push('Name cannot be empty')
    } else if (name.length > 100) {
      errors.push('Name is too long (max 100 characters)')
    } else if (!/^[a-zA-Z\s'-]+$/.test(name)) {
      errors.push('Name contains invalid characters')
    } else {
      sanitized.name = name
    }
  }
  
  // Age validation
  if (userData.age !== undefined) {
    if (typeof userData.age !== 'number') {
      errors.push('Age must be a number')
    } else if (userData.age < 0 || userData.age > 150) {
      errors.push('Age must be between 0 and 150')
    } else {
      sanitized.age = Math.floor(userData.age)
    }
  }
  
  // Bio validation and sanitization
  if (userData.bio !== undefined) {
    if (typeof userData.bio !== 'string') {
      errors.push('Bio must be a string')
    } else {
      const bio = userData.bio.trim()
      if (bio.length > 1000) {
        errors.push('Bio is too long (max 1000 characters)')
      } else {
        sanitized.bio = bio || null
      }
    }
  }
  
  return {
    isValid: errors.length === 0,
    sanitizedData: errors.length === 0 ? sanitized : undefined,
    errors
  }
}

// Create with validation
async function createValidatedUser(userData: any) {
  const validation = validateAndSanitizeUserData(userData)
  
  if (!validation.isValid) {
    return {
      success: false,
      errors: validation.errors
    }
  }
  
  try {
    const user = await prisma.user.create({
      data: validation.sanitizedData,
      select: {
        id: true,
        email: true,
        name: true,
        age: true,
        bio: true,
        createdAt: true
      }
    })
    
    return { success: true, user }
  } catch (error) {
    return await createUserWithErrorHandling(validation.sanitizedData!)
  }
}
```

## Performance Optimization Strategies

### Optimizing Create Operations
Maximizing performance for different scenarios:

```typescript
// Performance monitoring for create operations
async function createWithPerformanceMonitoring<T>(
  operation: () => Promise<T>,
  operationName: string
): Promise<{ result: T; metrics: { duration: number; memory: any } }> {
  const startTime = Date.now()
  const startMemory = process.memoryUsage()
  
  try {
    const result = await operation()
    const endTime = Date.now()
    const endMemory = process.memoryUsage()
    
    const metrics = {
      duration: endTime - startTime,
      memory: {
        heapUsed: endMemory.heapUsed - startMemory.heapUsed,
        heapTotal: endMemory.heapTotal - startMemory.heapTotal,
        external: endMemory.external - startMemory.external
      }
    }
    
    console.log(`${operationName} completed in ${metrics.duration}ms`)
    
    if (metrics.duration > 1000) {
      console.warn(`Slow operation detected: ${operationName} took ${metrics.duration}ms`)
    }
    
    return { result, metrics }
    
  } catch (error) {
    const endTime = Date.now()
    console.error(`${operationName} failed after ${endTime - startTime}ms:`, error)
    throw error
  }
}

// Batch size optimization
async function findOptimalBatchSize(sampleData: any[], maxTestSize = 10000) {
  const batchSizes = [100, 500, 1000, 2000, 5000]
  const results: { batchSize: number; timePerRecord: number; totalTime: number }[] = []
  
  for (const batchSize of batchSizes) {
    const testData = sampleData.slice(0, Math.min(maxTestSize, sampleData.length))
    const chunks = Math.ceil(testData.length / batchSize)
    
    console.log(`Testing batch size ${batchSize} (${chunks} chunks)...`)
    
    const { metrics } = await createWithPerformanceMonitoring(async () => {
      for (let i = 0; i < testData.length; i += batchSize) {
        const chunk = testData.slice(i, i + batchSize)
        await prisma.user.createMany({
          data: chunk,
          skipDuplicates: true
        })
      }
    }, `Batch size ${batchSize}`)
    
    results.push({
      batchSize,
      totalTime: metrics.duration,
      timePerRecord: metrics.duration / testData.length
    })
    
    // Clean up test data
    await prisma.user.deleteMany({
      where: {
        email: { in: testData.map(u => u.email) }
      }
    })
  }
  
  // Find optimal batch size (lowest time per record)
  const optimal = results.reduce((best, current) => 
    current.timePerRecord < best.timePerRecord ? current : best
  )
  
  console.log('Batch size performance results:', results)
  console.log(`Optimal batch size: ${optimal.batchSize} (${optimal.timePerRecord.toFixed(2)}ms per record)`)
  
  return optimal
}

// Connection pool optimization for create operations
async function createWithConnectionOptimization() {
  // Use a separate client for bulk operations if needed
  const bulkClient = new PrismaClient({
    datasources: {
      db: {
        url: process.env.DATABASE_URL + '?connection_limit=20&pool_timeout=20'
      }
    }
  })
  
  try {
    const { result, metrics } = await createWithPerformanceMonitoring(async () => {
      return await bulkClient.user.createMany({
        data: Array.from({ length: 5000 }, (_, i) => ({
          email: `bulk${i}@example.com`,
          name: `Bulk User ${i}`,
          age: Math.floor(Math.random() * 50) + 18
        })),
        skipDuplicates: true
      })
    }, 'Optimized bulk creation')
    
    return { result, metrics }
  } finally {
    await bulkClient.$disconnect()
  }
}
```

## Exercise: Advanced Create System

Design a comprehensive create operation system:

```typescript
// Your task: Build a production-ready create operation system

// Requirements:
// 1. Support both single and bulk creation
// 2. Implement comprehensive validation and sanitization
// 3. Handle all error scenarios gracefully
// 4. Include performance monitoring and optimization
// 5. Support nested relationship creation
// 6. Implement data transformation pipeline
// 7. Add audit logging for all create operations
// 8. Support different data sources and formats

interface CreateSystemConfig {
  // Define configuration options
}

class AdvancedCreateSystem {
  // Implement comprehensive create system
  
  // Methods to implement:
  // - createSingle<T>(model: string, data: any, options?: CreateOptions)
  // - createMany<T>(model: string, data: any[], options?: BulkCreateOptions)
  // - validateData(data: any, schema: ValidationSchema)
  // - optimizeBatchSize(sampleData: any[])
  // - createWithTransaction(operations: CreateOperation[])
  // - auditLog(operation: string, data: any, result: any)
  // - handleRelationships(data: any, relationConfig: RelationConfig)
}

// Bonus features:
// - Automatic retry with exponential backoff
// - Data transformation pipelines
// - Custom validation rules engine
// - Performance analytics and reporting
// - Integration with external data sources
// - Real-time progress tracking for large operations
```

## Key Takeaways

1. **Single vs Bulk**: Use `create()` for detailed operations with relations, `createMany()` for performance with large datasets
2. **Data Validation**: Always validate and sanitize data before insertion to prevent errors and security issues
3. **Error Handling**: Implement comprehensive error handling for different failure scenarios
4. **Performance Optimization**: Monitor performance and optimize batch sizes for your specific use case
5. **Relationship Management**: Understand when to use nested creates vs separate operations for related data
6. **Type Safety**: Leverage TypeScript and Prisma's generated types for compile-time safety
7. **Transaction Awareness**: Use transactions for operations that must succeed or fail together

## Next Steps

In the next lesson, we'll explore **Read Operations** (`findUnique`, `findFirst`, `findMany`) and learn how to efficiently query and retrieve data with advanced filtering, pagination, and optimization techniques.

---

**Estimated Time:** 22 minutes
**Difficulty:** Intermediate to Advanced
**Prerequisites:** Understanding of database concepts, TypeScript, and basic Prisma Client usage
