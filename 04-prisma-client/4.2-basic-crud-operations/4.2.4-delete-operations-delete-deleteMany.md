# 4.2.4 Delete Operations (`delete`, `deleteMany`)

## Learning Objectives
By the end of this lesson, you will be able to:
- Master single record deletion with `delete()` method and safety mechanisms
- Implement efficient bulk deletion using `deleteMany()` with proper safeguards
- Design soft deletion patterns for data recovery and audit requirements
- Handle cascade deletions and referential integrity in complex data models
- Implement deletion authorization and access control mechanisms
- Build robust deletion systems with confirmation workflows and recovery options
- Optimize delete operations for performance while maintaining data consistency
- Design deletion strategies for different business scenarios and compliance requirements

## Introduction

Think of Prisma's delete operations as **the careful demolition expert of a historic city district** - like a master architect who must precisely remove specific structures (delete) or efficiently clear entire blocks (deleteMany) while carefully considering historical preservation, safety protocols, and the interconnected infrastructure that depends on what's being removed. Just as a demolition expert knows when to preserve foundations for future construction (soft deletion) versus complete removal (hard deletion), and understands the cascading effects of removing load-bearing structures, Prisma Client provides sophisticated deletion operations that balance efficiency with safety, ensuring data integrity while supporting various business requirements from simple cleanup to complex compliance scenarios.

Understanding delete operations is crucial for building applications that can safely manage data lifecycle while protecting against accidental data loss.

## Single Record Deletion with `delete()`

### Basic Delete Operations
The foundation of safe data removal:

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Basic user deletion
async function deleteUser(id: number) {
  try {
    const user = await prisma.user.delete({
      where: {
        id: id
      }
    })
    
    console.log('Deleted user:', user)
    return { success: true, deletedUser: user }
  } catch (error: any) {
    if (error.code === 'P2025') {
      return { 
        success: false, 
        error: 'USER_NOT_FOUND',
        message: `User with ID ${id} not found`
      }
    }
    throw error
  }
}

// Delete with specific field return
async function deleteUserSelectFields(id: number) {
  const user = await prisma.user.delete({
    where: { id },
    select: {
      id: true,
      name: true,
      email: true,
      deletedAt: true
      // Only return specific fields of deleted record
    }
  })
  
  return user
}

// Delete with relationship data included
async function deleteUserWithRelatedData(id: number) {
  const user = await prisma.user.delete({
    where: { id },
    include: {
      posts: {
        select: {
          id: true,
          title: true
        }
      },
      profile: true,
      comments: {
        select: {
          id: true,
          content: true
        }
      }
    }
  })
  
  return user
}

// Safe delete with existence check
async function safeDeleteUser(id: number) {
  // First check if user exists and get related data count
  const userWithCounts = await prisma.user.findUnique({
    where: { id },
    include: {
      _count: {
        select: {
          posts: true,
          comments: true,
          followers: true,
          following: true
        }
      }
    }
  })
  
  if (!userWithCounts) {
    return {
      success: false,
      error: 'USER_NOT_FOUND',
      message: `User with ID ${id} not found`
    }
  }
  
  // Check if user has important related data
  const totalRelatedRecords = Object.values(userWithCounts._count).reduce((sum, count) => sum + count, 0)
  
  if (totalRelatedRecords > 0) {
    return {
      success: false,
      error: 'HAS_RELATED_DATA',
      message: 'User has related data that must be handled first',
      relatedCounts: userWithCounts._count
    }
  }
  
  // Safe to delete
  const deletedUser = await prisma.user.delete({
    where: { id }
  })
  
  return {
    success: true,
    deletedUser,
    message: 'User deleted successfully'
  }
}
```

### Conditional Deletion with Business Logic
Implementing deletion rules and constraints:

```typescript
// Delete with business rule validation
async function deleteUserWithValidation(id: number, deletedBy: number) {
  // Check if user can be deleted
  const user = await prisma.user.findUnique({
    where: { id },
    include: {
      posts: {
        where: {
          published: true
        },
        _count: true
      },
      _count: {
        select: {
          orders: { where: { status: 'PENDING' } },
          subscriptions: { where: { status: 'ACTIVE' } }
        }
      }
    }
  })
  
  if (!user) {
    return { success: false, error: 'USER_NOT_FOUND' }
  }
  
  // Business rules validation
  if (user._count.orders > 0) {
    return {
      success: false,
      error: 'HAS_PENDING_ORDERS',
      message: 'Cannot delete user with pending orders'
    }
  }
  
  if (user._count.subscriptions > 0) {
    return {
      success: false,
      error: 'HAS_ACTIVE_SUBSCRIPTIONS',
      message: 'Cannot delete user with active subscriptions'
    }
  }
  
  if (user.posts.length > 10) {
    return {
      success: false,
      error: 'TOO_MANY_POSTS',
      message: 'Users with more than 10 published posts cannot be deleted'
    }
  }
  
  // Check if user is trying to delete themselves
  if (id === deletedBy) {
    return {
      success: false,
      error: 'SELF_DELETION_FORBIDDEN',
      message: 'Users cannot delete their own accounts'
    }
  }
  
  // Proceed with deletion
  const deletedUser = await prisma.user.delete({
    where: { id }
  })
  
  return { success: true, deletedUser }
}

// Delete with confirmation token
async function initiateUserDeletion(userId: number, requestedBy: number) {
  const confirmationToken = `del_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours
  
  // Store deletion request
  const deletionRequest = await prisma.deletionRequest.create({
    data: {
      entityType: 'User',
      entityId: userId,
      requestedBy: requestedBy,
      confirmationToken,
      expiresAt,
      status: 'PENDING'
    }
  })
  
  return {
    success: true,
    confirmationToken,
    expiresAt,
    message: 'Deletion initiated. Use confirmation token to complete deletion.'
  }
}

async function confirmUserDeletion(confirmationToken: string) {
  const deletionRequest = await prisma.deletionRequest.findUnique({
    where: { confirmationToken },
    include: {
      requestedByUser: {
        select: { id: true, name: true, email: true }
      }
    }
  })
  
  if (!deletionRequest) {
    return { success: false, error: 'INVALID_TOKEN' }
  }
  
  if (deletionRequest.status !== 'PENDING') {
    return { success: false, error: 'ALREADY_PROCESSED' }
  }
  
  if (new Date() > deletionRequest.expiresAt) {
    return { success: false, error: 'TOKEN_EXPIRED' }
  }
  
  // Perform the actual deletion
  const result = await prisma.$transaction(async (tx) => {
    // Delete the user
    const deletedUser = await tx.user.delete({
      where: { id: deletionRequest.entityId }
    })
    
    // Mark deletion request as completed
    await tx.deletionRequest.update({
      where: { id: deletionRequest.id },
      data: {
        status: 'COMPLETED',
        completedAt: new Date()
      }
    })
    
    return deletedUser
  })
  
  return { success: true, deletedUser: result }
}
```

### Cascade Deletion Handling
Managing related data during deletion:

```typescript
// Manual cascade deletion with transaction
async function deleteUserWithCascade(userId: number) {
  return await prisma.$transaction(async (tx) => {
    // Delete in proper order to respect foreign key constraints
    
    // 1. Delete user's likes
    await tx.like.deleteMany({
      where: { userId }
    })
    
    // 2. Delete user's comments
    await tx.comment.deleteMany({
      where: { authorId: userId }
    })
    
    // 3. Delete user's post tags (many-to-many)
    await tx.post.updateMany({
      where: { authorId: userId },
      data: {
        tags: {
          set: [] // Clear all tag relationships
        }
      }
    })
    
    // 4. Delete user's posts
    await tx.post.deleteMany({
      where: { authorId: userId }
    })
    
    // 5. Delete user's profile
    await tx.profile.deleteMany({
      where: { userId }
    })
    
    // 6. Handle followers/following relationships
    await tx.follow.deleteMany({
      where: {
        OR: [
          { followerId: userId },
          { followingId: userId }
        ]
      }
    })
    
    // 7. Finally delete the user
    const deletedUser = await tx.user.delete({
      where: { id: userId }
    })
    
    return {
      deletedUser,
      cascadedDeletions: {
        likes: true,
        comments: true,
        posts: true,
        profile: true,
        relationships: true
      }
    }
  })
}

// Selective cascade with user choice
async function deleteUserWithSelectiveCascade(
  userId: number,
  cascadeOptions: {
    deletePosts?: boolean
    deleteComments?: boolean
    transferToUser?: number
  }
) {
  return await prisma.$transaction(async (tx) => {
    const { deletePosts, deleteComments, transferToUser } = cascadeOptions
    
    if (deletePosts) {
      // Delete user's posts
      await tx.post.deleteMany({
        where: { authorId: userId }
      })
    } else if (transferToUser) {
      // Transfer posts to another user
      await tx.post.updateMany({
        where: { authorId: userId },
        data: { authorId: transferToUser }
      })
    }
    
    if (deleteComments) {
      // Delete user's comments
      await tx.comment.deleteMany({
        where: { authorId: userId }
      })
    } else if (transferToUser) {
      // Transfer comments to another user
      await tx.comment.updateMany({
        where: { authorId: userId },
        data: { 
          authorId: transferToUser,
          content: '[Comment by deleted user]'
        }
      })
    }
    
    // Always delete profile and relationships
    await tx.profile.deleteMany({
      where: { userId }
    })
    
    await tx.follow.deleteMany({
      where: {
        OR: [
          { followerId: userId },
          { followingId: userId }
        ]
      }
    })
    
    // Delete the user
    const deletedUser = await tx.user.delete({
      where: { id: userId }
    })
    
    return { deletedUser, cascadeOptions }
  })
}
```

## Bulk Deletion with `deleteMany()`

### Basic Bulk Deletion Operations
Efficient removal of multiple records:

```typescript
// Basic deleteMany usage
async function deleteInactiveUsers() {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - 365) // 1 year ago
  
  const result = await prisma.user.deleteMany({
    where: {
      AND: [
        { isActive: false },
        { lastLoginAt: { lt: cutoffDate } },
        { 
          posts: {
            none: {} // No posts
          }
        },
        {
          comments: {
            none: {} // No comments
          }
        }
      ]
    }
  })
  
  console.log(`Deleted ${result.count} inactive users`)
  return result
}

// Bulk delete with relationship conditions
async function deleteOldUnpublishedPosts() {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - 30) // 30 days ago
  
  const result = await prisma.post.deleteMany({
    where: {
      AND: [
        { published: false },
        { createdAt: { lt: cutoffDate } },
        {
          comments: {
            none: {} // No comments
          }
        },
        {
          likes: {
            none: {} // No likes
          }
        }
      ]
    }
  })
  
  console.log(`Deleted ${result.count} old unpublished posts`)
  return result
}

// Conditional bulk deletion with safeguards
async function bulkDeleteWithSafeguards(
  criteria: any,
  maxDeleteCount: number = 1000
) {
  // First, count how many records would be deleted
  const countToDelete = await prisma.user.count({
    where: criteria
  })
  
  if (countToDelete === 0) {
    return {
      success: true,
      deleted: 0,
      message: 'No records match deletion criteria'
    }
  }
  
  if (countToDelete > maxDeleteCount) {
    return {
      success: false,
      error: 'DELETION_LIMIT_EXCEEDED',
      message: `Cannot delete ${countToDelete} records (limit: ${maxDeleteCount})`
    }
  }
  
  // Proceed with deletion
  const result = await prisma.user.deleteMany({
    where: criteria
  })
  
  return {
    success: true,
    deleted: result.count,
    message: `Successfully deleted ${result.count} records`
  }
}
```

### Chunked Bulk Deletion
Handling large-scale deletions efficiently:

```typescript
// Chunked deletion for large datasets
async function chunkedBulkDelete(
  whereCondition: any,
  chunkSize: number = 1000
) {
  let totalDeleted = 0
  let hasMore = true
  
  while (hasMore) {
    // Get a chunk of IDs to delete
    const recordsToDelete = await prisma.user.findMany({
      where: whereCondition,
      select: { id: true },
      take: chunkSize
    })
    
    if (recordsToDelete.length === 0) {
      hasMore = false
      break
    }
    
    // Delete the chunk
    const result = await prisma.user.deleteMany({
      where: {
        id: {
          in: recordsToDelete.map(r => r.id)
        }
      }
    })
    
    totalDeleted += result.count
    console.log(`Deleted chunk: ${result.count}, Total: ${totalDeleted}`)
    
    // Check if we got fewer records than requested (last chunk)
    hasMore = recordsToDelete.length === chunkSize
    
    // Small delay to prevent overwhelming the database
    if (hasMore) {
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }
  
  return { totalDeleted }
}

// Progressive deletion with monitoring
async function progressiveBulkDelete(
  whereCondition: any,
  onProgress?: (deleted: number, total: number) => void
) {
  // First count total records
  const totalCount = await prisma.user.count({
    where: whereCondition
  })
  
  if (totalCount === 0) {
    return { totalDeleted: 0, message: 'No records to delete' }
  }
  
  let deletedCount = 0
  const batchSize = 500
  
  while (deletedCount < totalCount) {
    const result = await prisma.user.deleteMany({
      where: whereCondition
    })
    
    if (result.count === 0) {
      break // No more records to delete
    }
    
    deletedCount += result.count
    
    // Call progress callback
    if (onProgress) {
      onProgress(deletedCount, totalCount)
    }
    
    console.log(`Progress: ${deletedCount}/${totalCount} deleted`)
    
    // Small delay between batches
    await new Promise(resolve => setTimeout(resolve, 200))
  }
  
  return { totalDeleted: deletedCount }
}

// Bulk deletion with transaction for atomicity
async function atomicBulkDelete(deletionCriteria: any[]) {
  return await prisma.$transaction(async (tx) => {
    const results = []
    
    for (const criteria of deletionCriteria) {
      const result = await tx.user.deleteMany({
        where: criteria.where
      })
      
      results.push({
        criteria: criteria.name || 'unnamed',
        deleted: result.count
      })
    }
    
    const totalDeleted = results.reduce((sum, r) => sum + r.deleted, 0)
    
    return {
      results,
      totalDeleted,
      success: true
    }
  })
}
```

## Soft Deletion Patterns

### Implementing Soft Deletion
Preserving data while marking as deleted:

```typescript
// Soft delete implementation
async function softDeleteUser(userId: number, deletedBy: number) {
  const user = await prisma.user.update({
    where: { id: userId },
    data: {
      isDeleted: true,
      deletedAt: new Date(),
      deletedBy: deletedBy,
      // Optionally anonymize sensitive data
      email: `deleted_${userId}@example.com`,
      // Keep name for audit trails but mark as deleted
      name: `[DELETED] ${user.name}`
    },
    select: {
      id: true,
      name: true,
      email: true,
      deletedAt: true,
      deletedBy: true
    }
  })
  
  return user
}

// Soft delete with cascade
async function softDeleteUserWithCascade(userId: number, deletedBy: number) {
  return await prisma.$transaction(async (tx) => {
    // Soft delete user
    const user = await tx.user.update({
      where: { id: userId },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: deletedBy
      }
    })
    
    // Soft delete user's posts
    await tx.post.updateMany({
      where: { authorId: userId },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: deletedBy
      }
    })
    
    // Soft delete user's comments
    await tx.comment.updateMany({
      where: { authorId: userId },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: deletedBy
      }
    })
    
    return user
  })
}

// Restore soft deleted user
async function restoreUser(userId: number, restoredBy: number) {
  const user = await prisma.user.update({
    where: { 
      id: userId,
      isDeleted: true // Only restore if currently deleted
    },
    data: {
      isDeleted: false,
      deletedAt: null,
      deletedBy: null,
      restoredAt: new Date(),
      restoredBy: restoredBy
    }
  })
  
  return user
}

// Bulk soft delete
async function bulkSoftDelete(
  whereCondition: any,
  deletedBy: number
) {
  const result = await prisma.user.updateMany({
    where: {
      ...whereCondition,
      isDeleted: false // Only delete non-deleted records
    },
    data: {
      isDeleted: true,
      deletedAt: new Date(),
      deletedBy: deletedBy
    }
  })
  
  return result
}

// Permanent deletion of soft-deleted records
async function permanentlyDeleteSoftDeleted(daysOld: number = 90) {
  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - daysOld)
  
  // Find soft-deleted records older than cutoff
  const recordsToDelete = await prisma.user.findMany({
    where: {
      isDeleted: true,
      deletedAt: {
        lt: cutoffDate
      }
    },
    select: { id: true }
  })
  
  if (recordsToDelete.length === 0) {
    return { deleted: 0, message: 'No records eligible for permanent deletion' }
  }
  
  // Permanently delete in chunks
  const chunkSize = 100
  let totalDeleted = 0
  
  for (let i = 0; i < recordsToDelete.length; i += chunkSize) {
    const chunk = recordsToDelete.slice(i, i + chunkSize)
    const ids = chunk.map(r => r.id)
    
    const result = await prisma.user.deleteMany({
      where: {
        id: { in: ids },
        isDeleted: true
      }
    })
    
    totalDeleted += result.count
    
    // Small delay between chunks
    await new Promise(resolve => setTimeout(resolve, 100))
  }
  
  return { 
    deleted: totalDeleted,
    message: `Permanently deleted ${totalDeleted} soft-deleted records`
  }
}
```

### Advanced Soft Deletion with Recovery
Comprehensive soft deletion system:

```typescript
// Soft deletion with full audit trail
interface SoftDeleteOptions {
  reason?: string
  cascadeToRelated?: boolean
  anonymizeData?: boolean
  retentionDays?: number
}

async function advancedSoftDelete(
  userId: number,
  deletedBy: number,
  options: SoftDeleteOptions = {}
) {
  const {
    reason = 'User requested deletion',
    cascadeToRelated = false,
    anonymizeData = true,
    retentionDays = 90
  } = options
  
  return await prisma.$transaction(async (tx) => {
    // Get current user data for audit
    const currentUser = await tx.user.findUnique({
      where: { id: userId },
      include: {
        profile: true,
        _count: {
          select: {
            posts: true,
            comments: true,
            followers: true,
            following: true
          }
        }
      }
    })
    
    if (!currentUser) {
      throw new Error('User not found')
    }
    
    if (currentUser.isDeleted) {
      throw new Error('User is already deleted')
    }
    
    // Create deletion record for audit
    const deletionRecord = await tx.deletionAudit.create({
      data: {
        entityType: 'User',
        entityId: userId,
        originalData: currentUser,
        reason,
        deletedBy,
        plannedPermanentDeletion: new Date(Date.now() + retentionDays * 24 * 60 * 60 * 1000),
        relatedDataCounts: currentUser._count
      }
    })
    
    // Prepare user update data
    const updateData: any = {
      isDeleted: true,
      deletedAt: new Date(),
      deletedBy: deletedBy,
      deletionAuditId: deletionRecord.id
    }
    
    // Anonymize data if requested
    if (anonymizeData) {
      updateData.email = `deleted_${userId}@anonymized.local`
      updateData.name = `[DELETED USER ${userId}]`
    }
    
    // Soft delete user
    const deletedUser = await tx.user.update({
      where: { id: userId },
      data: updateData
    })
    
    // Handle cascade deletion if requested
    if (cascadeToRelated) {
      await tx.post.updateMany({
        where: { authorId: userId },
        data: {
          isDeleted: true,
          deletedAt: new Date(),
          deletedBy: deletedBy
        }
      })
      
      await tx.comment.updateMany({
        where: { authorId: userId },
        data: {
          isDeleted: true,
          deletedAt: new Date(),
          deletedBy: deletedBy
        }
      })
      
      // Soft delete profile
      await tx.profile.updateMany({
        where: { userId },
        data: {
          isDeleted: true,
          deletedAt: new Date(),
          deletedBy: deletedBy
        }
      })
    }
    
    return {
      deletedUser,
      deletionRecord,
      cascaded: cascadeToRelated
    }
  })
}

// Recovery system for soft-deleted data
async function recoverDeletedUser(
  userId: number,
  recoveredBy: number,
  recoveryReason: string
) {
  return await prisma.$transaction(async (tx) => {
    // Check if user is deleted and can be recovered
    const deletedUser = await tx.user.findUnique({
      where: { 
        id: userId,
        isDeleted: true
      },
      include: {
        deletionAudit: true
      }
    })
    
    if (!deletedUser) {
      throw new Error('User not found or not deleted')
    }
    
    if (!deletedUser.deletionAudit) {
      throw new Error('Deletion audit record not found')
    }
    
    // Check if within recovery window
    const daysSinceDeletion = Math.floor(
      (Date.now() - deletedUser.deletedAt!.getTime()) / (1000 * 60 * 60 * 24)
    )
    
    if (daysSinceDeletion > 30) { // 30-day recovery window
      throw new Error('Recovery window has expired')
    }
    
    // Restore user data
    const originalData = deletedUser.deletionAudit.originalData as any
    
    const restoredUser = await tx.user.update({
      where: { id: userId },
      data: {
        isDeleted: false,
        deletedAt: null,
        deletedBy: null,
        deletionAuditId: null,
        // Restore original data
        email: originalData.email,
        name: originalData.name,
        // Add recovery metadata
        recoveredAt: new Date(),
        recoveredBy: recoveredBy
      }
    })
    
    // Update deletion audit record
    await tx.deletionAudit.update({
      where: { id: deletedUser.deletionAuditId! },
      data: {
        recoveredAt: new Date(),
        recoveredBy: recoveredBy,
        recoveryReason: recoveryReason
      }
    })
    
    return restoredUser
  })
}
```

## Error Handling and Safety Measures

### Comprehensive Deletion Safety
Protecting against accidental data loss:

```typescript
// Safe deletion with multiple confirmation levels
class DeletionSafetySystem {
  private static dangerousOperations = new Map<string, {
    initiated: Date
    confirmations: string[]
    requiredConfirmations: string[]
  }>()
  
  static async initiateDangerousDeletion(
    operation: string,
    details: any,
    initiatedBy: number
  ) {
    const operationId = `${operation}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    // Determine required confirmations based on operation severity
    let requiredConfirmations = ['OPERATOR_CONFIRM']
    
    if (details.recordCount > 1000) {
      requiredConfirmations.push('SUPERVISOR_CONFIRM')
    }
    
    if (details.recordCount > 10000) {
      requiredConfirmations.push('ADMIN_CONFIRM')
    }
    
    this.dangerousOperations.set(operationId, {
      initiated: new Date(),
      confirmations: [],
      requiredConfirmations
    })
    
    // Store in database for persistence
    await prisma.dangerousOperation.create({
      data: {
        operationId,
        operation,
        details,
        initiatedBy,
        requiredConfirmations,
        status: 'PENDING_CONFIRMATION'
      }
    })
    
    return {
      operationId,
      requiredConfirmations,
      message: `Dangerous operation initiated. Requires confirmations: ${requiredConfirmations.join(', ')}`
    }
  }
  
  static async confirmDangerousOperation(
    operationId: string,
    confirmationType: string,
    confirmedBy: number
  ) {
    const operation = this.dangerousOperations.get(operationId)
    
    if (!operation) {
      return { success: false, error: 'OPERATION_NOT_FOUND' }
    }
    
    // Check if this confirmation type is required and not already provided
    if (!operation.requiredConfirmations.includes(confirmationType)) {
      return { success: false, error: 'CONFIRMATION_NOT_REQUIRED' }
    }
    
    if (operation.confirmations.includes(confirmationType)) {
      return { success: false, error: 'ALREADY_CONFIRMED' }
    }
    
    // Add confirmation
    operation.confirmations.push(confirmationType)
    
    // Update database
    await prisma.dangerousOperation.update({
      where: { operationId },
      data: {
        confirmations: operation.confirmations,
        [`${confirmationType.toLowerCase()}By`]: confirmedBy,
        [`${confirmationType.toLowerCase()}At`]: new Date()
      }
    })
    
    // Check if all confirmations are received
    const allConfirmed = operation.requiredConfirmations.every(
      req => operation.confirmations.includes(req)
    )
    
    if (allConfirmed) {
      return {
        success: true,
        status: 'READY_FOR_EXECUTION',
        message: 'All confirmations received. Operation ready for execution.'
      }
    }
    
    return {
      success: true,
      status: 'PARTIAL_CONFIRMATION',
      remainingConfirmations: operation.requiredConfirmations.filter(
        req => !operation.confirmations.includes(req)
      )
    }
  }
  
  static async executeDangerousOperation(operationId: string) {
    const dbOperation = await prisma.dangerousOperation.findUnique({
      where: { operationId }
    })
    
    if (!dbOperation) {
      return { success: false, error: 'OPERATION_NOT_FOUND' }
    }
    
    // Verify all confirmations are present
    const operation = this.dangerousOperations.get(operationId)
    if (!operation) {
      return { success: false, error: 'OPERATION_EXPIRED' }
    }
    
    const allConfirmed = operation.requiredConfirmations.every(
      req => operation.confirmations.includes(req)
    )
    
    if (!allConfirmed) {
      return { success: false, error: 'INSUFFICIENT_CONFIRMATIONS' }
    }
    
    // Execute the operation
    try {
      let result
      
      switch (dbOperation.operation) {
        case 'BULK_DELETE_USERS':
          result = await prisma.user.deleteMany({
            where: dbOperation.details.whereCondition
          })
          break
        case 'BULK_DELETE_POSTS':
          result = await prisma.post.deleteMany({
            where: dbOperation.details.whereCondition
          })
          break
        default:
          throw new Error(`Unknown operation: ${dbOperation.operation}`)
      }
      
      // Mark operation as completed
      await prisma.dangerousOperation.update({
        where: { operationId },
        data: {
          status: 'COMPLETED',
          completedAt: new Date(),
          result: result
        }
      })
      
      // Clean up from memory
      this.dangerousOperations.delete(operationId)
      
      return { success: true, result }
      
    } catch (error) {
      // Mark operation as failed
      await prisma.dangerousOperation.update({
        where: { operationId },
        data: {
          status: 'FAILED',
          error: error.message,
          failedAt: new Date()
        }
      })
      
      throw error
    }
  }
}

// Usage example
async function safeBulkDelete(whereCondition: any, initiatedBy: number) {
  // Count records first
  const recordCount = await prisma.user.count({ where: whereCondition })
  
  if (recordCount === 0) {
    return { success: true, deleted: 0, message: 'No records to delete' }
  }
  
  // If it's a small operation, proceed directly
  if (recordCount < 100) {
    const result = await prisma.user.deleteMany({ where: whereCondition })
    return { success: true, deleted: result.count }
  }
  
  // For larger operations, require confirmation
  return await DeletionSafetySystem.initiateDangerousDeletion(
    'BULK_DELETE_USERS',
    { whereCondition, recordCount },
    initiatedBy
  )
}
```

## Exercise: Advanced Deletion System

Design a comprehensive deletion management system:

```typescript
// Your task: Build a production-ready deletion system

// Requirements:
// 1. Support both hard and soft deletion patterns
// 2. Implement comprehensive safety measures and confirmations
// 3. Add cascade deletion with configurable options
// 4. Include audit trails and recovery mechanisms
// 5. Support bulk operations with progress monitoring
// 6. Implement role-based deletion permissions
// 7. Add data retention policies and automatic cleanup
// 8. Support GDPR compliance features

interface DeletionSystemConfig {
  // Define configuration options
}

class AdvancedDeletionSystem {
  // Implement comprehensive deletion system
  
  // Methods to implement:
  // - deleteSingle<T>(model: string, id: any, options?: DeleteOptions)
  // - deleteMany<T>(model: string, criteria: any, options?: BulkDeleteOptions)
  // - softDelete<T>(model: string, id: any, options?: SoftDeleteOptions)
  // - recoverDeleted<T>(model: string, id: any, options?: RecoveryOptions)
  // - cascadeDelete<T>(model: string, id: any, cascadeConfig: CascadeConfig)
  // - scheduleDeletion<T>(model: string, criteria: any, scheduledFor: Date)
  // - auditDeletion(operation: DeletionOperation)
  // - enforceRetentionPolicy(policy: RetentionPolicy)
}

// Bonus features:
// - Automatic data anonymization
// - Integration with backup systems
// - Real-time deletion notifications
// - Compliance reporting and documentation
// - Recovery time optimization
// - Custom deletion workflows for different data types
```

## Key Takeaways

1. **Safety First**: Always implement safeguards and confirmations for deletion operations
2. **Soft vs Hard**: Choose soft deletion for recoverable scenarios, hard deletion for final cleanup
3. **Cascade Planning**: Carefully design cascade deletion strategies to maintain referential integrity
4. **Audit Trails**: Track all deletion operations for compliance and debugging
5. **Performance**: Use chunked operations for large-scale deletions to avoid timeouts
6. **Recovery**: Implement recovery mechanisms for accidental deletions
7. **Authorization**: Ensure proper access controls for deletion operations

## Next Steps

In the next lesson, we'll explore **Count Operations & Aggregations** and learn how to efficiently calculate statistics, perform aggregations, and generate analytical insights from your data with Prisma Client.

---

**Estimated Time:** 26 minutes
**Difficulty:** Advanced
**Prerequisites:** Understanding of database relationships, transaction patterns, and data compliance requirements
