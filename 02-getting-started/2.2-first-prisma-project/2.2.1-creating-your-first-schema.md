# 2.2.1 Creating Your First Schema

## 📋 Section Overview
- **Duration**: 40 minutes
- **Prerequisites**: 
  - Completed Section 2.1 Installation & Setup
  - Prisma CLI and Client installed
  - TypeScript configuration ready
  - Basic understanding of databases and data modeling
- **Learning Objectives**: 
  - Understand Prisma schema file structure and syntax
  - Create your first data models with proper relationships
  - Learn schema attributes, directives, and field types
  - Implement model relationships (one-to-one, one-to-many)
  - Follow schema design best practices and conventions
- **Difficulty Level**: Beginner to Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Master Prisma schema syntax and structure
- ✅ Create multiple related models with proper field types
- ✅ Implement different types of relationships between models
- ✅ Use Prisma attributes and directives effectively
- ✅ Follow naming conventions and best practices
- ✅ Validate and format your schema properly
- ✅ Understand schema evolution and migration preparation

---

## 📖 Content

### Understanding Prisma Schema

Creating your first Prisma schema is like **designing the blueprint for a modern city**. Just as urban planners carefully design streets, buildings, and infrastructure with clear relationships and efficient connections, a Prisma schema defines your data architecture with models, fields, and relationships that create a robust foundation for your application.

### 🏙️ The Modern City Blueprint Analogy

```
🏙️ City Blueprint = 📋 Prisma Schema Design

🏢 Building Zones (Models)
├── Residential District → User model
├── Commercial Center → Business/Store model
├── Educational Campus → Course/Student models
├── Transportation Hub → Vehicle/Route models
├── Administrative Center → Admin/Permission models
└── Public Services → Utility/Service models

🛣️ Infrastructure Network (Relationships)
├── Main highways → One-to-many relationships
├── Side streets → One-to-one relationships
├── Intersections → Many-to-many relationships
├── Bridges → Foreign key connections
├── Traffic signals → Constraints and validations
└── Public transit → Indirect relationships

🏗️ Construction Standards (Schema Rules)
├── Building codes → Field types and constraints
├── Zoning laws → Model organization
├── Safety regulations → Data validation
├── Accessibility standards → Indexes and performance
├── Utility connections → Database connections
└── Future expansion → Schema evolution

📋 Planning Documents (Schema Structure)
├── Master plan → schema.prisma file
├── Zoning maps → Model definitions
├── Technical specs → Field attributes
├── Connection diagrams → Relationship mappings
├── Regulation handbook → Prisma directives
└── Maintenance schedule → Migration planning
```

---

## 🔧 Schema File Structure

### 1. Understanding schema.prisma

The `schema.prisma` file is your single source of truth for data modeling. Let's explore its structure:

```prisma
// schema.prisma

// ==========================================
// Generator Configuration
// ==========================================
generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
  // Optional configurations
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
  previewFeatures = ["jsonProtocol"]
}

// ==========================================
// Database Configuration  
// ==========================================
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // For connection pooling
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // For migrations
}

// ==========================================
// Data Models
// ==========================================

// User model - represents application users
model User {
  // Primary key
  id        String   @id @default(cuid())
  
  // Basic user information
  email     String   @unique
  username  String?  @unique
  firstName String?
  lastName  String?
  
  // Metadata fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)
  
  // Relationships
  profile   Profile?
  posts     Post[]
  comments  Comment[]
  
  // Indexes for performance
  @@index([email])
  @@index([createdAt])
  @@map("users") // Custom table name
}

// Profile model - one-to-one with User
model Profile {
  id     String  @id @default(cuid())
  bio    String?
  avatar String?
  
  // Foreign key relationship
  userId String  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("profiles")
}

// Post model - represents blog posts or articles
model Post {
  id          String   @id @default(cuid())
  title       String
  content     String?
  excerpt     String?
  slug        String   @unique
  published   Boolean  @default(false)
  publishedAt DateTime?
  
  // Foreign key to User
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Self-referential relationship for categories
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id])
  
  // One-to-many relationship
  comments Comment[]
  
  // Many-to-many relationship through join table
  tags PostTag[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([slug])
  @@index([published])
  @@index([authorId])
  @@map("posts")
}

// Comment model - represents comments on posts
model Comment {
  id      String @id @default(cuid())
  content String
  
  // Foreign keys
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Self-referential for reply threads
  parentId String?
  parent   Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentReplies")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([postId])
  @@index([authorId])
  @@map("comments")
}

// Category model - for organizing posts
model Category {
  id          String @id @default(cuid())
  name        String @unique
  description String?
  slug        String @unique
  
  // Self-referential for nested categories
  parentId String?
  parent   Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")
  
  // One-to-many with posts
  posts Post[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([slug])
  @@map("categories")
}

// Tag model - for tagging posts
model Tag {
  id    String @id @default(cuid())
  name  String @unique
  color String? // For UI styling
  
  // Many-to-many relationship with posts
  posts PostTag[]
  
  createdAt DateTime @default(now())
  
  @@map("tags")
}

// Join table for many-to-many relationship between Post and Tag
model PostTag {
  postId String
  tagId  String
  
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@id([postId, tagId]) // Composite primary key
  @@map("post_tags")
}

// ==========================================
// Enums
// ==========================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
  SUPER_ADMIN
}

enum PostStatus {
  DRAFT
  REVIEW
  PUBLISHED
  ARCHIVED
}
```

---

## 📋 Field Types and Attributes

### 1. Basic Field Types

Prisma supports various field types for different data requirements:

```prisma
model DataTypeExample {
  id String @id @default(cuid())
  
  // String types
  title       String      // Required string
  description String?     // Optional string
  longText    String      @db.Text // Database-specific type
  
  // Number types
  count       Int         // Integer
  price       Float       // Floating point
  bigNumber   BigInt      // Large integers
  decimal     Decimal     // Precise decimal numbers
  
  // Boolean
  isActive    Boolean     @default(true)
  isDeleted   Boolean     @default(false)
  
  // Date and Time
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  birthDate   DateTime?
  
  // JSON (PostgreSQL, MySQL)
  metadata    Json?
  settings    Json        @default("{}")
  
  // Bytes (for binary data)
  fileData    Bytes?
  
  // Enums
  status      PostStatus  @default(DRAFT)
  role        UserRole    @default(USER)
  
  // Arrays (PostgreSQL)
  tags        String[]
  scores      Int[]
  
  @@map("data_type_examples")
}
```

### 2. Field Attributes

Attributes modify field behavior and add constraints:

```prisma
model AttributeExample {
  // Primary key attributes
  id         Int      @id @default(autoincrement())
  uuid       String   @id @default(uuid())
  customId   String   @id @default(cuid())
  
  // Unique constraints
  email      String   @unique
  username   String   @unique
  slug       String   @unique
  
  // Default values
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  isActive   Boolean  @default(true)
  count      Int      @default(0)
  
  // Database-specific attributes
  longText   String   @db.Text
  shortCode  String   @db.VarChar(10)
  price      Decimal  @db.Money
  
  // Validation (coming in future versions)
  // email    String   @email
  // age      Int      @min(0) @max(120)
  
  @@map("attribute_examples")
}
```

### 3. Model Attributes

Model-level attributes affect the entire model:

```prisma
model ModelAttributeExample {
  id        String   @id @default(cuid())
  name      String
  email     String
  createdAt DateTime @default(now())
  
  // Single field indexes
  @@index([email])
  @@index([createdAt])
  
  // Composite indexes
  @@index([name, email])
  
  // Unique constraints
  @@unique([name, email])
  
  // Custom table name
  @@map("custom_table_name")
  
  // Database schema (PostgreSQL)
  @@schema("public")
}
```

---

## 🔗 Implementing Relationships

### 1. One-to-One Relationships

```prisma
// User has one Profile
model User {
  id      String   @id @default(cuid())
  email   String   @unique
  name    String?
  
  // One-to-one relationship (optional)
  profile Profile?
  
  @@map("users")
}

model Profile {
  id       String  @id @default(cuid())
  bio      String?
  website  String?
  
  // Foreign key field
  userId   String  @unique
  // Relation field
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("profiles")
}

// Alternative: Required one-to-one
model Employee {
  id           String        @id @default(cuid())
  email        String        @unique
  name         String
  
  // Required one-to-one
  employeeInfo EmployeeInfo
  
  @@map("employees")
}

model EmployeeInfo {
  id           String   @id @default(cuid())
  department   String
  position     String
  salary       Decimal
  
  employeeId   String   @unique
  employee     Employee @relation(fields: [employeeId], references: [id])
  
  @@map("employee_info")
}
```

### 2. One-to-Many Relationships

```prisma
// User has many Posts
model User {
  id    String @id @default(cuid())
  email String @unique
  name  String?
  
  // One-to-many relationship
  posts Post[]
  
  @@map("users")
}

model Post {
  id       String  @id @default(cuid())
  title    String
  content  String?
  
  // Foreign key field
  authorId String
  // Relation field
  author   User    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  @@map("posts")
}

// Category hierarchy (self-referential one-to-many)
model Category {
  id          String @id @default(cuid())
  name        String
  description String?
  
  // Self-referential relationship
  parentId    String?
  parent      Category?  @relation("CategoryTree", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryTree")
  
  @@map("categories")
}
```

### 3. Many-to-Many Relationships

```prisma
// Explicit join table (recommended)
model Post {
  id    String @id @default(cuid())
  title String
  
  // Many-to-many through explicit join table
  tags  PostTag[]
  
  @@map("posts")
}

model Tag {
  id    String @id @default(cuid())
  name  String @unique
  
  // Many-to-many through explicit join table
  posts PostTag[]
  
  @@map("tags")
}

model PostTag {
  postId String
  tagId  String
  
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  // Additional fields on join table
  createdAt DateTime @default(now())
  createdBy String?
  
  @@id([postId, tagId])
  @@map("post_tags")
}

// Implicit many-to-many (simpler but less flexible)
model Student {
  id      String   @id @default(cuid())
  name    String
  
  // Implicit many-to-many
  courses Course[]
  
  @@map("students")
}

model Course {
  id       String    @id @default(cuid())
  name     String
  
  // Implicit many-to-many
  students Student[]
  
  @@map("courses")
}
```

---

## 🎨 Schema Design Best Practices

### 1. Naming Conventions

```prisma
// ✅ Good naming practices
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String?
  lastName  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relationship names should be descriptive
  authoredPosts Post[] @relation("AuthoredPosts")
  likedPosts    Post[] @relation("LikedPosts")
  
  @@map("users") // Use plural for table names
}

model Post {
  id          String @id @default(cuid())
  title       String
  content     String?
  publishedAt DateTime?
  
  // Foreign key should end with "Id"
  authorId    String
  author      User   @relation("AuthoredPosts", fields: [authorId], references: [id])
  
  // Many-to-many relation names should be clear
  likedBy     User[] @relation("LikedPosts")
  
  @@map("posts")
}

// ❌ Avoid these patterns
model user { // Don't use lowercase
  ID          Int    // Don't use all caps
  Email_Addr  String // Don't use underscores in field names
  user_posts  post[] // Inconsistent naming
}
```

### 2. Field Organization

```prisma
model WellOrganizedModel {
  // 1. Primary key first
  id String @id @default(cuid())
  
  // 2. Required fields next
  email String @unique
  name  String
  
  // 3. Optional fields
  bio        String?
  avatar     String?
  website    String?
  
  // 4. System fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  
  // 5. Relationship fields last
  profileId String?
  profile   Profile? @relation(fields: [profileId], references: [id])
  posts     Post[]
  
  // 6. Model attributes at the end
  @@index([email])
  @@index([createdAt])
  @@map("well_organized_models")
}
```

### 3. Performance Considerations

```prisma
model OptimizedModel {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  name      String
  createdAt DateTime @default(now())
  
  posts Post[]
  
  // Indexes for common queries
  @@index([email])              // Login queries
  @@index([username])           // Profile lookups
  @@index([createdAt])          // Sorting by creation date
  @@index([email, createdAt])   // Composite queries
  
  @@map("optimized_models")
}

model Post {
  id          String   @id @default(cuid())
  title       String
  content     String   @db.Text // Use appropriate database types
  published   Boolean  @default(false)
  publishedAt DateTime?
  authorId    String
  
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Indexes for filtering and sorting
  @@index([published])           // Filter published posts
  @@index([authorId])           // Posts by author
  @@index([publishedAt])        // Sort by publish date
  @@index([published, publishedAt]) // Published posts sorted by date
  
  @@map("posts")
}
```

---

## 🔍 Schema Validation and Formatting

### 1. Using Prisma Format

```bash
# Format your schema file
npx prisma format

# Check if schema is valid
npx prisma validate

# Format and validate in one command
npx prisma format && npx prisma validate
```

### 2. Schema Validation Script

Create a validation script for your project:

```typescript
// scripts/validate-schema.ts
import { execSync } from 'child_process'
import { readFileSync } from 'fs'
import path from 'path'

interface ValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
}

function validatePrismaSchema(): ValidationResult {
  const result: ValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
  }
  
  try {
    // Check if schema file exists
    const schemaPath = path.join(process.cwd(), 'prisma', 'schema.prisma')
    const schemaContent = readFileSync(schemaPath, 'utf8')
    
    // Basic syntax checks
    if (!schemaContent.includes('generator client')) {
      result.errors.push('Schema missing generator client configuration')
    }
    
    if (!schemaContent.includes('datasource db')) {
      result.errors.push('Schema missing datasource configuration')
    }
    
    // Check for common issues
    if (schemaContent.includes('@map(')) {
      const mapMatches = schemaContent.match(/@map\("([^"]+)"\)/g)
      mapMatches?.forEach(match => {
        const tableName = match.match(/@map\("([^"]+)"\)/)?.[1]
        if (tableName && tableName.includes(' ')) {
          result.warnings.push(`Table name "${tableName}" contains spaces`)
        }
      })
    }
    
    // Run Prisma validate
    try {
      execSync('npx prisma validate', { stdio: 'pipe' })
      console.log('✅ Prisma schema validation passed')
    } catch (error) {
      result.isValid = false
      result.errors.push('Prisma validation failed')
      console.error('❌ Schema validation errors:', error)
    }
    
    // Run Prisma format check
    try {
      const originalContent = schemaContent
      execSync('npx prisma format', { stdio: 'pipe' })
      const formattedContent = readFileSync(schemaPath, 'utf8')
      
      if (originalContent !== formattedContent) {
        result.warnings.push('Schema formatting was updated')
      }
    } catch (error) {
      result.warnings.push('Schema formatting check failed')
    }
    
  } catch (error) {
    result.isValid = false
    result.errors.push(`Schema validation error: ${error}`)
  }
  
  return result
}

// Run validation
const validation = validatePrismaSchema()

if (validation.errors.length > 0) {
  console.error('❌ Schema validation errors:')
  validation.errors.forEach(error => console.error(`  - ${error}`))
}

if (validation.warnings.length > 0) {
  console.warn('⚠️  Schema validation warnings:')
  validation.warnings.forEach(warning => console.warn(`  - ${warning}`))
}

if (validation.isValid) {
  console.log('🎉 Schema validation completed successfully!')
} else {
  process.exit(1)
}
```

### 3. Pre-commit Hook

Add schema validation to your pre-commit hooks:

```json
// package.json
{
  "scripts": {
    "validate:schema": "tsx scripts/validate-schema.ts",
    "format:schema": "prisma format",
    "check:schema": "npm run format:schema && npm run validate:schema"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "prisma/schema.prisma": [
      "prisma format",
      "prisma validate"
    ]
  }
}
```

---

## 📊 Common Schema Patterns

### 1. Audit Trail Pattern

```prisma
// Base model for audit trails
model AuditableModel {
  id        String   @id @default(cuid())
  
  // Audit fields
  createdAt DateTime @default(now())
  createdBy String?
  updatedAt DateTime @updatedAt
  updatedBy String?
  deletedAt DateTime? // Soft delete
  deletedBy String?
  version   Int      @default(1) // Optimistic locking
  
  @@map("auditable_models")
}
```

### 2. Polymorphic Associations

```prisma
// Polymorphic comments that can belong to different entities
model Comment {
  id            String @id @default(cuid())
  content       String
  
  // Polymorphic fields
  commentableId   String
  commentableType String // "Post", "User", "Product", etc.
  
  authorId String
  author   User   @relation(fields: [authorId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@index([commentableId, commentableType])
  @@map("comments")
}

// Usage in other models
model Post {
  id    String @id @default(cuid())
  title String
  
  // No direct relation - handled in application code
  // comments Comment[] @relation("PostComments")
  
  @@map("posts")
}
```

### 3. Multi-tenant Pattern

```prisma
// Multi-tenant application pattern
model Tenant {
  id   String @id @default(cuid())
  name String
  slug String @unique
  
  // All tenant-specific data
  users User[]
  posts Post[]
  
  createdAt DateTime @default(now())
  
  @@map("tenants")
}

model User {
  id    String @id @default(cuid())
  email String
  name  String?
  
  // Tenant association
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  
  posts Post[]
  
  // Email must be unique within tenant
  @@unique([email, tenantId])
  @@map("users")
}

model Post {
  id      String @id @default(cuid())
  title   String
  content String?
  
  // Both user and direct tenant reference
  authorId String
  author   User   @relation(fields: [authorId], references: [id])
  
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  
  @@index([tenantId])
  @@map("posts")
}
```

---

## 🧠 Knowledge Check

### Schema Design Quiz

1. **What is the purpose of the `@@map` attribute?**
   - [ ] A) To create relationships between models
   - [x] B) To specify custom table names in the database
   - [ ] C) To add indexes to the model
   - [ ] D) To set default values

   **Explanation**: The `@@map` attribute allows you to specify a custom table name that differs from the model name.

2. **Which relationship type requires a join table?**
   - [ ] A) One-to-one
   - [ ] B) One-to-many
   - [x] C) Many-to-many
   - [ ] D) Self-referential

   **Explanation**: Many-to-many relationships require a join table to connect the two entities, either implicit or explicit.

3. **What does the `@updatedAt` attribute do?**
   - [ ] A) Sets a default creation timestamp
   - [x] B) Automatically updates the field when the record is modified
   - [ ] C) Creates an index on the field
   - [ ] D) Makes the field required

   **Explanation**: The `@updatedAt` attribute automatically updates the field with the current timestamp whenever the record is modified.

### Practical Exercise: Complete Blog Schema

**Challenge**: Create a complete blog schema with proper relationships

**Requirements**:
1. User model with profile relationship
2. Post model with author, category, and tags
3. Comment model with threading (replies)
4. Category model with hierarchy
5. Tag model with many-to-many to posts
6. Proper indexes and constraints

**Validation Checklist**:
- [ ] All models have proper primary keys
- [ ] Relationships are correctly defined
- [ ] Appropriate indexes are added
- [ ] Naming conventions are followed
- [ ] Schema validates without errors

```prisma
// Your schema here:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Add your models here...
```

---

## 💡 Key Takeaways

- 📋 **Schema Structure**: The `schema.prisma` file is your single source of truth for data modeling
- 🔗 **Relationships**: Master one-to-one, one-to-many, and many-to-many relationships with proper foreign keys
- 🏷️ **Attributes**: Use field and model attributes to add constraints, defaults, and database-specific configurations
- 📝 **Naming**: Follow consistent naming conventions for models, fields, and relationships
- 🔍 **Validation**: Always format and validate your schema before applying migrations
- ⚡ **Performance**: Add appropriate indexes for commonly queried fields
- 🎯 **Best Practices**: Organize fields logically and use meaningful relationship names

---

## 🔗 Navigation

**📍 Current Location**: Module 2 → Section 2.2 → Lesson 2.2.1

**⬅️ Previous**: [2.1.5 TypeScript Configuration for Prisma](../2.1-installation-setup/2.1.5-typescript-configuration-for-prisma.md)
**➡️ Next**: [2.2.2 Database Connection String Configuration](./2.2.2-database-connection-string-configuration.md)

**🏠 Section Home**: [2.2 First Prisma Project](./README.md)
**📚 Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**🗺️ Quick Links**:
- [Next: Database Connection](./2.2.2-database-connection-string-configuration.md)
- [Jump to: First Migration](./2.2.3-running-first-migration-prisma-migrate-dev.md)
- [Official Docs: Schema Reference](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference)

---

*Fantastic! You've created your first Prisma schema. Ready to configure your database connection and see your schema come to life? Continue to the next lesson!*
