# 2.2.1 Creating Your First Schema

## üìã Section Overview
- **Duration**: 40 minutes
- **Prerequisites**: 
  - Completed Section 2.1 Installation & Setup
  - Prisma CLI and Client installed
  - TypeScript configuration ready
  - Basic understanding of databases and data modeling
- **Learning Objectives**: 
  - Understand Prisma schema file structure and syntax
  - Create your first data models with proper relationships
  - Learn schema attributes, directives, and field types
  - Implement model relationships (one-to-one, one-to-many)
  - Follow schema design best practices and conventions
- **Difficulty Level**: Beginner to Intermediate

---

## üéØ What You'll Learn

By the end of this section, you will:
- ‚úÖ Master Prisma schema syntax and structure
- ‚úÖ Create multiple related models with proper field types
- ‚úÖ Implement different types of relationships between models
- ‚úÖ Use Prisma attributes and directives effectively
- ‚úÖ Follow naming conventions and best practices
- ‚úÖ Validate and format your schema properly
- ‚úÖ Understand schema evolution and migration preparation

---

## üìñ Content

### Understanding Prisma Schema

Creating your first Prisma schema is like **designing the blueprint for a modern city**. Just as urban planners carefully design streets, buildings, and infrastructure with clear relationships and efficient connections, a Prisma schema defines your data architecture with models, fields, and relationships that create a robust foundation for your application.

### üèôÔ∏è The Modern City Blueprint Analogy

```
üèôÔ∏è City Blueprint = üìã Prisma Schema Design

üè¢ Building Zones (Models)
‚îú‚îÄ‚îÄ Residential District ‚Üí User model
‚îú‚îÄ‚îÄ Commercial Center ‚Üí Business/Store model
‚îú‚îÄ‚îÄ Educational Campus ‚Üí Course/Student models
‚îú‚îÄ‚îÄ Transportation Hub ‚Üí Vehicle/Route models
‚îú‚îÄ‚îÄ Administrative Center ‚Üí Admin/Permission models
‚îî‚îÄ‚îÄ Public Services ‚Üí Utility/Service models

üõ£Ô∏è Infrastructure Network (Relationships)
‚îú‚îÄ‚îÄ Main highways ‚Üí One-to-many relationships
‚îú‚îÄ‚îÄ Side streets ‚Üí One-to-one relationships
‚îú‚îÄ‚îÄ Intersections ‚Üí Many-to-many relationships
‚îú‚îÄ‚îÄ Bridges ‚Üí Foreign key connections
‚îú‚îÄ‚îÄ Traffic signals ‚Üí Constraints and validations
‚îî‚îÄ‚îÄ Public transit ‚Üí Indirect relationships

üèóÔ∏è Construction Standards (Schema Rules)
‚îú‚îÄ‚îÄ Building codes ‚Üí Field types and constraints
‚îú‚îÄ‚îÄ Zoning laws ‚Üí Model organization
‚îú‚îÄ‚îÄ Safety regulations ‚Üí Data validation
‚îú‚îÄ‚îÄ Accessibility standards ‚Üí Indexes and performance
‚îú‚îÄ‚îÄ Utility connections ‚Üí Database connections
‚îî‚îÄ‚îÄ Future expansion ‚Üí Schema evolution

üìã Planning Documents (Schema Structure)
‚îú‚îÄ‚îÄ Master plan ‚Üí schema.prisma file
‚îú‚îÄ‚îÄ Zoning maps ‚Üí Model definitions
‚îú‚îÄ‚îÄ Technical specs ‚Üí Field attributes
‚îú‚îÄ‚îÄ Connection diagrams ‚Üí Relationship mappings
‚îú‚îÄ‚îÄ Regulation handbook ‚Üí Prisma directives
‚îî‚îÄ‚îÄ Maintenance schedule ‚Üí Migration planning
```

---

## üîß Schema File Structure

### 1. Understanding schema.prisma

The `schema.prisma` file is your single source of truth for data modeling. Let's explore its structure:

```prisma
// schema.prisma

// ==========================================
// Generator Configuration
// ==========================================
generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
  // Optional configurations
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
  previewFeatures = ["jsonProtocol"]
}

// ==========================================
// Database Configuration  
// ==========================================
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // For connection pooling
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // For migrations
}

// ==========================================
// Data Models
// ==========================================

// User model - represents application users
model User {
  // Primary key
  id        String   @id @default(cuid())
  
  // Basic user information
  email     String   @unique
  username  String?  @unique
  firstName String?
  lastName  String?
  
  // Metadata fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)
  
  // Relationships
  profile   Profile?
  posts     Post[]
  comments  Comment[]
  
  // Indexes for performance
  @@index([email])
  @@index([createdAt])
  @@map("users") // Custom table name
}

// Profile model - one-to-one with User
model Profile {
  id     String  @id @default(cuid())
  bio    String?
  avatar String?
  
  // Foreign key relationship
  userId String  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("profiles")
}

// Post model - represents blog posts or articles
model Post {
  id          String   @id @default(cuid())
  title       String
  content     String?
  excerpt     String?
  slug        String   @unique
  published   Boolean  @default(false)
  publishedAt DateTime?
  
  // Foreign key to User
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Self-referential relationship for categories
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id])
  
  // One-to-many relationship
  comments Comment[]
  
  // Many-to-many relationship through join table
  tags PostTag[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([slug])
  @@index([published])
  @@index([authorId])
  @@map("posts")
}

// Comment model - represents comments on posts
model Comment {
  id      String @id @default(cuid())
  content String
  
  // Foreign keys
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Self-referential for reply threads
  parentId String?
  parent   Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentReplies")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([postId])
  @@index([authorId])
  @@map("comments")
}

// Category model - for organizing posts
model Category {
  id          String @id @default(cuid())
  name        String @unique
  description String?
  slug        String @unique
  
  // Self-referential for nested categories
  parentId String?
  parent   Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")
  
  // One-to-many with posts
  posts Post[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([slug])
  @@map("categories")
}

// Tag model - for tagging posts
model Tag {
  id    String @id @default(cuid())
  name  String @unique
  color String? // For UI styling
  
  // Many-to-many relationship with posts
  posts PostTag[]
  
  createdAt DateTime @default(now())
  
  @@map("tags")
}

// Join table for many-to-many relationship between Post and Tag
model PostTag {
  postId String
  tagId  String
  
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@id([postId, tagId]) // Composite primary key
  @@map("post_tags")
}

// ==========================================
// Enums
// ==========================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
  SUPER_ADMIN
}

enum PostStatus {
  DRAFT
  REVIEW
  PUBLISHED
  ARCHIVED
}
```

---

## üìã Field Types and Attributes

### 1. Basic Field Types

Prisma supports various field types for different data requirements:

```prisma
model DataTypeExample {
  id String @id @default(cuid())
  
  // String types
  title       String      // Required string
  description String?     // Optional string
  longText    String      @db.Text // Database-specific type
  
  // Number types
  count       Int         // Integer
  price       Float       // Floating point
  bigNumber   BigInt      // Large integers
  decimal     Decimal     // Precise decimal numbers
  
  // Boolean
  isActive    Boolean     @default(true)
  isDeleted   Boolean     @default(false)
  
  // Date and Time
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  birthDate   DateTime?
  
  // JSON (PostgreSQL, MySQL)
  metadata    Json?
  settings    Json        @default("{}")
  
  // Bytes (for binary data)
  fileData    Bytes?
  
  // Enums
  status      PostStatus  @default(DRAFT)
  role        UserRole    @default(USER)
  
  // Arrays (PostgreSQL)
  tags        String[]
  scores      Int[]
  
  @@map("data_type_examples")
}
```

### 2. Field Attributes

Attributes modify field behavior and add constraints:

```prisma
model AttributeExample {
  // Primary key attributes
  id         Int      @id @default(autoincrement())
  uuid       String   @id @default(uuid())
  customId   String   @id @default(cuid())
  
  // Unique constraints
  email      String   @unique
  username   String   @unique
  slug       String   @unique
  
  // Default values
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  isActive   Boolean  @default(true)
  count      Int      @default(0)
  
  // Database-specific attributes
  longText   String   @db.Text
  shortCode  String   @db.VarChar(10)
  price      Decimal  @db.Money
  
  // Validation (coming in future versions)
  // email    String   @email
  // age      Int      @min(0) @max(120)
  
  @@map("attribute_examples")
}
```

### 3. Model Attributes

Model-level attributes affect the entire model:

```prisma
model ModelAttributeExample {
  id        String   @id @default(cuid())
  name      String
  email     String
  createdAt DateTime @default(now())
  
  // Single field indexes
  @@index([email])
  @@index([createdAt])
  
  // Composite indexes
  @@index([name, email])
  
  // Unique constraints
  @@unique([name, email])
  
  // Custom table name
  @@map("custom_table_name")
  
  // Database schema (PostgreSQL)
  @@schema("public")
}
```

---

## üîó Implementing Relationships

### 1. One-to-One Relationships

```prisma
// User has one Profile
model User {
  id      String   @id @default(cuid())
  email   String   @unique
  name    String?
  
  // One-to-one relationship (optional)
  profile Profile?
  
  @@map("users")
}

model Profile {
  id       String  @id @default(cuid())
  bio      String?
  website  String?
  
  // Foreign key field
  userId   String  @unique
  // Relation field
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("profiles")
}

// Alternative: Required one-to-one
model Employee {
  id           String        @id @default(cuid())
  email        String        @unique
  name         String
  
  // Required one-to-one
  employeeInfo EmployeeInfo
  
  @@map("employees")
}

model EmployeeInfo {
  id           String   @id @default(cuid())
  department   String
  position     String
  salary       Decimal
  
  employeeId   String   @unique
  employee     Employee @relation(fields: [employeeId], references: [id])
  
  @@map("employee_info")
}
```

### 2. One-to-Many Relationships

```prisma
// User has many Posts
model User {
  id    String @id @default(cuid())
  email String @unique
  name  String?
  
  // One-to-many relationship
  posts Post[]
  
  @@map("users")
}

model Post {
  id       String  @id @default(cuid())
  title    String
  content  String?
  
  // Foreign key field
  authorId String
  // Relation field
  author   User    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  @@map("posts")
}

// Category hierarchy (self-referential one-to-many)
model Category {
  id          String @id @default(cuid())
  name        String
  description String?
  
  // Self-referential relationship
  parentId    String?
  parent      Category?  @relation("CategoryTree", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryTree")
  
  @@map("categories")
}
```

### 3. Many-to-Many Relationships

```prisma
// Explicit join table (recommended)
model Post {
  id    String @id @default(cuid())
  title String
  
  // Many-to-many through explicit join table
  tags  PostTag[]
  
  @@map("posts")
}

model Tag {
  id    String @id @default(cuid())
  name  String @unique
  
  // Many-to-many through explicit join table
  posts PostTag[]
  
  @@map("tags")
}

model PostTag {
  postId String
  tagId  String
  
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  // Additional fields on join table
  createdAt DateTime @default(now())
  createdBy String?
  
  @@id([postId, tagId])
  @@map("post_tags")
}

// Implicit many-to-many (simpler but less flexible)
model Student {
  id      String   @id @default(cuid())
  name    String
  
  // Implicit many-to-many
  courses Course[]
  
  @@map("students")
}

model Course {
  id       String    @id @default(cuid())
  name     String
  
  // Implicit many-to-many
  students Student[]
  
  @@map("courses")
}
```

---

## üé® Schema Design Best Practices

### 1. Naming Conventions

```prisma
// ‚úÖ Good naming practices
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String?
  lastName  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relationship names should be descriptive
  authoredPosts Post[] @relation("AuthoredPosts")
  likedPosts    Post[] @relation("LikedPosts")
  
  @@map("users") // Use plural for table names
}

model Post {
  id          String @id @default(cuid())
  title       String
  content     String?
  publishedAt DateTime?
  
  // Foreign key should end with "Id"
  authorId    String
  author      User   @relation("AuthoredPosts", fields: [authorId], references: [id])
  
  // Many-to-many relation names should be clear
  likedBy     User[] @relation("LikedPosts")
  
  @@map("posts")
}

// ‚ùå Avoid these patterns
model user { // Don't use lowercase
  ID          Int    // Don't use all caps
  Email_Addr  String // Don't use underscores in field names
  user_posts  post[] // Inconsistent naming
}
```

### 2. Field Organization

```prisma
model WellOrganizedModel {
  // 1. Primary key first
  id String @id @default(cuid())
  
  // 2. Required fields next
  email String @unique
  name  String
  
  // 3. Optional fields
  bio        String?
  avatar     String?
  website    String?
  
  // 4. System fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  
  // 5. Relationship fields last
  profileId String?
  profile   Profile? @relation(fields: [profileId], references: [id])
  posts     Post[]
  
  // 6. Model attributes at the end
  @@index([email])
  @@index([createdAt])
  @@map("well_organized_models")
}
```

### 3. Performance Considerations

```prisma
model OptimizedModel {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  name      String
  createdAt DateTime @default(now())
  
  posts Post[]
  
  // Indexes for common queries
  @@index([email])              // Login queries
  @@index([username])           // Profile lookups
  @@index([createdAt])          // Sorting by creation date
  @@index([email, createdAt])   // Composite queries
  
  @@map("optimized_models")
}

model Post {
  id          String   @id @default(cuid())
  title       String
  content     String   @db.Text // Use appropriate database types
  published   Boolean  @default(false)
  publishedAt DateTime?
  authorId    String
  
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Indexes for filtering and sorting
  @@index([published])           // Filter published posts
  @@index([authorId])           // Posts by author
  @@index([publishedAt])        // Sort by publish date
  @@index([published, publishedAt]) // Published posts sorted by date
  
  @@map("posts")
}
```

---

## üîç Schema Validation and Formatting

### 1. Using Prisma Format

```bash
# Format your schema file
npx prisma format

# Check if schema is valid
npx prisma validate

# Format and validate in one command
npx prisma format && npx prisma validate
```

### 2. Schema Validation Script

Create a validation script for your project:

```typescript
// scripts/validate-schema.ts
import { execSync } from 'child_process'
import { readFileSync } from 'fs'
import path from 'path'

interface ValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
}

function validatePrismaSchema(): ValidationResult {
  const result: ValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
  }
  
  try {
    // Check if schema file exists
    const schemaPath = path.join(process.cwd(), 'prisma', 'schema.prisma')
    const schemaContent = readFileSync(schemaPath, 'utf8')
    
    // Basic syntax checks
    if (!schemaContent.includes('generator client')) {
      result.errors.push('Schema missing generator client configuration')
    }
    
    if (!schemaContent.includes('datasource db')) {
      result.errors.push('Schema missing datasource configuration')
    }
    
    // Check for common issues
    if (schemaContent.includes('@map(')) {
      const mapMatches = schemaContent.match(/@map\("([^"]+)"\)/g)
      mapMatches?.forEach(match => {
        const tableName = match.match(/@map\("([^"]+)"\)/)?.[1]
        if (tableName && tableName.includes(' ')) {
          result.warnings.push(`Table name "${tableName}" contains spaces`)
        }
      })
    }
    
    // Run Prisma validate
    try {
      execSync('npx prisma validate', { stdio: 'pipe' })
      console.log('‚úÖ Prisma schema validation passed')
    } catch (error) {
      result.isValid = false
      result.errors.push('Prisma validation failed')
      console.error('‚ùå Schema validation errors:', error)
    }
    
    // Run Prisma format check
    try {
      const originalContent = schemaContent
      execSync('npx prisma format', { stdio: 'pipe' })
      const formattedContent = readFileSync(schemaPath, 'utf8')
      
      if (originalContent !== formattedContent) {
        result.warnings.push('Schema formatting was updated')
      }
    } catch (error) {
      result.warnings.push('Schema formatting check failed')
    }
    
  } catch (error) {
    result.isValid = false
    result.errors.push(`Schema validation error: ${error}`)
  }
  
  return result
}

// Run validation
const validation = validatePrismaSchema()

if (validation.errors.length > 0) {
  console.error('‚ùå Schema validation errors:')
  validation.errors.forEach(error => console.error(`  - ${error}`))
}

if (validation.warnings.length > 0) {
  console.warn('‚ö†Ô∏è  Schema validation warnings:')
  validation.warnings.forEach(warning => console.warn(`  - ${warning}`))
}

if (validation.isValid) {
  console.log('üéâ Schema validation completed successfully!')
} else {
  process.exit(1)
}
```

### 3. Pre-commit Hook

Add schema validation to your pre-commit hooks:

```json
// package.json
{
  "scripts": {
    "validate:schema": "tsx scripts/validate-schema.ts",
    "format:schema": "prisma format",
    "check:schema": "npm run format:schema && npm run validate:schema"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "prisma/schema.prisma": [
      "prisma format",
      "prisma validate"
    ]
  }
}
```

---

## üìä Common Schema Patterns

### 1. Audit Trail Pattern

```prisma
// Base model for audit trails
model AuditableModel {
  id        String   @id @default(cuid())
  
  // Audit fields
  createdAt DateTime @default(now())
  createdBy String?
  updatedAt DateTime @updatedAt
  updatedBy String?
  deletedAt DateTime? // Soft delete
  deletedBy String?
  version   Int      @default(1) // Optimistic locking
  
  @@map("auditable_models")
}
```

### 2. Polymorphic Associations

```prisma
// Polymorphic comments that can belong to different entities
model Comment {
  id            String @id @default(cuid())
  content       String
  
  // Polymorphic fields
  commentableId   String
  commentableType String // "Post", "User", "Product", etc.
  
  authorId String
  author   User   @relation(fields: [authorId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@index([commentableId, commentableType])
  @@map("comments")
}

// Usage in other models
model Post {
  id    String @id @default(cuid())
  title String
  
  // No direct relation - handled in application code
  // comments Comment[] @relation("PostComments")
  
  @@map("posts")
}
```

### 3. Multi-tenant Pattern

```prisma
// Multi-tenant application pattern
model Tenant {
  id   String @id @default(cuid())
  name String
  slug String @unique
  
  // All tenant-specific data
  users User[]
  posts Post[]
  
  createdAt DateTime @default(now())
  
  @@map("tenants")
}

model User {
  id    String @id @default(cuid())
  email String
  name  String?
  
  // Tenant association
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  
  posts Post[]
  
  // Email must be unique within tenant
  @@unique([email, tenantId])
  @@map("users")
}

model Post {
  id      String @id @default(cuid())
  title   String
  content String?
  
  // Both user and direct tenant reference
  authorId String
  author   User   @relation(fields: [authorId], references: [id])
  
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  
  @@index([tenantId])
  @@map("posts")
}
```

---

## üß† Knowledge Check

### Schema Design Quiz

1. **What is the purpose of the `@@map` attribute?**
   - [ ] A) To create relationships between models
   - [x] B) To specify custom table names in the database
   - [ ] C) To add indexes to the model
   - [ ] D) To set default values

   **Explanation**: The `@@map` attribute allows you to specify a custom table name that differs from the model name.

2. **Which relationship type requires a join table?**
   - [ ] A) One-to-one
   - [ ] B) One-to-many
   - [x] C) Many-to-many
   - [ ] D) Self-referential

   **Explanation**: Many-to-many relationships require a join table to connect the two entities, either implicit or explicit.

3. **What does the `@updatedAt` attribute do?**
   - [ ] A) Sets a default creation timestamp
   - [x] B) Automatically updates the field when the record is modified
   - [ ] C) Creates an index on the field
   - [ ] D) Makes the field required

   **Explanation**: The `@updatedAt` attribute automatically updates the field with the current timestamp whenever the record is modified.

### Practical Exercise: Complete Blog Schema

**Challenge**: Create a complete blog schema with proper relationships

**Requirements**:
1. User model with profile relationship
2. Post model with author, category, and tags
3. Comment model with threading (replies)
4. Category model with hierarchy
5. Tag model with many-to-many to posts
6. Proper indexes and constraints

**Validation Checklist**:
- [ ] All models have proper primary keys
- [ ] Relationships are correctly defined
- [ ] Appropriate indexes are added
- [ ] Naming conventions are followed
- [ ] Schema validates without errors

```prisma
// Your schema here:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Add your models here...
```

---

## üí° Key Takeaways

- üìã **Schema Structure**: The `schema.prisma` file is your single source of truth for data modeling
- üîó **Relationships**: Master one-to-one, one-to-many, and many-to-many relationships with proper foreign keys
- üè∑Ô∏è **Attributes**: Use field and model attributes to add constraints, defaults, and database-specific configurations
- üìù **Naming**: Follow consistent naming conventions for models, fields, and relationships
- üîç **Validation**: Always format and validate your schema before applying migrations
- ‚ö° **Performance**: Add appropriate indexes for commonly queried fields
- üéØ **Best Practices**: Organize fields logically and use meaningful relationship names

---

## üîó Navigation

**üìç Current Location**: Module 2 ‚Üí Section 2.2 ‚Üí Lesson 2.2.1

**‚¨ÖÔ∏è Previous**: [2.1.5 TypeScript Configuration for Prisma](../2.1-installation-setup/2.1.5-typescript-configuration-for-prisma.md)
**‚û°Ô∏è Next**: [2.2.2 Database Connection String Configuration](./2.2.2-database-connection-string-configuration.md)

**üè† Section Home**: [2.2 First Prisma Project](./README.md)
**üìö Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**üó∫Ô∏è Quick Links**:
- [Next: Database Connection](./2.2.2-database-connection-string-configuration.md)
- [Jump to: First Migration](./2.2.3-running-first-migration-prisma-migrate-dev.md)
- [Official Docs: Schema Reference](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference)

---

*Fantastic! You've created your first Prisma schema. Ready to configure your database connection and see your schema come to life? Continue to the next lesson!*
