# 2.2.5 First Query & CRUD Operations

## 📋 Section Overview
- **Duration**: 45 minutes
- **Prerequisites**: 
  - Completed lessons 2.2.1 - 2.2.4
  - Prisma Client generated and configured
  - Database migrated with your schema
  - TypeScript development environment ready
- **Learning Objectives**: 
  - Execute your first database queries with Prisma Client
  - Master all CRUD operations (Create, Read, Update, Delete)
  - Understand relationship queries and data fetching
  - Implement error handling and validation patterns
  - Learn query optimization and best practices
- **Difficulty Level**: Beginner to Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Execute your first successful database queries
- ✅ Master Create, Read, Update, and Delete operations
- ✅ Query related data with includes and selects
- ✅ Handle complex filtering and sorting scenarios
- ✅ Implement proper error handling and validation
- ✅ Optimize queries for performance and type safety
- ✅ Build a complete CRUD application foundation

---

## 📖 Content

### Understanding CRUD with Prisma

Performing your first CRUD operations with Prisma is like **conducting a symphony orchestra for the first time**. Just as a conductor uses precise gestures and musical knowledge to guide different instrument sections in creating harmonious music, Prisma Client provides you with elegant, type-safe methods to orchestrate data operations across your database tables, creating a symphony of perfectly coordinated data interactions.

### 🎼 The Symphony Orchestra Analogy

```
🎼 Symphony Orchestra = 🗄️ Database CRUD Operations

🎯 Conductor's Role (Developer)
├── Musical score reading → Schema understanding
├── Tempo control → Query timing and performance
├── Section coordination → Relationship management
├── Dynamic control → Data validation and constraints
├── Error correction → Exception handling
└── Performance optimization → Query optimization

🎵 Orchestra Sections (Database Models)
├── String section → User operations
├── Wind section → Post operations
├── Brass section → Comment operations
├── Percussion section → Category operations
├── Solo instruments → Special queries
└── Ensemble harmony → Relationship queries

🎶 Musical Techniques (CRUD Operations)
├── Solo performances → Single record operations
├── Section features → Batch operations
├── Call and response → Query relationships
├── Crescendos → Data aggregation
├── Harmonies → Complex joins
└── Finale → Transaction coordination

🎭 Performance Management (Best Practices)
├── Rehearsal preparation → Query planning
├── Timing precision → Performance optimization
├── Error handling → Graceful failure recovery
├── Audience engagement → User experience
├── Quality assurance → Data validation
└── Continuous improvement → Query refinement
```

---

## 🔧 Setting Up Your First Operations

### 1. Basic Client Setup

Create a simple setup file to test your first operations:

```typescript
// src/examples/first-operations.ts
import prisma from '../lib/prisma'

async function connectAndTest() {
  try {
    // Test database connection
    await prisma.$connect()
    console.log('✅ Database connected successfully!')
    
    // Test basic query
    const userCount = await prisma.user.count()
    console.log(`📊 Current user count: ${userCount}`)
    
    return true
  } catch (error) {
    console.error('❌ Database connection failed:', error)
    return false
  } finally {
    await prisma.$disconnect()
  }
}

// Run the connection test
connectAndTest()
```

### 2. Your First CRUD Operations

Let's implement all four CRUD operations step by step:

```typescript
// src/examples/crud-operations.ts
import prisma from '../lib/prisma'
import { User, Post, Prisma } from '@prisma/client'

class CRUDOperations {
  // CREATE - Adding new data
  async createOperations() {
    console.log('🆕 CREATE Operations')
    console.log('═'.repeat(30))

    try {
      // Create a single user
      const user = await prisma.user.create({
        data: {
          email: 'john.doe@example.com',
          firstName: 'John',
          lastName: 'Doe',
          username: 'johndoe',
        }
      })
      console.log('✅ User created:', user)

      // Create user with nested profile
      const userWithProfile = await prisma.user.create({
        data: {
          email: 'jane.smith@example.com',
          firstName: 'Jane',
          lastName: 'Smith',
          username: 'janesmith',
          profile: {
            create: {
              bio: 'Software developer passionate about databases',
              avatar: 'https://example.com/avatar.jpg'
            }
          }
        },
        include: {
          profile: true
        }
      })
      console.log('✅ User with profile created:', userWithProfile)

      // Create multiple records
      const users = await prisma.user.createMany({
        data: [
          {
            email: 'alice@example.com',
            firstName: 'Alice',
            lastName: 'Johnson',
            username: 'alice'
          },
          {
            email: 'bob@example.com',
            firstName: 'Bob',
            lastName: 'Wilson',
            username: 'bobw'
          }
        ]
      })
      console.log(`✅ Created ${users.count} users in batch`)

      return { user, userWithProfile, batchCount: users.count }

    } catch (error) {
      console.error('❌ Create operations failed:', error)
      throw error
    }
  }

  // READ - Retrieving data
  async readOperations() {
    console.log('📖 READ Operations')
    console.log('═'.repeat(30))

    try {
      // Find all users
      const allUsers = await prisma.user.findMany()
      console.log(`✅ Found ${allUsers.length} users`)

      // Find user by unique field
      const userByEmail = await prisma.user.findUnique({
        where: {
          email: 'john.doe@example.com'
        }
      })
      console.log('✅ User by email:', userByEmail?.firstName)

      // Find users with filtering
      const activeUsers = await prisma.user.findMany({
        where: {
          isActive: true,
          email: {
            contains: '@example.com'
          }
        },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          createdAt: true
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 10
      })
      console.log(`✅ Found ${activeUsers.length} active users`)

      // Find with relationships
      const usersWithProfiles = await prisma.user.findMany({
        include: {
          profile: true,
          posts: {
            select: {
              id: true,
              title: true,
              published: true
            }
          },
          _count: {
            select: {
              posts: true,
              comments: true
            }
          }
        }
      })
      console.log(`✅ Found ${usersWithProfiles.length} users with relationships`)

      // Complex filtering
      const recentActiveUsers = await prisma.user.findMany({
        where: {
          AND: [
            { isActive: true },
            { 
              createdAt: {
                gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
              }
            },
            {
              OR: [
                { firstName: { contains: 'John' } },
                { lastName: { contains: 'Smith' } }
              ]
            }
          ]
        }
      })
      console.log(`✅ Found ${recentActiveUsers.length} recent active users`)

      return {
        totalUsers: allUsers.length,
        userByEmail,
        activeUsers,
        usersWithProfiles,
        recentActiveUsers
      }

    } catch (error) {
      console.error('❌ Read operations failed:', error)
      throw error
    }
  }

  // UPDATE - Modifying existing data
  async updateOperations() {
    console.log('✏️ UPDATE Operations')
    console.log('═'.repeat(30))

    try {
      // Update single record
      const updatedUser = await prisma.user.update({
        where: {
          email: 'john.doe@example.com'
        },
        data: {
          firstName: 'Johnny',
          updatedAt: new Date()
        }
      })
      console.log('✅ User updated:', updatedUser.firstName)

      // Update with nested data
      const userWithUpdatedProfile = await prisma.user.update({
        where: {
          email: 'jane.smith@example.com'
        },
        data: {
          profile: {
            update: {
              bio: 'Senior Software Developer with 5+ years experience'
            }
          }
        },
        include: {
          profile: true
        }
      })
      console.log('✅ User profile updated')

      // Update multiple records
      const updatedUsers = await prisma.user.updateMany({
        where: {
          isActive: false
        },
        data: {
          isActive: true,
          updatedAt: new Date()
        }
      })
      console.log(`✅ Updated ${updatedUsers.count} users`)

      // Upsert - update or create
      const upsertedUser = await prisma.user.upsert({
        where: {
          email: 'new.user@example.com'
        },
        update: {
          firstName: 'Updated Name'
        },
        create: {
          email: 'new.user@example.com',
          firstName: 'New',
          lastName: 'User',
          username: 'newuser'
        }
      })
      console.log('✅ User upserted:', upsertedUser.firstName)

      return {
        updatedUser,
        userWithUpdatedProfile,
        batchUpdateCount: updatedUsers.count,
        upsertedUser
      }

    } catch (error) {
      console.error('❌ Update operations failed:', error)
      throw error
    }
  }

  // DELETE - Removing data
  async deleteOperations() {
    console.log('🗑️ DELETE Operations')
    console.log('═'.repeat(30))

    try {
      // Delete single record
      const deletedUser = await prisma.user.delete({
        where: {
          email: 'new.user@example.com'
        }
      })
      console.log('✅ User deleted:', deletedUser.email)

      // Delete with cascade (related records deleted automatically)
      const userToDelete = await prisma.user.findFirst({
        where: {
          email: {
            contains: '@example.com'
          }
        }
      })

      if (userToDelete) {
        const deletedUserWithRelations = await prisma.user.delete({
          where: {
            id: userToDelete.id
          }
        })
        console.log('✅ User with relations deleted')
      }

      // Delete multiple records
      const deletedUsers = await prisma.user.deleteMany({
        where: {
          email: {
            contains: '@example.com'
          }
        }
      })
      console.log(`✅ Deleted ${deletedUsers.count} users`)

      return {
        deletedUser,
        batchDeleteCount: deletedUsers.count
      }

    } catch (error) {
      console.error('❌ Delete operations failed:', error)
      throw error
    }
  }
}

// Example usage
async function runCRUDOperations() {
  const crud = new CRUDOperations()

  try {
    await prisma.$connect()

    const createResults = await crud.createOperations()
    const readResults = await crud.readOperations()
    const updateResults = await crud.updateOperations()
    const deleteResults = await crud.deleteOperations()

    console.log('\n🎉 All CRUD operations completed successfully!')

    return {
      create: createResults,
      read: readResults,
      update: updateResults,
      delete: deleteResults
    }

  } catch (error) {
    console.error('💥 CRUD operations failed:', error)
  } finally {
    await prisma.$disconnect()
  }
}

// Run the operations
runCRUDOperations()
```

---

## 🔗 Advanced Relationship Queries

### 1. Working with One-to-One Relationships

```typescript
// src/examples/relationship-queries.ts
import prisma from '../lib/prisma'

async function oneToOneOperations() {
  console.log('👤 One-to-One Relationship Operations')
  console.log('═'.repeat(40))

  // Create user with profile
  const userWithProfile = await prisma.user.create({
    data: {
      email: 'profile.user@example.com',
      firstName: 'Profile',
      lastName: 'User',
      username: 'profileuser',
      profile: {
        create: {
          bio: 'I love working with databases!',
          avatar: 'https://example.com/profile-avatar.jpg'
        }
      }
    },
    include: {
      profile: true
    }
  })

  // Query user with profile
  const userProfile = await prisma.user.findUnique({
    where: { email: 'profile.user@example.com' },
    include: {
      profile: true
    }
  })

  // Update profile through user
  const updatedUserProfile = await prisma.user.update({
    where: { email: 'profile.user@example.com' },
    data: {
      profile: {
        update: {
          bio: 'Updated bio: Database enthusiast and developer'
        }
      }
    },
    include: {
      profile: true
    }
  })

  console.log('✅ One-to-one operations completed')
  return { userWithProfile, userProfile, updatedUserProfile }
}
```

### 2. Working with One-to-Many Relationships

```typescript
async function oneToManyOperations() {
  console.log('📝 One-to-Many Relationship Operations')
  console.log('═'.repeat(40))

  // Create user with multiple posts
  const authorWithPosts = await prisma.user.create({
    data: {
      email: 'author@example.com',
      firstName: 'Author',
      lastName: 'Writer',
      username: 'authorwriter',
      posts: {
        create: [
          {
            title: 'Getting Started with Prisma',
            content: 'Learn how to use Prisma for database operations...',
            slug: 'getting-started-prisma',
            excerpt: 'A beginner guide to Prisma',
            published: true,
            publishedAt: new Date()
          },
          {
            title: 'Advanced Prisma Techniques',
            content: 'Explore advanced features of Prisma...',
            slug: 'advanced-prisma-techniques',
            excerpt: 'Advanced Prisma usage patterns',
            published: false
          }
        ]
      }
    },
    include: {
      posts: true
    }
  })

  // Query posts with author
  const postsWithAuthor = await prisma.post.findMany({
    where: {
      published: true
    },
    include: {
      author: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          username: true
        }
      }
    }
  })

  // Add new post to existing user
  const newPost = await prisma.post.create({
    data: {
      title: 'Prisma Best Practices',
      content: 'Learn the best practices for using Prisma...',
      slug: 'prisma-best-practices',
      excerpt: 'Essential Prisma best practices',
      published: true,
      publishedAt: new Date(),
      author: {
        connect: {
          email: 'author@example.com'
        }
      }
    },
    include: {
      author: true
    }
  })

  console.log('✅ One-to-many operations completed')
  return { authorWithPosts, postsWithAuthor, newPost }
}
```

### 3. Working with Many-to-Many Relationships

```typescript
async function manyToManyOperations() {
  console.log('🏷️ Many-to-Many Relationship Operations')
  console.log('═'.repeat(40))

  // Create tags
  const tags = await prisma.tag.createMany({
    data: [
      { name: 'TypeScript', color: '#3178c6' },
      { name: 'Database', color: '#336791' },
      { name: 'Tutorial', color: '#28a745' },
      { name: 'Advanced', color: '#dc3545' }
    ]
  })

  // Create post with tags (explicit many-to-many)
  const postWithTags = await prisma.post.create({
    data: {
      title: 'TypeScript Database Tutorial',
      content: 'Learn TypeScript with databases...',
      slug: 'typescript-database-tutorial',
      excerpt: 'Complete TypeScript and database guide',
      published: true,
      publishedAt: new Date(),
      author: {
        connect: {
          email: 'author@example.com'
        }
      },
      tags: {
        create: [
          {
            tag: {
              connect: { name: 'TypeScript' }
            }
          },
          {
            tag: {
              connect: { name: 'Database' }
            }
          },
          {
            tag: {
              connect: { name: 'Tutorial' }
            }
          }
        ]
      }
    },
    include: {
      tags: {
        include: {
          tag: true
        }
      },
      author: true
    }
  })

  // Query posts by tag
  const typeScriptPosts = await prisma.post.findMany({
    where: {
      tags: {
        some: {
          tag: {
            name: 'TypeScript'
          }
        }
      }
    },
    include: {
      tags: {
        include: {
          tag: true
        }
      },
      author: {
        select: {
          firstName: true,
          lastName: true
        }
      }
    }
  })

  // Add tags to existing post
  const existingPost = await prisma.post.findFirst({
    where: { slug: 'getting-started-prisma' }
  })

  if (existingPost) {
    await prisma.post.update({
      where: { id: existingPost.id },
      data: {
        tags: {
          create: [
            {
              tag: {
                connect: { name: 'Tutorial' }
              }
            }
          ]
        }
      }
    })
  }

  console.log('✅ Many-to-many operations completed')
  return { postWithTags, typeScriptPosts }
}
```

---

## 🚀 Advanced Query Patterns

### 1. Aggregation and Grouping

```typescript
// src/examples/advanced-queries.ts
import prisma from '../lib/prisma'

async function aggregationQueries() {
  console.log('📊 Aggregation and Grouping Queries')
  console.log('═'.repeat(40))

  // Count operations
  const userCounts = {
    total: await prisma.user.count(),
    active: await prisma.user.count({
      where: { isActive: true }
    }),
    withPosts: await prisma.user.count({
      where: {
        posts: {
          some: {}
        }
      }
    })
  }

  // Group by and aggregate
  const postStats = await prisma.post.groupBy({
    by: ['published'],
    _count: {
      id: true
    },
    _avg: {
      // Assuming you have a views field
      // views: true
    },
    where: {
      createdAt: {
        gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
      }
    }
  })

  // Complex aggregation with relationships
  const authorStats = await prisma.user.findMany({
    select: {
      id: true,
      firstName: true,
      lastName: true,
      _count: {
        select: {
          posts: true,
          comments: true
        }
      }
    },
    where: {
      posts: {
        some: {}
      }
    },
    orderBy: {
      posts: {
        _count: 'desc'
      }
    },
    take: 10
  })

  console.log('✅ Aggregation queries completed')
  return { userCounts, postStats, authorStats }
}
```

### 2. Raw Queries and Custom Operations

```typescript
async function rawQueries() {
  console.log('⚡ Raw Queries and Custom Operations')
  console.log('═'.repeat(40))

  // Raw SQL query
  const userStats = await prisma.$queryRaw<{
    total_users: bigint
    active_users: bigint
    users_with_posts: bigint
  }[]>`
    SELECT 
      COUNT(*) as total_users,
      COUNT(*) FILTER (WHERE is_active = true) as active_users,
      COUNT(DISTINCT u.id) FILTER (WHERE p.id IS NOT NULL) as users_with_posts
    FROM users u
    LEFT JOIN posts p ON u.id = p.author_id
  `

  // Raw query with parameters
  const recentPosts = await prisma.$queryRaw<{
    id: string
    title: string
    author_name: string
    created_at: Date
  }[]>`
    SELECT 
      p.id,
      p.title,
      CONCAT(u.first_name, ' ', u.last_name) as author_name,
      p.created_at
    FROM posts p
    JOIN users u ON p.author_id = u.id
    WHERE p.created_at >= ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)}
    ORDER BY p.created_at DESC
    LIMIT 10
  `

  // Execute raw SQL (for operations that don't return data)
  const updateResult = await prisma.$executeRaw`
    UPDATE posts 
    SET updated_at = CURRENT_TIMESTAMP 
    WHERE published = false
  `

  console.log('✅ Raw queries completed')
  return { userStats, recentPosts, updateResult }
}
```

### 3. Transactions and Batch Operations

```typescript
async function transactionOperations() {
  console.log('🔄 Transaction and Batch Operations')
  console.log('═'.repeat(40))

  try {
    // Sequential transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: 'transaction.user@example.com',
          firstName: 'Transaction',
          lastName: 'User',
          username: 'transactionuser'
        }
      })

      // Create profile for user
      const profile = await tx.profile.create({
        data: {
          bio: 'Created in transaction',
          userId: user.id
        }
      })

      // Create post for user
      const post = await tx.post.create({
        data: {
          title: 'Transaction Post',
          content: 'This post was created in a transaction',
          slug: 'transaction-post',
          excerpt: 'Transaction example',
          authorId: user.id,
          published: true,
          publishedAt: new Date()
        }
      })

      return { user, profile, post }
    })

    // Batch operations
    const batchOperations = await prisma.$transaction([
      prisma.user.create({
        data: {
          email: 'batch1@example.com',
          firstName: 'Batch',
          lastName: 'User1',
          username: 'batch1'
        }
      }),
      prisma.user.create({
        data: {
          email: 'batch2@example.com',
          firstName: 'Batch',
          lastName: 'User2',
          username: 'batch2'
        }
      }),
      prisma.post.updateMany({
        where: { published: false },
        data: { updatedAt: new Date() }
      })
    ])

    console.log('✅ Transaction operations completed')
    return { sequentialResult: result, batchResults: batchOperations }

  } catch (error) {
    console.error('❌ Transaction failed:', error)
    throw error
  }
}
```

---

## 🛡️ Error Handling and Validation

### 1. Comprehensive Error Handling

```typescript
// src/examples/error-handling.ts
import prisma from '../lib/prisma'
import { Prisma } from '@prisma/client'

class DatabaseErrorHandler {
  static handleError(error: unknown): { message: string; code?: string } {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          return {
            message: 'A unique constraint would be violated.',
            code: 'UNIQUE_CONSTRAINT_VIOLATION'
          }
        case 'P2014':
          return {
            message: 'The change would violate a required relation.',
            code: 'REQUIRED_RELATION_VIOLATION'
          }
        case 'P2003':
          return {
            message: 'Foreign key constraint failed.',
            code: 'FOREIGN_KEY_CONSTRAINT'
          }
        case 'P2025':
          return {
            message: 'Record not found.',
            code: 'RECORD_NOT_FOUND'
          }
        default:
          return {
            message: `Database error: ${error.message}`,
            code: error.code
          }
      }
    }

    if (error instanceof Prisma.PrismaClientUnknownRequestError) {
      return {
        message: 'Unknown database error occurred.',
        code: 'UNKNOWN_ERROR'
      }
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
      return {
        message: 'Invalid query parameters provided.',
        code: 'VALIDATION_ERROR'
      }
    }

    return {
      message: 'An unexpected error occurred.',
      code: 'UNEXPECTED_ERROR'
    }
  }
}

async function safeOperations() {
  console.log('🛡️ Safe Database Operations with Error Handling')
  console.log('═'.repeat(50))

  // Safe create operation
  async function safeCreateUser(userData: {
    email: string
    firstName: string
    lastName: string
    username: string
  }) {
    try {
      const user = await prisma.user.create({
        data: userData
      })
      return { success: true, data: user }
    } catch (error) {
      const handledError = DatabaseErrorHandler.handleError(error)
      console.error(`❌ Create user failed: ${handledError.message}`)
      return { success: false, error: handledError }
    }
  }

  // Safe update operation
  async function safeUpdateUser(email: string, updateData: {
    firstName?: string
    lastName?: string
  }) {
    try {
      const user = await prisma.user.update({
        where: { email },
        data: updateData
      })
      return { success: true, data: user }
    } catch (error) {
      const handledError = DatabaseErrorHandler.handleError(error)
      console.error(`❌ Update user failed: ${handledError.message}`)
      return { success: false, error: handledError }
    }
  }

  // Test error scenarios
  const results = {
    duplicateEmail: await safeCreateUser({
      email: 'author@example.com', // This should already exist
      firstName: 'Duplicate',
      lastName: 'User',
      username: 'duplicate'
    }),
    
    updateNonExistent: await safeUpdateUser('nonexistent@example.com', {
      firstName: 'Updated'
    }),
    
    validCreate: await safeCreateUser({
      email: 'safe.user@example.com',
      firstName: 'Safe',
      lastName: 'User',
      username: 'safeuser'
    })
  }

  console.log('✅ Safe operations completed')
  return results
}
```

### 2. Input Validation

```typescript
import { z } from 'zod'

// Validation schemas
const createUserSchema = z.object({
  email: z.string().email('Invalid email format'),
  firstName: z.string().min(1, 'First name is required').max(50, 'First name too long'),
  lastName: z.string().min(1, 'Last name is required').max(50, 'Last name too long'),
  username: z.string().min(3, 'Username must be at least 3 characters').max(20, 'Username too long')
})

const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  content: z.string().optional(),
  excerpt: z.string().max(300, 'Excerpt too long').optional(),
  slug: z.string().min(1, 'Slug is required').regex(/^[a-z0-9-]+$/, 'Invalid slug format'),
  published: z.boolean().default(false),
  authorId: z.string().min(1, 'Author ID is required')
})

async function validatedOperations() {
  console.log('✅ Validated Database Operations')
  console.log('═'.repeat(35))

  async function createValidatedUser(input: unknown) {
    try {
      const validatedData = createUserSchema.parse(input)
      
      const user = await prisma.user.create({
        data: validatedData
      })
      
      return { success: true, data: user }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          success: false,
          error: {
            message: 'Validation failed',
            details: error.errors
          }
        }
      }
      
      const handledError = DatabaseErrorHandler.handleError(error)
      return { success: false, error: handledError }
    }
  }

  // Test validation
  const validationTests = {
    invalidEmail: await createValidatedUser({
      email: 'invalid-email',
      firstName: 'Test',
      lastName: 'User',
      username: 'test'
    }),
    
    shortUsername: await createValidatedUser({
      email: 'test@example.com',
      firstName: 'Test',
      lastName: 'User',
      username: 'ab' // Too short
    }),
    
    validUser: await createValidatedUser({
      email: 'validated.user@example.com',
      firstName: 'Validated',
      lastName: 'User',
      username: 'validateduser'
    })
  }

  console.log('✅ Validation tests completed')
  return validationTests
}
```

---

## 🎯 Complete CRUD Application Example

### Putting It All Together

```typescript
// src/examples/complete-crud-app.ts
import prisma from '../lib/prisma'
import { z } from 'zod'

class BlogService {
  // User operations
  async createUser(data: {
    email: string
    firstName: string
    lastName: string
    username: string
  }) {
    return await prisma.user.create({
      data,
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        username: true,
        createdAt: true
      }
    })
  }

  async getUserById(id: string) {
    return await prisma.user.findUnique({
      where: { id },
      include: {
        profile: true,
        posts: {
          where: { published: true },
          select: {
            id: true,
            title: true,
            excerpt: true,
            slug: true,
            publishedAt: true
          },
          orderBy: { publishedAt: 'desc' }
        },
        _count: {
          select: {
            posts: true,
            comments: true
          }
        }
      }
    })
  }

  // Post operations
  async createPost(data: {
    title: string
    content: string
    excerpt?: string
    slug: string
    authorId: string
    published?: boolean
  }) {
    return await prisma.post.create({
      data: {
        ...data,
        publishedAt: data.published ? new Date() : null
      },
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        }
      }
    })
  }

  async getPosts(options: {
    published?: boolean
    authorId?: string
    tag?: string
    page?: number
    limit?: number
  } = {}) {
    const {
      published = true,
      authorId,
      tag,
      page = 1,
      limit = 10
    } = options

    const where: any = { published }

    if (authorId) {
      where.authorId = authorId
    }

    if (tag) {
      where.tags = {
        some: {
          tag: {
            name: tag
          }
        }
      }
    }

    const skip = (page - 1) * limit

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              username: true
            }
          },
          tags: {
            include: {
              tag: true
            }
          },
          _count: {
            select: {
              comments: true
            }
          }
        },
        orderBy: { publishedAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.post.count({ where })
    ])

    return {
      posts,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    }
  }

  async updatePost(id: string, data: {
    title?: string
    content?: string
    excerpt?: string
    published?: boolean
  }) {
    const updateData: any = { ...data }
    
    if (data.published !== undefined) {
      updateData.publishedAt = data.published ? new Date() : null
    }

    return await prisma.post.update({
      where: { id },
      data: updateData,
      include: {
        author: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    })
  }

  async deletePost(id: string) {
    return await prisma.post.delete({
      where: { id }
    })
  }

  // Comment operations
  async addComment(data: {
    content: string
    postId: string
    authorId: string
    parentId?: string
  }) {
    return await prisma.comment.create({
      data,
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        }
      }
    })
  }

  async getComments(postId: string) {
    return await prisma.comment.findMany({
      where: {
        postId,
        parentId: null // Top-level comments only
      },
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        },
        replies: {
          include: {
            author: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                username: true
              }
            }
          },
          orderBy: { createdAt: 'asc' }
        }
      },
      orderBy: { createdAt: 'desc' }
    })
  }
}

// Example usage
async function runBlogApplication() {
  const blogService = new BlogService()

  try {
    await prisma.$connect()
    console.log('🚀 Blog Application Started')

    // Create a user
    const user = await blogService.createUser({
      email: 'blogger@example.com',
      firstName: 'Blog',
      lastName: 'Writer',
      username: 'blogger'
    })
    console.log('✅ User created:', user.username)

    // Create a post
    const post = await blogService.createPost({
      title: 'My First Blog Post',
      content: 'This is the content of my first blog post...',
      excerpt: 'Introduction to my blog',
      slug: 'my-first-blog-post',
      authorId: user.id,
      published: true
    })
    console.log('✅ Post created:', post.title)

    // Get posts
    const postsResult = await blogService.getPosts({ page: 1, limit: 5 })
    console.log(`✅ Retrieved ${postsResult.posts.length} posts`)

    // Add a comment
    const comment = await blogService.addComment({
      content: 'Great first post!',
      postId: post.id,
      authorId: user.id
    })
    console.log('✅ Comment added')

    // Get user with all data
    const fullUser = await blogService.getUserById(user.id)
    console.log(`✅ User has ${fullUser?._count.posts} posts and ${fullUser?._count.comments} comments`)

    console.log('🎉 Blog application demo completed!')

  } catch (error) {
    console.error('💥 Blog application error:', error)
  } finally {
    await prisma.$disconnect()
  }
}

runBlogApplication()
```

---

## 🧠 Knowledge Check

### CRUD Operations Quiz

1. **Which Prisma method creates multiple records in a single operation?**
   - [ ] A) `create()`
   - [x] B) `createMany()`
   - [ ] C) `insertMany()`
   - [ ] D) `bulkCreate()`

   **Explanation**: `createMany()` is used to create multiple records in a single database operation, which is more efficient than multiple `create()` calls.

2. **What does the `include` option do in Prisma queries?**
   - [ ] A) Filters the results
   - [x] B) Fetches related data from other models
   - [ ] C) Limits the number of returned records
   - [ ] D) Sorts the results

   **Explanation**: The `include` option fetches related data from other models based on the relationships defined in your schema.

3. **Which operation allows you to update a record or create it if it doesn't exist?**
   - [ ] A) `update()`
   - [ ] B) `updateMany()`
   - [x] C) `upsert()`
   - [ ] D) `findOrCreate()`

   **Explanation**: `upsert()` performs an "update or insert" operation - it updates a record if it exists or creates a new one if it doesn't.

### Practical Exercise: Build a Complete CRUD Application

**Challenge**: Create a fully functional blog application with all CRUD operations

**Requirements**:
1. User management (create, read, update, delete)
2. Post management with relationships
3. Comment system with threading
4. Tag system with many-to-many relationships
5. Proper error handling and validation
6. Pagination and filtering

**Validation Checklist**:
- [ ] All CRUD operations work correctly
- [ ] Relationships are properly queried
- [ ] Error handling prevents crashes
- [ ] Validation ensures data integrity
- [ ] Pagination works for large datasets
- [ ] Complex queries return expected results

---

## 💡 Key Takeaways

- 🎯 **CRUD Mastery**: Master Create, Read, Update, and Delete operations with type safety
- 🔗 **Relationship Queries**: Efficiently query related data using `include` and `select`
- 🛡️ **Error Handling**: Implement robust error handling for production applications
- ✅ **Validation**: Use schema validation to ensure data integrity
- ⚡ **Performance**: Optimize queries with proper filtering, pagination, and aggregation
- 🔄 **Transactions**: Use transactions for complex operations that need atomicity
- 📊 **Advanced Queries**: Leverage raw SQL and complex filtering for special requirements

---

## 🔗 Navigation

**📍 Current Location**: Module 2 → Section 2.2 → Lesson 2.2.5

**⬅️ Previous**: [2.2.4 Generating Prisma Client with `prisma generate`](./2.2.4-generating-prisma-client-prisma-generate.md)
**➡️ Next**: [2.3.1 Connection String Formats & Parameters](../2.3-database-connection/2.3.1-connection-string-formats-parameters.md)

**🏠 Section Home**: [2.2 First Prisma Project](./README.md)
**📚 Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**🗺️ Quick Links**:
- [Next: Database Connection](../2.3-database-connection/2.3.1-connection-string-formats-parameters.md)
- [Jump to: Prisma CLI Basics](../2.4-prisma-cli-basics/2.4.1-essential-cli-commands-overview.md)
- [Official Docs: CRUD Operations](https://www.prisma.io/docs/concepts/components/prisma-client/crud)

---

*🎉 Congratulations! You've mastered your first Prisma CRUD operations and built a complete database foundation. You're now ready to explore advanced database connection patterns and Prisma CLI mastery!*
