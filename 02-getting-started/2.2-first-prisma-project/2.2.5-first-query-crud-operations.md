# 2.2.5 First Query & CRUD Operations

## üìã Section Overview
- **Duration**: 45 minutes
- **Prerequisites**: 
  - Completed lessons 2.2.1 - 2.2.4
  - Prisma Client generated and configured
  - Database migrated with your schema
  - TypeScript development environment ready
- **Learning Objectives**: 
  - Execute your first database queries with Prisma Client
  - Master all CRUD operations (Create, Read, Update, Delete)
  - Understand relationship queries and data fetching
  - Implement error handling and validation patterns
  - Learn query optimization and best practices
- **Difficulty Level**: Beginner to Intermediate

---

## üéØ What You'll Learn

By the end of this section, you will:
- ‚úÖ Execute your first successful database queries
- ‚úÖ Master Create, Read, Update, and Delete operations
- ‚úÖ Query related data with includes and selects
- ‚úÖ Handle complex filtering and sorting scenarios
- ‚úÖ Implement proper error handling and validation
- ‚úÖ Optimize queries for performance and type safety
- ‚úÖ Build a complete CRUD application foundation

---

## üìñ Content

### Understanding CRUD with Prisma

Performing your first CRUD operations with Prisma is like **conducting a symphony orchestra for the first time**. Just as a conductor uses precise gestures and musical knowledge to guide different instrument sections in creating harmonious music, Prisma Client provides you with elegant, type-safe methods to orchestrate data operations across your database tables, creating a symphony of perfectly coordinated data interactions.

### üéº The Symphony Orchestra Analogy

```
üéº Symphony Orchestra = üóÑÔ∏è Database CRUD Operations

üéØ Conductor's Role (Developer)
‚îú‚îÄ‚îÄ Musical score reading ‚Üí Schema understanding
‚îú‚îÄ‚îÄ Tempo control ‚Üí Query timing and performance
‚îú‚îÄ‚îÄ Section coordination ‚Üí Relationship management
‚îú‚îÄ‚îÄ Dynamic control ‚Üí Data validation and constraints
‚îú‚îÄ‚îÄ Error correction ‚Üí Exception handling
‚îî‚îÄ‚îÄ Performance optimization ‚Üí Query optimization

üéµ Orchestra Sections (Database Models)
‚îú‚îÄ‚îÄ String section ‚Üí User operations
‚îú‚îÄ‚îÄ Wind section ‚Üí Post operations
‚îú‚îÄ‚îÄ Brass section ‚Üí Comment operations
‚îú‚îÄ‚îÄ Percussion section ‚Üí Category operations
‚îú‚îÄ‚îÄ Solo instruments ‚Üí Special queries
‚îî‚îÄ‚îÄ Ensemble harmony ‚Üí Relationship queries

üé∂ Musical Techniques (CRUD Operations)
‚îú‚îÄ‚îÄ Solo performances ‚Üí Single record operations
‚îú‚îÄ‚îÄ Section features ‚Üí Batch operations
‚îú‚îÄ‚îÄ Call and response ‚Üí Query relationships
‚îú‚îÄ‚îÄ Crescendos ‚Üí Data aggregation
‚îú‚îÄ‚îÄ Harmonies ‚Üí Complex joins
‚îî‚îÄ‚îÄ Finale ‚Üí Transaction coordination

üé≠ Performance Management (Best Practices)
‚îú‚îÄ‚îÄ Rehearsal preparation ‚Üí Query planning
‚îú‚îÄ‚îÄ Timing precision ‚Üí Performance optimization
‚îú‚îÄ‚îÄ Error handling ‚Üí Graceful failure recovery
‚îú‚îÄ‚îÄ Audience engagement ‚Üí User experience
‚îú‚îÄ‚îÄ Quality assurance ‚Üí Data validation
‚îî‚îÄ‚îÄ Continuous improvement ‚Üí Query refinement
```

---

## üîß Setting Up Your First Operations

### 1. Basic Client Setup

Create a simple setup file to test your first operations:

```typescript
// src/examples/first-operations.ts
import prisma from '../lib/prisma'

async function connectAndTest() {
  try {
    // Test database connection
    await prisma.$connect()
    console.log('‚úÖ Database connected successfully!')
    
    // Test basic query
    const userCount = await prisma.user.count()
    console.log(`üìä Current user count: ${userCount}`)
    
    return true
  } catch (error) {
    console.error('‚ùå Database connection failed:', error)
    return false
  } finally {
    await prisma.$disconnect()
  }
}

// Run the connection test
connectAndTest()
```

### 2. Your First CRUD Operations

Let's implement all four CRUD operations step by step:

```typescript
// src/examples/crud-operations.ts
import prisma from '../lib/prisma'
import { User, Post, Prisma } from '@prisma/client'

class CRUDOperations {
  // CREATE - Adding new data
  async createOperations() {
    console.log('üÜï CREATE Operations')
    console.log('‚ïê'.repeat(30))

    try {
      // Create a single user
      const user = await prisma.user.create({
        data: {
          email: 'john.doe@example.com',
          firstName: 'John',
          lastName: 'Doe',
          username: 'johndoe',
        }
      })
      console.log('‚úÖ User created:', user)

      // Create user with nested profile
      const userWithProfile = await prisma.user.create({
        data: {
          email: 'jane.smith@example.com',
          firstName: 'Jane',
          lastName: 'Smith',
          username: 'janesmith',
          profile: {
            create: {
              bio: 'Software developer passionate about databases',
              avatar: 'https://example.com/avatar.jpg'
            }
          }
        },
        include: {
          profile: true
        }
      })
      console.log('‚úÖ User with profile created:', userWithProfile)

      // Create multiple records
      const users = await prisma.user.createMany({
        data: [
          {
            email: 'alice@example.com',
            firstName: 'Alice',
            lastName: 'Johnson',
            username: 'alice'
          },
          {
            email: 'bob@example.com',
            firstName: 'Bob',
            lastName: 'Wilson',
            username: 'bobw'
          }
        ]
      })
      console.log(`‚úÖ Created ${users.count} users in batch`)

      return { user, userWithProfile, batchCount: users.count }

    } catch (error) {
      console.error('‚ùå Create operations failed:', error)
      throw error
    }
  }

  // READ - Retrieving data
  async readOperations() {
    console.log('üìñ READ Operations')
    console.log('‚ïê'.repeat(30))

    try {
      // Find all users
      const allUsers = await prisma.user.findMany()
      console.log(`‚úÖ Found ${allUsers.length} users`)

      // Find user by unique field
      const userByEmail = await prisma.user.findUnique({
        where: {
          email: 'john.doe@example.com'
        }
      })
      console.log('‚úÖ User by email:', userByEmail?.firstName)

      // Find users with filtering
      const activeUsers = await prisma.user.findMany({
        where: {
          isActive: true,
          email: {
            contains: '@example.com'
          }
        },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          createdAt: true
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 10
      })
      console.log(`‚úÖ Found ${activeUsers.length} active users`)

      // Find with relationships
      const usersWithProfiles = await prisma.user.findMany({
        include: {
          profile: true,
          posts: {
            select: {
              id: true,
              title: true,
              published: true
            }
          },
          _count: {
            select: {
              posts: true,
              comments: true
            }
          }
        }
      })
      console.log(`‚úÖ Found ${usersWithProfiles.length} users with relationships`)

      // Complex filtering
      const recentActiveUsers = await prisma.user.findMany({
        where: {
          AND: [
            { isActive: true },
            { 
              createdAt: {
                gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
              }
            },
            {
              OR: [
                { firstName: { contains: 'John' } },
                { lastName: { contains: 'Smith' } }
              ]
            }
          ]
        }
      })
      console.log(`‚úÖ Found ${recentActiveUsers.length} recent active users`)

      return {
        totalUsers: allUsers.length,
        userByEmail,
        activeUsers,
        usersWithProfiles,
        recentActiveUsers
      }

    } catch (error) {
      console.error('‚ùå Read operations failed:', error)
      throw error
    }
  }

  // UPDATE - Modifying existing data
  async updateOperations() {
    console.log('‚úèÔ∏è UPDATE Operations')
    console.log('‚ïê'.repeat(30))

    try {
      // Update single record
      const updatedUser = await prisma.user.update({
        where: {
          email: 'john.doe@example.com'
        },
        data: {
          firstName: 'Johnny',
          updatedAt: new Date()
        }
      })
      console.log('‚úÖ User updated:', updatedUser.firstName)

      // Update with nested data
      const userWithUpdatedProfile = await prisma.user.update({
        where: {
          email: 'jane.smith@example.com'
        },
        data: {
          profile: {
            update: {
              bio: 'Senior Software Developer with 5+ years experience'
            }
          }
        },
        include: {
          profile: true
        }
      })
      console.log('‚úÖ User profile updated')

      // Update multiple records
      const updatedUsers = await prisma.user.updateMany({
        where: {
          isActive: false
        },
        data: {
          isActive: true,
          updatedAt: new Date()
        }
      })
      console.log(`‚úÖ Updated ${updatedUsers.count} users`)

      // Upsert - update or create
      const upsertedUser = await prisma.user.upsert({
        where: {
          email: 'new.user@example.com'
        },
        update: {
          firstName: 'Updated Name'
        },
        create: {
          email: 'new.user@example.com',
          firstName: 'New',
          lastName: 'User',
          username: 'newuser'
        }
      })
      console.log('‚úÖ User upserted:', upsertedUser.firstName)

      return {
        updatedUser,
        userWithUpdatedProfile,
        batchUpdateCount: updatedUsers.count,
        upsertedUser
      }

    } catch (error) {
      console.error('‚ùå Update operations failed:', error)
      throw error
    }
  }

  // DELETE - Removing data
  async deleteOperations() {
    console.log('üóëÔ∏è DELETE Operations')
    console.log('‚ïê'.repeat(30))

    try {
      // Delete single record
      const deletedUser = await prisma.user.delete({
        where: {
          email: 'new.user@example.com'
        }
      })
      console.log('‚úÖ User deleted:', deletedUser.email)

      // Delete with cascade (related records deleted automatically)
      const userToDelete = await prisma.user.findFirst({
        where: {
          email: {
            contains: '@example.com'
          }
        }
      })

      if (userToDelete) {
        const deletedUserWithRelations = await prisma.user.delete({
          where: {
            id: userToDelete.id
          }
        })
        console.log('‚úÖ User with relations deleted')
      }

      // Delete multiple records
      const deletedUsers = await prisma.user.deleteMany({
        where: {
          email: {
            contains: '@example.com'
          }
        }
      })
      console.log(`‚úÖ Deleted ${deletedUsers.count} users`)

      return {
        deletedUser,
        batchDeleteCount: deletedUsers.count
      }

    } catch (error) {
      console.error('‚ùå Delete operations failed:', error)
      throw error
    }
  }
}

// Example usage
async function runCRUDOperations() {
  const crud = new CRUDOperations()

  try {
    await prisma.$connect()

    const createResults = await crud.createOperations()
    const readResults = await crud.readOperations()
    const updateResults = await crud.updateOperations()
    const deleteResults = await crud.deleteOperations()

    console.log('\nüéâ All CRUD operations completed successfully!')

    return {
      create: createResults,
      read: readResults,
      update: updateResults,
      delete: deleteResults
    }

  } catch (error) {
    console.error('üí• CRUD operations failed:', error)
  } finally {
    await prisma.$disconnect()
  }
}

// Run the operations
runCRUDOperations()
```

---

## üîó Advanced Relationship Queries

### 1. Working with One-to-One Relationships

```typescript
// src/examples/relationship-queries.ts
import prisma from '../lib/prisma'

async function oneToOneOperations() {
  console.log('üë§ One-to-One Relationship Operations')
  console.log('‚ïê'.repeat(40))

  // Create user with profile
  const userWithProfile = await prisma.user.create({
    data: {
      email: 'profile.user@example.com',
      firstName: 'Profile',
      lastName: 'User',
      username: 'profileuser',
      profile: {
        create: {
          bio: 'I love working with databases!',
          avatar: 'https://example.com/profile-avatar.jpg'
        }
      }
    },
    include: {
      profile: true
    }
  })

  // Query user with profile
  const userProfile = await prisma.user.findUnique({
    where: { email: 'profile.user@example.com' },
    include: {
      profile: true
    }
  })

  // Update profile through user
  const updatedUserProfile = await prisma.user.update({
    where: { email: 'profile.user@example.com' },
    data: {
      profile: {
        update: {
          bio: 'Updated bio: Database enthusiast and developer'
        }
      }
    },
    include: {
      profile: true
    }
  })

  console.log('‚úÖ One-to-one operations completed')
  return { userWithProfile, userProfile, updatedUserProfile }
}
```

### 2. Working with One-to-Many Relationships

```typescript
async function oneToManyOperations() {
  console.log('üìù One-to-Many Relationship Operations')
  console.log('‚ïê'.repeat(40))

  // Create user with multiple posts
  const authorWithPosts = await prisma.user.create({
    data: {
      email: 'author@example.com',
      firstName: 'Author',
      lastName: 'Writer',
      username: 'authorwriter',
      posts: {
        create: [
          {
            title: 'Getting Started with Prisma',
            content: 'Learn how to use Prisma for database operations...',
            slug: 'getting-started-prisma',
            excerpt: 'A beginner guide to Prisma',
            published: true,
            publishedAt: new Date()
          },
          {
            title: 'Advanced Prisma Techniques',
            content: 'Explore advanced features of Prisma...',
            slug: 'advanced-prisma-techniques',
            excerpt: 'Advanced Prisma usage patterns',
            published: false
          }
        ]
      }
    },
    include: {
      posts: true
    }
  })

  // Query posts with author
  const postsWithAuthor = await prisma.post.findMany({
    where: {
      published: true
    },
    include: {
      author: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          username: true
        }
      }
    }
  })

  // Add new post to existing user
  const newPost = await prisma.post.create({
    data: {
      title: 'Prisma Best Practices',
      content: 'Learn the best practices for using Prisma...',
      slug: 'prisma-best-practices',
      excerpt: 'Essential Prisma best practices',
      published: true,
      publishedAt: new Date(),
      author: {
        connect: {
          email: 'author@example.com'
        }
      }
    },
    include: {
      author: true
    }
  })

  console.log('‚úÖ One-to-many operations completed')
  return { authorWithPosts, postsWithAuthor, newPost }
}
```

### 3. Working with Many-to-Many Relationships

```typescript
async function manyToManyOperations() {
  console.log('üè∑Ô∏è Many-to-Many Relationship Operations')
  console.log('‚ïê'.repeat(40))

  // Create tags
  const tags = await prisma.tag.createMany({
    data: [
      { name: 'TypeScript', color: '#3178c6' },
      { name: 'Database', color: '#336791' },
      { name: 'Tutorial', color: '#28a745' },
      { name: 'Advanced', color: '#dc3545' }
    ]
  })

  // Create post with tags (explicit many-to-many)
  const postWithTags = await prisma.post.create({
    data: {
      title: 'TypeScript Database Tutorial',
      content: 'Learn TypeScript with databases...',
      slug: 'typescript-database-tutorial',
      excerpt: 'Complete TypeScript and database guide',
      published: true,
      publishedAt: new Date(),
      author: {
        connect: {
          email: 'author@example.com'
        }
      },
      tags: {
        create: [
          {
            tag: {
              connect: { name: 'TypeScript' }
            }
          },
          {
            tag: {
              connect: { name: 'Database' }
            }
          },
          {
            tag: {
              connect: { name: 'Tutorial' }
            }
          }
        ]
      }
    },
    include: {
      tags: {
        include: {
          tag: true
        }
      },
      author: true
    }
  })

  // Query posts by tag
  const typeScriptPosts = await prisma.post.findMany({
    where: {
      tags: {
        some: {
          tag: {
            name: 'TypeScript'
          }
        }
      }
    },
    include: {
      tags: {
        include: {
          tag: true
        }
      },
      author: {
        select: {
          firstName: true,
          lastName: true
        }
      }
    }
  })

  // Add tags to existing post
  const existingPost = await prisma.post.findFirst({
    where: { slug: 'getting-started-prisma' }
  })

  if (existingPost) {
    await prisma.post.update({
      where: { id: existingPost.id },
      data: {
        tags: {
          create: [
            {
              tag: {
                connect: { name: 'Tutorial' }
              }
            }
          ]
        }
      }
    })
  }

  console.log('‚úÖ Many-to-many operations completed')
  return { postWithTags, typeScriptPosts }
}
```

---

## üöÄ Advanced Query Patterns

### 1. Aggregation and Grouping

```typescript
// src/examples/advanced-queries.ts
import prisma from '../lib/prisma'

async function aggregationQueries() {
  console.log('üìä Aggregation and Grouping Queries')
  console.log('‚ïê'.repeat(40))

  // Count operations
  const userCounts = {
    total: await prisma.user.count(),
    active: await prisma.user.count({
      where: { isActive: true }
    }),
    withPosts: await prisma.user.count({
      where: {
        posts: {
          some: {}
        }
      }
    })
  }

  // Group by and aggregate
  const postStats = await prisma.post.groupBy({
    by: ['published'],
    _count: {
      id: true
    },
    _avg: {
      // Assuming you have a views field
      // views: true
    },
    where: {
      createdAt: {
        gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
      }
    }
  })

  // Complex aggregation with relationships
  const authorStats = await prisma.user.findMany({
    select: {
      id: true,
      firstName: true,
      lastName: true,
      _count: {
        select: {
          posts: true,
          comments: true
        }
      }
    },
    where: {
      posts: {
        some: {}
      }
    },
    orderBy: {
      posts: {
        _count: 'desc'
      }
    },
    take: 10
  })

  console.log('‚úÖ Aggregation queries completed')
  return { userCounts, postStats, authorStats }
}
```

### 2. Raw Queries and Custom Operations

```typescript
async function rawQueries() {
  console.log('‚ö° Raw Queries and Custom Operations')
  console.log('‚ïê'.repeat(40))

  // Raw SQL query
  const userStats = await prisma.$queryRaw<{
    total_users: bigint
    active_users: bigint
    users_with_posts: bigint
  }[]>`
    SELECT 
      COUNT(*) as total_users,
      COUNT(*) FILTER (WHERE is_active = true) as active_users,
      COUNT(DISTINCT u.id) FILTER (WHERE p.id IS NOT NULL) as users_with_posts
    FROM users u
    LEFT JOIN posts p ON u.id = p.author_id
  `

  // Raw query with parameters
  const recentPosts = await prisma.$queryRaw<{
    id: string
    title: string
    author_name: string
    created_at: Date
  }[]>`
    SELECT 
      p.id,
      p.title,
      CONCAT(u.first_name, ' ', u.last_name) as author_name,
      p.created_at
    FROM posts p
    JOIN users u ON p.author_id = u.id
    WHERE p.created_at >= ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)}
    ORDER BY p.created_at DESC
    LIMIT 10
  `

  // Execute raw SQL (for operations that don't return data)
  const updateResult = await prisma.$executeRaw`
    UPDATE posts 
    SET updated_at = CURRENT_TIMESTAMP 
    WHERE published = false
  `

  console.log('‚úÖ Raw queries completed')
  return { userStats, recentPosts, updateResult }
}
```

### 3. Transactions and Batch Operations

```typescript
async function transactionOperations() {
  console.log('üîÑ Transaction and Batch Operations')
  console.log('‚ïê'.repeat(40))

  try {
    // Sequential transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: 'transaction.user@example.com',
          firstName: 'Transaction',
          lastName: 'User',
          username: 'transactionuser'
        }
      })

      // Create profile for user
      const profile = await tx.profile.create({
        data: {
          bio: 'Created in transaction',
          userId: user.id
        }
      })

      // Create post for user
      const post = await tx.post.create({
        data: {
          title: 'Transaction Post',
          content: 'This post was created in a transaction',
          slug: 'transaction-post',
          excerpt: 'Transaction example',
          authorId: user.id,
          published: true,
          publishedAt: new Date()
        }
      })

      return { user, profile, post }
    })

    // Batch operations
    const batchOperations = await prisma.$transaction([
      prisma.user.create({
        data: {
          email: 'batch1@example.com',
          firstName: 'Batch',
          lastName: 'User1',
          username: 'batch1'
        }
      }),
      prisma.user.create({
        data: {
          email: 'batch2@example.com',
          firstName: 'Batch',
          lastName: 'User2',
          username: 'batch2'
        }
      }),
      prisma.post.updateMany({
        where: { published: false },
        data: { updatedAt: new Date() }
      })
    ])

    console.log('‚úÖ Transaction operations completed')
    return { sequentialResult: result, batchResults: batchOperations }

  } catch (error) {
    console.error('‚ùå Transaction failed:', error)
    throw error
  }
}
```

---

## üõ°Ô∏è Error Handling and Validation

### 1. Comprehensive Error Handling

```typescript
// src/examples/error-handling.ts
import prisma from '../lib/prisma'
import { Prisma } from '@prisma/client'

class DatabaseErrorHandler {
  static handleError(error: unknown): { message: string; code?: string } {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          return {
            message: 'A unique constraint would be violated.',
            code: 'UNIQUE_CONSTRAINT_VIOLATION'
          }
        case 'P2014':
          return {
            message: 'The change would violate a required relation.',
            code: 'REQUIRED_RELATION_VIOLATION'
          }
        case 'P2003':
          return {
            message: 'Foreign key constraint failed.',
            code: 'FOREIGN_KEY_CONSTRAINT'
          }
        case 'P2025':
          return {
            message: 'Record not found.',
            code: 'RECORD_NOT_FOUND'
          }
        default:
          return {
            message: `Database error: ${error.message}`,
            code: error.code
          }
      }
    }

    if (error instanceof Prisma.PrismaClientUnknownRequestError) {
      return {
        message: 'Unknown database error occurred.',
        code: 'UNKNOWN_ERROR'
      }
    }

    if (error instanceof Prisma.PrismaClientValidationError) {
      return {
        message: 'Invalid query parameters provided.',
        code: 'VALIDATION_ERROR'
      }
    }

    return {
      message: 'An unexpected error occurred.',
      code: 'UNEXPECTED_ERROR'
    }
  }
}

async function safeOperations() {
  console.log('üõ°Ô∏è Safe Database Operations with Error Handling')
  console.log('‚ïê'.repeat(50))

  // Safe create operation
  async function safeCreateUser(userData: {
    email: string
    firstName: string
    lastName: string
    username: string
  }) {
    try {
      const user = await prisma.user.create({
        data: userData
      })
      return { success: true, data: user }
    } catch (error) {
      const handledError = DatabaseErrorHandler.handleError(error)
      console.error(`‚ùå Create user failed: ${handledError.message}`)
      return { success: false, error: handledError }
    }
  }

  // Safe update operation
  async function safeUpdateUser(email: string, updateData: {
    firstName?: string
    lastName?: string
  }) {
    try {
      const user = await prisma.user.update({
        where: { email },
        data: updateData
      })
      return { success: true, data: user }
    } catch (error) {
      const handledError = DatabaseErrorHandler.handleError(error)
      console.error(`‚ùå Update user failed: ${handledError.message}`)
      return { success: false, error: handledError }
    }
  }

  // Test error scenarios
  const results = {
    duplicateEmail: await safeCreateUser({
      email: 'author@example.com', // This should already exist
      firstName: 'Duplicate',
      lastName: 'User',
      username: 'duplicate'
    }),
    
    updateNonExistent: await safeUpdateUser('nonexistent@example.com', {
      firstName: 'Updated'
    }),
    
    validCreate: await safeCreateUser({
      email: 'safe.user@example.com',
      firstName: 'Safe',
      lastName: 'User',
      username: 'safeuser'
    })
  }

  console.log('‚úÖ Safe operations completed')
  return results
}
```

### 2. Input Validation

```typescript
import { z } from 'zod'

// Validation schemas
const createUserSchema = z.object({
  email: z.string().email('Invalid email format'),
  firstName: z.string().min(1, 'First name is required').max(50, 'First name too long'),
  lastName: z.string().min(1, 'Last name is required').max(50, 'Last name too long'),
  username: z.string().min(3, 'Username must be at least 3 characters').max(20, 'Username too long')
})

const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  content: z.string().optional(),
  excerpt: z.string().max(300, 'Excerpt too long').optional(),
  slug: z.string().min(1, 'Slug is required').regex(/^[a-z0-9-]+$/, 'Invalid slug format'),
  published: z.boolean().default(false),
  authorId: z.string().min(1, 'Author ID is required')
})

async function validatedOperations() {
  console.log('‚úÖ Validated Database Operations')
  console.log('‚ïê'.repeat(35))

  async function createValidatedUser(input: unknown) {
    try {
      const validatedData = createUserSchema.parse(input)
      
      const user = await prisma.user.create({
        data: validatedData
      })
      
      return { success: true, data: user }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return {
          success: false,
          error: {
            message: 'Validation failed',
            details: error.errors
          }
        }
      }
      
      const handledError = DatabaseErrorHandler.handleError(error)
      return { success: false, error: handledError }
    }
  }

  // Test validation
  const validationTests = {
    invalidEmail: await createValidatedUser({
      email: 'invalid-email',
      firstName: 'Test',
      lastName: 'User',
      username: 'test'
    }),
    
    shortUsername: await createValidatedUser({
      email: 'test@example.com',
      firstName: 'Test',
      lastName: 'User',
      username: 'ab' // Too short
    }),
    
    validUser: await createValidatedUser({
      email: 'validated.user@example.com',
      firstName: 'Validated',
      lastName: 'User',
      username: 'validateduser'
    })
  }

  console.log('‚úÖ Validation tests completed')
  return validationTests
}
```

---

## üéØ Complete CRUD Application Example

### Putting It All Together

```typescript
// src/examples/complete-crud-app.ts
import prisma from '../lib/prisma'
import { z } from 'zod'

class BlogService {
  // User operations
  async createUser(data: {
    email: string
    firstName: string
    lastName: string
    username: string
  }) {
    return await prisma.user.create({
      data,
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        username: true,
        createdAt: true
      }
    })
  }

  async getUserById(id: string) {
    return await prisma.user.findUnique({
      where: { id },
      include: {
        profile: true,
        posts: {
          where: { published: true },
          select: {
            id: true,
            title: true,
            excerpt: true,
            slug: true,
            publishedAt: true
          },
          orderBy: { publishedAt: 'desc' }
        },
        _count: {
          select: {
            posts: true,
            comments: true
          }
        }
      }
    })
  }

  // Post operations
  async createPost(data: {
    title: string
    content: string
    excerpt?: string
    slug: string
    authorId: string
    published?: boolean
  }) {
    return await prisma.post.create({
      data: {
        ...data,
        publishedAt: data.published ? new Date() : null
      },
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        }
      }
    })
  }

  async getPosts(options: {
    published?: boolean
    authorId?: string
    tag?: string
    page?: number
    limit?: number
  } = {}) {
    const {
      published = true,
      authorId,
      tag,
      page = 1,
      limit = 10
    } = options

    const where: any = { published }

    if (authorId) {
      where.authorId = authorId
    }

    if (tag) {
      where.tags = {
        some: {
          tag: {
            name: tag
          }
        }
      }
    }

    const skip = (page - 1) * limit

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              username: true
            }
          },
          tags: {
            include: {
              tag: true
            }
          },
          _count: {
            select: {
              comments: true
            }
          }
        },
        orderBy: { publishedAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.post.count({ where })
    ])

    return {
      posts,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    }
  }

  async updatePost(id: string, data: {
    title?: string
    content?: string
    excerpt?: string
    published?: boolean
  }) {
    const updateData: any = { ...data }
    
    if (data.published !== undefined) {
      updateData.publishedAt = data.published ? new Date() : null
    }

    return await prisma.post.update({
      where: { id },
      data: updateData,
      include: {
        author: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      }
    })
  }

  async deletePost(id: string) {
    return await prisma.post.delete({
      where: { id }
    })
  }

  // Comment operations
  async addComment(data: {
    content: string
    postId: string
    authorId: string
    parentId?: string
  }) {
    return await prisma.comment.create({
      data,
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        }
      }
    })
  }

  async getComments(postId: string) {
    return await prisma.comment.findMany({
      where: {
        postId,
        parentId: null // Top-level comments only
      },
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            username: true
          }
        },
        replies: {
          include: {
            author: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                username: true
              }
            }
          },
          orderBy: { createdAt: 'asc' }
        }
      },
      orderBy: { createdAt: 'desc' }
    })
  }
}

// Example usage
async function runBlogApplication() {
  const blogService = new BlogService()

  try {
    await prisma.$connect()
    console.log('üöÄ Blog Application Started')

    // Create a user
    const user = await blogService.createUser({
      email: 'blogger@example.com',
      firstName: 'Blog',
      lastName: 'Writer',
      username: 'blogger'
    })
    console.log('‚úÖ User created:', user.username)

    // Create a post
    const post = await blogService.createPost({
      title: 'My First Blog Post',
      content: 'This is the content of my first blog post...',
      excerpt: 'Introduction to my blog',
      slug: 'my-first-blog-post',
      authorId: user.id,
      published: true
    })
    console.log('‚úÖ Post created:', post.title)

    // Get posts
    const postsResult = await blogService.getPosts({ page: 1, limit: 5 })
    console.log(`‚úÖ Retrieved ${postsResult.posts.length} posts`)

    // Add a comment
    const comment = await blogService.addComment({
      content: 'Great first post!',
      postId: post.id,
      authorId: user.id
    })
    console.log('‚úÖ Comment added')

    // Get user with all data
    const fullUser = await blogService.getUserById(user.id)
    console.log(`‚úÖ User has ${fullUser?._count.posts} posts and ${fullUser?._count.comments} comments`)

    console.log('üéâ Blog application demo completed!')

  } catch (error) {
    console.error('üí• Blog application error:', error)
  } finally {
    await prisma.$disconnect()
  }
}

runBlogApplication()
```

---

## üß† Knowledge Check

### CRUD Operations Quiz

1. **Which Prisma method creates multiple records in a single operation?**
   - [ ] A) `create()`
   - [x] B) `createMany()`
   - [ ] C) `insertMany()`
   - [ ] D) `bulkCreate()`

   **Explanation**: `createMany()` is used to create multiple records in a single database operation, which is more efficient than multiple `create()` calls.

2. **What does the `include` option do in Prisma queries?**
   - [ ] A) Filters the results
   - [x] B) Fetches related data from other models
   - [ ] C) Limits the number of returned records
   - [ ] D) Sorts the results

   **Explanation**: The `include` option fetches related data from other models based on the relationships defined in your schema.

3. **Which operation allows you to update a record or create it if it doesn't exist?**
   - [ ] A) `update()`
   - [ ] B) `updateMany()`
   - [x] C) `upsert()`
   - [ ] D) `findOrCreate()`

   **Explanation**: `upsert()` performs an "update or insert" operation - it updates a record if it exists or creates a new one if it doesn't.

### Practical Exercise: Build a Complete CRUD Application

**Challenge**: Create a fully functional blog application with all CRUD operations

**Requirements**:
1. User management (create, read, update, delete)
2. Post management with relationships
3. Comment system with threading
4. Tag system with many-to-many relationships
5. Proper error handling and validation
6. Pagination and filtering

**Validation Checklist**:
- [ ] All CRUD operations work correctly
- [ ] Relationships are properly queried
- [ ] Error handling prevents crashes
- [ ] Validation ensures data integrity
- [ ] Pagination works for large datasets
- [ ] Complex queries return expected results

---

## üí° Key Takeaways

- üéØ **CRUD Mastery**: Master Create, Read, Update, and Delete operations with type safety
- üîó **Relationship Queries**: Efficiently query related data using `include` and `select`
- üõ°Ô∏è **Error Handling**: Implement robust error handling for production applications
- ‚úÖ **Validation**: Use schema validation to ensure data integrity
- ‚ö° **Performance**: Optimize queries with proper filtering, pagination, and aggregation
- üîÑ **Transactions**: Use transactions for complex operations that need atomicity
- üìä **Advanced Queries**: Leverage raw SQL and complex filtering for special requirements

---

## üîó Navigation

**üìç Current Location**: Module 2 ‚Üí Section 2.2 ‚Üí Lesson 2.2.5

**‚¨ÖÔ∏è Previous**: [2.2.4 Generating Prisma Client with `prisma generate`](./2.2.4-generating-prisma-client-prisma-generate.md)
**‚û°Ô∏è Next**: [2.3.1 Connection String Formats & Parameters](../2.3-database-connection/2.3.1-connection-string-formats-parameters.md)

**üè† Section Home**: [2.2 First Prisma Project](./README.md)
**üìö Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**üó∫Ô∏è Quick Links**:
- [Next: Database Connection](../2.3-database-connection/2.3.1-connection-string-formats-parameters.md)
- [Jump to: Prisma CLI Basics](../2.4-prisma-cli-basics/2.4.1-essential-cli-commands-overview.md)
- [Official Docs: CRUD Operations](https://www.prisma.io/docs/concepts/components/prisma-client/crud)

---

*üéâ Congratulations! You've mastered your first Prisma CRUD operations and built a complete database foundation. You're now ready to explore advanced database connection patterns and Prisma CLI mastery!*
