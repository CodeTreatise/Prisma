# 2.4.5 Custom Scripts & Automation

## 📋 Section Overview
- **Duration**: 28 minutes
- **Prerequisites**: 
  - Completed lessons 2.4.1-2.4.4 (All CLI basics)
  - Understanding of package.json scripts
  - Basic knowledge of shell scripting or Node.js
  - Familiarity with development workflows
- **Learning Objectives**: 
  - Create custom npm scripts for Prisma workflows
  - Automate common development tasks and database operations
  - Build comprehensive CI/CD integration scripts
  - Implement environment-specific automation patterns
  - Create custom tools and utilities for team productivity
  - Design fail-safe automation with proper error handling
- **Difficulty Level**: Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Create powerful npm scripts for automated Prisma workflows
- ✅ Build custom CLI tools and utilities for database management
- ✅ Implement CI/CD automation for different environments
- ✅ Design safe automation patterns with proper error handling
- ✅ Create team-wide productivity tools and shortcuts
- ✅ Integrate Prisma commands into complex build pipelines
- ✅ Automate database seeding, testing, and maintenance tasks

---

## 📖 Content

### Understanding Prisma Automation

Automating Prisma workflows is like **orchestrating a symphony orchestra**. Just as a conductor coordinates multiple instrument sections—ensuring violins enter at precisely the right moment, brass sections provide powerful crescendos, and percussion maintains perfect rhythm while each musician follows their individual sheet music—Prisma automation coordinates multiple CLI commands, database operations, and development tools to create seamless workflows where schema validation, migration execution, client generation, and testing all work in perfect harmony, executed at exactly the right time with proper error handling and recovery mechanisms.

### 🎼 Symphony Orchestra Analogy

```
🎼 Symphony Orchestra = 🔧 Prisma Automation System

🎭 Conductor (Automation Controller)
├── Score reading → Workflow definition files
├── Tempo control → Execution timing and sequencing
├── Section coordination → Command orchestration
├── Dynamic control → Environment-based variations
└── Error correction → Failure recovery and retry logic

🎻 String Section (Core Commands)
├── First violins → prisma generate (primary operations)
├── Second violins → prisma validate (supporting validation)
├── Violas → prisma format (harmony and consistency)
├── Cellos → prisma migrate (foundational changes)
└── Double bass → prisma db (underlying database operations)

🎺 Brass Section (Power Operations)
├── Trumpets → prisma migrate deploy (production deployments)
├── French horns → prisma migrate reset (major transformations)
├── Trombones → prisma db push (direct database operations)
└── Tuba → prisma db seed (foundational data operations)

🥁 Percussion Section (Support Operations)
├── Timpani → prisma studio (major inspection points)
├── Snare drums → test execution (rhythm and validation)
├── Cymbals → notification systems (success/failure alerts)
└── Triangle → logging and monitoring (precise timing marks)
```

---

## 📦 Package.json Script Automation

### 1. Comprehensive Development Scripts

```json
{
  "name": "prisma-automation-example",
  "version": "1.0.0",
  "scripts": {
    // === Core Development Workflows ===
    "db:setup": "npm run db:migrate && npm run db:generate && npm run db:seed",
    "db:reset": "prisma migrate reset --force && npm run db:seed",
    "db:refresh": "npm run db:reset && npm run db:studio",
    
    // === Schema Management ===
    "schema:validate": "prisma validate",
    "schema:format": "prisma format",
    "schema:check": "prisma validate && prisma format --check",
    "schema:fix": "prisma format && prisma validate",
    
    // === Migration Workflows ===
    "migrate:dev": "prisma migrate dev",
    "migrate:dev:create": "prisma migrate dev --create-only",
    "migrate:reset": "prisma migrate reset",
    "migrate:status": "prisma migrate status",
    "migrate:deploy": "prisma migrate deploy",
    
    // === Client Generation ===
    "generate": "prisma generate",
    "generate:watch": "prisma generate --watch",
    
    // === Database Operations ===
    "db:push": "prisma db push",
    "db:pull": "prisma db pull",
    "db:seed": "tsx prisma/seed.ts",
    "db:studio": "prisma studio",
    
    // === Testing & Quality Assurance ===
    "test:db": "npm run db:test:setup && npm run test && npm run db:test:cleanup",
    "db:test:setup": "DATABASE_URL=$TEST_DATABASE_URL npm run db:setup",
    "db:test:cleanup": "DATABASE_URL=$TEST_DATABASE_URL prisma migrate reset --force",
    
    // === Environment-Specific Scripts ===
    "dev": "npm run db:setup && npm run dev:start",
    "dev:start": "concurrently \"npm run generate:watch\" \"npm run dev:server\"",
    "dev:server": "tsx watch src/index.ts",
    "dev:studio": "prisma studio --port 5555",
    
    // === Production Deployment ===
    "build": "npm run schema:check && npm run generate && npm run build:app",
    "deploy:production": "npm run migrate:deploy && npm run generate",
    "deploy:staging": "DATABASE_URL=$STAGING_DATABASE_URL npm run deploy:production",
    
    // === Comprehensive Workflows ===
    "fresh:start": "npm run db:reset && npm run generate && npm run dev",
    "quality:check": "npm run schema:check && npm run test:db && npm run lint",
    "backup:create": "node scripts/backup-database.js",
    "maintenance": "npm run backup:create && npm run db:refresh"
  },
  "devDependencies": {
    "concurrently": "^8.2.0",
    "tsx": "^3.12.7",
    "@types/node": "^20.0.0"
  }
}
```

### 2. Advanced Script Automation

```typescript
// scripts/prisma-automation.ts
import { execSync, spawn } from 'child_process'
import fs from 'fs'
import path from 'path'

class PrismaAutomation {
  private environment: string
  private config: AutomationConfig
  
  constructor(environment: string = process.env.NODE_ENV || 'development') {
    this.environment = environment
    this.config = this.loadConfig()
  }
  
  // Comprehensive database setup workflow
  async setupDatabase(): Promise<void> {
    console.log(`🚀 Setting up database for ${this.environment} environment...`)
    
    try {
      // Step 1: Validate schema
      await this.executeStep('Schema Validation', () => this.validateSchema())
      
      // Step 2: Apply migrations
      await this.executeStep('Migration Application', () => this.applyMigrations())
      
      // Step 3: Generate client
      await this.executeStep('Client Generation', () => this.generateClient())
      
      // Step 4: Seed database (if not production)
      if (this.environment !== 'production') {
        await this.executeStep('Database Seeding', () => this.seedDatabase())
      }
      
      // Step 5: Verify setup
      await this.executeStep('Setup Verification', () => this.verifySetup())
      
      console.log('✅ Database setup completed successfully!')
      
    } catch (error) {
      console.error(`❌ Database setup failed: ${error.message}`)
      await this.handleSetupFailure(error)
      process.exit(1)
    }
  }
  
  // Automated testing workflow
  async runTestSuite(): Promise<void> {
    console.log('🧪 Running automated test suite...')
    
    const testDatabaseUrl = this.config.testDatabaseUrl || this.generateTestDatabaseUrl()
    
    try {
      // Setup test environment
      await this.setupTestEnvironment(testDatabaseUrl)
      
      // Run tests
      await this.executeTests()
      
      // Cleanup
      await this.cleanupTestEnvironment(testDatabaseUrl)
      
      console.log('✅ All tests passed!')
      
    } catch (error) {
      console.error(`❌ Test suite failed: ${error.message}`)
      await this.cleanupTestEnvironment(testDatabaseUrl)
      process.exit(1)
    }
  }
  
  // Production deployment workflow
  async deployToProduction(): Promise<void> {
    console.log('🚀 Starting production deployment...')
    
    try {
      // Pre-deployment checks
      await this.executeStep('Pre-deployment Validation', () => this.preDeploymentChecks())
      
      // Create backup
      await this.executeStep('Database Backup', () => this.createDatabaseBackup())
      
      // Deploy migrations
      await this.executeStep('Migration Deployment', () => this.deployMigrations())
      
      // Generate production client
      await this.executeStep('Production Client Generation', () => this.generateProductionClient())
      
      // Post-deployment verification
      await this.executeStep('Post-deployment Verification', () => this.verifyDeployment())
      
      console.log('✅ Production deployment completed successfully!')
      
    } catch (error) {
      console.error(`❌ Production deployment failed: ${error.message}`)
      await this.handleDeploymentFailure(error)
      throw error
    }
  }
  
  // Automated maintenance workflow
  async performMaintenance(): Promise<void> {
    console.log('🔧 Performing automated maintenance...')
    
    try {
      // Create backup
      await this.createDatabaseBackup()
      
      // Analyze database performance
      await this.analyzeDatabasePerformance()
      
      // Optimize database
      await this.optimizeDatabase()
      
      // Update statistics
      await this.updateDatabaseStatistics()
      
      // Generate maintenance report
      await this.generateMaintenanceReport()
      
      console.log('✅ Maintenance completed successfully!')
      
    } catch (error) {
      console.error(`❌ Maintenance failed: ${error.message}`)
      throw error
    }
  }
  
  // Execute individual steps with error handling
  private async executeStep(stepName: string, stepFunction: () => Promise<void>): Promise<void> {
    const startTime = Date.now()
    
    console.log(`  📋 ${stepName}...`)
    
    try {
      await stepFunction()
      const duration = Date.now() - startTime
      console.log(`    ✅ ${stepName} completed in ${duration}ms`)
      
    } catch (error) {
      const duration = Date.now() - startTime
      console.error(`    ❌ ${stepName} failed in ${duration}ms: ${error.message}`)
      throw error
    }
  }
  
  // Core Prisma operations
  private async validateSchema(): Promise<void> {
    this.execPrismaCommand('validate')
  }
  
  private async applyMigrations(): Promise<void> {
    if (this.environment === 'production') {
      this.execPrismaCommand('migrate deploy')
    } else {
      this.execPrismaCommand('migrate dev')
    }
  }
  
  private async generateClient(): Promise<void> {
    this.execPrismaCommand('generate')
  }
  
  private async seedDatabase(): Promise<void> {
    if (this.config.seedScript) {
      this.execCommand(`tsx ${this.config.seedScript}`)
    }
  }
  
  // Utility methods
  private execPrismaCommand(command: string): void {
    const fullCommand = `prisma ${command}`
    console.log(`    $ ${fullCommand}`)
    execSync(fullCommand, { stdio: 'inherit' })
  }
  
  private execCommand(command: string): void {
    console.log(`    $ ${command}`)
    execSync(command, { stdio: 'inherit' })
  }
  
  private loadConfig(): AutomationConfig {
    const configPath = path.join(process.cwd(), 'prisma-automation.config.json')
    
    if (fs.existsSync(configPath)) {
      return JSON.parse(fs.readFileSync(configPath, 'utf-8'))
    }
    
    return this.getDefaultConfig()
  }
  
  private getDefaultConfig(): AutomationConfig {
    return {
      seedScript: 'prisma/seed.ts',
      backupDirectory: 'backups',
      testDatabaseUrl: process.env.TEST_DATABASE_URL,
      maintenanceSchedule: 'daily',
      notifications: {
        success: true,
        failure: true,
        webhook: process.env.NOTIFICATION_WEBHOOK
      }
    }
  }
}

// Configuration interfaces
interface AutomationConfig {
  seedScript?: string
  backupDirectory?: string
  testDatabaseUrl?: string
  maintenanceSchedule?: 'daily' | 'weekly' | 'monthly'
  notifications?: {
    success: boolean
    failure: boolean
    webhook?: string
  }
}

// CLI interface for the automation tool
async function main() {
  const args = process.argv.slice(2)
  const command = args[0]
  const environment = args[1] || process.env.NODE_ENV || 'development'
  
  const automation = new PrismaAutomation(environment)
  
  switch (command) {
    case 'setup':
      await automation.setupDatabase()
      break
    case 'test':
      await automation.runTestSuite()
      break
    case 'deploy':
      await automation.deployToProduction()
      break
    case 'maintenance':
      await automation.performMaintenance()
      break
    default:
      console.log(`
🔧 Prisma Automation Tool

Usage: tsx scripts/prisma-automation.ts <command> [environment]

Commands:
  setup       Setup database with migrations, generation, and seeding
  test        Run complete test suite with test database
  deploy      Deploy to production with safety checks
  maintenance Perform automated maintenance tasks

Environments:
  development (default)
  staging
  production

Examples:
  tsx scripts/prisma-automation.ts setup development
  tsx scripts/prisma-automation.ts deploy production
  tsx scripts/prisma-automation.ts test
      `)
  }
}

if (require.main === module) {
  main().catch(console.error)
}

export { PrismaAutomation }
```

---

## 🔄 CI/CD Integration Automation

### 1. GitHub Actions Workflow

```yaml
# .github/workflows/prisma-ci.yml
name: Prisma CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  TEST_DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

jobs:
  validate:
    runs-on: ubuntu-latest
    name: Validate Schema & Format
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Validate Prisma schema
      run: npm run schema:validate
    
    - name: Check schema formatting
      run: npm run schema:format -- --check
    
    - name: Generate Prisma client
      run: npm run generate

  test:
    runs-on: ubuntu-latest
    name: Run Tests
    needs: validate
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run automated test suite
      run: npm run test:db
      env:
        TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

  deploy-staging:
    runs-on: ubuntu-latest
    name: Deploy to Staging
    needs: [validate, test]
    if: github.ref == 'refs/heads/develop'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Deploy to staging
      run: npm run deploy:staging
      env:
        STAGING_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}

  deploy-production:
    runs-on: ubuntu-latest
    name: Deploy to Production
    needs: [validate, test]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Create database backup
      run: npm run backup:create
      env:
        DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
    
    - name: Deploy to production
      run: npm run deploy:production
      env:
        DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
    
    - name: Notify deployment success
      if: success()
      run: |
        curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
        -H 'Content-type: application/json' \
        --data '{"text":"🚀 Production deployment successful!"}'
    
    - name: Notify deployment failure
      if: failure()
      run: |
        curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
        -H 'Content-type: application/json' \
        --data '{"text":"❌ Production deployment failed!"}'
```

### 2. Docker Automation

```dockerfile
# Dockerfile.automation
FROM node:18-alpine

WORKDIR /app

# Install system dependencies
RUN apk add --no-cache postgresql-client

# Copy package files
COPY package*.json ./
COPY prisma/ ./prisma/

# Install dependencies
RUN npm ci

# Copy automation scripts
COPY scripts/ ./scripts/
COPY prisma-automation.config.json ./

# Copy application code
COPY src/ ./src/

# Generate Prisma client
RUN npm run generate

# Create automation entrypoint
COPY docker-entrypoint.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/docker-entrypoint.sh

ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["setup"]
```

```bash
#!/bin/bash
# docker-entrypoint.sh

set -e

# Wait for database to be ready
echo "🔍 Waiting for database connection..."
while ! pg_isready -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER"; do
  echo "  Waiting for database..."
  sleep 2
done

echo "✅ Database connection established"

# Execute the automation command
echo "🚀 Executing automation command: $1"
tsx scripts/prisma-automation.ts "$@"
```

---

## 🧠 Knowledge Check

### Automation Mastery Quiz

1. **Which npm script pattern is best for environment-specific commands?**
   - [ ] A) Using different package.json files
   - [x] B) Using environment variables in script commands
   - [ ] C) Creating separate npm projects
   - [ ] D) Using only CLI flags

   **Explanation**: Environment variables allow the same script to work across different environments by changing configuration rather than code.

2. **What's the safest way to automate production deployments?**
   - [ ] A) Direct database manipulation
   - [x] B) Backup creation before migration deployment
   - [ ] C) Skipping validation steps for speed
   - [ ] D) Running migrations manually

   **Explanation**: Always create backups before production deployments to enable quick recovery if issues arise.

3. **Which approach provides the most comprehensive automation?**
   - [ ] A) Only npm scripts
   - [ ] B) Only CI/CD pipelines
   - [x] C) Combined npm scripts, custom tools, and CI/CD integration
   - [ ] D) Manual command execution

   **Explanation**: A comprehensive approach combines local development automation (npm scripts), custom tooling, and CI/CD integration for complete workflow coverage.

### Practical Exercise: Complete Automation Setup

**Challenge**: Build a comprehensive automation system for your Prisma project

**Requirements**:
1. Create full package.json script suite
2. Build custom automation tool with TypeScript
3. Implement CI/CD pipeline with GitHub Actions
4. Add Docker automation support
5. Create maintenance and backup automation
6. Include comprehensive error handling and notifications

**Validation Checklist**:
- [ ] All development workflows automated via npm scripts
- [ ] Custom automation tool handles complex scenarios
- [ ] CI/CD pipeline validates and deploys automatically
- [ ] Docker automation works in containerized environments
- [ ] Backup and maintenance procedures automated
- [ ] Error handling and notifications functional

---

## 💡 Key Takeaways

- 🎼 **Symphony Orchestra**: Automation coordinates multiple tools into harmonious workflows
- 📦 **Script Foundation**: npm scripts provide the base layer for automation
- 🔧 **Custom Tools**: TypeScript automation tools handle complex scenarios
- 🚀 **CI/CD Integration**: Automated pipelines ensure consistent deployment
- 🐳 **Container Ready**: Docker automation enables portable deployments
- 🛡️ **Safety First**: Always include backup and recovery mechanisms
- 📊 **Monitoring**: Track automation performance and success rates

---

## 🔗 Navigation

**📍 Current Location**: Module 2 → Section 2.4 → Lesson 2.4.5

**⬅️ Previous**: [2.4.4 Format & Validation](./2.4.4-format-validation.md)
**➡️ Next**: [Module 3: Prisma Schema](../../03-prisma-schema/03-prisma-schema.md)

**🏠 Section Home**: [2.4 Prisma CLI Basics](./README.md)
**📚 Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**🗺️ Quick Links**:
- [Previous: Format & Validation](./2.4.4-format-validation.md)
- [Next: Module 3](../../03-prisma-schema/03-prisma-schema.md)
- [Official Docs: CLI Reference](https://www.prisma.io/docs/reference/api-reference/command-reference)

---

*🎼 Outstanding! You've mastered the symphony of Prisma automation. You're now ready to dive deep into advanced schema design in Module 3!*
