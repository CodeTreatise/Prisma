# 2.3.5 Environment-Specific Connection Management

## 📋 Section Overview
- **Duration**: 35 minutes
- **Prerequisites**: 
  - Completed lessons 2.3.1-2.3.4 (Database connection fundamentals)
  - Understanding of software development environments
  - Knowledge of deployment pipelines and DevOps practices
- **Learning Objectives**: 
  - Master environment-specific database connection strategies
  - Implement secure credential management across environments
  - Configure connection patterns for different deployment stages
  - Set up environment-aware monitoring and alerting
  - Design connection management for CI/CD pipelines
  - Implement disaster recovery and failover strategies
- **Difficulty Level**: Intermediate to Advanced

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Configure optimal connection patterns for each environment type
- ✅ Implement secure, scalable credential management systems
- ✅ Set up environment-aware connection pooling and monitoring
- ✅ Design resilient connection strategies for production workloads
- ✅ Create automated connection management for CI/CD pipelines
- ✅ Implement disaster recovery and high availability patterns
- ✅ Master environment promotion and connection migration strategies

---

## 📖 Content

### Understanding Environment-Specific Connection Management

Managing database connections across different environments is like **orchestrating a sophisticated multi-theater theatrical production company**. Just as a production company must adapt their shows for different venues—from intimate studio theaters requiring minimal technical setup to grand opera houses demanding full orchestras and elaborate staging, from touring productions needing portable equipment to flagship venues with permanent installations—database connection management requires tailored approaches for each environment, balancing resource requirements, security protocols, performance expectations, and operational complexity while maintaining consistency and reliability across all deployment stages.

### 🎭 Multi-Theater Production Analogy

```
🎭 Theatrical Production Company = 🌍 Environment-Specific Database Management

🏛️ Theater Types (Environment Categories)
├── Studio theater → Development environment
├── Community theater → Testing/staging environment
├── Regional theater → Pre-production environment
├── Broadway theater → Production environment
├── Touring production → CI/CD pipeline
└── Festival venue → Temporary/review environments

🎪 Production Requirements (Connection Specifications)
├── Cast size → Connection pool sizing
├── Technical crew → Monitoring and support tools
├── Equipment needs → Infrastructure requirements
├── Security protocols → Access control and authentication
├── Audience capacity → Expected load and throughput
└── Budget constraints → Resource allocation and costs

🎬 Show Adaptation (Environment Configuration)
├── Script modifications → Connection string adjustments
├── Staging adjustments → Performance optimizations
├── Technical setup → Infrastructure provisioning
├── Rehearsal schedules → Testing and validation procedures
├── Performance monitoring → Real-time connection monitoring
└── Emergency protocols → Disaster recovery procedures

🔄 Tour Management (Environment Promotion)
├── Venue preparation → Environment setup and validation
├── Equipment transport → Configuration migration
├── Setup procedures → Deployment automation
├── Performance validation → Connection testing
├── Audience experience → User acceptance testing
└── Strike and move → Environment cleanup and transition
```

---

## 🌍 Environment Classification and Strategies

### 1. Comprehensive Environment Types

```typescript
// Environment classification and connection strategies
enum EnvironmentType {
  LOCAL_DEVELOPMENT = "local_development",
  SHARED_DEVELOPMENT = "shared_development", 
  FEATURE_BRANCH = "feature_branch",
  INTEGRATION_TESTING = "integration_testing",
  SYSTEM_TESTING = "system_testing",
  USER_ACCEPTANCE = "user_acceptance",
  STAGING = "staging",
  PRE_PRODUCTION = "pre_production",
  PRODUCTION = "production",
  DISASTER_RECOVERY = "disaster_recovery",
  REVIEW_APPS = "review_apps",
  LOAD_TESTING = "load_testing"
}

// Environment-specific connection configuration
class EnvironmentConnectionManager {
  private environmentConfigs: Map<EnvironmentType, EnvironmentConfig> = new Map()
  
  constructor() {
    this.initializeEnvironmentConfigs()
  }
  
  // Initialize all environment configurations
  private initializeEnvironmentConfigs() {
    // Local Development Environment
    this.environmentConfigs.set(EnvironmentType.LOCAL_DEVELOPMENT, {
      purpose: "Individual developer workstation",
      characteristics: {
        isolation: "high",
        dataVolume: "minimal", 
        security: "basic",
        performance: "adequate",
        availability: "low",
        cost: "minimal"
      },
      connectionStrategy: {
        provider: "sqlite", // or docker postgres
        poolSize: 5,
        timeout: 10000,
        ssl: false,
        monitoring: "basic"
      },
      connectionString: "file:./dev.db?cache=shared&_pragma=journal_mode(WAL)",
      infrastructure: {
        hosting: "local",
        backup: "none",
        scaling: "none",
        monitoring: "minimal"
      }
    })
    
    // Shared Development Environment
    this.environmentConfigs.set(EnvironmentType.SHARED_DEVELOPMENT, {
      purpose: "Team collaboration and integration",
      characteristics: {
        isolation: "medium",
        dataVolume: "small",
        security: "enhanced",
        performance: "good",
        availability: "medium",
        cost: "low"
      },
      connectionStrategy: {
        provider: "postgresql",
        poolSize: 15,
        timeout: 15000,
        ssl: true,
        monitoring: "enhanced"
      },
      connectionString: `postgresql://\${DEV_DB_USER}:\${DEV_DB_PASSWORD}@dev-db.company.com:5432/myapp_dev?
        sslmode=require&
        connection_limit=15&
        pool_timeout=15&
        application_name=SharedDev`,
      infrastructure: {
        hosting: "cloud_shared",
        backup: "daily",
        scaling: "manual",
        monitoring: "standard"
      }
    })
    
    // Production Environment
    this.environmentConfigs.set(EnvironmentType.PRODUCTION, {
      purpose: "Live user-facing application",
      characteristics: {
        isolation: "maximum",
        dataVolume: "large",
        security: "maximum",
        performance: "critical",
        availability: "maximum",
        cost: "optimized"
      },
      connectionStrategy: {
        provider: "postgresql",
        poolSize: 50,
        timeout: 20000,
        ssl: true,
        monitoring: "comprehensive"
      },
      connectionString: `postgresql://\${PROD_DB_USER}:\${PROD_DB_PASSWORD}@prod-primary.company.com:5432/myapp_prod?
        sslmode=verify-full&
        sslrootcert=/certs/ca.pem&
        sslcert=/certs/client.pem&
        sslkey=/certs/client-key.pem&
        connection_limit=50&
        pool_timeout=20&
        statement_timeout=45000&
        application_name=ProdApp`,
      infrastructure: {
        hosting: "cloud_dedicated",
        backup: "continuous",
        scaling: "automatic",
        monitoring: "real_time"
      }
    })
    
    // Add other environment configurations...
    this.initializeRemainingEnvironments()
  }
  
  // Get environment-specific configuration
  getEnvironmentConfig(envType: EnvironmentType): EnvironmentConfig {
    const config = this.environmentConfigs.get(envType)
    if (!config) {
      throw new Error(`Configuration not found for environment: ${envType}`)
    }
    return config
  }
  
  // Generate connection string for environment
  generateConnectionString(envType: EnvironmentType, overrides?: ConnectionOverrides): string {
    const config = this.getEnvironmentConfig(envType)
    let connectionString = config.connectionString
    
    // Apply environment variable substitution
    connectionString = this.substituteEnvironmentVariables(connectionString, envType)
    
    // Apply any overrides
    if (overrides) {
      connectionString = this.applyConnectionOverrides(connectionString, overrides)
    }
    
    // Validate connection string
    this.validateConnectionString(connectionString, envType)
    
    return connectionString
  }
  
  // Environment-specific validation
  private validateConnectionString(connectionString: string, envType: EnvironmentType) {
    const config = this.getEnvironmentConfig(envType)
    
    // Security validation for production environments
    if (this.isProductionLike(envType)) {
      if (!connectionString.includes('sslmode=verify-full')) {
        throw new Error(`Production environment ${envType} requires verify-full SSL mode`)
      }
      
      if (connectionString.includes('password')) {
        throw new Error(`Production environment ${envType} should not have hardcoded passwords`)
      }
    }
    
    // Pool size validation
    const poolMatch = connectionString.match(/connection_limit=(\d+)/)
    if (poolMatch) {
      const poolSize = parseInt(poolMatch[1])
      if (poolSize > config.connectionStrategy.poolSize * 1.5) {
        console.warn(`⚠️ Pool size ${poolSize} exceeds recommended size for ${envType}`)
      }
    }
  }
}

// Environment configuration interfaces
interface EnvironmentConfig {
  purpose: string
  characteristics: EnvironmentCharacteristics
  connectionStrategy: ConnectionStrategy
  connectionString: string
  infrastructure: InfrastructureConfig
}

interface EnvironmentCharacteristics {
  isolation: "low" | "medium" | "high" | "maximum"
  dataVolume: "minimal" | "small" | "medium" | "large" | "massive"
  security: "basic" | "enhanced" | "high" | "maximum"
  performance: "adequate" | "good" | "high" | "critical"
  availability: "low" | "medium" | "high" | "maximum"
  cost: "minimal" | "low" | "medium" | "high" | "optimized"
}

interface ConnectionStrategy {
  provider: string
  poolSize: number
  timeout: number
  ssl: boolean
  monitoring: "minimal" | "basic" | "standard" | "enhanced" | "comprehensive"
}
```

### 2. Credential Management System

```typescript
// Secure credential management across environments
class CredentialManager {
  private credentialStore: Map<string, CredentialConfig> = new Map()
  private encryptionKey: string
  
  constructor(encryptionKey: string) {
    this.encryptionKey = encryptionKey
    this.initializeCredentialSources()
  }
  
  // Initialize credential sources by environment
  private initializeCredentialSources() {
    // Development credentials - local files
    this.credentialStore.set("development", {
      source: CredentialSource.LOCAL_FILE,
      location: ".env.local",
      encryption: false,
      rotation: false,
      validation: "basic"
    })
    
    // Staging credentials - cloud secrets manager
    this.credentialStore.set("staging", {
      source: CredentialSource.CLOUD_SECRETS,
      location: "aws-secrets-manager://staging/database",
      encryption: true,
      rotation: true,
      validation: "enhanced"
    })
    
    // Production credentials - enterprise vault
    this.credentialStore.set("production", {
      source: CredentialSource.ENTERPRISE_VAULT,
      location: "vault://secret/database/production",
      encryption: true,
      rotation: true,
      validation: "maximum",
      auditLogging: true,
      accessControl: "role-based"
    })
  }
  
  // Retrieve credentials for environment
  async getCredentials(environment: string, context: CredentialContext): Promise<DatabaseCredentials> {
    const config = this.credentialStore.get(environment)
    if (!config) {
      throw new Error(`No credential configuration for environment: ${environment}`)
    }
    
    // Validate access permissions
    await this.validateAccess(environment, context)
    
    // Retrieve credentials based on source
    let credentials: DatabaseCredentials
    
    switch (config.source) {
      case CredentialSource.LOCAL_FILE:
        credentials = await this.getLocalFileCredentials(config.location)
        break
        
      case CredentialSource.ENVIRONMENT_VARIABLES:
        credentials = await this.getEnvironmentVariables()
        break
        
      case CredentialSource.CLOUD_SECRETS:
        credentials = await this.getCloudSecrets(config.location)
        break
        
      case CredentialSource.ENTERPRISE_VAULT:
        credentials = await this.getVaultCredentials(config.location, context)
        break
        
      default:
        throw new Error(`Unsupported credential source: ${config.source}`)
    }
    
    // Decrypt if necessary
    if (config.encryption) {
      credentials = await this.decryptCredentials(credentials)
    }
    
    // Validate credentials
    await this.validateCredentials(credentials, config.validation)
    
    // Log access if required
    if (config.auditLogging) {
      await this.logCredentialAccess(environment, context)
    }
    
    return credentials
  }
  
  // Automated credential rotation
  async rotateCredentials(environment: string): Promise<CredentialRotationResult> {
    const config = this.credentialStore.get(environment)
    if (!config || !config.rotation) {
      throw new Error(`Credential rotation not enabled for environment: ${environment}`)
    }
    
    console.log(`🔄 Starting credential rotation for ${environment}`)
    
    try {
      // Generate new credentials
      const newCredentials = await this.generateNewCredentials(environment)
      
      // Update database user permissions
      await this.updateDatabaseUser(environment, newCredentials)
      
      // Test new credentials
      await this.testCredentials(environment, newCredentials)
      
      // Update credential store
      await this.updateCredentialStore(environment, newCredentials)
      
      // Notify applications of credential change
      await this.notifyApplications(environment, newCredentials)
      
      // Clean up old credentials after grace period
      setTimeout(async () => {
        await this.cleanupOldCredentials(environment)
      }, this.getGracePeriod(environment))
      
      console.log(`✅ Credential rotation completed for ${environment}`)
      
      return {
        success: true,
        rotationId: this.generateRotationId(),
        timestamp: new Date(),
        environment,
        gracePeriodEndTime: new Date(Date.now() + this.getGracePeriod(environment))
      }
      
    } catch (error) {
      console.error(`❌ Credential rotation failed for ${environment}:`, error)
      
      // Rollback if possible
      await this.rollbackRotation(environment)
      
      throw error
    }
  }
  
  // Environment-specific credential validation
  private async validateCredentials(
    credentials: DatabaseCredentials, 
    validationLevel: string
  ): Promise<void> {
    // Basic validation
    if (!credentials.username || !credentials.password) {
      throw new Error("Invalid credentials: missing username or password")
    }
    
    switch (validationLevel) {
      case "enhanced":
        // Check password complexity
        await this.validatePasswordComplexity(credentials.password)
        
        // Test database connectivity
        await this.testDatabaseConnection(credentials)
        break
        
      case "maximum":
        // Full security validation
        await this.validatePasswordComplexity(credentials.password)
        await this.testDatabaseConnection(credentials)
        await this.validateUserPermissions(credentials)
        await this.checkSecurityCompliance(credentials)
        break
    }
  }
}

// Credential management types
enum CredentialSource {
  LOCAL_FILE = "local_file",
  ENVIRONMENT_VARIABLES = "environment_variables",
  CLOUD_SECRETS = "cloud_secrets",
  ENTERPRISE_VAULT = "enterprise_vault"
}

interface CredentialConfig {
  source: CredentialSource
  location: string
  encryption: boolean
  rotation: boolean
  validation: string
  auditLogging?: boolean
  accessControl?: string
}

interface DatabaseCredentials {
  username: string
  password: string
  host: string
  port: number
  database: string
  additionalParams?: Record<string, string>
}
```

---

## 🔄 Environment Promotion and Migration

### 1. Environment Promotion Pipeline

```typescript
// Automated environment promotion system
class EnvironmentPromotionManager {
  private promotionPipeline: PromotionPipeline
  
  constructor(pipeline: PromotionPipeline) {
    this.promotionPipeline = pipeline
  }
  
  // Execute environment promotion
  async promoteToEnvironment(
    sourceEnv: EnvironmentType,
    targetEnv: EnvironmentType,
    promotionConfig: PromotionConfig
  ): Promise<PromotionResult> {
    const promotionId = this.generatePromotionId()
    
    console.log(`🚀 Starting promotion ${promotionId}: ${sourceEnv} → ${targetEnv}`)
    
    try {
      // Pre-promotion validation
      await this.validatePromotionReadiness(sourceEnv, targetEnv, promotionConfig)
      
      // Execute promotion steps
      const result = await this.executePromotionSteps(
        sourceEnv, 
        targetEnv, 
        promotionConfig, 
        promotionId
      )
      
      // Post-promotion validation
      await this.validatePromotionSuccess(targetEnv, result)
      
      console.log(`✅ Promotion ${promotionId} completed successfully`)
      
      return result
      
    } catch (error) {
      console.error(`❌ Promotion ${promotionId} failed:`, error)
      
      // Attempt rollback if configured
      if (promotionConfig.rollbackOnFailure) {
        await this.rollbackPromotion(promotionId)
      }
      
      throw error
    }
  }
  
  // Execute individual promotion steps
  private async executePromotionSteps(
    sourceEnv: EnvironmentType,
    targetEnv: EnvironmentType,
    config: PromotionConfig,
    promotionId: string
  ): Promise<PromotionResult> {
    const steps: PromotionStep[] = []
    
    // Step 1: Environment preparation
    steps.push(await this.prepareTargetEnvironment(targetEnv, config))
    
    // Step 2: Database migration
    if (config.includeDatabaseMigration) {
      steps.push(await this.migrateDatabase(sourceEnv, targetEnv, config))
    }
    
    // Step 3: Configuration migration
    steps.push(await this.migrateConfiguration(sourceEnv, targetEnv, config))
    
    // Step 4: Connection validation
    steps.push(await this.validateConnections(targetEnv, config))
    
    // Step 5: Performance testing
    if (config.performanceValidation) {
      steps.push(await this.runPerformanceTests(targetEnv, config))
    }
    
    // Step 6: Security validation
    if (config.securityValidation) {
      steps.push(await this.validateSecurity(targetEnv, config))
    }
    
    // Step 7: Smoke tests
    steps.push(await this.runSmokeTests(targetEnv, config))
    
    return {
      promotionId,
      sourceEnvironment: sourceEnv,
      targetEnvironment: targetEnv,
      startTime: new Date(),
      endTime: new Date(),
      steps,
      success: true,
      metrics: await this.collectPromotionMetrics(steps)
    }
  }
  
  // Database migration during promotion
  private async migrateDatabase(
    sourceEnv: EnvironmentType,
    targetEnv: EnvironmentType,
    config: PromotionConfig
  ): Promise<PromotionStep> {
    const stepStart = Date.now()
    
    try {
      // Get source and target configurations
      const sourceConfig = this.getEnvironmentConfig(sourceEnv)
      const targetConfig = this.getEnvironmentConfig(targetEnv)
      
      // Backup target database if configured
      if (config.backupBeforeMigration) {
        await this.backupDatabase(targetEnv)
      }
      
      // Run schema migrations
      await this.runSchemaMigrations(targetEnv, config.migrationStrategy)
      
      // Migrate data if configured
      if (config.migrateData) {
        await this.migrateData(sourceEnv, targetEnv, config.dataMigrationStrategy)
      }
      
      // Validate migration success
      await this.validateMigration(targetEnv)
      
      return {
        name: "database_migration",
        status: StepStatus.SUCCESS,
        startTime: new Date(stepStart),
        endTime: new Date(),
        duration: Date.now() - stepStart,
        details: {
          migrationsApplied: await this.getMigrationCount(),
          dataRecordsMigrated: config.migrateData ? await this.getDataCount() : 0
        }
      }
      
    } catch (error) {
      return {
        name: "database_migration",
        status: StepStatus.FAILED,
        startTime: new Date(stepStart),
        endTime: new Date(),
        duration: Date.now() - stepStart,
        error: error.message
      }
    }
  }
  
  // Connection validation during promotion
  private async validateConnections(
    targetEnv: EnvironmentType,
    config: PromotionConfig
  ): Promise<PromotionStep> {
    const stepStart = Date.now()
    
    try {
      const envConfig = this.getEnvironmentConfig(targetEnv)
      
      // Test basic connectivity
      await this.testBasicConnectivity(targetEnv)
      
      // Test SSL configuration
      if (envConfig.connectionStrategy.ssl) {
        await this.testSSLConnectivity(targetEnv)
      }
      
      // Test connection pooling
      await this.testConnectionPooling(targetEnv)
      
      // Test performance
      const performanceMetrics = await this.measureConnectionPerformance(targetEnv)
      
      // Validate against thresholds
      await this.validatePerformanceThresholds(performanceMetrics, config.performanceThresholds)
      
      return {
        name: "connection_validation",
        status: StepStatus.SUCCESS,
        startTime: new Date(stepStart),
        endTime: new Date(),
        duration: Date.now() - stepStart,
        details: {
          connectivityTests: "passed",
          sslTests: envConfig.connectionStrategy.ssl ? "passed" : "skipped",
          poolingTests: "passed",
          performanceMetrics
        }
      }
      
    } catch (error) {
      return {
        name: "connection_validation",
        status: StepStatus.FAILED,
        startTime: new Date(stepStart),
        endTime: new Date(),
        duration: Date.now() - stepStart,
        error: error.message
      }
    }
  }
}

// Promotion pipeline types
interface PromotionConfig {
  includeDatabaseMigration: boolean
  migrateData: boolean
  migrationStrategy: MigrationStrategy
  dataMigrationStrategy?: DataMigrationStrategy
  backupBeforeMigration: boolean
  performanceValidation: boolean
  securityValidation: boolean
  rollbackOnFailure: boolean
  performanceThresholds: PerformanceThresholds
}

interface PromotionResult {
  promotionId: string
  sourceEnvironment: EnvironmentType
  targetEnvironment: EnvironmentType
  startTime: Date
  endTime: Date
  steps: PromotionStep[]
  success: boolean
  metrics: PromotionMetrics
}

enum StepStatus {
  PENDING = "pending",
  RUNNING = "running",
  SUCCESS = "success",
  FAILED = "failed",
  SKIPPED = "skipped"
}
```

### 2. High Availability and Disaster Recovery

```typescript
// High availability and disaster recovery management
class HADRManager {
  private haConfig: HAConfiguration
  private drConfig: DRConfiguration
  
  constructor(haConfig: HAConfiguration, drConfig: DRConfiguration) {
    this.haConfig = haConfig
    this.drConfig = drConfig
    this.startHealthMonitoring()
  }
  
  // Configure high availability setup
  async configureHighAvailability(environment: EnvironmentType): Promise<HASetup> {
    console.log(`🏗️ Configuring high availability for ${environment}`)
    
    const envConfig = this.getEnvironmentConfig(environment)
    
    // Set up primary-replica configuration
    const primaryConfig = this.createPrimaryConfig(envConfig)
    const replicaConfigs = this.createReplicaConfigs(envConfig, this.haConfig.replicaCount)
    
    // Configure connection load balancing
    const loadBalancerConfig = this.createLoadBalancerConfig(primaryConfig, replicaConfigs)
    
    // Set up health monitoring
    const healthMonitorConfig = this.createHealthMonitorConfig(environment)
    
    // Configure automatic failover
    const failoverConfig = this.createFailoverConfig(environment)
    
    return {
      environment,
      primary: primaryConfig,
      replicas: replicaConfigs,
      loadBalancer: loadBalancerConfig,
      healthMonitor: healthMonitorConfig,
      failover: failoverConfig,
      connectionStrings: this.generateHAConnectionStrings(loadBalancerConfig)
    }
  }
  
  // Configure disaster recovery
  async configureDisasterRecovery(
    primaryEnvironment: EnvironmentType,
    drEnvironment: EnvironmentType
  ): Promise<DRSetup> {
    console.log(`🛡️ Configuring disaster recovery: ${primaryEnvironment} → ${drEnvironment}`)
    
    // Set up cross-region replication
    const replicationConfig = await this.setupCrossRegionReplication(
      primaryEnvironment,
      drEnvironment
    )
    
    // Configure backup strategies
    const backupConfig = await this.configureBackupStrategy(primaryEnvironment, drEnvironment)
    
    // Set up monitoring and alerting
    const monitoringConfig = await this.setupDRMonitoring(primaryEnvironment, drEnvironment)
    
    // Configure failover procedures
    const failoverProcedures = await this.configureDRFailover(
      primaryEnvironment,
      drEnvironment
    )
    
    // Set up recovery testing
    const recoveryTestingConfig = await this.configureRecoveryTesting(
      primaryEnvironment,
      drEnvironment
    )
    
    return {
      primaryEnvironment,
      drEnvironment,
      replication: replicationConfig,
      backup: backupConfig,
      monitoring: monitoringConfig,
      failover: failoverProcedures,
      testing: recoveryTestingConfig,
      rto: this.drConfig.recoveryTimeObjective,
      rpo: this.drConfig.recoveryPointObjective
    }
  }
  
  // Automated failover execution
  async executeFailover(
    failoverType: FailoverType,
    sourceEnvironment: EnvironmentType,
    targetEnvironment: EnvironmentType
  ): Promise<FailoverResult> {
    const failoverId = this.generateFailoverId()
    
    console.log(`🚨 Executing ${failoverType} failover ${failoverId}: ${sourceEnvironment} → ${targetEnvironment}`)
    
    const startTime = Date.now()
    
    try {
      // Pre-failover validation
      await this.validateFailoverReadiness(targetEnvironment)
      
      // Execute failover steps based on type
      const steps = await this.executeFailoverSteps(failoverType, sourceEnvironment, targetEnvironment)
      
      // Update connection routing
      await this.updateConnectionRouting(targetEnvironment)
      
      // Validate failover success
      await this.validateFailoverSuccess(targetEnvironment)
      
      // Update monitoring and alerting
      await this.updateMonitoringForFailover(targetEnvironment)
      
      const duration = Date.now() - startTime
      
      console.log(`✅ Failover ${failoverId} completed in ${duration}ms`)
      
      return {
        failoverId,
        type: failoverType,
        sourceEnvironment,
        targetEnvironment,
        startTime: new Date(startTime),
        endTime: new Date(),
        duration,
        success: true,
        steps
      }
      
    } catch (error) {
      console.error(`❌ Failover ${failoverId} failed:`, error)
      
      // Attempt automatic recovery if possible
      if (this.haConfig.autoRecovery) {
        await this.attemptAutoRecovery(sourceEnvironment, targetEnvironment)
      }
      
      throw error
    }
  }
  
  // Health monitoring for HA/DR
  private startHealthMonitoring() {
    setInterval(async () => {
      for (const environment of this.getMonitoredEnvironments()) {
        try {
          const health = await this.checkEnvironmentHealth(environment)
          
          if (health.status === HealthStatus.CRITICAL) {
            await this.handleCriticalHealthFailure(environment, health)
          } else if (health.status === HealthStatus.WARNING) {
            await this.handleHealthWarning(environment, health)
          }
          
        } catch (error) {
          console.error(`Health monitoring error for ${environment}:`, error)
        }
      }
    }, this.haConfig.healthCheckIntervalMs)
  }
  
  private async checkEnvironmentHealth(environment: EnvironmentType): Promise<EnvironmentHealth> {
    const health: EnvironmentHealth = {
      environment,
      timestamp: new Date(),
      status: HealthStatus.UNKNOWN,
      checks: {}
    }
    
    // Database connectivity check
    health.checks.connectivity = await this.checkDatabaseConnectivity(environment)
    
    // Performance check
    health.checks.performance = await this.checkDatabasePerformance(environment)
    
    // Resource utilization check
    health.checks.resources = await this.checkResourceUtilization(environment)
    
    // Replication lag check (if applicable)
    if (this.isReplicaEnvironment(environment)) {
      health.checks.replicationLag = await this.checkReplicationLag(environment)
    }
    
    // Determine overall health status
    health.status = this.calculateOverallHealthStatus(health.checks)
    
    return health
  }
}

// HA/DR configuration types
interface HAConfiguration {
  replicaCount: number
  healthCheckIntervalMs: number
  failoverThresholdMs: number
  autoRecovery: boolean
  loadBalancingStrategy: LoadBalancingStrategy
}

interface DRConfiguration {
  recoveryTimeObjective: number // RTO in seconds
  recoveryPointObjective: number // RPO in seconds
  backupFrequency: BackupFrequency
  crossRegionReplication: boolean
  testingSchedule: TestingSchedule
}

enum FailoverType {
  AUTOMATIC = "automatic",
  MANUAL = "manual",
  PLANNED = "planned",
  EMERGENCY = "emergency"
}

enum HealthStatus {
  HEALTHY = "healthy",
  WARNING = "warning", 
  CRITICAL = "critical",
  UNKNOWN = "unknown"
}
```

---

## 📊 Environment Monitoring and Observability

### 1. Comprehensive Environment Monitoring

```typescript
// Environment-aware monitoring and observability
class EnvironmentMonitoringSystem {
  private monitoringConfigs: Map<EnvironmentType, MonitoringConfig> = new Map()
  private alertManagers: Map<EnvironmentType, AlertManager> = new Map()
  
  constructor() {
    this.initializeMonitoringConfigs()
    this.setupAlertManagers()
  }
  
  // Initialize monitoring configurations per environment
  private initializeMonitoringConfigs() {
    // Development monitoring - basic metrics
    this.monitoringConfigs.set(EnvironmentType.LOCAL_DEVELOPMENT, {
      metricsCollection: {
        connectionMetrics: true,
        performanceMetrics: false,
        securityMetrics: false,
        businessMetrics: false
      },
      alerting: {
        connectionFailures: false,
        performanceThresholds: false,
        securityEvents: false,
        resourceLimits: false
      },
      retention: {
        metrics: "1 day",
        logs: "1 day",
        traces: "1 hour"
      }
    })
    
    // Production monitoring - comprehensive metrics
    this.monitoringConfigs.set(EnvironmentType.PRODUCTION, {
      metricsCollection: {
        connectionMetrics: true,
        performanceMetrics: true,
        securityMetrics: true,
        businessMetrics: true,
        customMetrics: true
      },
      alerting: {
        connectionFailures: true,
        performanceThresholds: true,
        securityEvents: true,
        resourceLimits: true,
        businessImpact: true
      },
      retention: {
        metrics: "90 days",
        logs: "30 days",
        traces: "7 days"
      },
      dashboards: {
        realTime: true,
        historical: true,
        predictive: true
      }
    })
  }
  
  // Collect environment-specific metrics
  async collectEnvironmentMetrics(environment: EnvironmentType): Promise<EnvironmentMetrics> {
    const config = this.monitoringConfigs.get(environment)
    if (!config) throw new Error(`No monitoring config for ${environment}`)
    
    const metrics: EnvironmentMetrics = {
      environment,
      timestamp: new Date(),
      connection: {},
      performance: {},
      security: {},
      business: {}
    }
    
    // Collect connection metrics
    if (config.metricsCollection.connectionMetrics) {
      metrics.connection = await this.collectConnectionMetrics(environment)
    }
    
    // Collect performance metrics
    if (config.metricsCollection.performanceMetrics) {
      metrics.performance = await this.collectPerformanceMetrics(environment)
    }
    
    // Collect security metrics
    if (config.metricsCollection.securityMetrics) {
      metrics.security = await this.collectSecurityMetrics(environment)
    }
    
    // Collect business metrics
    if (config.metricsCollection.businessMetrics) {
      metrics.business = await this.collectBusinessMetrics(environment)
    }
    
    return metrics
  }
  
  // Environment-specific alerting
  async checkAlerts(environment: EnvironmentType, metrics: EnvironmentMetrics): Promise<Alert[]> {
    const config = this.monitoringConfigs.get(environment)
    const alertManager = this.alertManagers.get(environment)
    
    if (!config || !alertManager) return []
    
    const alerts: Alert[] = []
    
    // Connection failure alerts
    if (config.alerting.connectionFailures && metrics.connection.errorRate > 0.01) {
      alerts.push({
        type: AlertType.CONNECTION_FAILURE,
        severity: this.calculateAlertSeverity(environment, metrics.connection.errorRate),
        message: `High connection error rate: ${(metrics.connection.errorRate * 100).toFixed(2)}%`,
        environment,
        timestamp: new Date(),
        metrics: { errorRate: metrics.connection.errorRate }
      })
    }
    
    // Performance threshold alerts
    if (config.alerting.performanceThresholds) {
      const responseTime = metrics.performance.averageResponseTime
      const threshold = this.getPerformanceThreshold(environment)
      
      if (responseTime > threshold) {
        alerts.push({
          type: AlertType.PERFORMANCE_DEGRADATION,
          severity: this.calculatePerformanceSeverity(environment, responseTime, threshold),
          message: `Response time ${responseTime}ms exceeds threshold ${threshold}ms`,
          environment,
          timestamp: new Date(),
          metrics: { responseTime, threshold }
        })
      }
    }
    
    // Security event alerts
    if (config.alerting.securityEvents && metrics.security.suspiciousActivity > 0) {
      alerts.push({
        type: AlertType.SECURITY_EVENT,
        severity: AlertSeverity.HIGH,
        message: `${metrics.security.suspiciousActivity} suspicious security events detected`,
        environment,
        timestamp: new Date(),
        metrics: { suspiciousActivity: metrics.security.suspiciousActivity }
      })
    }
    
    return alerts
  }
  
  // Generate environment health dashboard
  generateHealthDashboard(environment: EnvironmentType): EnvironmentDashboard {
    const config = this.monitoringConfigs.get(environment)
    const recentMetrics = this.getRecentMetrics(environment)
    const alerts = this.getActiveAlerts(environment)
    
    return {
      environment,
      lastUpdated: new Date(),
      status: this.calculateEnvironmentStatus(recentMetrics, alerts),
      
      // Connection health
      connectionHealth: {
        poolUtilization: recentMetrics.connection.poolUtilization,
        errorRate: recentMetrics.connection.errorRate,
        averageAcquisitionTime: recentMetrics.connection.averageAcquisitionTime,
        activeConnections: recentMetrics.connection.activeConnections
      },
      
      // Performance health
      performanceHealth: {
        averageResponseTime: recentMetrics.performance.averageResponseTime,
        throughput: recentMetrics.performance.throughput,
        p95ResponseTime: recentMetrics.performance.p95ResponseTime,
        errorRate: recentMetrics.performance.errorRate
      },
      
      // Security health
      securityHealth: {
        sslConnectionsPercentage: recentMetrics.security.sslConnectionsPercentage,
        authenticationFailures: recentMetrics.security.authenticationFailures,
        suspiciousActivity: recentMetrics.security.suspiciousActivity,
        complianceScore: recentMetrics.security.complianceScore
      },
      
      // Active alerts
      alerts: alerts.map(alert => ({
        type: alert.type,
        severity: alert.severity,
        message: alert.message,
        age: Date.now() - alert.timestamp.getTime()
      })),
      
      // Recommendations
      recommendations: this.generateEnvironmentRecommendations(environment, recentMetrics, alerts)
    }
  }
}

// Monitoring types
interface EnvironmentMetrics {
  environment: EnvironmentType
  timestamp: Date
  connection: ConnectionMetrics
  performance: PerformanceMetrics
  security: SecurityMetrics
  business: BusinessMetrics
}

interface MonitoringConfig {
  metricsCollection: MetricsCollectionConfig
  alerting: AlertingConfig
  retention: RetentionConfig
  dashboards?: DashboardConfig
}

enum AlertType {
  CONNECTION_FAILURE = "connection_failure",
  PERFORMANCE_DEGRADATION = "performance_degradation",
  SECURITY_EVENT = "security_event",
  RESOURCE_LIMIT = "resource_limit",
  BUSINESS_IMPACT = "business_impact"
}

enum AlertSeverity {
  LOW = "low",
  MEDIUM = "medium",
  HIGH = "high",
  CRITICAL = "critical"
}
```

---

## 🧠 Knowledge Check

### Environment Management Quiz

1. **Which environment should have the strictest SSL configuration?**
   - [ ] A) Development
   - [ ] B) Testing
   - [ ] C) Staging
   - [x] D) Production

   **Explanation**: Production environments require the strictest SSL configuration (verify-full) to ensure maximum security for live user data.

2. **What is the primary purpose of environment promotion?**
   - [ ] A) To backup data between environments
   - [x] B) To safely move changes through deployment pipeline stages
   - [ ] C) To create new environments
   - [ ] D) To monitor environment health

   **Explanation**: Environment promotion safely moves validated changes through different stages of the deployment pipeline, ensuring quality and stability.

3. **Which credential management approach is most secure for production?**
   - [ ] A) Environment variables
   - [ ] B) Configuration files
   - [x] C) Enterprise secrets vault with rotation
   - [ ] D) Hardcoded credentials

   **Explanation**: Enterprise secrets vaults provide the highest security with features like access control, audit logging, and automated credential rotation.

### Practical Exercise: Complete Environment Strategy

**Challenge**: Design a comprehensive environment management strategy for a multi-tier application

**Requirements**:
1. Configure 5 different environment types with appropriate settings
2. Implement secure credential management across all environments
3. Set up environment promotion pipeline with validation
4. Configure monitoring and alerting per environment
5. Design disaster recovery for production

**Validation Checklist**:
- [ ] Each environment has appropriate security and performance settings
- [ ] Credential management follows security best practices
- [ ] Promotion pipeline includes proper validation steps
- [ ] Monitoring is tailored to each environment's needs
- [ ] Disaster recovery meets business requirements

---

## 💡 Key Takeaways

- 🎭 **Theater Production**: Environment management is like orchestrating productions across different venues - each requires tailored approaches
- 🌍 **Environment Classification**: Different environment types have distinct requirements for security, performance, and monitoring
- 🔐 **Credential Security**: Implement progressive credential security from basic in development to enterprise vaults in production
- 🔄 **Promotion Automation**: Automated environment promotion reduces errors and ensures consistency
- 🛡️ **HA/DR Planning**: High availability and disaster recovery require proactive planning and regular testing
- 📊 **Environment Monitoring**: Monitoring and alerting should scale with environment criticality
- 🎯 **Best Practices**: Follow environment-specific best practices for optimal security, performance, and reliability

---

## 🔗 Navigation

**📍 Current Location**: Module 2 → Section 2.3 → Lesson 2.3.5

**⬅️ Previous**: [2.3.4 SSL Configuration & Security](./2.3.4-ssl-configuration-security.md)
**➡️ Next**: [2.4.1 Essential CLI Commands Overview](../2.4-prisma-cli-basics/2.4.1-essential-cli-commands-overview.md)

**🏠 Section Home**: [2.3 Database Connection](./README.md)
**📚 Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**🗺️ Quick Links**:
- [Previous: SSL Configuration](./2.3.4-ssl-configuration-security.md)
- [Next: CLI Commands](../2.4-prisma-cli-basics/2.4.1-essential-cli-commands-overview.md)
- [Official Docs: Environment Variables](https://www.prisma.io/docs/guides/development-environment/environment-variables)

---

*🎭 Spectacular! You've mastered the multi-theater production management of environment-specific database connections. Next, we'll explore the powerful command-line tools that make Prisma development efficient and enjoyable!*
