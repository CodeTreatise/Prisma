# 2.1.5 TypeScript Configuration for Prisma

## üìã Section Overview
- **Duration**: 30 minutes
- **Prerequisites**: 
  - Completed lessons 2.1.1 - 2.1.4
  - Basic TypeScript knowledge
  - Node.js project setup
  - Prisma CLI and Client installed
- **Learning Objectives**: 
  - Configure TypeScript for optimal Prisma development
  - Set up type generation and validation
  - Implement advanced TypeScript patterns with Prisma
  - Configure development workflow with TypeScript
  - Optimize build and development processes
- **Difficulty Level**: Intermediate

---

## üéØ What You'll Learn

By the end of this section, you will:
- ‚úÖ Configure TypeScript for Prisma projects
- ‚úÖ Set up type-safe database operations
- ‚úÖ Implement advanced TypeScript patterns with Prisma
- ‚úÖ Configure development and build workflows
- ‚úÖ Optimize TypeScript compiler settings
- ‚úÖ Handle Prisma-generated types effectively
- ‚úÖ Set up testing with TypeScript and Prisma

---

## üìñ Content

### Understanding TypeScript with Prisma

Configuring TypeScript for Prisma is like **setting up a precision watchmaking workshop**. Just as a master watchmaker needs specialized tools, precise measurements, and quality controls to create perfect timepieces, TypeScript provides the precision tooling, type safety, and development experience needed to build robust database-driven applications with Prisma.

### ‚åö The Precision Watchmaking Workshop Analogy

```
‚åö Watchmaking Workshop = üîß TypeScript Configuration for Prisma

üî¨ Precision Tools (TypeScript Compiler)
‚îú‚îÄ‚îÄ Calibrated instruments ‚Üí Strict type checking
‚îú‚îÄ‚îÄ Measurement gauges ‚Üí Type inference
‚îú‚îÄ‚îÄ Quality standards ‚Üí ESLint + Prettier
‚îú‚îÄ‚îÄ Assembly guides ‚Üí Auto-completion
‚îú‚îÄ‚îÄ Testing equipment ‚Üí Type validation
‚îî‚îÄ‚îÄ Documentation system ‚Üí Generated types

üõ†Ô∏è Specialized Equipment (Development Tools)
‚îú‚îÄ‚îÄ Workbench setup ‚Üí tsconfig.json
‚îú‚îÄ‚îÄ Tool organization ‚Üí Path mapping
‚îú‚îÄ‚îÄ Quality control ‚Üí Build scripts
‚îú‚îÄ‚îÄ Testing station ‚Üí Jest/Vitest setup
‚îú‚îÄ‚îÄ Documentation ‚Üí Type exports
‚îî‚îÄ‚îÄ Maintenance procedures ‚Üí Hot reloading

‚öôÔ∏è Component Library (Type System)
‚îú‚îÄ‚îÄ Base components ‚Üí Prisma generated types
‚îú‚îÄ‚îÄ Custom parts ‚Üí Extended types
‚îú‚îÄ‚îÄ Assembly procedures ‚Üí Type composition
‚îú‚îÄ‚îÄ Quality standards ‚Üí Type validation
‚îú‚îÄ‚îÄ Compatibility charts ‚Üí Version management
‚îî‚îÄ‚îÄ Maintenance guides ‚Üí Type utilities

üéØ Quality Assurance (Development Experience)
‚îú‚îÄ‚îÄ Precision standards ‚Üí Strict compilation
‚îú‚îÄ‚îÄ Error detection ‚Üí Real-time validation
‚îú‚îÄ‚îÄ Performance metrics ‚Üí Build optimization
‚îú‚îÄ‚îÄ Testing protocols ‚Üí Type testing
‚îú‚îÄ‚îÄ Documentation standards ‚Üí Type documentation
‚îî‚îÄ‚îÄ Continuous improvement ‚Üí Development workflow
```

---

## üîß TypeScript Configuration

### 1. Complete tsconfig.json for Prisma

Create a comprehensive TypeScript configuration optimized for Prisma development:

```json
{
  "compilerOptions": {
    /* Base Configuration */
    "target": "ES2022",
    "module": "CommonJS",
    "lib": ["ES2022"],
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    
    /* Output Configuration */
    "outDir": "./dist",
    "rootDir": "./src",
    "removeComments": false,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "inlineSourceMap": false,
    "inlineSources": false,
    
    /* Strict Type Checking */
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true,
    
    /* Additional Checks */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,
    "noFallthroughCasesInSwitch": true,
    "noPropertyAccessFromIndexSignature": false,
    
    /* Advanced Options */
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,
    "importsNotUsedAsValues": "error",
    "preserveConstEnums": true,
    
    /* Prisma Specific */
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    
    /* Path Mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/types/*": ["src/types/*"],
      "@/utils/*": ["src/utils/*"],
      "@/config/*": ["src/config/*"],
      "@/db/*": ["src/db/*"],
      "@/services/*": ["src/services/*"],
      "@/controllers/*": ["src/controllers/*"],
      "@/middleware/*": ["src/middleware/*"],
      "@/tests/*": ["tests/*"]
    }
  },
  
  /* Include/Exclude */
  "include": [
    "src/**/*",
    "prisma/**/*",
    "tests/**/*",
    "scripts/**/*",
    "global.d.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "coverage",
    "*.config.js",
    "*.config.ts"
  ],
  
  /* TypeScript Project References */
  "references": [],
  
  /* Watch Options */
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",
    "fallbackPolling": "dynamicPriority",
    "synchronousWatchDirectory": true,
    "excludeDirectories": ["**/node_modules", "dist", "coverage"]
  }
}
```

### 2. Development-Specific Configuration

Create a separate configuration for development:

```json
// tsconfig.dev.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    /* Development Optimizations */
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo",
    
    /* Faster Compilation */
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    
    /* Debug Support */
    "sourceMap": true,
    "inlineSourceMap": false,
    "inlineSources": false,
    
    /* Relaxed Checks for Development */
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "exactOptionalPropertyTypes": false
  },
  
  "include": [
    "src/**/*",
    "tests/**/*",
    "scripts/**/*",
    "prisma/**/*"
  ],
  
  "exclude": [
    "dist",
    "coverage",
    "node_modules"
  ]
}
```

### 3. Production Build Configuration

```json
// tsconfig.build.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    /* Production Optimizations */
    "removeComments": true,
    "declaration": false,
    "declarationMap": false,
    "sourceMap": false,
    
    /* Strict Production Checks */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true
  },
  
  "include": [
    "src/**/*"
  ],
  
  "exclude": [
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "tests/**/*",
    "scripts/**/*",
    "**/*.d.ts"
  ]
}
```

---

## üì¶ Type Definitions and Declarations

### 1. Global Type Declarations

Create global type definitions for your project:

```typescript
// global.d.ts
import { PrismaClient } from '@prisma/client'

declare global {
  /* Environment Variables */
  namespace NodeJS {
    interface ProcessEnv {
      NODE_ENV: 'development' | 'staging' | 'production'
      DATABASE_URL: string
      DIRECT_URL?: string
      APP_PORT?: string
      APP_SECRET: string
      JWT_SECRET: string
      JWT_EXPIRES_IN?: string
      REDIS_URL?: string
      AWS_ACCESS_KEY_ID?: string
      AWS_SECRET_ACCESS_KEY?: string
      AWS_S3_BUCKET?: string
      AWS_REGION?: string
      PRISMA_CLIENT_ENGINE_TYPE?: 'library' | 'binary'
      PRISMA_HIDE_UPDATE_MESSAGE?: string
      DEBUG?: string
      LOG_LEVEL?: 'error' | 'warn' | 'info' | 'debug'
    }
  }
  
  /* Global Prisma Instance */
  var __globalPrisma: PrismaClient | undefined
  
  /* Express Request Extensions */
  namespace Express {
    interface Request {
      user?: {
        id: string
        email: string
        role: string
      }
      startTime?: number
      requestId?: string
    }
  }
}

export {}
```

### 2. Prisma Type Extensions

Create extended types for Prisma models:

```typescript
// src/types/prisma.ts
import { Prisma, PrismaClient } from '@prisma/client'

/* Extended Prisma Client */
export type ExtendedPrismaClient = PrismaClient & {
  // Add custom methods or properties
}

/* Model Type Utilities */
export type UserWithProfile = Prisma.UserGetPayload<{
  include: { profile: true }
}>

export type PostWithAuthor = Prisma.PostGetPayload<{
  include: { author: true }
}>

export type PostWithAuthorAndComments = Prisma.PostGetPayload<{
  include: {
    author: true
    comments: {
      include: { author: true }
    }
  }
}>

/* Input Type Utilities */
export type CreateUserInput = Prisma.UserCreateInput
export type UpdateUserInput = Prisma.UserUpdateInput
export type CreatePostInput = Prisma.PostCreateInput

/* Nested Input Types */
export type CreateUserWithProfileInput = Prisma.UserCreateInput & {
  profile: Prisma.ProfileCreateWithoutUserInput
}

/* Query Result Types */
export type UserQueryResult = Prisma.UserGetPayload<{}>
export type PostQueryResult = Prisma.PostGetPayload<{}>

/* Pagination Types */
export type PaginationArgs = {
  skip?: number
  take?: number
}

export type PaginatedResult<T> = {
  data: T[]
  pagination: {
    total: number
    page: number
    pageSize: number
    totalPages: number
    hasNext: boolean
    hasPrev: boolean
  }
}

/* Filter Types */
export type UserFilters = {
  email?: string
  role?: string
  isActive?: boolean
  createdAfter?: Date
  createdBefore?: Date
}

export type PostFilters = {
  title?: string
  authorId?: string
  published?: boolean
  tags?: string[]
  createdAfter?: Date
  createdBefore?: Date
}

/* Sort Types */
export type SortOrder = 'asc' | 'desc'

export type UserSortFields = 'email' | 'createdAt' | 'updatedAt'
export type PostSortFields = 'title' | 'createdAt' | 'updatedAt'

export type SortConfig<T extends string> = {
  field: T
  order: SortOrder
}

/* Service Return Types */
export type ServiceResult<T> = {
  success: boolean
  data?: T
  error?: string
  errors?: string[]
}

export type ValidationResult = {
  isValid: boolean
  errors: Record<string, string[]>
}

/* Transaction Types */
export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

export type TransactionCallback<T> = (prisma: TransactionClient) => Promise<T>

/* Prisma JSON Types */
export type JsonValue = Prisma.JsonValue
export type JsonObject = Prisma.JsonObject
export type JsonArray = Prisma.JsonArray

/* Model Enums */
export type UserRole = Prisma.UserRole
export type PostStatus = Prisma.PostStatus
```

### 3. Database Utility Types

```typescript
// src/types/database.ts
import { Prisma } from '@prisma/client'

/* Generic CRUD Types */
export interface CreateOptions<T> {
  data: T
  include?: any
  select?: any
}

export interface UpdateOptions<T> {
  where: any
  data: T
  include?: any
  select?: any
}

export interface FindOptions {
  where?: any
  include?: any
  select?: any
  orderBy?: any
  skip?: number
  take?: number
}

export interface DeleteOptions {
  where: any
}

/* Repository Pattern Types */
export interface BaseRepository<Model, CreateInput, UpdateInput> {
  findById(id: string): Promise<Model | null>
  findMany(options?: FindOptions): Promise<Model[]>
  create(data: CreateInput): Promise<Model>
  update(id: string, data: UpdateInput): Promise<Model>
  delete(id: string): Promise<Model>
  count(where?: any): Promise<number>
}

/* Query Builder Types */
export type WhereCondition<T> = {
  [K in keyof T]?: T[K] | {
    equals?: T[K]
    not?: T[K]
    in?: T[K][]
    notIn?: T[K][]
    lt?: T[K]
    lte?: T[K]
    gt?: T[K]
    gte?: T[K]
    contains?: string
    startsWith?: string
    endsWith?: string
  }
}

export type OrderByCondition<T> = {
  [K in keyof T]?: 'asc' | 'desc'
}

/* Migration Types */
export interface MigrationInfo {
  id: string
  checksum: string
  finished_at: Date | null
  migration_name: string
  logs: string | null
  rolled_back_at: Date | null
  started_at: Date
  applied_steps_count: number
}

/* Connection Types */
export interface DatabaseConfig {
  url: string
  shadowDatabaseUrl?: string
  directUrl?: string
}

export interface ConnectionOptions {
  maxConnections?: number
  timeout?: number
  ssl?: boolean
}
```

---

## üî® Development Workflow Configuration

### 1. Package.json Scripts for TypeScript

```json
{
  "scripts": {
    /* Development */
    "dev": "tsx watch src/index.ts",
    "dev:debug": "tsx watch --inspect src/index.ts",
    "dev:clean": "rm -rf dist .tsbuildinfo && npm run dev",
    
    /* Building */
    "build": "tsc -p tsconfig.build.json",
    "build:dev": "tsc -p tsconfig.dev.json",
    "build:watch": "tsc -p tsconfig.build.json --watch",
    "build:clean": "rm -rf dist .tsbuildinfo && npm run build",
    
    /* Type Checking */
    "type-check": "tsc --noEmit",
    "type-check:watch": "tsc --noEmit --watch",
    "type-check:dev": "tsc -p tsconfig.dev.json --noEmit",
    
    /* Prisma + TypeScript */
    "prisma:generate": "prisma generate && npm run type-check",
    "prisma:migrate": "prisma migrate dev && prisma generate && npm run type-check",
    "prisma:reset": "prisma migrate reset --force && prisma generate && npm run type-check",
    "prisma:deploy": "prisma migrate deploy && prisma generate",
    
    /* Testing */
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage",
    "test:types": "tsc --noEmit && vitest --typecheck",
    
    /* Linting */
    "lint": "eslint src tests --ext .ts,.tsx",
    "lint:fix": "eslint src tests --ext .ts,.tsx --fix",
    "lint:types": "npm run type-check && npm run lint",
    
    /* Formatting */
    "format": "prettier --write src tests prisma",
    "format:check": "prettier --check src tests prisma",
    
    /* Complete Checks */
    "check": "npm run type-check && npm run lint && npm run format:check",
    "check:fix": "npm run type-check && npm run lint:fix && npm run format",
    
    /* Production */
    "start": "node dist/index.js",
    "start:prod": "NODE_ENV=production node dist/index.js",
    
    /* Utilities */
    "clean": "rm -rf dist .tsbuildinfo coverage",
    "reset": "npm run clean && rm -rf node_modules && npm install",
    "setup": "npm install && npm run prisma:generate && npm run build"
  }
}
```

### 2. TypeScript Development Dependencies

```json
{
  "devDependencies": {
    /* TypeScript Core */
    "typescript": "^5.2.2",
    "tsx": "^3.12.7",
    "@types/node": "^20.5.1",
    
    /* Prisma */
    "prisma": "^5.3.1",
    "@prisma/client": "^5.3.1",
    
    /* Testing */
    "vitest": "^0.34.1",
    "@vitest/coverage-v8": "^0.34.1",
    "supertest": "^6.3.3",
    "@types/supertest": "^2.0.12",
    
    /* Linting & Formatting */
    "eslint": "^8.47.0",
    "@typescript-eslint/eslint-plugin": "^6.4.0",
    "@typescript-eslint/parser": "^6.4.0",
    "prettier": "^3.0.2",
    
    /* Path Resolution */
    "tsconfig-paths": "^4.2.0",
    "module-alias": "^2.2.3"
  }
}
```

### 3. Path Resolution Setup

Configure path resolution for cleaner imports:

```typescript
// src/utils/path-resolver.ts
import moduleAlias from 'module-alias'
import path from 'path'

// Register path aliases for runtime
moduleAlias.addAliases({
  '@': path.join(__dirname, '..'),
  '@/types': path.join(__dirname, '..', 'types'),
  '@/utils': path.join(__dirname, '..', 'utils'),
  '@/config': path.join(__dirname, '..', 'config'),
  '@/db': path.join(__dirname, '..', 'db'),
  '@/services': path.join(__dirname, '..', 'services'),
  '@/controllers': path.join(__dirname, '..', 'controllers'),
  '@/middleware': path.join(__dirname, '..', 'middleware'),
})

// For testing environments
if (process.env.NODE_ENV === 'test') {
  moduleAlias.addAlias('@/tests', path.join(__dirname, '..', '..', 'tests'))
}
```

---

## üß™ Testing Configuration

### 1. Vitest Configuration with TypeScript

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import path from 'path'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./tests/setup.ts'],
    include: ['tests/**/*.test.ts', 'src/**/*.test.ts'],
    exclude: ['node_modules', 'dist', 'coverage'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: ['node_modules/', 'dist/', 'tests/', '**/*.d.ts'],
    },
    typecheck: {
      checker: 'tsc',
      tsconfig: './tsconfig.dev.json',
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/types': path.resolve(__dirname, './src/types'),
      '@/utils': path.resolve(__dirname, './src/utils'),
      '@/config': path.resolve(__dirname, './src/config'),
      '@/db': path.resolve(__dirname, './src/db'),
      '@/services': path.resolve(__dirname, './src/services'),
      '@/controllers': path.resolve(__dirname, './src/controllers'),
      '@/middleware': path.resolve(__dirname, './src/middleware'),
      '@/tests': path.resolve(__dirname, './tests'),
    },
  },
})
```

### 2. Test Setup with TypeScript

```typescript
// tests/setup.ts
import { beforeAll, afterAll, beforeEach, afterEach } from 'vitest'
import { PrismaClient } from '@prisma/client'
import { mockDeep, mockReset, DeepMockProxy } from 'vitest-mock-extended'

/* Global Test Setup */
const prisma = new PrismaClient()

beforeAll(async () => {
  // Connect to test database
  await prisma.$connect()
  console.log('üìä Connected to test database')
})

afterAll(async () => {
  // Cleanup and disconnect
  await prisma.$disconnect()
  console.log('üîå Disconnected from test database')
})

beforeEach(async () => {
  // Reset database state before each test
  await prisma.$transaction([
    prisma.comment.deleteMany(),
    prisma.post.deleteMany(),
    prisma.profile.deleteMany(),
    prisma.user.deleteMany(),
  ])
})

afterEach(() => {
  mockReset(prismaMock)
})

/* Mock Prisma Client for Unit Tests */
export const prismaMock = mockDeep<PrismaClient>() as unknown as DeepMockProxy<PrismaClient>

/* Test Utilities */
export async function createTestUser(overrides: Partial<any> = {}) {
  return prisma.user.create({
    data: {
      email: 'test@example.com',
      name: 'Test User',
      ...overrides,
    },
  })
}

export async function createTestPost(authorId: string, overrides: Partial<any> = {}) {
  return prisma.post.create({
    data: {
      title: 'Test Post',
      content: 'Test content',
      authorId,
      ...overrides,
    },
  })
}

/* Type-safe Test Assertions */
export function assertIsArray<T>(value: unknown): asserts value is T[] {
  if (!Array.isArray(value)) {
    throw new Error('Expected array')
  }
}

export function assertIsObject<T extends object>(value: unknown): asserts value is T {
  if (typeof value !== 'object' || value === null) {
    throw new Error('Expected object')
  }
}
```

### 3. Example TypeScript Test

```typescript
// tests/services/user.service.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { UserService } from '@/services/user.service'
import { prismaMock, createTestUser } from '@/tests/setup'
import { CreateUserInput, UserWithProfile } from '@/types/prisma'

describe('UserService', () => {
  let userService: UserService
  
  beforeEach(() => {
    userService = new UserService(prismaMock)
  })
  
  describe('createUser', () => {
    it('should create a user with valid data', async () => {
      // Arrange
      const userData: CreateUserInput = {
        email: 'test@example.com',
        name: 'Test User',
      }
      
      const expectedUser = {
        id: '1',
        ...userData,
        createdAt: new Date(),
        updatedAt: new Date(),
      }
      
      prismaMock.user.create.mockResolvedValue(expectedUser)
      
      // Act
      const result = await userService.createUser(userData)
      
      // Assert
      expect(result).toEqual(expectedUser)
      expect(prismaMock.user.create).toHaveBeenCalledWith({
        data: userData,
      })
    })
    
    it('should throw error for duplicate email', async () => {
      // Arrange
      const userData: CreateUserInput = {
        email: 'existing@example.com',
        name: 'Test User',
      }
      
      prismaMock.user.create.mockRejectedValue(
        new Error('Unique constraint failed')
      )
      
      // Act & Assert
      await expect(userService.createUser(userData)).rejects.toThrow(
        'Unique constraint failed'
      )
    })
  })
  
  describe('getUserWithProfile', () => {
    it('should return user with profile', async () => {
      // Arrange
      const userId = '1'
      const expectedUser: UserWithProfile = {
        id: userId,
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
        profile: {
          id: '1',
          userId: userId,
          bio: 'Test bio',
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      }
      
      prismaMock.user.findUnique.mockResolvedValue(expectedUser)
      
      // Act
      const result = await userService.getUserWithProfile(userId)
      
      // Assert
      expect(result).toEqual(expectedUser)
      expect(prismaMock.user.findUnique).toHaveBeenCalledWith({
        where: { id: userId },
        include: { profile: true },
      })
    })
    
    it('should return null for non-existent user', async () => {
      // Arrange
      const userId = 'non-existent'
      prismaMock.user.findUnique.mockResolvedValue(null)
      
      // Act
      const result = await userService.getUserWithProfile(userId)
      
      // Assert
      expect(result).toBeNull()
    })
  })
})
```

---

## üîß Advanced TypeScript Patterns

### 1. Type-Safe Repository Pattern

```typescript
// src/repositories/base.repository.ts
import { PrismaClient } from '@prisma/client'

export abstract class BaseRepository<
  Model,
  CreateInput,
  UpdateInput,
  WhereInput = any,
  IncludeInput = any
> {
  constructor(protected prisma: PrismaClient) {}
  
  abstract get modelName(): string
  
  abstract findById(
    id: string,
    include?: IncludeInput
  ): Promise<Model | null>
  
  abstract findMany(options?: {
    where?: WhereInput
    include?: IncludeInput
    orderBy?: any
    skip?: number
    take?: number
  }): Promise<Model[]>
  
  abstract create(
    data: CreateInput,
    include?: IncludeInput
  ): Promise<Model>
  
  abstract update(
    id: string,
    data: UpdateInput,
    include?: IncludeInput
  ): Promise<Model>
  
  abstract delete(id: string): Promise<Model>
  
  abstract count(where?: WhereInput): Promise<number>
}

// src/repositories/user.repository.ts
import { Prisma, User } from '@prisma/client'
import { BaseRepository } from './base.repository'

export class UserRepository extends BaseRepository<
  User,
  Prisma.UserCreateInput,
  Prisma.UserUpdateInput,
  Prisma.UserWhereInput,
  Prisma.UserInclude
> {
  get modelName() {
    return 'user'
  }
  
  async findById(id: string, include?: Prisma.UserInclude) {
    return this.prisma.user.findUnique({
      where: { id },
      include,
    })
  }
  
  async findByEmail(email: string, include?: Prisma.UserInclude) {
    return this.prisma.user.findUnique({
      where: { email },
      include,
    })
  }
  
  async findMany(options?: {
    where?: Prisma.UserWhereInput
    include?: Prisma.UserInclude
    orderBy?: Prisma.UserOrderByWithRelationInput
    skip?: number
    take?: number
  }) {
    return this.prisma.user.findMany(options)
  }
  
  async create(data: Prisma.UserCreateInput, include?: Prisma.UserInclude) {
    return this.prisma.user.create({
      data,
      include,
    })
  }
  
  async update(
    id: string,
    data: Prisma.UserUpdateInput,
    include?: Prisma.UserInclude
  ) {
    return this.prisma.user.update({
      where: { id },
      data,
      include,
    })
  }
  
  async delete(id: string) {
    return this.prisma.user.delete({
      where: { id },
    })
  }
  
  async count(where?: Prisma.UserWhereInput) {
    return this.prisma.user.count({ where })
  }
}
```

### 2. Type-Safe Service Layer

```typescript
// src/services/user.service.ts
import { UserRepository } from '@/repositories/user.repository'
import { CreateUserInput, UpdateUserInput, UserWithProfile } from '@/types/prisma'
import { ServiceResult, ValidationResult } from '@/types/prisma'

export class UserService {
  constructor(private userRepository: UserRepository) {}
  
  async createUser(data: CreateUserInput): Promise<ServiceResult<UserWithProfile>> {
    try {
      // Validate input
      const validation = await this.validateCreateInput(data)
      if (!validation.isValid) {
        return {
          success: false,
          errors: Object.values(validation.errors).flat(),
        }
      }
      
      // Check for existing email
      const existingUser = await this.userRepository.findByEmail(data.email)
      if (existingUser) {
        return {
          success: false,
          error: 'User with this email already exists',
        }
      }
      
      // Create user
      const user = await this.userRepository.create(data, {
        profile: true,
      })
      
      return {
        success: true,
        data: user as UserWithProfile,
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }
  
  async getUserById(id: string): Promise<ServiceResult<UserWithProfile>> {
    try {
      const user = await this.userRepository.findById(id, {
        profile: true,
      })
      
      if (!user) {
        return {
          success: false,
          error: 'User not found',
        }
      }
      
      return {
        success: true,
        data: user as UserWithProfile,
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }
  
  private async validateCreateInput(data: CreateUserInput): Promise<ValidationResult> {
    const errors: Record<string, string[]> = {}
    
    // Email validation
    if (!data.email) {
      errors.email = ['Email is required']
    } else if (!this.isValidEmail(data.email)) {
      errors.email = ['Invalid email format']
    }
    
    // Name validation
    if (!data.name) {
      errors.name = ['Name is required']
    } else if (data.name.length < 2) {
      errors.name = ['Name must be at least 2 characters']
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors,
    }
  }
  
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  }
}
```

### 3. Type-Safe Controllers

```typescript
// src/controllers/user.controller.ts
import { Request, Response } from 'express'
import { UserService } from '@/services/user.service'
import { CreateUserInput } from '@/types/prisma'
import { z } from 'zod'

const createUserSchema = z.object({
  email: z.string().email('Invalid email format'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
})

const updateUserSchema = z.object({
  email: z.string().email().optional(),
  name: z.string().min(2).optional(),
})

export class UserController {
  constructor(private userService: UserService) {}
  
  async createUser(req: Request, res: Response) {
    try {
      // Validate request body
      const validation = createUserSchema.safeParse(req.body)
      if (!validation.success) {
        return res.status(400).json({
          error: 'Validation failed',
          details: validation.error.errors,
        })
      }
      
      const userData = validation.data as CreateUserInput
      const result = await this.userService.createUser(userData)
      
      if (!result.success) {
        return res.status(400).json({
          error: result.error || 'Failed to create user',
          details: result.errors,
        })
      }
      
      res.status(201).json({
        message: 'User created successfully',
        data: result.data,
      })
    } catch (error) {
      console.error('Error creating user:', error)
      res.status(500).json({
        error: 'Internal server error',
      })
    }
  }
  
  async getUserById(req: Request, res: Response) {
    try {
      const { id } = req.params
      
      if (!id) {
        return res.status(400).json({
          error: 'User ID is required',
        })
      }
      
      const result = await this.userService.getUserById(id)
      
      if (!result.success) {
        const statusCode = result.error === 'User not found' ? 404 : 400
        return res.status(statusCode).json({
          error: result.error,
        })
      }
      
      res.json({
        message: 'User retrieved successfully',
        data: result.data,
      })
    } catch (error) {
      console.error('Error retrieving user:', error)
      res.status(500).json({
        error: 'Internal server error',
      })
    }
  }
}
```

---

## üß† Knowledge Check

### TypeScript Configuration Quiz

1. **Which TypeScript compiler option is most important for Prisma type safety?**
   - [ ] A) `noImplicitAny`
   - [x] B) `strict`
   - [ ] C) `declaration`
   - [ ] D) `sourceMap`

   **Explanation**: The `strict` flag enables all strict type checking options, which is essential for type safety with Prisma.

2. **What is the recommended way to handle Prisma-generated types?**
   - [ ] A) Copy them to a separate file
   - [ ] B) Modify them directly
   - [x] C) Extend them with custom utility types
   - [ ] D) Ignore them completely

   **Explanation**: You should extend Prisma-generated types with custom utility types rather than modifying the generated code.

3. **Which file should contain global type declarations?**
   - [ ] A) index.ts
   - [ ] B) types.ts
   - [x] C) global.d.ts
   - [ ] D) prisma.d.ts

   **Explanation**: `global.d.ts` is the conventional file for global type declarations that should be available throughout the project.

### Practical Exercise: Complete TypeScript Setup

**Challenge**: Set up a complete TypeScript configuration for a Prisma project

**Tasks**:
1. Create comprehensive tsconfig.json with Prisma optimizations
2. Set up global type declarations
3. Create Prisma type extensions
4. Configure development and build scripts
5. Set up testing with TypeScript

**Validation Checklist**:
- [ ] tsconfig.json has strict type checking enabled
- [ ] Path mapping is configured for clean imports
- [ ] Global types include environment variables
- [ ] Prisma types are properly extended
- [ ] Build and development scripts work correctly
- [ ] Tests run with full type checking

---

## üí° Key Takeaways

- üîß **Strict Configuration**: Enable strict TypeScript settings for maximum type safety with Prisma
- üì¶ **Type Extensions**: Extend Prisma-generated types rather than modifying them directly
- üõ†Ô∏è **Development Workflow**: Configure separate TypeScript settings for development and production
- üß™ **Testing Setup**: Include TypeScript type checking in your test pipeline
- üìÅ **Path Mapping**: Use path aliases for cleaner imports and better code organization
- üîç **Type Validation**: Implement runtime validation alongside TypeScript compile-time checking
- ‚ö° **Performance**: Optimize TypeScript configuration for fast compilation and development experience

---

## üîó Navigation

**üìç Current Location**: Module 2 ‚Üí Section 2.1 ‚Üí Lesson 2.1.5

**‚¨ÖÔ∏è Previous**: [2.1.4 Environment Variables & .env Setup](./2.1.4-environment-variables-env-setup.md)
**‚û°Ô∏è Next**: [2.2.1 Creating Your First Schema](../2.2-first-prisma-project/2.2.1-creating-your-first-schema.md)

**üè† Section Home**: [2.1 Installation & Setup](./README.md)
**üìö Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**üó∫Ô∏è Quick Links**:
- [Next: First Schema](../2.2-first-prisma-project/2.2.1-creating-your-first-schema.md)
- [Jump to: Database Connection](../2.3-database-connection/2.3.1-connecting-to-postgresql.md)
- [Official Docs: TypeScript](https://www.prisma.io/docs/concepts/more/comparisons/prisma-and-typeorm#type-safety)

---

*Excellent! You've mastered TypeScript configuration for Prisma. Ready to create your first schema and start building? Continue to the next section!*
