# 2.1.5 TypeScript Configuration for Prisma

## 📋 Section Overview
- **Duration**: 30 minutes
- **Prerequisites**: 
  - Completed lessons 2.1.1 - 2.1.4
  - Basic TypeScript knowledge
  - Node.js project setup
  - Prisma CLI and Client installed
- **Learning Objectives**: 
  - Configure TypeScript for optimal Prisma development
  - Set up type generation and validation
  - Implement advanced TypeScript patterns with Prisma
  - Configure development workflow with TypeScript
  - Optimize build and development processes
- **Difficulty Level**: Intermediate

---

## 🎯 What You'll Learn

By the end of this section, you will:
- ✅ Configure TypeScript for Prisma projects
- ✅ Set up type-safe database operations
- ✅ Implement advanced TypeScript patterns with Prisma
- ✅ Configure development and build workflows
- ✅ Optimize TypeScript compiler settings
- ✅ Handle Prisma-generated types effectively
- ✅ Set up testing with TypeScript and Prisma

---

## 📖 Content

### Understanding TypeScript with Prisma

Configuring TypeScript for Prisma is like **setting up a precision watchmaking workshop**. Just as a master watchmaker needs specialized tools, precise measurements, and quality controls to create perfect timepieces, TypeScript provides the precision tooling, type safety, and development experience needed to build robust database-driven applications with Prisma.

### ⌚ The Precision Watchmaking Workshop Analogy

```
⌚ Watchmaking Workshop = 🔧 TypeScript Configuration for Prisma

🔬 Precision Tools (TypeScript Compiler)
├── Calibrated instruments → Strict type checking
├── Measurement gauges → Type inference
├── Quality standards → ESLint + Prettier
├── Assembly guides → Auto-completion
├── Testing equipment → Type validation
└── Documentation system → Generated types

🛠️ Specialized Equipment (Development Tools)
├── Workbench setup → tsconfig.json
├── Tool organization → Path mapping
├── Quality control → Build scripts
├── Testing station → Jest/Vitest setup
├── Documentation → Type exports
└── Maintenance procedures → Hot reloading

⚙️ Component Library (Type System)
├── Base components → Prisma generated types
├── Custom parts → Extended types
├── Assembly procedures → Type composition
├── Quality standards → Type validation
├── Compatibility charts → Version management
└── Maintenance guides → Type utilities

🎯 Quality Assurance (Development Experience)
├── Precision standards → Strict compilation
├── Error detection → Real-time validation
├── Performance metrics → Build optimization
├── Testing protocols → Type testing
├── Documentation standards → Type documentation
└── Continuous improvement → Development workflow
```

---

## 🔧 TypeScript Configuration

### 1. Complete tsconfig.json for Prisma

Create a comprehensive TypeScript configuration optimized for Prisma development:

```json
{
  "compilerOptions": {
    /* Base Configuration */
    "target": "ES2022",
    "module": "CommonJS",
    "lib": ["ES2022"],
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    
    /* Output Configuration */
    "outDir": "./dist",
    "rootDir": "./src",
    "removeComments": false,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "inlineSourceMap": false,
    "inlineSources": false,
    
    /* Strict Type Checking */
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true,
    
    /* Additional Checks */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,
    "noFallthroughCasesInSwitch": true,
    "noPropertyAccessFromIndexSignature": false,
    
    /* Advanced Options */
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,
    "importsNotUsedAsValues": "error",
    "preserveConstEnums": true,
    
    /* Prisma Specific */
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    
    /* Path Mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/types/*": ["src/types/*"],
      "@/utils/*": ["src/utils/*"],
      "@/config/*": ["src/config/*"],
      "@/db/*": ["src/db/*"],
      "@/services/*": ["src/services/*"],
      "@/controllers/*": ["src/controllers/*"],
      "@/middleware/*": ["src/middleware/*"],
      "@/tests/*": ["tests/*"]
    }
  },
  
  /* Include/Exclude */
  "include": [
    "src/**/*",
    "prisma/**/*",
    "tests/**/*",
    "scripts/**/*",
    "global.d.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "coverage",
    "*.config.js",
    "*.config.ts"
  ],
  
  /* TypeScript Project References */
  "references": [],
  
  /* Watch Options */
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",
    "fallbackPolling": "dynamicPriority",
    "synchronousWatchDirectory": true,
    "excludeDirectories": ["**/node_modules", "dist", "coverage"]
  }
}
```

### 2. Development-Specific Configuration

Create a separate configuration for development:

```json
// tsconfig.dev.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    /* Development Optimizations */
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo",
    
    /* Faster Compilation */
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    
    /* Debug Support */
    "sourceMap": true,
    "inlineSourceMap": false,
    "inlineSources": false,
    
    /* Relaxed Checks for Development */
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "exactOptionalPropertyTypes": false
  },
  
  "include": [
    "src/**/*",
    "tests/**/*",
    "scripts/**/*",
    "prisma/**/*"
  ],
  
  "exclude": [
    "dist",
    "coverage",
    "node_modules"
  ]
}
```

### 3. Production Build Configuration

```json
// tsconfig.build.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    /* Production Optimizations */
    "removeComments": true,
    "declaration": false,
    "declarationMap": false,
    "sourceMap": false,
    
    /* Strict Production Checks */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true
  },
  
  "include": [
    "src/**/*"
  ],
  
  "exclude": [
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "tests/**/*",
    "scripts/**/*",
    "**/*.d.ts"
  ]
}
```

---

## 📦 Type Definitions and Declarations

### 1. Global Type Declarations

Create global type definitions for your project:

```typescript
// global.d.ts
import { PrismaClient } from '@prisma/client'

declare global {
  /* Environment Variables */
  namespace NodeJS {
    interface ProcessEnv {
      NODE_ENV: 'development' | 'staging' | 'production'
      DATABASE_URL: string
      DIRECT_URL?: string
      APP_PORT?: string
      APP_SECRET: string
      JWT_SECRET: string
      JWT_EXPIRES_IN?: string
      REDIS_URL?: string
      AWS_ACCESS_KEY_ID?: string
      AWS_SECRET_ACCESS_KEY?: string
      AWS_S3_BUCKET?: string
      AWS_REGION?: string
      PRISMA_CLIENT_ENGINE_TYPE?: 'library' | 'binary'
      PRISMA_HIDE_UPDATE_MESSAGE?: string
      DEBUG?: string
      LOG_LEVEL?: 'error' | 'warn' | 'info' | 'debug'
    }
  }
  
  /* Global Prisma Instance */
  var __globalPrisma: PrismaClient | undefined
  
  /* Express Request Extensions */
  namespace Express {
    interface Request {
      user?: {
        id: string
        email: string
        role: string
      }
      startTime?: number
      requestId?: string
    }
  }
}

export {}
```

### 2. Prisma Type Extensions

Create extended types for Prisma models:

```typescript
// src/types/prisma.ts
import { Prisma, PrismaClient } from '@prisma/client'

/* Extended Prisma Client */
export type ExtendedPrismaClient = PrismaClient & {
  // Add custom methods or properties
}

/* Model Type Utilities */
export type UserWithProfile = Prisma.UserGetPayload<{
  include: { profile: true }
}>

export type PostWithAuthor = Prisma.PostGetPayload<{
  include: { author: true }
}>

export type PostWithAuthorAndComments = Prisma.PostGetPayload<{
  include: {
    author: true
    comments: {
      include: { author: true }
    }
  }
}>

/* Input Type Utilities */
export type CreateUserInput = Prisma.UserCreateInput
export type UpdateUserInput = Prisma.UserUpdateInput
export type CreatePostInput = Prisma.PostCreateInput

/* Nested Input Types */
export type CreateUserWithProfileInput = Prisma.UserCreateInput & {
  profile: Prisma.ProfileCreateWithoutUserInput
}

/* Query Result Types */
export type UserQueryResult = Prisma.UserGetPayload<{}>
export type PostQueryResult = Prisma.PostGetPayload<{}>

/* Pagination Types */
export type PaginationArgs = {
  skip?: number
  take?: number
}

export type PaginatedResult<T> = {
  data: T[]
  pagination: {
    total: number
    page: number
    pageSize: number
    totalPages: number
    hasNext: boolean
    hasPrev: boolean
  }
}

/* Filter Types */
export type UserFilters = {
  email?: string
  role?: string
  isActive?: boolean
  createdAfter?: Date
  createdBefore?: Date
}

export type PostFilters = {
  title?: string
  authorId?: string
  published?: boolean
  tags?: string[]
  createdAfter?: Date
  createdBefore?: Date
}

/* Sort Types */
export type SortOrder = 'asc' | 'desc'

export type UserSortFields = 'email' | 'createdAt' | 'updatedAt'
export type PostSortFields = 'title' | 'createdAt' | 'updatedAt'

export type SortConfig<T extends string> = {
  field: T
  order: SortOrder
}

/* Service Return Types */
export type ServiceResult<T> = {
  success: boolean
  data?: T
  error?: string
  errors?: string[]
}

export type ValidationResult = {
  isValid: boolean
  errors: Record<string, string[]>
}

/* Transaction Types */
export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

export type TransactionCallback<T> = (prisma: TransactionClient) => Promise<T>

/* Prisma JSON Types */
export type JsonValue = Prisma.JsonValue
export type JsonObject = Prisma.JsonObject
export type JsonArray = Prisma.JsonArray

/* Model Enums */
export type UserRole = Prisma.UserRole
export type PostStatus = Prisma.PostStatus
```

### 3. Database Utility Types

```typescript
// src/types/database.ts
import { Prisma } from '@prisma/client'

/* Generic CRUD Types */
export interface CreateOptions<T> {
  data: T
  include?: any
  select?: any
}

export interface UpdateOptions<T> {
  where: any
  data: T
  include?: any
  select?: any
}

export interface FindOptions {
  where?: any
  include?: any
  select?: any
  orderBy?: any
  skip?: number
  take?: number
}

export interface DeleteOptions {
  where: any
}

/* Repository Pattern Types */
export interface BaseRepository<Model, CreateInput, UpdateInput> {
  findById(id: string): Promise<Model | null>
  findMany(options?: FindOptions): Promise<Model[]>
  create(data: CreateInput): Promise<Model>
  update(id: string, data: UpdateInput): Promise<Model>
  delete(id: string): Promise<Model>
  count(where?: any): Promise<number>
}

/* Query Builder Types */
export type WhereCondition<T> = {
  [K in keyof T]?: T[K] | {
    equals?: T[K]
    not?: T[K]
    in?: T[K][]
    notIn?: T[K][]
    lt?: T[K]
    lte?: T[K]
    gt?: T[K]
    gte?: T[K]
    contains?: string
    startsWith?: string
    endsWith?: string
  }
}

export type OrderByCondition<T> = {
  [K in keyof T]?: 'asc' | 'desc'
}

/* Migration Types */
export interface MigrationInfo {
  id: string
  checksum: string
  finished_at: Date | null
  migration_name: string
  logs: string | null
  rolled_back_at: Date | null
  started_at: Date
  applied_steps_count: number
}

/* Connection Types */
export interface DatabaseConfig {
  url: string
  shadowDatabaseUrl?: string
  directUrl?: string
}

export interface ConnectionOptions {
  maxConnections?: number
  timeout?: number
  ssl?: boolean
}
```

---

## 🔨 Development Workflow Configuration

### 1. Package.json Scripts for TypeScript

```json
{
  "scripts": {
    /* Development */
    "dev": "tsx watch src/index.ts",
    "dev:debug": "tsx watch --inspect src/index.ts",
    "dev:clean": "rm -rf dist .tsbuildinfo && npm run dev",
    
    /* Building */
    "build": "tsc -p tsconfig.build.json",
    "build:dev": "tsc -p tsconfig.dev.json",
    "build:watch": "tsc -p tsconfig.build.json --watch",
    "build:clean": "rm -rf dist .tsbuildinfo && npm run build",
    
    /* Type Checking */
    "type-check": "tsc --noEmit",
    "type-check:watch": "tsc --noEmit --watch",
    "type-check:dev": "tsc -p tsconfig.dev.json --noEmit",
    
    /* Prisma + TypeScript */
    "prisma:generate": "prisma generate && npm run type-check",
    "prisma:migrate": "prisma migrate dev && prisma generate && npm run type-check",
    "prisma:reset": "prisma migrate reset --force && prisma generate && npm run type-check",
    "prisma:deploy": "prisma migrate deploy && prisma generate",
    
    /* Testing */
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage",
    "test:types": "tsc --noEmit && vitest --typecheck",
    
    /* Linting */
    "lint": "eslint src tests --ext .ts,.tsx",
    "lint:fix": "eslint src tests --ext .ts,.tsx --fix",
    "lint:types": "npm run type-check && npm run lint",
    
    /* Formatting */
    "format": "prettier --write src tests prisma",
    "format:check": "prettier --check src tests prisma",
    
    /* Complete Checks */
    "check": "npm run type-check && npm run lint && npm run format:check",
    "check:fix": "npm run type-check && npm run lint:fix && npm run format",
    
    /* Production */
    "start": "node dist/index.js",
    "start:prod": "NODE_ENV=production node dist/index.js",
    
    /* Utilities */
    "clean": "rm -rf dist .tsbuildinfo coverage",
    "reset": "npm run clean && rm -rf node_modules && npm install",
    "setup": "npm install && npm run prisma:generate && npm run build"
  }
}
```

### 2. TypeScript Development Dependencies

```json
{
  "devDependencies": {
    /* TypeScript Core */
    "typescript": "^5.2.2",
    "tsx": "^3.12.7",
    "@types/node": "^20.5.1",
    
    /* Prisma */
    "prisma": "^5.3.1",
    "@prisma/client": "^5.3.1",
    
    /* Testing */
    "vitest": "^0.34.1",
    "@vitest/coverage-v8": "^0.34.1",
    "supertest": "^6.3.3",
    "@types/supertest": "^2.0.12",
    
    /* Linting & Formatting */
    "eslint": "^8.47.0",
    "@typescript-eslint/eslint-plugin": "^6.4.0",
    "@typescript-eslint/parser": "^6.4.0",
    "prettier": "^3.0.2",
    
    /* Path Resolution */
    "tsconfig-paths": "^4.2.0",
    "module-alias": "^2.2.3"
  }
}
```

### 3. Path Resolution Setup

Configure path resolution for cleaner imports:

```typescript
// src/utils/path-resolver.ts
import moduleAlias from 'module-alias'
import path from 'path'

// Register path aliases for runtime
moduleAlias.addAliases({
  '@': path.join(__dirname, '..'),
  '@/types': path.join(__dirname, '..', 'types'),
  '@/utils': path.join(__dirname, '..', 'utils'),
  '@/config': path.join(__dirname, '..', 'config'),
  '@/db': path.join(__dirname, '..', 'db'),
  '@/services': path.join(__dirname, '..', 'services'),
  '@/controllers': path.join(__dirname, '..', 'controllers'),
  '@/middleware': path.join(__dirname, '..', 'middleware'),
})

// For testing environments
if (process.env.NODE_ENV === 'test') {
  moduleAlias.addAlias('@/tests', path.join(__dirname, '..', '..', 'tests'))
}
```

---

## 🧪 Testing Configuration

### 1. Vitest Configuration with TypeScript

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import path from 'path'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./tests/setup.ts'],
    include: ['tests/**/*.test.ts', 'src/**/*.test.ts'],
    exclude: ['node_modules', 'dist', 'coverage'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: ['node_modules/', 'dist/', 'tests/', '**/*.d.ts'],
    },
    typecheck: {
      checker: 'tsc',
      tsconfig: './tsconfig.dev.json',
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/types': path.resolve(__dirname, './src/types'),
      '@/utils': path.resolve(__dirname, './src/utils'),
      '@/config': path.resolve(__dirname, './src/config'),
      '@/db': path.resolve(__dirname, './src/db'),
      '@/services': path.resolve(__dirname, './src/services'),
      '@/controllers': path.resolve(__dirname, './src/controllers'),
      '@/middleware': path.resolve(__dirname, './src/middleware'),
      '@/tests': path.resolve(__dirname, './tests'),
    },
  },
})
```

### 2. Test Setup with TypeScript

```typescript
// tests/setup.ts
import { beforeAll, afterAll, beforeEach, afterEach } from 'vitest'
import { PrismaClient } from '@prisma/client'
import { mockDeep, mockReset, DeepMockProxy } from 'vitest-mock-extended'

/* Global Test Setup */
const prisma = new PrismaClient()

beforeAll(async () => {
  // Connect to test database
  await prisma.$connect()
  console.log('📊 Connected to test database')
})

afterAll(async () => {
  // Cleanup and disconnect
  await prisma.$disconnect()
  console.log('🔌 Disconnected from test database')
})

beforeEach(async () => {
  // Reset database state before each test
  await prisma.$transaction([
    prisma.comment.deleteMany(),
    prisma.post.deleteMany(),
    prisma.profile.deleteMany(),
    prisma.user.deleteMany(),
  ])
})

afterEach(() => {
  mockReset(prismaMock)
})

/* Mock Prisma Client for Unit Tests */
export const prismaMock = mockDeep<PrismaClient>() as unknown as DeepMockProxy<PrismaClient>

/* Test Utilities */
export async function createTestUser(overrides: Partial<any> = {}) {
  return prisma.user.create({
    data: {
      email: 'test@example.com',
      name: 'Test User',
      ...overrides,
    },
  })
}

export async function createTestPost(authorId: string, overrides: Partial<any> = {}) {
  return prisma.post.create({
    data: {
      title: 'Test Post',
      content: 'Test content',
      authorId,
      ...overrides,
    },
  })
}

/* Type-safe Test Assertions */
export function assertIsArray<T>(value: unknown): asserts value is T[] {
  if (!Array.isArray(value)) {
    throw new Error('Expected array')
  }
}

export function assertIsObject<T extends object>(value: unknown): asserts value is T {
  if (typeof value !== 'object' || value === null) {
    throw new Error('Expected object')
  }
}
```

### 3. Example TypeScript Test

```typescript
// tests/services/user.service.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { UserService } from '@/services/user.service'
import { prismaMock, createTestUser } from '@/tests/setup'
import { CreateUserInput, UserWithProfile } from '@/types/prisma'

describe('UserService', () => {
  let userService: UserService
  
  beforeEach(() => {
    userService = new UserService(prismaMock)
  })
  
  describe('createUser', () => {
    it('should create a user with valid data', async () => {
      // Arrange
      const userData: CreateUserInput = {
        email: 'test@example.com',
        name: 'Test User',
      }
      
      const expectedUser = {
        id: '1',
        ...userData,
        createdAt: new Date(),
        updatedAt: new Date(),
      }
      
      prismaMock.user.create.mockResolvedValue(expectedUser)
      
      // Act
      const result = await userService.createUser(userData)
      
      // Assert
      expect(result).toEqual(expectedUser)
      expect(prismaMock.user.create).toHaveBeenCalledWith({
        data: userData,
      })
    })
    
    it('should throw error for duplicate email', async () => {
      // Arrange
      const userData: CreateUserInput = {
        email: 'existing@example.com',
        name: 'Test User',
      }
      
      prismaMock.user.create.mockRejectedValue(
        new Error('Unique constraint failed')
      )
      
      // Act & Assert
      await expect(userService.createUser(userData)).rejects.toThrow(
        'Unique constraint failed'
      )
    })
  })
  
  describe('getUserWithProfile', () => {
    it('should return user with profile', async () => {
      // Arrange
      const userId = '1'
      const expectedUser: UserWithProfile = {
        id: userId,
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
        profile: {
          id: '1',
          userId: userId,
          bio: 'Test bio',
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      }
      
      prismaMock.user.findUnique.mockResolvedValue(expectedUser)
      
      // Act
      const result = await userService.getUserWithProfile(userId)
      
      // Assert
      expect(result).toEqual(expectedUser)
      expect(prismaMock.user.findUnique).toHaveBeenCalledWith({
        where: { id: userId },
        include: { profile: true },
      })
    })
    
    it('should return null for non-existent user', async () => {
      // Arrange
      const userId = 'non-existent'
      prismaMock.user.findUnique.mockResolvedValue(null)
      
      // Act
      const result = await userService.getUserWithProfile(userId)
      
      // Assert
      expect(result).toBeNull()
    })
  })
})
```

---

## 🔧 Advanced TypeScript Patterns

### 1. Type-Safe Repository Pattern

```typescript
// src/repositories/base.repository.ts
import { PrismaClient } from '@prisma/client'

export abstract class BaseRepository<
  Model,
  CreateInput,
  UpdateInput,
  WhereInput = any,
  IncludeInput = any
> {
  constructor(protected prisma: PrismaClient) {}
  
  abstract get modelName(): string
  
  abstract findById(
    id: string,
    include?: IncludeInput
  ): Promise<Model | null>
  
  abstract findMany(options?: {
    where?: WhereInput
    include?: IncludeInput
    orderBy?: any
    skip?: number
    take?: number
  }): Promise<Model[]>
  
  abstract create(
    data: CreateInput,
    include?: IncludeInput
  ): Promise<Model>
  
  abstract update(
    id: string,
    data: UpdateInput,
    include?: IncludeInput
  ): Promise<Model>
  
  abstract delete(id: string): Promise<Model>
  
  abstract count(where?: WhereInput): Promise<number>
}

// src/repositories/user.repository.ts
import { Prisma, User } from '@prisma/client'
import { BaseRepository } from './base.repository'

export class UserRepository extends BaseRepository<
  User,
  Prisma.UserCreateInput,
  Prisma.UserUpdateInput,
  Prisma.UserWhereInput,
  Prisma.UserInclude
> {
  get modelName() {
    return 'user'
  }
  
  async findById(id: string, include?: Prisma.UserInclude) {
    return this.prisma.user.findUnique({
      where: { id },
      include,
    })
  }
  
  async findByEmail(email: string, include?: Prisma.UserInclude) {
    return this.prisma.user.findUnique({
      where: { email },
      include,
    })
  }
  
  async findMany(options?: {
    where?: Prisma.UserWhereInput
    include?: Prisma.UserInclude
    orderBy?: Prisma.UserOrderByWithRelationInput
    skip?: number
    take?: number
  }) {
    return this.prisma.user.findMany(options)
  }
  
  async create(data: Prisma.UserCreateInput, include?: Prisma.UserInclude) {
    return this.prisma.user.create({
      data,
      include,
    })
  }
  
  async update(
    id: string,
    data: Prisma.UserUpdateInput,
    include?: Prisma.UserInclude
  ) {
    return this.prisma.user.update({
      where: { id },
      data,
      include,
    })
  }
  
  async delete(id: string) {
    return this.prisma.user.delete({
      where: { id },
    })
  }
  
  async count(where?: Prisma.UserWhereInput) {
    return this.prisma.user.count({ where })
  }
}
```

### 2. Type-Safe Service Layer

```typescript
// src/services/user.service.ts
import { UserRepository } from '@/repositories/user.repository'
import { CreateUserInput, UpdateUserInput, UserWithProfile } from '@/types/prisma'
import { ServiceResult, ValidationResult } from '@/types/prisma'

export class UserService {
  constructor(private userRepository: UserRepository) {}
  
  async createUser(data: CreateUserInput): Promise<ServiceResult<UserWithProfile>> {
    try {
      // Validate input
      const validation = await this.validateCreateInput(data)
      if (!validation.isValid) {
        return {
          success: false,
          errors: Object.values(validation.errors).flat(),
        }
      }
      
      // Check for existing email
      const existingUser = await this.userRepository.findByEmail(data.email)
      if (existingUser) {
        return {
          success: false,
          error: 'User with this email already exists',
        }
      }
      
      // Create user
      const user = await this.userRepository.create(data, {
        profile: true,
      })
      
      return {
        success: true,
        data: user as UserWithProfile,
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }
  
  async getUserById(id: string): Promise<ServiceResult<UserWithProfile>> {
    try {
      const user = await this.userRepository.findById(id, {
        profile: true,
      })
      
      if (!user) {
        return {
          success: false,
          error: 'User not found',
        }
      }
      
      return {
        success: true,
        data: user as UserWithProfile,
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }
  
  private async validateCreateInput(data: CreateUserInput): Promise<ValidationResult> {
    const errors: Record<string, string[]> = {}
    
    // Email validation
    if (!data.email) {
      errors.email = ['Email is required']
    } else if (!this.isValidEmail(data.email)) {
      errors.email = ['Invalid email format']
    }
    
    // Name validation
    if (!data.name) {
      errors.name = ['Name is required']
    } else if (data.name.length < 2) {
      errors.name = ['Name must be at least 2 characters']
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors,
    }
  }
  
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  }
}
```

### 3. Type-Safe Controllers

```typescript
// src/controllers/user.controller.ts
import { Request, Response } from 'express'
import { UserService } from '@/services/user.service'
import { CreateUserInput } from '@/types/prisma'
import { z } from 'zod'

const createUserSchema = z.object({
  email: z.string().email('Invalid email format'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
})

const updateUserSchema = z.object({
  email: z.string().email().optional(),
  name: z.string().min(2).optional(),
})

export class UserController {
  constructor(private userService: UserService) {}
  
  async createUser(req: Request, res: Response) {
    try {
      // Validate request body
      const validation = createUserSchema.safeParse(req.body)
      if (!validation.success) {
        return res.status(400).json({
          error: 'Validation failed',
          details: validation.error.errors,
        })
      }
      
      const userData = validation.data as CreateUserInput
      const result = await this.userService.createUser(userData)
      
      if (!result.success) {
        return res.status(400).json({
          error: result.error || 'Failed to create user',
          details: result.errors,
        })
      }
      
      res.status(201).json({
        message: 'User created successfully',
        data: result.data,
      })
    } catch (error) {
      console.error('Error creating user:', error)
      res.status(500).json({
        error: 'Internal server error',
      })
    }
  }
  
  async getUserById(req: Request, res: Response) {
    try {
      const { id } = req.params
      
      if (!id) {
        return res.status(400).json({
          error: 'User ID is required',
        })
      }
      
      const result = await this.userService.getUserById(id)
      
      if (!result.success) {
        const statusCode = result.error === 'User not found' ? 404 : 400
        return res.status(statusCode).json({
          error: result.error,
        })
      }
      
      res.json({
        message: 'User retrieved successfully',
        data: result.data,
      })
    } catch (error) {
      console.error('Error retrieving user:', error)
      res.status(500).json({
        error: 'Internal server error',
      })
    }
  }
}
```

---

## 🧠 Knowledge Check

### TypeScript Configuration Quiz

1. **Which TypeScript compiler option is most important for Prisma type safety?**
   - [ ] A) `noImplicitAny`
   - [x] B) `strict`
   - [ ] C) `declaration`
   - [ ] D) `sourceMap`

   **Explanation**: The `strict` flag enables all strict type checking options, which is essential for type safety with Prisma.

2. **What is the recommended way to handle Prisma-generated types?**
   - [ ] A) Copy them to a separate file
   - [ ] B) Modify them directly
   - [x] C) Extend them with custom utility types
   - [ ] D) Ignore them completely

   **Explanation**: You should extend Prisma-generated types with custom utility types rather than modifying the generated code.

3. **Which file should contain global type declarations?**
   - [ ] A) index.ts
   - [ ] B) types.ts
   - [x] C) global.d.ts
   - [ ] D) prisma.d.ts

   **Explanation**: `global.d.ts` is the conventional file for global type declarations that should be available throughout the project.

### Practical Exercise: Complete TypeScript Setup

**Challenge**: Set up a complete TypeScript configuration for a Prisma project

**Tasks**:
1. Create comprehensive tsconfig.json with Prisma optimizations
2. Set up global type declarations
3. Create Prisma type extensions
4. Configure development and build scripts
5. Set up testing with TypeScript

**Validation Checklist**:
- [ ] tsconfig.json has strict type checking enabled
- [ ] Path mapping is configured for clean imports
- [ ] Global types include environment variables
- [ ] Prisma types are properly extended
- [ ] Build and development scripts work correctly
- [ ] Tests run with full type checking

---

## 💡 Key Takeaways

- 🔧 **Strict Configuration**: Enable strict TypeScript settings for maximum type safety with Prisma
- 📦 **Type Extensions**: Extend Prisma-generated types rather than modifying them directly
- 🛠️ **Development Workflow**: Configure separate TypeScript settings for development and production
- 🧪 **Testing Setup**: Include TypeScript type checking in your test pipeline
- 📁 **Path Mapping**: Use path aliases for cleaner imports and better code organization
- 🔍 **Type Validation**: Implement runtime validation alongside TypeScript compile-time checking
- ⚡ **Performance**: Optimize TypeScript configuration for fast compilation and development experience

---

## 🔗 Navigation

**📍 Current Location**: Module 2 → Section 2.1 → Lesson 2.1.5

**⬅️ Previous**: [2.1.4 Environment Variables & .env Setup](./2.1.4-environment-variables-env-setup.md)
**➡️ Next**: [2.2.1 Creating Your First Schema](../2.2-first-prisma-project/2.2.1-creating-your-first-schema.md)

**🏠 Section Home**: [2.1 Installation & Setup](./README.md)
**📚 Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**🗺️ Quick Links**:
- [Next: First Schema](../2.2-first-prisma-project/2.2.1-creating-your-first-schema.md)
- [Jump to: Database Connection](../2.3-database-connection/2.3.1-connecting-to-postgresql.md)
- [Official Docs: TypeScript](https://www.prisma.io/docs/concepts/more/comparisons/prisma-and-typeorm#type-safety)

---

*Excellent! You've mastered TypeScript configuration for Prisma. Ready to create your first schema and start building? Continue to the next section!*
