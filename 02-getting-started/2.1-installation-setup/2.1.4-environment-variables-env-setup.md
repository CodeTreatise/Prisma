# 2.1.4 Environment Variables & .env Setup

## üìã Section Overview
- **Duration**: 35 minutes
- **Prerequisites**: 
  - Completed lessons 2.1.1 - 2.1.3
  - Understanding of Node.js environment variables
  - Basic security awareness
  - Prisma CLI and Client installed
- **Learning Objectives**: 
  - Master environment variable management for Prisma
  - Configure secure database connections
  - Set up multi-environment workflows
  - Implement security best practices
  - Handle environment-specific configurations
- **Difficulty Level**: Beginner to Intermediate

---

## üéØ What You'll Learn

By the end of this section, you will:
- ‚úÖ Configure `.env` files for different environments
- ‚úÖ Secure database connection strings and sensitive data
- ‚úÖ Set up development, staging, and production configurations
- ‚úÖ Implement environment variable validation and fallbacks
- ‚úÖ Use dotenv patterns and best practices
- ‚úÖ Handle multi-database and multi-environment scenarios
- ‚úÖ Configure Prisma-specific environment variables

---

## üìñ Content

### Understanding Environment Variables in Prisma

Managing environment variables in Prisma is like **operating a high-security vault system**. Just as a bank vault requires different access codes, security levels, and protocols for different areas (public lobby, teller area, vault), your application needs different configurations and security measures for different environments while keeping sensitive information properly protected.

### üè¶ The High-Security Vault System Analogy

```
üè¶ Bank Security System = üîê Environment Variable Management

üîê Access Control Levels (Environment Types)
‚îú‚îÄ‚îÄ Public Lobby ‚Üí Development environment
‚îú‚îÄ‚îÄ Teller Area ‚Üí Staging environment  
‚îú‚îÄ‚îÄ Manager Office ‚Üí Testing environment
‚îú‚îÄ‚îÄ Vault Room ‚Üí Production environment
‚îú‚îÄ‚îÄ Emergency Protocols ‚Üí Fallback configurations
‚îî‚îÄ‚îÄ Audit Trail ‚Üí Environment logging

üóùÔ∏è Security Keys & Codes (Environment Variables)
‚îú‚îÄ‚îÄ Master Key ‚Üí DATABASE_URL
‚îú‚îÄ‚îÄ Access Codes ‚Üí API keys and secrets
‚îú‚îÄ‚îÄ Backup Keys ‚Üí Fallback configurations
‚îú‚îÄ‚îÄ Emergency Codes ‚Üí Default values
‚îú‚îÄ‚îÄ Audit Codes ‚Üí Logging levels
‚îî‚îÄ‚îÄ Transfer Codes ‚Üí Service connections

üõ°Ô∏è Security Protocols (Best Practices)
‚îú‚îÄ‚îÄ Key Rotation ‚Üí Regular secret updates
‚îú‚îÄ‚îÄ Access Logging ‚Üí Environment tracking
‚îú‚îÄ‚îÄ Compartmentalization ‚Üí Separate environments
‚îú‚îÄ‚îÄ Backup Systems ‚Üí Fallback strategies
‚îú‚îÄ‚îÄ Audit Procedures ‚Üí Configuration validation
‚îî‚îÄ‚îÄ Emergency Procedures ‚Üí Error handling

üèóÔ∏è Vault Architecture (Configuration Structure)
‚îú‚îÄ‚îÄ Blueprint Plans ‚Üí .env.example files
‚îú‚îÄ‚îÄ Construction Phases ‚Üí Environment setup
‚îú‚îÄ‚îÄ Security Installation ‚Üí Variable validation
‚îú‚îÄ‚îÄ System Testing ‚Üí Configuration testing
‚îú‚îÄ‚îÄ Operational Procedures ‚Üí Runtime management
‚îî‚îÄ‚îÄ Maintenance Protocols ‚Üí Updates and rotation
```

---

## üîß Environment Variable Fundamentals

### Understanding Prisma's Environment Variables

Prisma uses several key environment variables to configure database connections and behavior:

#### **Primary Variables**

| Variable | Purpose | Required | Example |
|----------|---------|----------|---------|
| `DATABASE_URL` | Main database connection | ‚úÖ | `postgresql://user:pass@localhost:5432/mydb` |
| `DIRECT_URL` | Direct database connection (Prisma Accelerate) | ‚ùå | `postgresql://user:pass@localhost:5432/mydb` |
| `PRISMA_ENGINE_TYPE` | Query engine type | ‚ùå | `library` or `binary` |
| `PRISMA_CLIENT_ENGINE_TYPE` | Client engine type | ‚ùå | `library` |

#### **Secondary Variables**

| Variable | Purpose | Default | Usage |
|----------|---------|---------|-------|
| `PRISMA_ENGINES_MIRROR` | Engine download mirror | Official CDN | Corporate networks |
| `PRISMA_QUERY_ENGINE_LIBRARY` | Custom engine path | Auto-detected | Custom builds |
| `PRISMA_HIDE_UPDATE_MESSAGE` | Hide update notifications | `false` | CI/CD environments |
| `DEBUG` | Enable debug logging | None | `prisma:*` |

---

## üìÅ .env File Configuration

### 1. Basic .env File Structure

Create a comprehensive `.env` file for your Prisma project:

```bash
# .env
# ==========================================
# Prisma Database Configuration
# ==========================================

# Primary database connection
# Format: postgresql://username:password@hostname:port/database_name
DATABASE_URL="postgresql://postgres:mypassword@localhost:5432/myapp_dev"

# Optional: Direct connection for Prisma Accelerate
# DIRECT_URL="postgresql://postgres:mypassword@localhost:5432/myapp_dev"

# ==========================================
# Application Environment
# ==========================================

# Environment type
NODE_ENV="development"

# Application settings
APP_PORT=3000
APP_HOST="localhost"
APP_SECRET="your-super-secret-key-change-in-production"

# ==========================================
# External Services
# ==========================================

# Redis configuration
REDIS_URL="redis://localhost:6379"

# Email service
SMTP_HOST="smtp.gmail.com"
SMTP_PORT=587
SMTP_USER="your-email@gmail.com"
SMTP_PASS="your-app-password"

# File storage
AWS_ACCESS_KEY_ID="your-aws-access-key"
AWS_SECRET_ACCESS_KEY="your-aws-secret-key"
AWS_S3_BUCKET="your-bucket-name"
AWS_REGION="us-east-1"

# ==========================================
# Prisma Configuration
# ==========================================

# Engine configuration
PRISMA_CLIENT_ENGINE_TYPE="library"
PRISMA_HIDE_UPDATE_MESSAGE="true"

# Debug settings (development only)
DEBUG="prisma:query,prisma:info"

# ==========================================
# Security & Logging
# ==========================================

# JWT configuration
JWT_SECRET="your-jwt-secret-key"
JWT_EXPIRES_IN="7d"

# Logging level
LOG_LEVEL="info"

# Rate limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
```

### 2. Environment-Specific Configurations

#### **Development Environment (.env.development)**

```bash
# .env.development
# Development-specific settings

DATABASE_URL="postgresql://postgres:devpassword@localhost:5432/myapp_dev"

NODE_ENV="development"
APP_PORT=3000
LOG_LEVEL="debug"

# Development features
DEBUG="prisma:*"
PRISMA_HIDE_UPDATE_MESSAGE="false"

# Relaxed security for development
JWT_EXPIRES_IN="30d"
RATE_LIMIT_MAX_REQUESTS=1000

# Local services
REDIS_URL="redis://localhost:6379"
SMTP_HOST="localhost"
SMTP_PORT=1025  # MailHog for testing
```

#### **Staging Environment (.env.staging)**

```bash
# .env.staging
# Staging environment configuration

DATABASE_URL="postgresql://staginguser:stagingpass@staging-db:5432/myapp_staging"

NODE_ENV="staging"
APP_PORT=3000
LOG_LEVEL="info"

# Staging-specific settings
DEBUG=""
PRISMA_HIDE_UPDATE_MESSAGE="true"

# Production-like security
JWT_EXPIRES_IN="7d"
RATE_LIMIT_MAX_REQUESTS=200

# External services
REDIS_URL="redis://staging-redis:6379"
AWS_S3_BUCKET="myapp-staging-assets"
```

#### **Production Environment (.env.production)**

```bash
# .env.production
# Production environment configuration

DATABASE_URL="${DATABASE_URL}"  # Injected by deployment platform

NODE_ENV="production"
APP_PORT="${PORT:-3000}"  # Platform-provided port
LOG_LEVEL="warn"

# Production security
DEBUG=""
PRISMA_HIDE_UPDATE_MESSAGE="true"
PRISMA_CLIENT_ENGINE_TYPE="library"

# Strict security settings
JWT_EXPIRES_IN="1d"
RATE_LIMIT_MAX_REQUESTS=50

# Production services
REDIS_URL="${REDIS_URL}"
AWS_S3_BUCKET="${AWS_S3_BUCKET}"
```

### 3. .env.example Template

Create a template file for team members:

```bash
# .env.example
# Copy this file to .env and fill in your values
# ==========================================

# ==========================================
# Required Variables
# ==========================================

# Database connection (REQUIRED)
DATABASE_URL="postgresql://username:password@localhost:5432/database_name"

# Application environment
NODE_ENV="development"
APP_PORT=3000
APP_SECRET="change-this-in-production"

# ==========================================
# Optional Variables
# ==========================================

# Prisma configuration
# PRISMA_CLIENT_ENGINE_TYPE="library"
# PRISMA_HIDE_UPDATE_MESSAGE="true"
# DEBUG="prisma:query"

# External services
# REDIS_URL="redis://localhost:6379"
# SMTP_HOST="smtp.gmail.com"
# SMTP_PORT=587
# SMTP_USER="your-email@example.com"
# SMTP_PASS="your-password"

# ==========================================
# Development Only
# ==========================================

# Debug settings (development)
# DEBUG="prisma:*"
# LOG_LEVEL="debug"

# ==========================================
# Instructions
# ==========================================

# 1. Copy this file: cp .env.example .env
# 2. Fill in your database credentials
# 3. Generate a secure APP_SECRET
# 4. Configure external services as needed
# 5. Never commit the .env file to version control!
```

---

## üîí Security Best Practices

### 1. Environment Variable Validation

Create a validation system for environment variables:

```typescript
// src/config/env-validation.ts
import { z } from 'zod'

const envSchema = z.object({
  // Database
  DATABASE_URL: z.string().url('Invalid DATABASE_URL format'),
  DIRECT_URL: z.string().url().optional(),
  
  // Application
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  APP_PORT: z.coerce.number().min(1).max(65535).default(3000),
  APP_SECRET: z.string().min(32, 'APP_SECRET must be at least 32 characters'),
  
  // JWT
  JWT_SECRET: z.string().min(32, 'JWT_SECRET must be at least 32 characters'),
  JWT_EXPIRES_IN: z.string().default('7d'),
  
  // External services
  REDIS_URL: z.string().url().optional(),
  AWS_ACCESS_KEY_ID: z.string().optional(),
  AWS_SECRET_ACCESS_KEY: z.string().optional(),
  AWS_S3_BUCKET: z.string().optional(),
  AWS_REGION: z.string().default('us-east-1'),
  
  // Prisma
  PRISMA_CLIENT_ENGINE_TYPE: z.enum(['library', 'binary']).optional(),
  PRISMA_HIDE_UPDATE_MESSAGE: z.string().optional(),
  DEBUG: z.string().optional(),
  
  // Logging
  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),
})

export type EnvConfig = z.infer<typeof envSchema>

export function validateEnv(): EnvConfig {
  try {
    return envSchema.parse(process.env)
  } catch (error) {
    console.error('‚ùå Invalid environment configuration:')
    if (error instanceof z.ZodError) {
      error.errors.forEach(err => {
        console.error(`  ${err.path.join('.')}: ${err.message}`)
      })
    }
    process.exit(1)
  }
}

// Usage in your application
export const env = validateEnv()
```

### 2. Configuration Management

Create a centralized configuration system:

```typescript
// src/config/index.ts
import { validateEnv } from './env-validation'
import { PrismaClient } from '@prisma/client'

const env = validateEnv()

export const config = {
  // Database
  database: {
    url: env.DATABASE_URL,
    directUrl: env.DIRECT_URL,
  },
  
  // Application
  app: {
    env: env.NODE_ENV,
    port: env.APP_PORT,
    secret: env.APP_SECRET,
    isDevelopment: env.NODE_ENV === 'development',
    isProduction: env.NODE_ENV === 'production',
    isStaging: env.NODE_ENV === 'staging',
  },
  
  // Authentication
  jwt: {
    secret: env.JWT_SECRET,
    expiresIn: env.JWT_EXPIRES_IN,
  },
  
  // External services
  redis: {
    url: env.REDIS_URL,
  },
  
  aws: {
    accessKeyId: env.AWS_ACCESS_KEY_ID,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY,
    s3Bucket: env.AWS_S3_BUCKET,
    region: env.AWS_REGION,
  },
  
  // Prisma
  prisma: {
    clientEngineType: env.PRISMA_CLIENT_ENGINE_TYPE,
    hideUpdateMessage: env.PRISMA_HIDE_UPDATE_MESSAGE === 'true',
    debug: env.DEBUG,
  },
  
  // Logging
  logging: {
    level: env.LOG_LEVEL,
  },
}

// Create Prisma client with configuration
export const prisma = new PrismaClient({
  log: env.NODE_ENV === 'development' 
    ? ['query', 'info', 'warn', 'error']
    : ['warn', 'error'],
  
  datasources: {
    db: {
      url: config.database.url,
    },
  },
})

export default config
```

### 3. Secret Management

#### **For Development**

```typescript
// scripts/generate-secrets.ts
import crypto from 'crypto'
import fs from 'fs'

function generateSecret(length: number = 64): string {
  return crypto.randomBytes(length).toString('hex')
}

function updateEnvFile() {
  const envPath = '.env'
  let envContent = ''
  
  if (fs.existsSync(envPath)) {
    envContent = fs.readFileSync(envPath, 'utf8')
  }
  
  const secrets = {
    APP_SECRET: generateSecret(32),
    JWT_SECRET: generateSecret(32),
  }
  
  Object.entries(secrets).forEach(([key, value]) => {
    const regex = new RegExp(`^${key}=.*$`, 'm')
    const line = `${key}="${value}"`
    
    if (regex.test(envContent)) {
      envContent = envContent.replace(regex, line)
    } else {
      envContent += `\n${line}`
    }
  })
  
  fs.writeFileSync(envPath, envContent.trim() + '\n')
  
  console.log('üîê Generated new secrets:')
  Object.keys(secrets).forEach(key => {
    console.log(`  ‚úÖ ${key}`)
  })
}

updateEnvFile()
```

#### **For Production**

```bash
# Use your deployment platform's secret management
# Example for Vercel:
vercel env add DATABASE_URL
vercel env add JWT_SECRET

# Example for Railway:
railway variables set DATABASE_URL="postgresql://..."
railway variables set JWT_SECRET="your-secret"

# Example for Docker:
docker run -e DATABASE_URL="postgresql://..." \
           -e JWT_SECRET="your-secret" \
           your-app
```

---

## üåç Multi-Environment Setup

### 1. Environment Loading Strategy

Create a robust environment loading system:

```typescript
// src/config/env-loader.ts
import dotenv from 'dotenv'
import path from 'path'

export function loadEnvironment(): void {
  const environment = process.env.NODE_ENV || 'development'
  
  // Load environment-specific .env file first
  const envFiles = [
    `.env.${environment}.local`,
    `.env.${environment}`,
    '.env.local',
    '.env',
  ]
  
  console.log(`üåç Loading environment: ${environment}`)
  
  envFiles.forEach(file => {
    const filePath = path.resolve(process.cwd(), file)
    
    try {
      const result = dotenv.config({ path: filePath })
      if (result.error) {
        // File doesn't exist, continue to next
        return
      }
      console.log(`  ‚úÖ Loaded: ${file}`)
    } catch (error) {
      console.warn(`  ‚ö†Ô∏è  Failed to load: ${file}`)
    }
  })
  
  // Validate required variables
  const required = ['DATABASE_URL']
  const missing = required.filter(key => !process.env[key])
  
  if (missing.length > 0) {
    console.error('‚ùå Missing required environment variables:')
    missing.forEach(key => console.error(`  - ${key}`))
    process.exit(1)
  }
  
  console.log('‚úÖ Environment loaded successfully')
}

// Load environment variables before anything else
loadEnvironment()
```

### 2. Database URL Management

Handle different database configurations:

```typescript
// src/config/database.ts
import { config } from './index'

export interface DatabaseConfig {
  url: string
  maxConnections: number
  ssl: boolean
  schema?: string
}

export function getDatabaseConfig(): DatabaseConfig {
  const { app, database } = config
  
  // Parse DATABASE_URL for configuration
  const url = new URL(database.url)
  
  const baseConfig: DatabaseConfig = {
    url: database.url,
    maxConnections: 20,
    ssl: false,
  }
  
  // Environment-specific configurations
  switch (app.env) {
    case 'development':
      return {
        ...baseConfig,
        maxConnections: 5,
        ssl: false,
      }
    
    case 'staging':
      return {
        ...baseConfig,
        maxConnections: 10,
        ssl: url.protocol === 'postgres:' && url.hostname !== 'localhost',
      }
    
    case 'production':
      return {
        ...baseConfig,
        maxConnections: 20,
        ssl: true,
      }
    
    default:
      return baseConfig
  }
}

// Connection string builders for different scenarios
export function buildDatabaseUrl(options: {
  host: string
  port: number
  database: string
  username: string
  password: string
  ssl?: boolean
  schema?: string
}): string {
  const { host, port, database, username, password, ssl, schema } = options
  
  let url = `postgresql://${username}:${password}@${host}:${port}/${database}`
  
  const params: string[] = []
  if (ssl) params.push('sslmode=require')
  if (schema) params.push(`schema=${schema}`)
  
  if (params.length > 0) {
    url += `?${params.join('&')}`
  }
  
  return url
}

// Example usage for different environments
export const databaseUrls = {
  development: buildDatabaseUrl({
    host: 'localhost',
    port: 5432,
    database: 'myapp_dev',
    username: 'postgres',
    password: 'devpassword',
  }),
  
  staging: buildDatabaseUrl({
    host: 'staging-db.example.com',
    port: 5432,
    database: 'myapp_staging',
    username: 'staging_user',
    password: process.env.STAGING_DB_PASSWORD!,
    ssl: true,
  }),
  
  production: buildDatabaseUrl({
    host: process.env.PROD_DB_HOST!,
    port: parseInt(process.env.PROD_DB_PORT!),
    database: process.env.PROD_DB_NAME!,
    username: process.env.PROD_DB_USER!,
    password: process.env.PROD_DB_PASSWORD!,
    ssl: true,
  }),
}
```

### 3. Environment Switching Scripts

Add convenient scripts to package.json:

```json
{
  "scripts": {
    "dev": "NODE_ENV=development tsx src/index.ts",
    "dev:staging": "NODE_ENV=staging tsx src/index.ts",
    "build": "NODE_ENV=production tsc",
    "start": "NODE_ENV=production node dist/index.js",
    
    "prisma:dev": "NODE_ENV=development prisma",
    "prisma:staging": "NODE_ENV=staging prisma",
    "prisma:prod": "NODE_ENV=production prisma",
    
    "db:migrate:dev": "NODE_ENV=development prisma migrate dev",
    "db:migrate:staging": "NODE_ENV=staging prisma migrate deploy",
    "db:migrate:prod": "NODE_ENV=production prisma migrate deploy",
    
    "db:studio:dev": "NODE_ENV=development prisma studio",
    "db:studio:staging": "NODE_ENV=staging prisma studio --port 5556",
    
    "env:generate-secrets": "tsx scripts/generate-secrets.ts",
    "env:validate": "tsx scripts/validate-env.ts",
    "env:show": "tsx scripts/show-env.ts"
  }
}
```

---

## üîç Environment Debugging & Monitoring

### 1. Environment Status Script

Create a script to check environment status:

```typescript
// scripts/show-env.ts
import { config } from '../src/config'
import { getDatabaseConfig } from '../src/config/database'

function maskSecret(value: string | undefined, showLength: number = 4): string {
  if (!value) return 'Not set'
  if (value.length <= showLength * 2) return '*'.repeat(value.length)
  
  const start = value.substring(0, showLength)
  const end = value.substring(value.length - showLength)
  const masked = '*'.repeat(value.length - showLength * 2)
  
  return `${start}${masked}${end}`
}

function showEnvironmentStatus(): void {
  console.log('üåç Environment Configuration Status\n')
  
  // Application settings
  console.log('üì± Application:')
  console.log(`  Environment: ${config.app.env}`)
  console.log(`  Port: ${config.app.port}`)
  console.log(`  Secret: ${maskSecret(config.app.secret)}`)
  console.log('')
  
  // Database
  const dbConfig = getDatabaseConfig()
  const dbUrl = new URL(config.database.url)
  console.log('üóÑÔ∏è  Database:')
  console.log(`  Host: ${dbUrl.hostname}:${dbUrl.port}`)
  console.log(`  Database: ${dbUrl.pathname.substring(1)}`)
  console.log(`  Username: ${dbUrl.username}`)
  console.log(`  Password: ${maskSecret(dbUrl.password)}`)
  console.log(`  SSL: ${dbConfig.ssl ? 'Enabled' : 'Disabled'}`)
  console.log(`  Max Connections: ${dbConfig.maxConnections}`)
  console.log('')
  
  // External services
  console.log('üîó External Services:')
  console.log(`  Redis: ${config.redis.url || 'Not configured'}`)
  console.log(`  AWS S3: ${config.aws.s3Bucket || 'Not configured'}`)
  console.log('')
  
  // Security
  console.log('üîê Security:')
  console.log(`  JWT Secret: ${maskSecret(config.jwt.secret)}`)
  console.log(`  JWT Expires: ${config.jwt.expiresIn}`)
  console.log('')
  
  // Prisma
  console.log('‚ö° Prisma:')
  console.log(`  Engine Type: ${config.prisma.clientEngineType || 'Default'}`)
  console.log(`  Debug: ${config.prisma.debug || 'Disabled'}`)
  console.log(`  Hide Updates: ${config.prisma.hideUpdateMessage}`)
  console.log('')
  
  // Environment validation
  console.log('‚úÖ Validation:')
  console.log(`  All required variables: Present`)
  console.log(`  Configuration: Valid`)
  console.log(`  Ready for: ${config.app.env} environment`)
}

showEnvironmentStatus()
```

### 2. Environment Testing

Create comprehensive environment tests:

```typescript
// tests/config/environment.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { validateEnv } from '../../src/config/env-validation'

describe('Environment Configuration', () => {
  const originalEnv = process.env
  
  beforeEach(() => {
    // Reset environment
    process.env = { ...originalEnv }
  })
  
  afterEach(() => {
    process.env = originalEnv
  })
  
  describe('Required Variables', () => {
    it('should validate with all required variables', () => {
      process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/test'
      process.env.APP_SECRET = 'a'.repeat(32)
      process.env.JWT_SECRET = 'b'.repeat(32)
      
      expect(() => validateEnv()).not.toThrow()
    })
    
    it('should fail without DATABASE_URL', () => {
      delete process.env.DATABASE_URL
      process.env.APP_SECRET = 'a'.repeat(32)
      process.env.JWT_SECRET = 'b'.repeat(32)
      
      expect(() => validateEnv()).toThrow()
    })
    
    it('should fail with short secrets', () => {
      process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/test'
      process.env.APP_SECRET = 'short'
      process.env.JWT_SECRET = 'short'
      
      expect(() => validateEnv()).toThrow()
    })
  })
  
  describe('Optional Variables', () => {
    it('should use defaults for optional variables', () => {
      process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/test'
      process.env.APP_SECRET = 'a'.repeat(32)
      process.env.JWT_SECRET = 'b'.repeat(32)
      
      const config = validateEnv()
      
      expect(config.NODE_ENV).toBe('development')
      expect(config.APP_PORT).toBe(3000)
      expect(config.LOG_LEVEL).toBe('info')
    })
  })
  
  describe('Database URL Validation', () => {
    it('should accept valid PostgreSQL URLs', () => {
      const validUrls = [
        'postgresql://user:pass@localhost:5432/db',
        'postgres://user:pass@localhost:5432/db',
        'postgresql://user@localhost/db',
      ]
      
      validUrls.forEach(url => {
        process.env.DATABASE_URL = url
        process.env.APP_SECRET = 'a'.repeat(32)
        process.env.JWT_SECRET = 'b'.repeat(32)
        
        expect(() => validateEnv()).not.toThrow()
      })
    })
    
    it('should reject invalid URLs', () => {
      const invalidUrls = [
        'not-a-url',
        'http://localhost',
        'invalid://localhost/db',
      ]
      
      invalidUrls.forEach(url => {
        process.env.DATABASE_URL = url
        process.env.APP_SECRET = 'a'.repeat(32)
        process.env.JWT_SECRET = 'b'.repeat(32)
        
        expect(() => validateEnv()).toThrow()
      })
    })
  })
})
```

---

## üöÄ Advanced Environment Patterns

### 1. Dynamic Environment Loading

```typescript
// src/config/dynamic-env.ts
import { z } from 'zod'

interface EnvironmentProvider {
  load(): Promise<Record<string, string>>
}

class FileEnvironmentProvider implements EnvironmentProvider {
  constructor(private filePath: string) {}
  
  async load(): Promise<Record<string, string>> {
    const { default: dotenv } = await import('dotenv')
    const result = dotenv.config({ path: this.filePath })
    return result.parsed || {}
  }
}

class AwsSecretsManagerProvider implements EnvironmentProvider {
  constructor(private secretName: string) {}
  
  async load(): Promise<Record<string, string>> {
    const { SecretsManagerClient, GetSecretValueCommand } = await import('@aws-sdk/client-secrets-manager')
    
    const client = new SecretsManagerClient({ region: 'us-east-1' })
    const response = await client.send(new GetSecretValueCommand({
      SecretId: this.secretName,
    }))
    
    return JSON.parse(response.SecretString || '{}')
  }
}

class VaultEnvironmentProvider implements EnvironmentProvider {
  constructor(private vaultUrl: string, private token: string) {}
  
  async load(): Promise<Record<string, string>> {
    // Implementation for HashiCorp Vault
    const response = await fetch(`${this.vaultUrl}/v1/secret/data/app`, {
      headers: { 'X-Vault-Token': this.token },
    })
    
    const data = await response.json()
    return data.data.data
  }
}

export class EnvironmentManager {
  private providers: EnvironmentProvider[] = []
  
  addProvider(provider: EnvironmentProvider): this {
    this.providers.push(provider)
    return this
  }
  
  async loadAll(): Promise<Record<string, string>> {
    const environments = await Promise.all(
      this.providers.map(provider => provider.load())
    )
    
    // Merge all environments (later providers override earlier ones)
    return Object.assign({}, ...environments)
  }
}

// Usage
export async function initializeEnvironment(): Promise<void> {
  const manager = new EnvironmentManager()
    .addProvider(new FileEnvironmentProvider('.env'))
    .addProvider(new FileEnvironmentProvider(`.env.${process.env.NODE_ENV}`))
  
  if (process.env.NODE_ENV === 'production') {
    // Add cloud secret providers for production
    if (process.env.AWS_SECRET_NAME) {
      manager.addProvider(new AwsSecretsManagerProvider(process.env.AWS_SECRET_NAME))
    }
  }
  
  const environment = await manager.loadAll()
  
  // Apply to process.env
  Object.assign(process.env, environment)
}
```

### 2. Configuration Hot Reloading

```typescript
// src/config/hot-reload.ts
import { watchFile } from 'fs'
import { EventEmitter } from 'events'

export class ConfigurationWatcher extends EventEmitter {
  private watchers: Map<string, any> = new Map()
  
  watch(filePath: string): void {
    if (this.watchers.has(filePath)) return
    
    const watcher = watchFile(filePath, (curr, prev) => {
      if (curr.mtime !== prev.mtime) {
        this.emit('change', filePath)
      }
    })
    
    this.watchers.set(filePath, watcher)
  }
  
  stop(): void {
    this.watchers.forEach((watcher, filePath) => {
      watcher.stop()
    })
    this.watchers.clear()
  }
}

// Usage in development
if (process.env.NODE_ENV === 'development') {
  const watcher = new ConfigurationWatcher()
  
  watcher.on('change', (filePath) => {
    console.log(`üîÑ Configuration file changed: ${filePath}`)
    console.log('   Restart the application to apply changes')
  })
  
  watcher.watch('.env')
  watcher.watch('.env.development')
}
```

---

## üß† Knowledge Check

### Environment Variables Quiz

1. **What is the primary environment variable required by Prisma?**
   - [ ] A) PRISMA_URL
   - [x] B) DATABASE_URL
   - [ ] C) DB_CONNECTION
   - [ ] D) PRISMA_DATABASE

   **Explanation**: `DATABASE_URL` is the primary and required environment variable that defines the database connection string.

2. **Which approach is recommended for production secrets?**
   - [ ] A) Store in .env files committed to git
   - [ ] B) Hardcode in application
   - [x] C) Use deployment platform secret management
   - [ ] D) Store in public configuration

   **Explanation**: Production secrets should use secure secret management systems, never committed to version control.

3. **What file should contain example environment variables for team members?**
   - [ ] A) .env.sample
   - [x] B) .env.example
   - [ ] C) .env.template
   - [ ] D) .env.default

   **Explanation**: `.env.example` is the conventional name for environment variable templates that can be safely committed to version control.

### Practical Exercise: Multi-Environment Setup

**Challenge**: Set up a complete multi-environment configuration

**Tasks**:
1. Create `.env.example` with all required and optional variables
2. Set up environment-specific files for dev/staging/production
3. Implement environment validation
4. Create environment status script
5. Configure package.json scripts for different environments

**Validation Checklist**:
- [ ] `.env.example` contains comprehensive variable documentation
- [ ] Environment validation prevents startup with missing variables
- [ ] Different environments use appropriate security settings
- [ ] Scripts allow easy switching between environments
- [ ] Secrets are properly masked in status output

---

## üí° Key Takeaways

- üîê **Security First**: Never commit sensitive environment variables to version control
- üìÅ **File Organization**: Use `.env.example` for documentation, environment-specific files for configuration
- ‚úÖ **Validation**: Always validate environment variables on application startup
- üåç **Multi-Environment**: Support development, staging, and production with appropriate security levels
- üõ°Ô∏è **Secret Management**: Use platform-specific secret management for production deployments
- üìä **Monitoring**: Implement environment status checking and debugging tools
- üîÑ **Documentation**: Maintain clear documentation of all environment variables and their purposes

---

## üîó Navigation

**üìç Current Location**: Module 2 ‚Üí Section 2.1 ‚Üí Lesson 2.1.4

**‚¨ÖÔ∏è Previous**: [2.1.3 Package.json Configuration & Scripts](./2.1.3-package-json-configuration-scripts.md)
**‚û°Ô∏è Next**: [2.1.5 TypeScript Configuration for Prisma](./2.1.5-typescript-configuration-for-prisma.md)

**üè† Section Home**: [2.1 Installation & Setup](./README.md)
**üìö Module Home**: [Module 2: Getting Started](../02-getting-started.md)

**üó∫Ô∏è Quick Links**:
- [Next: TypeScript Configuration](./2.1.5-typescript-configuration-for-prisma.md)
- [Jump to: First Schema](../2.2-first-prisma-project/2.2.1-creating-your-first-schema.md)
- [Official Docs: Environment Variables](https://www.prisma.io/docs/guides/development-environment/environment-variables)

---

*Excellent! You've mastered environment variable management. Ready to configure TypeScript for optimal Prisma development? Continue to the next lesson!*
